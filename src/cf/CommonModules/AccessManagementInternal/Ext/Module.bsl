///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2019, 1C-Soft LLC
// All Rights reserved. This application and supporting materials are provided under the terms of 
// Attribution 4.0 International license (CC BY 4.0)
// The license text is available at:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Region Internal

////////////////////////////////////////////////////////////////////////////////
// Main procedures and functions.

// Adds a user to an access group of the supplied profile.
// The access group is determined by ID of the reference of a supplied profile.
// If an access group is not found, it will be created.
//
// Parameters:
//  User - CatalogRef.Users,
//                        CatalogRef.ExternalUsers,
//                        CatalogRef.UserGroups,
//                        CatalogRef.ExternalUserGroups
//                        - a member to be included in the access group.
// 
//  SuppliedProfile - String - an ID string of a supplied profile.
//                      - CatalogRef.AccessGroupsProfiles - a reference to the profile created by 
//                        description in the AccessControlOverridable module in 
//                        FillAccessGroupsSuppliedProfiles procedure.
//                        Profiles with a non-blank list of access kinds are not supported.
//                        Administrator access group profile is not supported.
// 
Procedure AddUserToAccessGroup(User, SuppliedProfile) Export
	
	ProcessUserLinkToAccessGroup(User, SuppliedProfile, True);
	
EndProcedure

// Updates the users of the assignee groups.
// 
// This procedure must be called when users are changed in assignee groups, for example, in task 
// assignee groups.
//
// Assignee groups whose memebers are changed, are passed as parameter values.
//
// Parameters:
//  PerformerGroups - For example, CatalogRef.TaskAssigneesGroups.
//                     - Array of values of the types specified above.
//                     - Undefined - without filter.
//
Procedure UpdatePerformersGroupsUsers(PerformersGroups = Undefined) Export
	
	If TypeOf(PerformersGroups) = Type("Array") AND PerformersGroups.Count() = 0 Then
		Return;
	EndIf;
	
	Parameters = New Structure;
	Parameters.Insert("PerformersGroups", PerformersGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
EndProcedure

// Checks whether an access kind of the specified name exists.
// It is used for automation of conditional subsystem embedding.
// 
Function AccessKindExists(AccessKindName) Export
	
	Return AccessKindProperties(AccessKindName) <> Undefined;
	
EndFunction

// Returns the user interface type for access setup.
Function SimplifiedAccessRightsSetupInterface() Export
	
	SimplifiedInterface = False;
	AccessManagementOverridable.OnDefineAccessSettingInterface(SimplifiedInterface);
	
	Return SimplifiedInterface = True;
	
EndFunction

// Returns an array of allowed values of the specified types within all access groups.
// Used in the SetDynamicListFilters procedure to speed up the opening of dynamic lists.
// 
// Parameters:
//  Table - String - a full name of the metadata object, for example, Document.PurchaseInvoice.
//  ValueType - Type - a type of access values whose allowed values are to be returned.
//               - Array - an array of above listed types.
//
//  Values - Undefined - do not consider.
//               - Array - an array of type values specified in the ValuesType parameter.
//
//  User - Undefined - return allowed values for the authorized user.
//               - CatalogRef.Users, CatalogRef.ExternalUsers - return allowed values for the 
//                   specified user.
//
//  ReturnAll   - Boolean - if set to True, all allowed values will be returned, even in case, when 
//                   there are more than 100 of them.
//
// Returns:
//  Undefined - either all values are allowed for types specified in the ValueType parameter, or 
//                 (when ReturnAll = False) the number of allowed values exceeds 100.
//  Array - references of allowed values of the specified types.
//
Function AllowedDynamicListValues(Table, ValuesType, Values = Undefined, User = Undefined, ReturnAll = False) Export
	
	If TypeOf(ValuesType) <> Type("Array") Then
		ValueTypes = New Array;
		ValueTypes.Add(ValuesType);
		
	ElsIf ValuesType.Count() = 0 Then
		Return Undefined;
	Else
		ValueTypes = ValuesType;
	EndIf;
	
	SetPrivilegedMode(True);
	
	ValuesQueryTextWithoutGroups =
	"SELECT TOP 101
	|	ValuesWithoutGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithoutGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|							WHERE
	|								Values.AccessGroup = AccessGroups.Ref
	|								AND Values.AccessValue = ValuesWithoutGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithoutGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithoutGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "TOP 101", "");
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		ValuesQueryTextWithoutGroups = StrReplace(ValuesQueryTextWithoutGroups, "ValuesWithoutGroups.Ref IN(&Values)", "True");
	EndIf;
	
	ValuesQueryTextWithGroups =
	"SELECT TOP 101
	|	ValuesWithGroups.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS ValuesWithGroups
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				UserAccessGroups AS AccessGroups
	|			WHERE
	|				CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.AccessGroupsValues AS Values
	|									INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
	|									ON
	|										Values.AccessGroup = AccessGroups.Ref
	|											AND Values.AccessValue = ValueGroups.AccessValuesGroup
	|											AND ValueGroups.AccessValue = ValuesWithGroups.Ref)
	|						THEN TRUE
	|					ELSE FALSE
	|				END = CASE
	|					WHEN TRUE IN
	|							(SELECT TOP 1
	|								TRUE
	|							FROM
	|								InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|							WHERE
	|								DefaultValues.AccessGroup = AccessGroups.Ref
	|								AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValuesWithGroups.Ref)
	|								AND DefaultValues.AllAllowed = FALSE)
	|						THEN TRUE
	|					ELSE FALSE
	|				END)
	|	AND ValuesWithGroups.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "TOP 101", "");
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		ValuesQueryTextWithGroups = StrReplace(ValuesQueryTextWithGroups, "ValuesWithGroups.Ref IN(&Values)", "True");
	EndIf;
	
	QueryTextAllValues =
	"SELECT TOP 101
	|	AllValues.Ref AS Ref
	|FROM
	|	(SELECT
	|		&EmptyRefValue AS Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		ValuesWithoutEmptyRef.Ref
	|	FROM
	|		&AccessValuesTable AS ValuesWithoutEmptyRef) AS AllValues
	|WHERE
	|	AllValues.Ref IN(&Values)";
	
	If TypeOf(Values) = Type("Array") Or ReturnAll Then
		QueryTextAllValues = StrReplace(QueryTextAllValues, "TOP 101", "");
	EndIf;
	If TypeOf(Values) <> Type("Array") Then
		QueryTextAllValues = StrReplace(QueryTextAllValues, "AllValues.Ref IN(&Values)", "True");
	EndIf;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	QueryText = "";
	If User <> Undefined Then
		AuthorizedUser = User;
	Else
		AuthorizedUser = Users.AuthorizedUser();
	EndIf;
	AddCurrentUser = False;
	HasUsedAccessKinds = False;
	
	For Each CurrentType In ValueTypes Do
		Properties = AccessKindsProperties.ByValuesTypes.Get(CurrentType);
		If Properties = Undefined Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Тип ""%1"" не является типом значений доступа'; en = 'Type ""%1"" is not an access value type'; pl = 'Typ ""%1"" nie jest typem wartości dostępu';de = 'Typ ""%1"" ist kein Typ von Zugriffswert';ro = 'Tipul ""%1"" nu este tip al valorilor de acces';tr = 'Tür ""%1"" erişim değerlerin türü değil'; es_ES = 'Tipo ""%1"" no es tipo de valores de acceso'"), String(CurrentType));
			Raise ErrorText;
		EndIf;
		If Not AccessKindUsed(Properties.Name) Then
			CurrentQueryText = QueryTextAllValues;
		Else
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(CurrentType) = Undefined Then
				CurrentQueryText = ValuesQueryTextWithoutGroups;
			Else
				CurrentQueryText = ValuesQueryTextWithGroups;
			EndIf;
			HasUsedAccessKinds = True;
		EndIf;
		AccessValuesTable = Metadata.FindByType(CurrentType).FullName();
		CurrentQueryText = StrReplace(CurrentQueryText, "&AccessValuesTable", AccessValuesTable);
		CurrentQueryText = StrReplace(CurrentQueryText, "&EmptyRefValue",
			"VALUE(" + AccessValuesTable + ".EmptyRef)");
		If ValueIsFilled(QueryText) Then
			UnionQueryWithQuery(QueryText, CurrentQueryText);
		Else
			QueryText = CurrentQueryText;
		EndIf;
		If CurrentType = TypeOf(AuthorizedUser) Then
			AddCurrentUser = True;
		EndIf;
	EndDo;
	
	If Not HasUsedAccessKinds Then
		Return Undefined;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", AuthorizedUser);
	Query.Text = AccessGroupsRequestText();
	If TypeOf(Values) = Type("Array") Then
		Query.SetParameter("Values", Values);
	EndIf;
	
	AddQueryToPackage(Query.Text, QueryText);
	
	DataExported = Query.Execute().Unload();
	
	If TypeOf(Values) <> Type("Array")
	   AND Not ReturnAll
	   AND DataExported.Count() > 100 Then
		
		Return Undefined;
	EndIf;
	
	AllowedValues = DataExported.UnloadColumn("Ref");
	
	If AddCurrentUser Then
		AllowedValues.Add(AuthorizedUser);
	EndIf;
	
	Return AllowedValues;
	
EndFunction

// Adds system administrators to the access group connected with the predefined 
// OpenExternalReportsAndDataProcessors profile.
//
Procedure SetExternalReportsAndDataProcessorsOpenRight(OpenAllowed) Export
	
	ProfileProperties = OpenExternalReportsAndDataProcessorsProfileDetails();
	ProfileProperties.Insert("Ref", Catalogs.AccessGroupProfiles.SuppliedProfileByID(
		ProfileProperties.Name, True));
	
	RoleID = Common.MetadataObjectID(
		Metadata.Roles.InteractiveOpenExtReportsAndDataProcessors);
	
	// It is not required to create an access group in the simplified interface (only profile).
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	If Not SimplifiedInterface Then
		ProfileGroup = OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties);
	EndIf;
	
	If OpenAllowed Then
		// Adding administrators to access groups with this profile.
		If Not SimplifiedInterface Then
			AccessGroupObject = ProfileGroup.GetObject();
		EndIf;
		AdministratorRole = Metadata.Roles.SystemAdministrator;
		IBUsers = InfoBaseUsers.GetUsers();
		For Each InfobaseUser In IBUsers Do
			If InfobaseUser.Roles.Contains(AdministratorRole) Then
				User = Catalogs.Users.FindByAttribute(
					"IBUserID",
					InfobaseUser.UUID);
				If User = Undefined Then
					Continue;
				EndIf;
				If SimplifiedInterface Then
					// In the simplified interface, each administrator is added to a separate group.
					AccessManagement.EnableProfileForUser(User, ProfileProperties.Ref);
				Else
					// In the extended interface, administrators are added to one group connected to the predefined profile.
					If AccessGroupObject.Users.Find(User, "User") = Undefined Then
						AccessGroupObject.Users.Add().User = User;
					EndIf;
				EndIf;
			EndIf;
		EndDo;
		If Not SimplifiedInterface AND AccessGroupObject.Modified() Then
			AccessGroupObject.Write();
		EndIf;
	Else
		// Deleting a role from all profiles, except for the predefined one.
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupProfilesRoles.Ref
		|FROM
		|	Catalog.AccessGroupProfiles.Roles AS AccessGroupProfilesRoles
		|WHERE
		|	AccessGroupProfilesRoles.Role = &Role
		|	AND AccessGroupProfilesRoles.Ref <> &ProfileToExclude";
		Query.SetParameter("Role", RoleID);
		Query.SetParameter("ProfileToExclude", ProfileProperties.Ref);
		ProfilesArray = Query.Execute().Unload().UnloadColumn("Ref");
		For Each Profile In ProfilesArray Do
			ProfileObject = Profile.GetObject();
			FoundItems = ProfileObject.Roles.FindRows(New Structure("Role", RoleID));
			For Each TableRow In FoundItems Do
				ProfileObject.Roles.Delete(TableRow);
			EndDo;
			ProfileObject.Write();
		EndDo;
		
		// Clearing access group members connected to the predefined profile.
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroups.Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile";
		Query.SetParameter("Profile", ProfileProperties.Ref);
		GroupsArray = Query.Execute().Unload().UnloadColumn("Ref");
		For Each AccessGroup In GroupsArray Do
			AccessGroupObject = AccessGroup.GetObject();
			AccessGroupObject.Users.Clear();
			AccessGroupObject.Write();
		EndDo;
	EndIf;
	
EndProcedure

#Region UniversalRestriction

Function LimitAccessAtRecordLevelUniversally(WithConstantAccessRestrictionAtRecordLevel = False,
			WhenFirstAccessUpdateCompleted = False) Export
	
	If WithConstantAccessRestrictionAtRecordLevel Then
		Return Constants.LimitAccessAtRecordLevelUniversally.Get()
		      AND (Not WhenFirstAccessUpdateCompleted
		         Or Constants.FirstAccessUpdateCompleted.Get());
	EndIf;
	
	If Not WhenFirstAccessUpdateCompleted Then
		Return AccessManagementInternalCached.LimitAccessAtRecordLevelUniversallyConstant();
	EndIf;
	
	If SessionParameters.RecordLevelAccessRestrictionIsUniversal Then
		Return True;
	EndIf;
	
	LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
	
	If LastCheck.Date + 3 <= CurrentSessionDate() Then
		LastCheck.Date = CurrentSessionDate();
		
		If Constants.FirstAccessUpdateCompleted.Get() Then
			SpecifiedParameters = New Array;
			SetPrivilegedMode(True);
			SessionParametersSetting("", SpecifiedParameters);
			SetPrivilegedMode(False);
			RefreshReusableValues();
		EndIf;
	EndIf;
	
	Return SessionParameters.RecordLevelAccessRestrictionIsUniversal;
	
EndFunction

// Sets the use of the AccessUpdate scheduled job.
//
// Parameters:
//   Use - Boolean - True if the job must be enabled, otherwise, False.
//
Procedure SetAccessUpdate(Usage, WithoutCheckingIBUpdateExecution = False) Export
	
	If Usage
	   AND Not WithoutCheckingIBUpdateExecution
	   AND InfobaseUpdate.InfobaseUpdateInProgress() Then
		
		Return; // After infobase update, the job is activated unconditionally.
	EndIf;
	
	If Usage Then
		LastAccessUpdate = LastAccessUpdate();
		If LastAccessUpdate.AccessUpdateProhibited Then
			Return;
		EndIf;
	EndIf;
	
	EnableJob = ?(LimitAccessAtRecordLevelUniversally(), Usage, False);
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	Jobs = ScheduledJobsServer.FindJobs(Filter);
	
	JobEnabled = False;
	For Each Job In Jobs Do
		If Not EnableJob AND    Job.Use
		 Or    EnableJob AND Not Job.Use Then 
		
			JobEnabled = EnableJob;
			ScheduledJobsServer.ChangeJob(Job.UUID,
				New Structure("Use", EnableJob));
		EndIf;
	EndDo;
	
	If Not EnableJob
	 Or Not JobEnabled
	 Or Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	// Running the scheduled job immediately.
	CurrentSchedule = ScheduledJobsServer.JobSchedule(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	
	ScheduledJobsServer.SetJobSchedule(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel, CurrentSchedule);
	
EndProcedure

// Returns text errors of object access restrictions without dependencies between objects.
// Texts are checked in the mode of maximum restrictions (as if all restriction kinds are enabled).
// The function must be called before the ImplementationSettings function to collect the entire error package.
//
// Returns:
//  Array - with the following values:
//   * Structure - with the following properties:
//      * FullName - String - a full name of a metadata object.
//      * ErrorText - String - an error text in access restriction.
//
Function AccessRestrictionErrors() Export
	
	Errors = New Array;
	CommonContext = CommonContextOfRestrictionParametersCalculation(True, False);
	
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInformation = ErrorInfo();
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Списки с ограничением доступа некорректно указаны
			           |в процедуре ПриЗаполненииСписковСОграничениемДоступа
			           |общего модуля УправлениеДоступомПереопределяемый по причине:
			           |
			           |%1'; 
			           |en = 'Lists with access restriction are incorrectly specified
			           |in the OnFillListsWithAccessRestriction procedure
			           |of the AccessManagementOverridable common module due to:
			           |
			           |%1'; 
			           |pl = 'Ograniczone listy dostępu są niepoprawnie określone
			           |w procedurze ПриЗаполненииСписковСОграничениемДоступа
			           | wspólnego modułu УправлениеДоступомПереопределяемый z powodu:
			           |
			           |%1';
			           |de = 'Listen mit Zugriffsbeschränkung sind
			           |in der Prozedur BeimAusfüllenDerListenMit ZugriffsBeschränkung
			           |des allgemeinen Moduls ZugriffsKontrollÜberschreibung falsch angegeben, weil:
			           |
			           |%1';
			           |ro = 'Listele cu restricția de acces sunt indicate incorect
			           |în procedura ПриЗаполненииСписковСОграничениемДоступа
			           |a modulului general УправлениеДоступомПереопределяемый din motivul:
			           |
			           |%1';
			           |tr = 'ErişimKontrolüYenidenTanımlanmış genel modülün 
			           | ErişimKısıtlamalıListeleriniDoldururken prosedüründe 
			           |Erişim kısıtlama listeleri aşağıdaki nedenle yanlış belirtildi: 
			           |
			           |%1'; 
			           |es_ES = 'Las listas con restricción de acceso están indicadas incorrectamente
			           |en el procedimiento OnFillListsWithAccessRestriction
			           |del módulo común AccessManagementOverridable a causa de:
			           |
			           |%1'"), DetailErrorDescription(ErrorInformation));
		ErrorObject = "CommonModule.AccessManagementOverridable";
		Errors.Add(New Structure("FullName, ErrorText", ErrorObject, ErrorText));
		Return Errors;
	EndTry;
	
	ErrorsTexts = New Map;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	CommonContext.Insert("RestrictionsDetails", New Map);
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		Try
			ErrorText = AccessRestrictionError(CommonContext, FullName);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = DetailErrorDescription(ErrorInformation);
		EndTry;
		If ValueIsFilled(ErrorText) AND ErrorsTexts.Get(ErrorText) = Undefined Then
			ErrorsTexts.Insert(ErrorText, True);
			Errors.Add(New Structure("FullName, ErrorText", FullName, ErrorText));
		EndIf;
	EndDo;
	
	Return Errors;
	
EndFunction

// Returns implementation settings for developer tools.
//
// Parameters:
//  ActiveParameters - Undefined - a default value.
//                       - Structure - only to call from the CheckAccessRestrictionResult function.
//
// Returns:
//  Structure - with the following properties:
//    * RestrictionsInRoles - Structure - with the following properties:
//       * ForUsers - Map - with properties like for external users (below).
//       * ForExternalUsers - Map - with the following properties:
//           * Key - String - a full name of the metadata object (list). Collection name in English.
//                                 Object form must have the OnReadAtServer inserted.
//           * Value - Structure - with the following properties:
//               * TemplateForObject - Boolean - if True, the #ForObject template is used, if False, 
//                                             the #ForRegister template is used.
//               * Parameters - Array - array parameters (1 for the object, 6 for the register).
//                   * Value - String - for example, the Owner field name, or a name of basic field 
//                                      of the Company register.
//
//    * PredefinedIDs - Map - with the following properties:
//        * Key - String - a name of the required predefined catalog item.
//                              MetadataObjectIDs or ExtensionObjectIDs in the "<CatalogName>.
//                              <PredefinedItemName>" format.
//        * Value - String - a full name of the relevant metadata object.
//
//    * AccessKeysValuesOwners - Structure - for the group of defined types:
//        * Refs - Array - full names of the reference types (collection name in English).
//        * Documents - Array - full names of the object types (collection name in English).
//        * Objects - Array - the same as in the previous paragraph.
//        * RecordSets - Array - the same as in the previous paragraph.
//        * CalculationRegisterRecordSets - Array - the same as in the previous paragraph.
//
//    * AccessValues - Array - full names of reference types (collection name in English).
//                                 To supplement the defined AccessValue type.
//
//    * KeysRegistersDimensionsTypes - Map - for changes with the Field* name
//        of the AccessKeysToRegisters register and AccessKeysToRegister* registers: 
//           * Key - String - a register name.
//           * Value - Structure - with the following properties:
//               * TypesNames - Array - with the following values:
//                   * Value - String - full type name (in English).
//               * RegistersFields - Map - with the following properties:
//                   * Key - a full name of the register being restricted.
//                   * Value - Array - an order of fields that match the service fields (Field1, Field2, ...):
//                       * Value - Structure - with the following properties:
//                           * Field - String - a register field name.
//                           * Type - TypesDetails - register field types.
//               * RegistersFieldsByTypes - Map - with the following properties:
//                   * Key - full type name (in English).
//                   * Value - Array - an array with the following values:
//                       * Value - a full field name, for example,
//                                      "InformationRegister.AdditionalInfo.Property".
//
Function ImplementationSettings(ActiveParameters = Undefined) Export
	
	RestrictionsInRoles = New Structure;
	RestrictionsInRoles.Insert("ForUsers",        New Map);
	RestrictionsInRoles.Insert("ForExternalUsers", New Map);
	
	AccessKeysValuesOwners = New Structure;
	AccessKeysValuesOwners.Insert("References",        New Array);
	AccessKeysValuesOwners.Insert("Documents",     New Array);
	AccessKeysValuesOwners.Insert("Objects",       New Array);
	AccessKeysValuesOwners.Insert("RecordSets", New Array);
	AccessKeysValuesOwners.Insert("CalculationRegisterRecordSets", New Array);
	
	PredefinedIDs = New Map;
	AccessValues = New Array;
	KeysRegistersDimensionsTypes = New Map;
	KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, "AccessKeysForRegisters");
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	AccessValues.Add(XMLRefTypeName(Metadata.Catalogs.AccessKeys.FullName(), TablesTypesByNames));
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	For Each AvailableRightsDetails In AvailableRights.ByFullNames Do
		AccessValues.Add(XMLRefTypeName(AvailableRightsDetails.Key, TablesTypesByNames));
	EndDo;
	
	If ActiveParameters = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation(True);
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get());
	EndIf;
	
	AddedLists = New Map;
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		FullName = VersionDetails.Key;
		XMLFullName = XMLFullName(FullName, TablesTypesByNames);
		XMLRefTypeName  = XMLRefTypeName(FullName, TablesTypesByNames);
		XMLObjectTypeName = ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames);
		
		If ValueIsFilled(XMLRefTypeName) Then
			AccessKeysValuesOwners.References.Add(XMLRefTypeName);
		EndIf;
		
		AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners);
		AddedLists.Insert(Upper(FullName), True);
		
		If VersionDetails.Value = Undefined Then
			Continue;
		EndIf;
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForUsers,
			ActiveParameters.AdditionalContext.ForUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
		
		AddRestrictionsInRoles(XMLFullName,
			FullName,
			RestrictionsInRoles.ForExternalUsers,
			ActiveParameters.AdditionalContext.ForExternalUsers.ListRestrictionsProperties,
			KeysRegistersDimensionsTypes,
			TablesTypesByNames,
			PredefinedIDs);
	EndDo;
	
	For Each LeadingList In ActiveParameters.LeadingLists Do
		FullName = LeadingList.Key;
		If AddedLists.Get(Upper(FullName)) <> Undefined Then
			Continue;
		EndIf;
		XMLObjectTypeName = ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames);
		AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners);
	EndDo;
	
	Settings = New Structure;
	Settings.Insert("RestrictionsInRoles",              RestrictionsInRoles);
	Settings.Insert("PredefinedIDs", PredefinedIDs);
	Settings.Insert("AccessKeysValuesOwners", AccessKeysValuesOwners);
	Settings.Insert("AccessValues",                AccessValues);
	Settings.Insert("KeysRegistersDimensionsTypes",   KeysRegistersDimensionsTypes);
	
	Return Settings;
	
EndFunction

// Returns access restriction check result for the developer tool.
//
// Parameters:
//  FullName - String - full name of a metadata object.
//  AdditionalParameters
//            - Undefined - check and return the current restriction.
//            - Structure - with the following properties:
//                * Text - String - a new restriction text for users.
//                * TextForExternalUsers - String - a new restriction text for external users.
//                * ConsiderDependencies - Boolean - consider dependencies between object restrictions.
//
// Returns:
//  Structure - with the following properties:
//   * RestrictionDetailsError - String - if not blank, then the restriction description cannot be received.
//       If ConsiderDependencies = True, this is a text of the first error when all details are received.
//
//   * TextInManagerModule - Undefined - when RestrictionDetailsError is filled in.
//                           - Boolean - returns a restriction text location, when True - in the 
//                               manager module, otherwise, in the overridable module.
//
//   * ForUsers - Structure - with the following properties:
//      * RestrictionToCheck - Undefined, String - a checked restriction text.
//      * ErrorsDescription         - Undefined, Structure - see AccessManagement. RestrictionStructure.
//      * RestrictionParametersGenerationError - Undefined, String - an error text.
//      * QueriesTextsGenerationError - Undefined, String - an error text.
//      * RestrictionByOwnerPossible - Undefined, Boolean - a checked restriction property.
//      * RestrictionsInRoles - Undefined, Structure - with the following properties:
//          * TemplateForObject - Boolean - if True, the #ForObject template is used, if False, the 
//                                        #ForRegister template is used.
//          * Parameters - Array - array parameters (1 for the object, 6 for the register).
//              * Value - String - for example, the Owner field name, or a name of basic field of 
//                                    the Company register.
//      * RestrictionInModule - Undefined, String - a restriction text set in the configuration.
//      * ByOwnerWithoutWritingAccessKeys - Undefined, Boolean - a restriction setting set in the 
//                                    configuration.
//
//   * ForExternalUsers - Structure - with properties like ForUsers.
//
//   * AccessKeysValuesOwner - String - types for the same defined type.
//   * AccessKeysValuesOwnerObject - String - types for the same defined type.
//   * AccessKeysValuesOwnerRecordSet - String - types for the same defined type.
//   * AccessKeysValuesOwnerCalculationRegisterRecordSet - String - types for the same defined type.
//   * AccessKeysToRegistersRegisterField - String - types for the same defined type.
//   * AccessValue - String - types for the same defined type.
//
//   * SeparateKeysRegisterDimensionsTypes - Undefined, Structure - with the following properties:
//      * InformationRegisterName - String - an access key register name.
//      * DimensionsTypes - String - types for the corresponding register dimensions.
//
//   * PredefinedID - Undefined, Structure - with the following properties
//      * CatalogName - String - metadata object (or extension) IDs catalog name.
//      * PredefinedItemName - String - a predefined item name in the catalog.
//
Function AccessRestrictionCheckResult(FullName, AdditionalParameters = Undefined) Export
	
	Return ObjectAccessRestrictionCheckResult(FullName, AdditionalParameters);
	
EndFunction

// Returns a structure of the specified restriction text for a metadata object.
//
// Parameters:
//  FullName - String - a full metadata object name.
//  RestrictionText - String - a restriction text that will be parsed.
//
// Returns:
//  Structure - see a return value in AccessManagement.RestrictionStructure. 
//
Function RestrictionStructureFromDetails(FullName, RestrictionText) Export
	
	Return CalculatedRestrictionStructure(FullName,
		RestrictionText, Undefined, Undefined, True);
	
EndFunction

// Adds access update for the specified lists or all lists.
// 
// Parameters:
//  Lists - Undefined - schedule full access update.
//         - String - a full metadata object name.
//         - CatalogRef.MetadataObjectsIDs - an ID.
//         - Array - FixedArray - type values specified above, except for Undefined.
//
//  PlanningParameters - Undefined - use the default values.
//                        - Structure - see AccessUpdatePlanningParameters(). 
//
Procedure ScheduleAccessUpdate(Lists = Undefined, PlanningParameters = Undefined) Export
	
	If PlanningParameters = Undefined Then
		PlanningParameters = AccessUpdatePlanningParameters();
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not PlanningParameters.DataAccessKeys
	   AND Not PlanningParameters.AllowedAccessKeys Then
		
		Return;
	EndIf;
	
	RegistersIDs     = New Array;
	KeysListsIDs = New Array;
	
	If Lists = Undefined Then
		ClearAccessGroupsValuesCacheToCalculateRights();
		
		If PlanningParameters.ListsRestrictionsVersions = Undefined Then
			ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
			ListsRestrictionsVersions = New Map(ActiveParameters.ListsRestrictionsVersions);
		Else
			ListsRestrictionsVersions = PlanningParameters.ListsRestrictionsVersions;
		EndIf;
		Query = New Query;
		Query.SetParameter("AllowedAccessKey",
			AccessManagementInternalCached.AllowedAccessKey());
		Query.Text =
		"SELECT DISTINCT
		|	VALUETYPE(DataAccessKeys.Object) AS RefType
		|FROM
		|	InformationRegister.AccessKeysForObjects AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	DataAccessKeys.Register AS Register
		|FROM
		|	InformationRegister.AccessKeysForRegisters AS DataAccessKeys
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT DISTINCT
		|	AccessKeys.List AS List
		|FROM
		|	Catalog.AccessKeys AS AccessKeys
		|WHERE
		|	AccessKeys.Ref <> &AllowedAccessKey";
		QueryResults = Query.ExecuteBatch();
		RegistersIDs     = QueryResults[1].Unload().UnloadColumn("Register");
		KeysListsIDs = QueryResults[2].Unload().UnloadColumn("List");
		
		Selection = QueryResults[0].Select();
		AllowedTypes = AccessManagementInternalCached.AllowedObjectsRefsTypesDetails();
		HasInvalidType = False;
		While Selection.Next() Do
			If TypeOf(Selection.RefType) <> Type("Type") Then
				Continue;
			ElsIf Selection.RefType = Type("Undefined")
			      Or Not AllowedTypes.ContainsType(Selection.RefType) Then
				HasInvalidType = True;
				Continue;
			EndIf;
			MetadataObject = Metadata.FindByType(Selection.RefType);
			If MetadataObject = Undefined Then
				Continue;
			EndIf;
			ListsRestrictionsVersions.Insert(MetadataObject.FullName(), True);
		EndDo;
		ListsRestrictionsVersions.Insert("Catalog.SetsOfAccessGroups", True);
		If HasInvalidType Then
			RegistersIDs.Add(Catalogs.MetadataObjectIDs.EmptyRef());
		EndIf;
		
		ListsToUpdate = New Array;
		For Each KeyAndValue In ListsRestrictionsVersions Do
			ListsToUpdate.Add(KeyAndValue.Key);
		EndDo;
		
		// The following items are added when planning full update:
		// a) lists with a restriction b) lists that write access keys for restrictions by the owner field 
		// c) lists without restrictions, for which there are records in registers of access keys to data d) 
		// lists, for which allowed access keys are calculated e) lists without calculating allowed access 
		// keys, for which there are records in registers of allowed access keys.
		// 
		//    
		
	ElsIf TypeOf(Lists) <> Type("Array")
	        AND TypeOf(Lists) <> Type("FixedArray") Then
		
		ListsToUpdate = CommonClientServer.ValueInArray(Lists);
	Else
		ListsToUpdate = Lists;
	EndIf;
	
	If ListsToUpdate.Count() = 0 Then
		Return;
	EndIf;
	
	If TypeOf(ListsToUpdate[0]) = Type("String") Then
		IDs = Common.MetadataObjectIDs(ListsToUpdate);
		ListsByIDs = New Map;
		For Each IDDetails In IDs Do
			ListsByIDs.Insert(IDDetails.Value, IDDetails.Key);
		EndDo;
	Else
		ListsByIDs = New Map;
		For Each ID In ListsToUpdate Do
			ListsByIDs.Insert(ID, "");
		EndDo;
	EndIf;
	
	If ValueIsFilled(RegistersIDs)
	 Or ValueIsFilled(KeysListsIDs) Then
		
		For Each RegisterID In RegistersIDs Do
			If RegisterID = Undefined Then
				ListsByIDs.Insert(
					Catalogs.MetadataObjectIDs.EmptyRef(), "");
			EndIf;
			ListsByIDs.Insert(RegisterID, "");
		EndDo;
		For Each AllowedItemsID In KeysListsIDs Do
			ListsByIDs.Insert(AllowedItemsID, "");
		EndDo;
	EndIf;
	
	AccessGroupsSetsCatalogID =
		Common.MetadataObjectID("Catalog.SetsOfAccessGroups");
	
	CurrentSessionDate = CurrentSessionDate();
	RecordsUniqueKey = New UUID;
	
	IsSpotJob = False;
	JobParameters = New Structure;
	JobSize = 3;
	
	If PlanningParameters.IsObsoleteItemsDataProcessor Then
		PlanningParameters.IsUpdateContinuation = True;
		SetDataKeyKind(JobParameters, "ObsoleteItems");
		LatestUpdatedItemDate = '00010101';
		JobSize = 2;
	Else
		LeadingObject = PlanningParameters.LeadingObject;
		If LeadingObject <> Undefined
		   AND Not (    LeadingObject.Property("ByAccessKeys")
		         Or LeadingObject.Property("ByValuesWithGroups")
		         Or LeadingObject.Property("ByFieldsValues")
		           AND TypeOf(LeadingObject.ByFieldsValues.ChangesContent) = Type("ValueTable") ) Then
			LeadingObject = Undefined;
		EndIf;
		If LeadingObject <> Undefined Then
			IsSpotJob = True;
			PlanningParameters = New Structure(New FixedStructure(PlanningParameters));
			PlanningParameters.Insert("IsSpotJob");
			JobSize = 1;
			JobParameters.Insert("SpotJob", LeadingObject);
		EndIf;
		LatestUpdatedItemDate = ?(PlanningParameters.IsUpdateContinuation,
			MaxDateOnContinue(), MaxDate());
	EndIf;
	If JobParameters.Count() = 0 Then
		JobParameters = Undefined;
	EndIf;
	JobParametersStorage = New ValueStorage(JobParameters);
	
	DataAccessKeysUpdate       = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	UsersAccessKeysUpdate = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	
	For Each ListDetails In ListsByIDs Do
		ListID = ListDetails.Key;
		
		If PlanningParameters.DataAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey                   = RecordsUniqueKey;
				NewRecord.List                             = ListID;
				NewRecord.SpotJob                    = IsSpotJob;
				NewRecord.LatestUpdatedItemDate = LatestUpdatedItemDate;
				NewRecord.JobParameters                   = JobParametersStorage;
				NewRecord.JobSize                      = JobSize;
				NewRecord.RegisterRecordChangeDate        = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = DataAccessKeysUpdate.Add();
				NewRecord.UniqueKey                   = RecordsUniqueKey;
				NewRecord.List                             = ListID;
				NewRecord.ForExternalUsers            = True;
				NewRecord.SpotJob                    = IsSpotJob;
				NewRecord.LatestUpdatedItemDate = LatestUpdatedItemDate;
				NewRecord.JobParameters                   = JobParametersStorage;
				NewRecord.JobSize                      = JobSize;
				NewRecord.RegisterRecordChangeDate        = CurrentSessionDate;
			EndIf;
		EndIf;
		
		If ListID = AccessGroupsSetsCatalogID Then
			Continue;
		EndIf;
		
		If PlanningParameters.AllowedAccessKeys Then
			If PlanningParameters.ForUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey            = RecordsUniqueKey;
				NewRecord.List                      = ListID;
				NewRecord.SpotJob             = IsSpotJob;
				NewRecord.JobParameters            = JobParametersStorage;
				NewRecord.JobSize               = JobSize;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
			If PlanningParameters.ForExternalUsers Then
				NewRecord = UsersAccessKeysUpdate.Add();
				NewRecord.UniqueKey            = RecordsUniqueKey;
				NewRecord.List                      = ListID;
				NewRecord.ForExternalUsers     = True;
				NewRecord.SpotJob             = IsSpotJob;
				NewRecord.JobParameters            = JobParametersStorage;
				NewRecord.JobSize               = JobSize;
				NewRecord.RegisterRecordChangeDate = CurrentSessionDate;
			EndIf;
		EndIf;
	EndDo;
	
	If DataAccessKeysUpdate.Count() > 0 Then
		DataAccessKeysUpdate.Write(False);
	EndIf;
	
	If UsersAccessKeysUpdate.Count() > 0 Then
		UsersAccessKeysUpdate.Write(False);
	EndIf;
	
	RegisterAccessUpdatePlanning(ListsByIDs,
		PlanningParameters, Lists = Undefined);
	
	If DataAccessKeysUpdate.Count() > 0
	 Or UsersAccessKeysUpdate.Count() > 0 Then
		
		SetAccessUpdate(True);
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// The constructor of additional parameter structure for the ScheduleAccessUpdate procedure.
//
// Returns:
//  Structure - with the following properties:
//    * DataAccessKeys - Boolean - True by default - schedule update of data access keys.
//                                  
//    * AllowedAccessKeys - Boolean - True by default - schedule update of access keys for users and 
//                                  access groups.
//    * ForUsers - Boolean - True by default - schedule an update for users.
//    * ForExternalUsers - Boolean - the default value of the EnableExternalUsers constant is 
//                                         schedule an update for external users.
//
Function AccessUpdatePlanningParameters(CalculateForExternalUsers = True) Export
	
	ForExternalUsers = ?(CalculateForExternalUsers,
		Constants.UseExternalUsers.Get(), True);
	
	Result = New Structure;
	Result.Insert("DataAccessKeys", True);
	Result.Insert("AllowedAccessKeys", True);
	Result.Insert("ForUsers", True);
	Result.Insert("ForExternalUsers", ForExternalUsers);
	Result.Insert("LeadingObject", Undefined);
	Result.Insert("ListsRestrictionsVersions", Undefined);
	Result.Insert("Details", "");
	Result.Insert("IsUpdateContinuation", False);
	Result.Insert("IsObsoleteItemsDataProcessor", False);
	
	Return Result;
	
EndFunction

// Starts access update if it is scheduled and not started yet.
Procedure StartAccessUpdate() Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	StartAccessUpdateAtRecordLevel();
	
EndProcedure

// Executes access update to the end if it is scheduled.
Procedure UpdateAccess(RaiseExceptiopnInsteadErrorRegistration = False) Export
	
	ExecuteAccessUpdateAtRecordLevel(True, RaiseExceptiopnInsteadErrorRegistration);
	
EndProcedure

#EndRegion

////////////////////////////////////////////////////////////////////////////////
// Configuration subsystems event handlers.

// See BatchObjectModificationOverridable.OnDetermineObjectsWithEditableAttributes. 
Procedure OnDefineObjectsWithEditableAttributes(Objects) Export
	Objects.Insert(Metadata.Catalogs.AccessGroups.FullName(), "AttributesToSkipInBatchProcessing");
	Objects.Insert(Metadata.Catalogs.AccessGroupProfiles.FullName(), "AttributesToSkipInBatchProcessing");
EndProcedure

// See CommonOverridable.OnAddSessionParametersSettingHandlers. 
Procedure OnAddSessionParameterSettingHandlers(Handlers) Export
	
	Handlers.Insert("RecordLevelAccessRestrictionInUse",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessKinds*",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllAccessKindsExceptSpecialOnes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("TablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessValuesTypesWithGroups",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("RightsSettingsOwnersTypes",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("IDsOfTablesWithIndividualRightsSettings",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("TableOfExtensionsWithAccessRestriction",
		"AccessManagementInternal.SessionParametersSetting");
	
	#Region UniversalRestriction
	
	Handlers.Insert("RecordLevelAccessRestrictionIsUniversal",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("DIsableAccessKeysUpdate",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionTemplatesVersions",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedBlankAccessGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUserGroupsSet",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AllowedUser",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("CommonAccessRestrictionTemplateParameters",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithRestrictionByFields",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListWithRestrictionUsingAccessKeys*",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("ListsWithReadRestrictionDisabled",
		"AccessManagementInternal.SessionParametersSetting");
	
	Handlers.Insert("AccessRestrictionParameters",
		"AccessManagementInternal.SessionParametersSetting");
	
	#EndRegion
	
EndProcedure

// See ScheduledJobsOverridable.OnDefineScheduledJobsSettings. 
Procedure OnDefineScheduledJobSettings(Dependencies) Export
	
	Dependence = Dependencies.Add();
	Dependence.ScheduledJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
	Dependence.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevel;
	
	Dependence = Dependencies.Add();
	Dependence.ScheduledJob = Metadata.ScheduledJobs.AccessUpdateAtRecordLevel;
	Dependence.FunctionalOption = Metadata.FunctionalOptions.LimitAccessAtRecordLevelUniversally;
	
EndProcedure

// Updates auxiliary data that depends only on configuration.
// Writes changes of this data (if any) by configuration versions to use these changes upon updating 
// other auxiliary data, for example, in the UpdateAuxiliaryDataByConfigurationChanges handler.
// 
//
Procedure UpdateAccessRestrictionParameters(HasChanges = Undefined) Export
	
	InformationRegisters.RolesRights.UpdateRegisterData(HasChanges);
	
	InformationRegisters.AccessRightsDependencies.UpdateRegisterData(HasChanges);
	
	UpdateAccessKindsPropertiesDetails(HasChanges);
	
	Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesDescription(HasChanges);
	
	Catalogs.AccessGroupProfiles.UpdatePredefinedProfileComposition(HasChanges);
	
	InformationRegisters.ObjectsRightsSettings.UpdateAvailableRightsForObjectsRightsSettings(HasChanges);
	
EndProcedure

// Updates description of access kind properties in the application parameters.
// 
// Parameters:
//  HasChanges - Boolean - (return value) - if recorded, True is set, otherwise, it does not change.
//                  
//
Procedure UpdateAccessKindsPropertiesDetails(HasChanges = False) Export
	
	SetPrivilegedMode(True);
	
	AccessKindsProperties = AccessKindsProperties();
	
	BeginTransaction();
	Try
		HasCurrentChanges = False;
		PreviousValue = Undefined;
		
		StandardSubsystemsServer.UpdateApplicationParameter(
			"StandardSubsystems.AccessManagement.AccessKindsProperties",
			AccessKindsProperties, HasCurrentChanges, PreviousValue);
		
		HasChangesOfGroupsTypesAndAccessValues = HasCurrentChanges
			AND HasChangesOfGroupsTypesAndAccessValues(AccessKindsProperties, PreviousValue);
		
		StandardSubsystemsServer.AddApplicationParameterChanges(
			"StandardSubsystems.AccessManagement.GroupAndAccessValueTypes",
			?(HasChangesOfGroupsTypesAndAccessValues,
			  New FixedStructure("HasChanges", True),
			  New FixedStructure()) );
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasCurrentChanges Then
		HasChanges = True;
	EndIf;
	
EndProcedure

// See InfobaseUpdateSSL.OnAddUpdateHandlers. 
Procedure OnAddUpdateHandlers(Handlers) Export
	
	// Shared data update handlers.
	Handler = Handlers.Add();
	Handler.SharedData = True;
	Handler.HandlerManagement = True;
	Handler.Priority = 1;
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.FillSeparatedDataHandlers";
	
	// Separated data update handlers.
	Handler = Handlers.Add();
	Handler.Version = "*";
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	
	Handler = Handlers.Add();
	Handler.InitialFilling = True;
	Handler.ExecutionMode = "Seamless";
	Handler.Procedure = "AccessManagementInternal.FillPredefinedItemsDescription";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "InformationRegisters.DeleteRightsByAccessValues.MoveDataToNewRegister";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "AccessManagementInternal.ConvertRoleNamesToIDs";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.8";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.16";
	Handler.Procedure = "InformationRegisters.AccessGroupsTables.UpdateRegisterData";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.2.16";
	Handler.Procedure = "AccessManagement.UpdateUserRoles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.3.5";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	
	Handler = Handlers.Add();
	Handler.Version = "2.1.4.15";
	Handler.Procedure = "Catalogs.AccessGroupProfiles.FillSuppliedDataIDs";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	// Executed after the FillSuppliedDataIDs handler.
	Handler = Handlers.Add();
	Handler.Version = "1.0.0.1";
	Handler.InitialFilling = True;
	Handler.Procedure = "Catalogs.AccessGroups.FillAdministratorsAccessGroupProfile";
	Handler.ExecutionMode = "Exclusive";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "Catalogs.AccessGroupProfiles.ConvertAccessKindsIDs";
	Handler.ExecutionMode = "Exclusive";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateUsersGroupings";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.DeleteAccessValuesGroups.MoveDataToNewRegister";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.ObjectRightsSettingsInheritance.UpdateRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterData";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.15";
	Handler.Procedure = "AccessManagementInternal.EnableDataFillingForAccessRestriction";
	Handler.ExecutionMode = "Exclusive";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.1.35";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.UpdateEmptyAccessValueGroups";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.3.27";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.5.4";
	Handler.Procedure = "InformationRegisters.DeleteAccessValuesGroups.ClearRegister";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.2.5.7";
	Handler.Procedure = "AccessManagement.UpdateUserRoles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.1.61";
	Handler.Procedure = "AccessManagementInternal.FillAccessGroupsProfilesAssignment";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.1.55";
	Handler.Procedure = "AccessManagementInternal.ReplaceDeletedRolesInAccessGroupProfiles";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.3.2.23";
	Handler.Procedure = "InformationRegisters.AccessGroupsValues.UpdateRegisterData";
	Handler.ExecutionMode = "Seamless";
	
	Handler = Handlers.Add();
	Handler.Version = "2.4.1.1";
	Handler.Procedure = "AccessManagementInternal.UpdateProfileDataOpenExternalReportsAndDataProcessors";
	Handler.ExecutionMode = "Seamless";
	Handler.ExecuteInMandatoryGroup = True;
	Handler.Priority = 1;
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.1.196";
	Handler.Procedure = "Catalogs.AccessGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.RunAlsoInSubordinateDIBNodeWithFilters = True;
	Handler.Comment = NStr("ru = 'Устраняет некорректное скрытие данных в некоторых списках при включенном ограничении на уровне записей.'; en = 'Eliminates incorrect data hiding in some lists with enabled restriction at the record level.'; pl = 'Eliminuje niepoprawne ukrywanie danych na niektórych listach, gdy włączone jest ograniczenie na poziomie zapisów.';de = 'Beseitigt das Verbergen falscher Daten in einigen Listen, wenn die Beschränkung der Datensatzebene aktiviert ist.';ro = 'Înlătură ascunderea incorectă a datelor în unele liste cu restricția activată la nivel de înregistrări.';tr = 'Kayıt düzeyi kısıtlaması etkinleştirildiğinde bazı listelerde verilerin yanlış gizlenmesini giderir.'; es_ES = 'Remueve oculto incorrecto de datos en algunas listas con la restricción activada en nivel de registros.'");
	Handler.ID = New UUID("b73c2481-f789-4b2d-b705-8219aea0e75d");
	Handler.CheckProcedure = "InfobaseUpdate.DataProcessingCompleted";
	Handler.UpdateDataFillingProcedure = "Catalogs.AccessGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.DeferredProcessingQueue = 1;
	Handler.ObjectsToBeRead = "Catalog.AccessGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessGroupsTables,InformationRegister.AccessGroupsValues,InformationRegister.DefaultAccessGroupsValues";
	
	If Not Common.SeparatedDataUsageAvailable()
	 Or LimitAccessAtRecordLevelUniversally(True) Then
		
		Handler = Handlers.Add();
		Handler.Version = "3.0.3.3";
		Handler.Procedure = "InformationRegisters.AccessRestrictionParameters.ProcessDataForMigrationToNewVersion2";
		Handler.ExecutionMode = "Deferred";
		Handler.RunAlsoInSubordinateDIBNodeWithFilters = True;
		Handler.Comment = NStr("ru = 'Планирование частичного обновления доступа по изменениям программы.'; en = 'Planning partial access update by application changes.'; pl = 'Planowanie częściowej aktualizacji dostępu przez zmiany programu.';de = 'Planung von teilweisen Aktualisierungen bei Programmänderungen.';ro = 'Planificarea actualizării parțiale a accesului conform modificărilor programului.';tr = 'Program değişiklikleri için kısmi erişim güncellemesini planlama.'; es_ES = 'Planificación de actualización parcial de acceso por cambios del programa.'");
		Handler.ID = New UUID("2721d667-858d-48ed-8736-f7ece8218697");
		Handler.UpdateDataFillingProcedure = "InformationRegisters.AccessRestrictionParameters.RegisterDataToProcessForMigrationToNewVersion2";
		Handler.DeferredProcessingQueue = 1;
		Handler.ObjectsToBeRead = "InformationRegister.AccessRestrictionParameters";
		Handler.ObjectsToChange = "InformationRegister.AccessRestrictionParameters";
	EndIf;
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.2.139";
	Handler.Procedure = "InformationRegisters.AccessValuesGroups.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.Comment = NStr("ru = 'Обновление данных по изменениям программы.'; en = 'Data update by application changes.'; pl = 'Aktualizacja danych dotyczących zmian programu.';de = 'Aktualisierung der Daten bei Programmänderungen.';ro = 'Actualizarea datelor conform modificărilor programului.';tr = 'Program değişiklik verilerini güncelleme.'; es_ES = 'Actualización de datos por cambios del programa.'");
	Handler.ID = New UUID("b3cb643e-d5cf-40b7-9db3-6315a88c063d");
	Handler.UpdateDataFillingProcedure = "InformationRegisters.AccessValuesGroups.RegisterDataToProcessForMigrationToNewVersion";
	Handler.DeferredProcessingQueue = 1;
	Handler.ObjectsToBeRead = "InformationRegister.AccessValuesGroups";
	Handler.ObjectsToChange = "InformationRegister.AccessValuesGroups";
	
	Handler = Handlers.Add();
	Handler.Version = "3.0.2.174";
	Handler.Procedure = "InformationRegisters.ObjectsRightsSettings.ProcessDataForMigrationToNewVersion";
	Handler.ExecutionMode = "Deferred";
	Handler.Comment = NStr("ru = 'Обновление вспомогательных данных настроек прав.'; en = 'Updating auxiliary data of right settings.'; pl = 'Zaktualizuj dane pomocnicze ustawień praw.';de = 'Aktualisieren Sie die Zusatzdaten der Rechteeinstellungen.';ro = 'Actualizarea datelor auxiliare ale setărilor drepturilor.';tr = 'Yardımcı hak ayarları verilerini güncelle.'; es_ES = 'Actualización de datos auxiliares de ajustes de derechos.'");
	Handler.ID = New UUID("40d1c62f-c3f1-4608-8985-2dc618c3d758");
	Handler.UpdateDataFillingProcedure = "InformationRegisters.ObjectsRightsSettings.RegisterDataToProcessForMigrationToNewVersion";
	Handler.DeferredProcessingQueue = 1;
	Handler.ObjectsToBeRead = "InformationRegister.ObjectsRightsSettings";
	Handler.ObjectsToChange = "InformationRegister.ObjectsRightsSettings";
	
EndProcedure

// See InfobaseUpdateSSL.AfterUpdateInfobase. 
Procedure AfterUpdateInfobase(Val PreviousVersion, Val CurrentVersion,
		Val CompletedHandlers, OutputUpdatesDetails, ExclusiveMode) Export
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
	If Common.SeparatedDataUsageAvailable() Then
		SetAccessUpdate(True, True);
	EndIf;
	
EndProcedure

// Fills parameter structures required by the application client code.
// 
//
// Parameters:
//   Parameters - Structure - a parameter structure.
//
Procedure OnAddClientParameters(Parameters) Export
	
	Parameters.Insert("SimplifiedAccessRightsSetupInterface",
		SimplifiedAccessRightsSetupInterface());
	
EndProcedure

// See CommonOverridable.OnAddRefsSearchExceptions. 
Procedure OnAddReferenceSearchExceptions(Array) Export
	
	Array.Add(Metadata.InformationRegisters.AccessValuesGroups);
	Array.Add(Metadata.InformationRegisters.AccessRightsDependencies);
	Array.Add(Metadata.InformationRegisters.AccessGroupsValues);
	Array.Add(Metadata.InformationRegisters.DefaultAccessGroupsValues);
	Array.Add(Metadata.InformationRegisters.AccessValuesSets);
	Array.Add(Metadata.InformationRegisters.RolesRights);
	Array.Add(Metadata.InformationRegisters.ObjectRightsSettingsInheritance);
	Array.Add(Metadata.InformationRegisters.ObjectsRightsSettings);
	Array.Add(Metadata.InformationRegisters.AccessGroupsTables);
	
	OnAddRefsSearchExceptionsThatAllowDeletion(Array);
	
EndProcedure

// Objects with deferred deletion.
Procedure OnAddRefsSearchExceptionsThatAllowDeletion(Array) Export
	
	Array.Add(Metadata.Catalogs.AccessKeys);
	Array.Add(Metadata.Catalogs.SetsOfAccessGroups);
	Array.Add(Metadata.InformationRegisters.ExternalUsersAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessGroupsAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessGroupSetsAccessKeys);
	Array.Add(Metadata.InformationRegisters.AccessKeysForObjects);
	Array.Add(Metadata.InformationRegisters.AccessKeysForRegisters);
	Array.Add(Metadata.InformationRegisters.UsersAccessKeys);
	Array.Add(Metadata.InformationRegisters.DataAccessKeysUpdate);
	Array.Add(Metadata.InformationRegisters.UsersAccessKeysUpdate);
	Array.Add(Metadata.InformationRegisters.AccessRestrictionParameters);
	
	For Each InformationRegister In Metadata.InformationRegisters Do 
		If StrStartsWith(Upper(InformationRegister.Name), Upper("AccessKeysToRegister")) Then 
			Array.Add(InformationRegister);
		EndIf;
	EndDo;
	
EndProcedure

// This procedure is called when importing predefined item references while importing important data.
// Allows correcting or registering information on non-unique predefined items. Also allows you to 
// cancel further actions if the uniqueness issue cannot be solved.
//
// Parameters:
//   Object - CatalogObject, ChartOfCharacteristicTypesObject, ChartOfAccountsObject, 
//                     ChartOfCalculationTypesObject - a predefined item object whose recording resulted in uniqueness conflict.
//   WriteToLog - Boolean - a return value. Set to False not to add the uniqueness conflict details 
//                     to the event log in a common message.
//                     Set to False if the uniqueness conflict was resolved automatically.
//   Cancel - Boolean - a return value. Set to True to raise an exception with cancellation details.
//                     
//   CancelDetails - String - a return value. If Cancel is set to True, the description is added to 
//                     the list of the reasons preventing from further actions.
//
Procedure OnFindNotUniquePredefinedItem(Object, WriteToLog, Cancel, CancelDetails) Export
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles")
	   AND Object.PredefinedDataName = "Administrator" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("Ref", Object.Ref);
		Query.SetParameter("PredefinedDataName", "Administrator");
		Query.Text =
		"SELECT
		|	AccessGroupProfiles.Ref AS Ref
		|FROM
		|	Catalog.AccessGroupProfiles AS AccessGroupProfiles
		|WHERE
		|	AccessGroupProfiles.Ref <> &Ref
		|	AND AccessGroupProfiles.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			CurrentObject = Selection.Ref.GetObject();
			CurrentObject.PredefinedDataName = "";
			CurrentObject.SuppliedDataID = "";
			InfobaseUpdate.WriteData(CurrentObject);
		EndDo;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups")
	        AND Object.PredefinedDataName = "Administrators" Then
		
		WriteToLog = False;
		
		Query = New Query;
		Query.SetParameter("PredefinedDataName", "Administrators");
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.User
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	AccessGroupsUsers.Ref.PredefinedDataName = &PredefinedDataName";
		AllUsers = Query.Execute().Unload().UnloadColumn("User");
		
		Write = False;
		For each User In AllUsers Do
			If Object.Users.Find(User, "User") = Undefined Then
				Object.Users.Add().User = User;
				Write = True;
			EndIf;
		EndDo;
		
		If Write Then
			InfobaseUpdate.WriteData(Object);
		EndIf;
		
		Query.SetParameter("Ref", Object.Ref);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Ref <> &Ref
		|	AND AccessGroups.PredefinedDataName = &PredefinedDataName";
		
		Selection = Query.Execute().Select();
		While Selection.Next() Do
			CurrentObject = Selection.Ref.GetObject();
			CurrentObject.PredefinedDataName = "";
			InfobaseUpdate.WriteData(CurrentObject);
		EndDo;
	EndIf;
	
EndProcedure

// See DataExchangeOverridable.OnSetUpSubordinateDIBNode. 
Procedure OnSetUpSubordinateDIBNode() Export
	
	// Extension roles are assigned independently in all DIB nodes.
	Catalogs.AccessGroupProfiles.DeleteExtensionsRolesInAllAccessGroupsProfiles();
	
	// Administrators are assigned independently in all DIB nodes.
	Catalogs.AccessGroups.DeleteMembersOfAdministratorsAccessGroupWithoutIBUser();
	
	If Common.IsStandaloneWorkplace() Then
		Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
	EndIf;
	
	If LimitAccessAtRecordLevelUniversally()
	   AND Common.IsSubordinateDIBNodeWithFilter() Then
		
		PlanningParameters = AccessUpdatePlanningParameters();
		PlanningParameters.Details = "OnSetUpSubordinateDIBNode";
		ScheduleAccessUpdate(, PlanningParameters);
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnSendDataToMaster. 
Procedure OnSendDataToMaster(DataItem, ItemSending, Recipient) Export
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		ItemSending = DataItemSend.Ignore;
		Return;
	EndIf;
	
	// Profile and access group of opening external reports and data processors are unavailable in the 
	// service, but available in an offline workplace.
	If Common.IsStandaloneWorkplace()
	   AND (    TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles")
	        AND IsProfileOpenExternalReportsAndDataProcessors(DataItem)
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroups")
	        AND Not DataItem.IsFolder
	        AND IsProfileOpenExternalReportsAndDataProcessors(DataItem.Profile) ) Then
		
		ItemSending = DataItemSend.Ignore;
	EndIf;
	
	// Extension roles are assigned independently in all DIB nodes.
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(DataItem);
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnSendDataToSlave. 
Procedure OnSendDataToSlave(DataItem, ItemSending, InitialImageCreation, Recipient) Export
	
	// Extension roles are assigned independently in all DIB nodes.
	// Partially changing of objects when creating the initial image is not supported, see the deletion 
	// of extension roles in the OnSetUpSubordinateDIBNode procedure.
	
	// Administrators are assigned independently in all DIB nodes.
	// Partially changing of objects when creating the initial image is not supported, see clearing of 
	// administrators in the OnSetUpSubordinateDIBNode procedure.
	
	If InitialImageCreation Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		ItemSending = DataItemSend.Ignore;
		Return;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromMaster. 
Procedure OnReceiveDataFromMaster(DataItem, GetItem, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If GetItem = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		GetItem = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	OnReceiveDataFromMasterOrSlave(DataItem);
	
EndProcedure

// See StandardSubsystemsServer.OnReceiveDataFromSlave. 
Procedure OnReceiveDataFromSlave(DataItem, GetItem, SendBack, Sender) Export
	
	// Standard data processor cannot be overridden.
	If GetItem = DataItemReceive.Ignore Then
		Return;
	EndIf;
	
	If AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	 Or AccessManagementSubsystemObjectNameStartsWithDelete(DataItem) Then
		
		GetItem = DataItemReceive.Ignore;
		Return;
	EndIf;
	
	If Not Common.DataSeparationEnabled() Then
		OnReceiveDataFromMasterOrSlave(DataItem);
		
	ElsIf TypeOf(DataItem) = Type("ConstantValueManager.LimitAccessAtRecordLevel")
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroups")
	      Or TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessValuesGroups")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessValuesSets")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ObjectRightsSettingsInheritance")
	      Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ObjectsRightsSettings") Then
		
		// Getting data from a standalone workplace is skipped. Data is sent back to the standalone 
		// workplace to establish data mapping between the nodes.
		GetItem = DataItemReceive.Ignore;
		SendBack = True;
	EndIf;
	
EndProcedure

// See StandardSubsystemsServer.AfterGetData. 
Procedure AfterGetData(Sender, Cancel, GetFromMasterNode) Export
	
	If InfobaseUpdate.InfobaseUpdateInProgress() Then
		Return;
	EndIf;
	
	UpdateAuxiliaryDataOfItemsChangedOnImport();
	
EndProcedure

// See description in the FillAllExtensionsParameters procedure of the ExtensionsVersionsParameters 
// information register manager module.
//
Procedure OnFillAllExtensionsParameters() Export
	
	UpdateAccessGroupsTablesForEnabledExtensions();
	
EndProcedure

// Event handlers of the Users subsystem.

// See UsersOverridable.OnDefineSettings. 
Procedure OnDefineSettings(Settings) Export
	
	// Roles are set automatically by linking access group data this way: AccessGroupUsers -> Profile -> 
	// ProfileRoles.
	Settings.EditRoles = False;
	
EndProcedure

// See UsersOverridable.OnDefineActionsInForm. 
Procedure OnDefineActionsInForm(Ref, FormActions) Export
	
	FormActions.Roles = "";
	
EndProcedure

// See SSLSubsystemsIntegration.AfterWriteAdministratorOnAuthorization. 
Procedure AfterWriteAdministratorOnAuthorization(Comment) Export
	
	Comment =
		NStr("ru = 'Выполнен запуск от имени пользователя с ролью ""Полные права"",
		           |который не зарегистрирован в списке пользователей.
		           |Выполнена автоматическая регистрация в списке пользователей.
		           |Пользователь добавлен в группу доступа Администраторы.
		           |
		           |Для ведения списка и настройки прав пользователей предназначен список Пользователи,
		           |режим конфигурирования 1С:Предприятия для этого использовать не следует.'; 
		           |en = 'Launch under user with the ""Full rights"" role
		           |not registered in the user list is performed.
		           |Automatic registration in the user list is performed.
		           |The user is added to the Administrators access group.
		           |
		           |Use the Users list to manage the list and assign user rights,
		           |do not use 1C: Enterprise configuration mode for that.'; 
		           |pl = 'Uruchomiony w imieniu użytkownika z rolą ""Pełne prawa"",
		           |który nie jest zarejestrowany na liście użytkowników.
		           |Wykonana jest automatyczna rejestracja na liście użytkowników.
		           |Użytkownik dodany do grupy dostępu Administratorzy.
		           |
		           |Do prowadzenia listy i ustawienia uprawnień użytkowników przeznaczona jest lista Użytkowników,
		           |tryb konfiguracji 1C:Enterprise do tego celu używać nie należy.';
		           |de = 'Wurde als Benutzer mit der Rolle ""Volle Rechte"" gestartet,
		           |der nicht in der Liste der Benutzer registriert ist.
		           |Die automatische Registrierung in der Liste der Benutzer wird durchgeführt.
		           |Der Benutzer wird der Zugriffsgruppe Administratoren hinzugefügt.
		           |
		           |Die Benutzerliste ist für die Pflege der Liste und die Einrichtung der Rechte von Benutzern gedacht,
		           |der Modus der Konfiguration von 1C:Enterprise sollte zu diesem Zweck nicht verwendet werden.';
		           |ro = 'A fost executată lansarea din numele utilizatorului cu rolul ""Drepturi depline"",
		           |care nu este înregistrat în lista utilizatorilor.
		           |Este executată înregistrarea automată în lista utilizatorilor.
		           |Utilizatorul este adăugat în grupul de acces Administratori.
		           |
		           |Pentru ținerea listei și setarea drepturilor utilizatorilor este destinată lista Utilizatori,
		           |nu trebuie să utilizați cu acest scop regimul de configurare 1С:Enterprise.';
		           |tr = 'Kullanıcı listesinde kayıtlı olmayan 
		           |""Tam haklar"" rolüyle kullanıcı adına başlar. 
		           |Kullanıcı listesinde otomatik kayıt yapılır. 
		           |Kullanıcı Yöneticiler erişim grubuna eklendi.
		           |
		           |Bir  liste ve kullanıcı hakları ayarını korumak için, 
		           |Kullanıcılar listesini  kullanın, 1C: İşletme yapılandırma modu kullanılmamalıdır.'; 
		           |es_ES = 'Se ha realizado el inicio del nombre de usuario con el rol ""Derechos completos""
		           |que no está registrado en la lista de usuarios.
		           |Se ha realizado el registro automático en la lista de usuarios.
		           |El usuario se ha añadido en el grupo de acceso Administradores.
		           |
		           |Para llevar la lista y los ajustes de usuarios está destinada la lista Usuarios
		           |no hay que usar el modo de configurar de 1C:Enterprise para esto.'");
	
EndProcedure

// See SSLSubsystemsIntegration.AfterSetIBUser. 
Procedure AfterSetIBUser(Ref, ServiceUserPassword) Export
	
	UpdateUserRoles(Ref, ServiceUserPassword);
	
EndProcedure

// See SSLSubsystemsIntegration.OnDefineQuestionTextBeforeWriteFirstAdministrator. 
Procedure OnDefineQuestionTextBeforeWriteFirstAdministrator(QuestionText) Export
	
	QuestionText =
		NStr("ru = 'В список пользователей программы добавляется первый пользователь,
		           |поэтому он будет автоматически включен в группу доступа Администраторы. 
		           |Продолжить?'; 
		           |en = 'The first user is added to the application user list,
		           |the user will be automatically included in the Administrators access group.
		           |Continue?'; 
		           |pl = 'Do listy użytkowników programu zostanie dodany pierwszy użytkownik,
		           |dlatego zostanie on automatycznie włączony do grupy dostępu Administratorzy.
		           |Kontynuować?';
		           |de = 'Der erste Benutzer wird der Liste der Benutzer des Programms hinzugefügt,
		           |so dass er automatisch in die Gruppe Administratoren aufgenommen wird. 
		           |Fortfahren?';
		           |ro = 'Primul utilizator este adăugat la lista de utilizatori a aplicației,
		           |de aceea el sau ea va fi inclus în mod automat în grupul de acces Administratori.
		           |Continuați?';
		           |tr = 'İlk kullanıcı, uygulamanın 
		           |kullanıcı listesine eklenir, bu yüzden otomatik olarak Yöneticiler erişim grubuna dahil edilir. 
		           |Devam etmek istiyor musunuz?'; 
		           |es_ES = 'El primer usuario se ha añadido a la lista de usuarios del programa,
		           |por lo tanto se incluirá automáticamente en el grupo de acceso Administradores. 
		           |¿Continuar?'")
	
EndProcedure

// See SSLSubsystemsIntegration.OnCreateAdministrator. 
Procedure OnCreateAdministrator(Administrator, Clarification) Export
	
	If TypeOf(Administrator) <> Type("CatalogRef.Users") Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("User", Administrator);
	Query.Text =
	"SELECT
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers
	|WHERE
	|	AccessGroupsUsers.Ref = VALUE(Catalog.AccessGroups.Administrators)
	|	AND AccessGroupsUsers.User = &User";
	
	If Not Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	CommentForLog = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Пользователь ""%1"" добавлен в группу доступа Администраторы по причине:
		           |%2'; 
		           |en = 'User ""%1"" was added to the Administrators access group due to:
		           |%2'; 
		           |pl = 'Użytkownik ""%1"" dodany do grupy dostępu Administratorzy, z powodu:
		           |%2';
		           |de = 'Der Benutzer ""%1"" wird aus diesem Grund der Zugriffsgruppe Administratoren hinzugefügt:
		           |%2';
		           |ro = 'Utilizatorul ""%1"" este adăugat în grupul de acces Administratori din motivul:
		           |%2';
		           |tr = 'Kullanıcı ""%1"" aşağıdaki nedenle Yöneticiler erişim grubuna eklendi: 
		           |%2'; 
		           |es_ES = 'El usuario ""%1"" se ha añadido en el grupo de acceso Administradores a causa de:
		           |%2'"),
		Administrator,
		Clarification);
	
	Object = Catalogs.AccessGroups.Administrators.GetObject();
	
	BeginTransaction();
	Try
		LockDataForEdit(Object.Ref, Object.DataVersion);
		If Object.Users.Find(Administrator, "User") = Undefined Then
			Object.Users.Add().User = Administrator;
			InfobaseUpdate.WriteData(Object);
			WriteLogEvent(
				NStr("ru = 'Управление доступом.Автоматическое изменение группы доступа Администраторы'; en = 'Access management.Automatic change of Administrators access group'; pl = 'Kontrola dostępu.Automatyczna zmiana grupy dostępu Administratorzy';de = 'Zugriffskontrolle. Automatische Änderung der Zugriffsgruppe Administratoren ';ro = 'Administrarea accesului.Modificarea automată a grupului de acces Administratori';tr = 'Erişim kontrolü. Yöneticiler erişim grubunun otomatik değişmesi'; es_ES = 'Gestión de acceso.Cambio automático del grupo de acceso Administradores'",
				     Common.DefaultLanguageCode()),
				EventLogLevel.Information,
				Metadata.Catalogs.Users,
				Administrator,
				CommentForLog,
				EventLogEntryTransactionMode.Transactional);
		EndIf;
		UnlockDataForEdit(Object.Ref);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterAddChangeUserOrGroup. 
Procedure AfterAddChangeUserOrGroup(Ref, IsNew) Export
	
	If IsNew Then
		If TypeOf(Ref) = Type("CatalogRef.UserGroups")
		 OR TypeOf(Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		
			Parameters = New Structure;
			Parameters.Insert("UserGroups", Ref);
			InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
		EndIf;
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterUserGroupsUpdate. 
Procedure AfterUserGroupsUpdate(ItemsToChange, ModifiedGroups) Export
	
	Parameters = New Structure;
	Parameters.Insert("Users",        ItemsToChange);
	Parameters.Insert("UserGroups", ModifiedGroups);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
	UpdateUserRoles(ItemsToChange);
	
	If LimitAccessAtRecordLevelUniversally() Then
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ItemsToChange);
		ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ModifiedGroups);
	EndIf;
	
EndProcedure

// See SSLSubsystemsIntegration.AfterChangeExternalUserAuthorizationObject. 
Procedure AfterChangeExternalUserAuthorizationObject(ExternalUser,
                                                               PreviousAuthorizationObject,
                                                               NewAuthorizationObject) Export
	
	AuthorizationObjects = New Array;
	If PreviousAuthorizationObject <> NULL Then
		AuthorizationObjects.Add(PreviousAuthorizationObject);
	EndIf;
	AuthorizationObjects.Add(NewAuthorizationObject);
	
	Parameters = New Structure;
	Parameters.Insert("AuthorizationObjects", AuthorizationObjects);
	
	InformationRegisters.AccessValuesGroups.UpdateUsersGroupings(Parameters);
	
EndProcedure

// Copies rights from one user to another.
Procedure OnCopyRightsToNewUser(Source, Destination) Export
	
	SimplifiedInterface = SimplifiedAccessRightsSetupInterface();
	Query = New Query;
	Query.SetParameter("User", Source);
	
	If SimplifiedInterface Then
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.Ref.Profile AS Profile
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	(AccessGroupsUsers.User = &User
		|			OR AccessGroupsUsers.User IN
		|				(SELECT
		|					UserGroupCompositions.UsersGroup
		|				FROM
		|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|				WHERE
		|					UserGroupCompositions.User = &User))";
	Else
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsUsers.Ref AS AccessGroup
		|FROM
		|	Catalog.AccessGroups.Users AS AccessGroupsUsers
		|WHERE
		|	(AccessGroupsUsers.User = &User
		|			OR AccessGroupsUsers.User IN
		|				(SELECT
		|					UserGroupCompositions.UsersGroup
		|				FROM
		|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|				WHERE
		|					UserGroupCompositions.User = &User))";
	EndIf;
	
	QueryResult = Query.Execute();
	If QueryResult.IsEmpty() Then
		Return;
	EndIf;
	
	Selection = QueryResult.Select();
	
	If Not SimplifiedInterface Then
		Lock = New DataLock();
		LockItem = Lock.Add("Catalog.AccessGroups");
		LockItem.DataSource = QueryResult;
	EndIf;
	
	BeginTransaction();
	Try
		If SimplifiedInterface Then
			While Selection.Next() Do
				AccessManagement.EnableProfileForUser(Destination, Selection.Profile);
			EndDo;
		Else
			Lock.Lock();
			While Selection.Next() Do
				AccessGroupObject = Selection.AccessGroup.GetObject();
				If AccessGroupObject.Users.Find(Destination, "User") = Undefined Then
					Row = AccessGroupObject.Users.Add();
					Row.User = Destination;
					AccessGroupObject.Write();
				EndIf;
			EndDo;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// Event handlers of the ReportsOptions subsystem.

// See ReportsOptionsOverridable.CustomizeReportsOptions. 
Procedure OnSetUpReportsOptions(Settings) Export
	ModuleReportsOptions = Common.CommonModule("ReportsOptions");
	ModuleReportsOptions.CustomizeReportInManagerModule(Settings, Metadata.Reports.AccessRights);
EndProcedure

// AccessManagement subsystem event handlers.

// See AccessManagementOverridable.OnFillListsWithAccessRestriction. 
Procedure OnFillListsWithAccessRestriction(Lists) Export
	
	Lists.Insert(Metadata.Catalogs.AccessGroupProfiles, True);
	Lists.Insert(Metadata.Catalogs.AccessGroups, True);
	
EndProcedure

// Events handlers of the SaaSTechnology library.

// See DataExportImportOverridable.OnFillCommonDataTypesThatDoNotRequireMappingRefsOnImport. 
Procedure OnFillCommonDataTypesThatDoNotRequireMappingRefsOnImport(Types) Export
	
	// In separated data, references are used only to predefined items of the DeleteAccessKinds chart of 
	// characteristic types.
	Types.Add(Metadata.ChartsOfCharacteristicTypes.DeleteAccessKinds);
	
EndProcedure

// See ExportImportDataOverridable.OnFillTypesExcludedFromExportImport. 
Procedure OnFillTypesExcludedFromExportImport(Types) Export
	
	Types.Add(Metadata.ChartsOfCharacteristicTypes.DeleteAccessKinds);
	
EndProcedure

// See DataExportImportOverridable.OnRegisterDataExportHandlers. 
Procedure OnRegisterDataExportHandlers(HandlersTable) Export
	ModuleDataExportImportInternalEvents = Common.CommonModule("ExportImportDataInternalEvents");
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroupProfiles;
	Handler.Handler = Catalogs.AccessGroupProfiles;
	Handler.BeforeExportObject = True;
	Handler.Version = ModuleDataExportImportInternalEvents.HandlersVersion1_0_0_1();
	
	Handler = HandlersTable.Add();
	Handler.MetadataObject = Metadata.Catalogs.AccessGroups;
	Handler.Handler = Catalogs.AccessGroups;
	Handler.BeforeExportObject = True;
	Handler.Version = ModuleDataExportImportInternalEvents.HandlersVersion1_0_0_1();
EndProcedure

#EndRegion

#Region Private

// See DataExportImportOverridable.OnRegisterDataExportHandlers. 
Procedure BeforeExportObject(Container, ObjectExportManager, Serializer, Object, Artifacts, Cancel) Export
	
	// Extension roles are assigned independently both in the box and in the service.
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.DeleteExtensionsRoles(Object);
	EndIf;
	
	// In the SaaS mode, the right to open external reports and data processors is not used for data 
	// area users. The check is applied only when the Box -> Service transition occurs.
	If Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	If TypeOf(Object) = Type("CatalogObject.AccessGroupProfiles") Then
		Profile = Object;
		
	ElsIf TypeOf(Object) = Type("CatalogObject.AccessGroups") AND Not Object.IsFolder Then
		Profile = Object.Profile;
	Else
		Return;
	EndIf;
	
	If IsProfileOpenExternalReportsAndDataProcessors(Profile) Then
		Cancel = True;
	EndIf;
	
EndProcedure

// See CommonOverridable.OnAddSessionParametersSettingHandlers. 
Procedure SessionParametersSetting(ParameterName, SpecifiedParameters) Export
	
	#Region UniversalRestriction
	If ParameterName = "AccessRestrictionParameters" Then
		SessionParameters.AccessRestrictionParameters = New FixedStructure(New Structure);
		SpecifiedParameters.Add("AccessRestrictionParameters");
		Return;
	EndIf;
	
	If ParameterName = "DIsableAccessKeysUpdate" Then
		Properties = New Structure;
		Properties.Insert("Standard",      False);
		Properties.Insert("Full",           False);
		Properties.Insert("EditedLists", New ValueStorage(New Map));
		SessionParameters.DIsableAccessKeysUpdate = New FixedStructure(Properties);
		SpecifiedParameters.Add("DIsableAccessKeysUpdate");
		Return;
	EndIf;
	
	UniversalRestriction = LimitAccessAtRecordLevelUniversally(True, True);
	
	SessionParameters.RecordLevelAccessRestrictionIsUniversal = UniversalRestriction;
	
	SpecifiedParameters.Add("RecordLevelAccessRestrictionIsUniversal");
	If ParameterName = "RecordLevelAccessRestrictionIsUniversal" Then
		Return;
	EndIf;
	#EndRegion
	
	// If you want the preprocessor to function correctly when the access is restricted, initialize all 
	// session parameters that can be required by the preprocessor.
	LimitAccessAtRecordLevel = Constants.LimitAccessAtRecordLevel.Get();
	InfobaseLockedForUpdate = ValueIsFilled(
		InfobaseUpdateInternal.InfobaseLockedForUpdate(False));
	
	#Region UniversalRestriction
	If Not LimitAccessAtRecordLevel
	 Or Not UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.ListsWithReadRestrictionDisabled =
			?(InfobaseLockedForUpdate
				Or Not UniversalRestriction, "Undefined", "All");
		
		BlankAccessGroupsSet = Catalogs.SetsOfAccessGroups.EmptyRef();
		
		SessionParameters.AccessRestrictionTemplatesVersions   = AccessRestrictionTemplatesVersions();
		SessionParameters.AllowedAccessGroupsSet       = BlankAccessGroupsSet;
		SessionParameters.AllowedBlankAccessGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUserGroupsSet = BlankAccessGroupsSet;
		SessionParameters.AllowedUser            = BlankAccessGroupsSet;
		SessionParameters.CommonAccessRestrictionTemplateParameters = "";
		SessionParameters.ListsWithAccessGroupsAccessKeysRestriction  = "";
		SessionParameters.ListsWithUsersAccessKeysRestriction = "";
		SessionParameters.ListsWithRestrictionByFields = "";
		
		SpecifiedParameters.Add("ListsWithReadRestrictionDisabled");
		SpecifiedParameters.Add("AccessRestrictionTemplatesVersions");
		SpecifiedParameters.Add("AllowedAccessGroupsSet");
		SpecifiedParameters.Add("AllowedBlankAccessGroupsSet");
		SpecifiedParameters.Add("AllowedUserGroupsSet");
		SpecifiedParameters.Add("AllowedUser");
		SpecifiedParameters.Add("CommonAccessRestrictionTemplateParameters");
		SpecifiedParameters.Add("ListsWithAccessGroupsAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithUsersAccessKeysRestriction");
		SpecifiedParameters.Add("ListsWithRestrictionByFields");
	EndIf;
	#EndRegion
	
	If Not LimitAccessAtRecordLevel
	 Or UniversalRestriction
	 Or InfobaseLockedForUpdate Then
		
		SessionParameters.RecordLevelAccessRestrictionInUse =
			?(InfobaseLockedForUpdate
				Or UniversalRestriction, "", False);
		
		SessionParameters.AllAccessKindsExceptSpecialOnes             = "";
		SessionParameters.DisabledAccessKinds      = "";
		SessionParameters.AccessKindsWithoutGroupsForAccessValues      = "";
		SessionParameters.AccessKindsWithSingleGroupForAccessValue = "";
		
		SessionParameters.AccessValuesTypesWithGroups
			= New FixedArray(New Array);
		
		SessionParameters.TablesWithIndividualRightsSettings = "";
		
		SessionParameters.IDsOfTablesWithIndividualRightsSettings
			= New FixedArray(New Array);
		
		SessionParameters.RightsSettingsOwnersTypes
			= New FixedArray(New Array);
		
		SessionParameters.TableOfExtensionsWithAccessRestriction = "";
		
		SpecifiedParameters.Add("RecordLevelAccessRestrictionInUse");
		SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
		SpecifiedParameters.Add("DisabledAccessKinds");
		SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
		SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
		SpecifiedParameters.Add("AccessValuesTypesWithGroups");
		SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
		SpecifiedParameters.Add("RightsSettingsOwnersTypes");
		SpecifiedParameters.Add("TableOfExtensionsWithAccessRestriction");
	EndIf;
	
	If InfobaseLockedForUpdate Then
		Return;
	EndIf;
	
	#Region UniversalRestriction
	If UniversalRestriction Then
		ActiveAccessRestrictionParameters(Undefined, Undefined, False, True);
		Return;
	EndIf;
	#EndRegion
	
	If Not LimitAccessAtRecordLevel Then
		Return;
	EndIf;
	
	SessionParameters.RecordLevelAccessRestrictionInUse = True;
	
	Query = New Query;
	Query.SetParameter("CurrentUser", Users.AuthorizedUser());
	Query.Text =
	"SELECT DISTINCT
	|	DefaultValues.AccessValuesType AS ValuesType,
	|	DefaultValues.AllAllowedWithoutExceptions AS AllAllowedWithoutExceptions
	|INTO DefaultValuesForUser
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				Catalog.AccessGroups.Users AS AccessGroupsUsers
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						AccessGroupsUsers.Ref = DefaultValues.AccessGroup
	|							AND AccessGroupsUsers.User = UserGroupCompositions.UsersGroup
	|							AND UserGroupCompositions.User = &CurrentUser)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	DefaultValues.ValuesType
	|FROM
	|	DefaultValuesForUser AS DefaultValues
	|
	|GROUP BY
	|	DefaultValues.ValuesType
	|
	|HAVING
	|	MIN(DefaultValues.AllAllowedWithoutExceptions) = TRUE";
	
	ValuesTypesAllAllowedWithoutExceptions = Query.Execute().Unload().UnloadColumn("ValuesType");
	
	// Setting parameters AllAccessKindsExceptSpecial and DisabledAccessKinds.
	AllAccessKindsExceptSpecialOnes        = New Array;
	DisabledAccessKinds = New Array;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	For each AccessKindProperties In AccessKindsProperties.Array Do
		AllAccessKindsExceptSpecialOnes.Add(AccessKindProperties.Name);
		
		If NOT AccessKindUsed(AccessKindProperties.Ref)
		 OR ValuesTypesAllAllowedWithoutExceptions.Find(AccessKindProperties.Ref) <> Undefined Then
			
			DisabledAccessKinds.Add(AccessKindProperties.Name);
		EndIf;
	EndDo;
	
	SessionParameters.AllAccessKindsExceptSpecialOnes = AllAccessKindsCombinations(AllAccessKindsExceptSpecialOnes);
	
	SpecifiedParameters.Add("AllAccessKindsExceptSpecialOnes");
	
	AllAccessKindsExceptSpecialOnesDisabled = (AllAccessKindsExceptSpecialOnes.Count()
		= DisabledAccessKinds.Count());
	
	If AllAccessKindsExceptSpecialOnesDisabled Then
		SessionParameters.DisabledAccessKinds = "All";
	Else
		SessionParameters.DisabledAccessKinds
			= AllAccessKindsCombinations(DisabledAccessKinds);
	EndIf;
	
	SpecifiedParameters.Add("DisabledAccessKinds");
	
	// Setting the AccessKindsWithoutGroupsForAccessValue,
	// AccessKindsWithSingleGroupForAccessValue, and AccessValuesTypesWithGroups parameters.
	SessionParameters.AccessKindsWithoutGroupsForAccessValues =
		AllAccessKindsCombinations(AccessKindsProperties.NoGroupsForAccessValue);
	SessionParameters.AccessKindsWithSingleGroupForAccessValue =
		AllAccessKindsCombinations(AccessKindsProperties.WithOneGroupForAccessValue);
	
	AccessValuesTypesWithGroups = New Array;
	For each KeyAndValue In AccessKindsProperties.AccessValuesTypesWithGroups Do
		AccessValuesTypesWithGroups.Add(KeyAndValue.Value);
	EndDo;
	SessionParameters.AccessValuesTypesWithGroups = New FixedArray(AccessValuesTypesWithGroups);
	
	SpecifiedParameters.Add("AccessKindsWithoutGroupsForAccessValues");
	SpecifiedParameters.Add("AccessKindsWithSingleGroupForAccessValue");
	SpecifiedParameters.Add("AccessValuesTypesWithGroups");
	
	// Setting the TablesWithIndividualRightsSettings,
	// IDsOfTablesWithIndividualRightsSettings, and RightsSettingsOwnersTypes parameters.
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	SeparateTables = AvailableRights.SeparateTables;
	TablesWithIndividualRightsSettings = "";
	IDsOfTablesWithIndividualRightsSettings = New Array;
	For each KeyAndValue In SeparateTables Do
		TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings
			+ "|" + KeyAndValue.Value + ";" + Chars.LF;
		IDsOfTablesWithIndividualRightsSettings.Add(KeyAndValue.Key);
	EndDo;
	
	SessionParameters.TablesWithIndividualRightsSettings = TablesWithIndividualRightsSettings;
	
	SessionParameters.IDsOfTablesWithIndividualRightsSettings =
		New FixedArray(IDsOfTablesWithIndividualRightsSettings);
	
	SessionParameters.RightsSettingsOwnersTypes = AvailableRights.OwnersTypes;
	
	FullNames = Catalogs.ExtensionObjectIDs.DataTablesFullNames();
	ExtensionsTables = StrConcat(FullNames, ";" + Chars.LF + "|");
	ExtensionsTables = ?(ExtensionsTables = "", "", "|" + ExtensionsTables + ";" + Chars.LF);
	
	SessionParameters.TableOfExtensionsWithAccessRestriction = ExtensionsTables;
	
	SpecifiedParameters.Add("TablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("IDsOfTablesWithIndividualRightsSettings");
	SpecifiedParameters.Add("RightsSettingsOwnersTypes");
	SpecifiedParameters.Add("TableOfExtensionsWithAccessRestriction");
	
EndProcedure

// Updates a role list of infobase users by their current access groups.
// 
//  Users with the FullAccess role are skipped.
// 
// Parameters:
//  Users - CatalogRef.Users,
//                 CatalogRef.ExternalUsers.
//                 Array of values of the types specified above.
//               - Undefined - update all user roles.
//               - Type used for metadata object search:
//                 if Catalog.ExternalUsers is found, all external user roles are updated, otherwise, 
//                 all user roles are updated.
//                 
//
//  ServiceUserPassword - String - a password for authorization in the service manager.
//                        
//  HasChanges - Boolean (return value) - True is returned to this parameter if changes are saved. 
//                  Otherwise, not modified.
//
Procedure UpdateUserRoles(Val Users1 = Undefined,
                                    Val ServiceUserPassword = Undefined,
                                    HasChanges = False) Export
	
	If NOT UsersInternal.CannotEditRoles() Then
		// Roles are set by tools of Users and ExternalUsers subsystems.
		Return;
	EndIf;
	
	If Users1 = Undefined Then
		UsersArray = Undefined;
		Users.FindAmbiguousIBUsers(Undefined);
		
	ElsIf TypeOf(Users1) = Type("Array") Then
		UsersArray = Users1;
		If UsersArray.Count() = 0 Then
			Return;
		ElsIf UsersArray.Count() = 1 Then
			Users.FindAmbiguousIBUsers(UsersArray[0]);
		Else
			Users.FindAmbiguousIBUsers(Undefined);
		EndIf;
		
	ElsIf TypeOf(Users1) = Type("Type") Then
		UsersArray = Users1;
		Users.FindAmbiguousIBUsers(Undefined);
	Else
		UsersArray = New Array;
		UsersArray.Add(Users1);
		Users.FindAmbiguousIBUsers(Users1);
	EndIf;
	
	SetPrivilegedMode(True);
	
	CurrentUsersProperties = CurrentUsersProperties(UsersArray);
	
	// Checking parameters in the loop.
	AllRoles                       = UsersInternal.AllRoles().Map;
	IBUsersIDs = CurrentUsersProperties.IBUsersIDs;
	NewUsersRoles        = CurrentUsersProperties.UsersRoles;
	Administrators                = CurrentUsersProperties.Administrators;
	DataSeparationEnabled            = Common.DataSeparationEnabled();
	
	RequiredAdministratorRoles = New Map;
	RequiredAdministratorRoles.Insert("FullRights", True);
	If Not DataSeparationEnabled Then
		RequiredAdministratorRoles.Insert("SystemAdministrator", True);
	EndIf;
	AdditionalAdministratorRoles = New Map;
	AdditionalAdministratorRoles.Insert("InteractiveOpenExtReportsAndDataProcessors", True);
	
	// Expected result after the loop ends.
	NewIBAdministrators     = New Map;
	IBUsersToUpdate = New Map;
	
	For Each UserDetails In IBUsersIDs Do
		
		CurrentUser         = UserDetails.User;
		IBUserID = UserDetails.IBUserID;
		NewIBAdministrator        = False;
		
		Cancel = False;
		SaaSIntegration.OnUpdateIBUserRoles(IBUserID, Cancel);
		If Cancel Then
			Continue;
		EndIf;
		
		// Searching for an infobase user.
		If TypeOf(IBUserID) = Type("UUID") Then
			InfobaseUser = InfoBaseUsers.FindByUUID(
				IBUserID);
		Else
			InfobaseUser = Undefined;
		EndIf;
		
		If InfobaseUser = Undefined
		 Or Not ValueIsFilled(InfobaseUser.Name) Then
			Continue;
		EndIf;
		
		Filter = New Structure("User", CurrentUser);
		NewRoles = NewUsersRoles.Copy(
			NewUsersRoles.FindRows(Filter), "Role, RoleRef");
		
		NewRoles.Indexes.Add("Role");
		
		If Administrators[CurrentUser] <> Undefined Then
			CurrentNewRoles = NewRoles;
			NewRoles = CurrentNewRoles.Copy(New Array);
			For Each KeyAndValue In RequiredAdministratorRoles Do
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
			For Each KeyAndValue In AdditionalAdministratorRoles Do
				If CurrentNewRoles.Find(KeyAndValue.Key, "Role") = Undefined Then
					Continue;
				EndIf;
				NewRoles.Add().Role = KeyAndValue.Key;
			EndDo;
		EndIf;
		
		// Checking old roles.
		OldRoles        = New Map;
		RolesForAdding = New Map;
		RolesForDeletion   = New Map;
		
		For Each Role In InfobaseUser.Roles Do
			RoleName = Role.Name;
			OldRoles.Insert(RoleName, True);
			If NewRoles.Find(RoleName, "Role") = Undefined Then
				RolesForDeletion.Insert(RoleName, True);
			EndIf;
		EndDo;
		
		UnavailableRoles = UsersInternalCached.UnavailableRolesByUserType(
			TypeOf(CurrentUser) = Type("CatalogRef.ExternalUsers"));
		
		// Checking new roles.
		For Each Row In NewRoles Do
			
			If OldRoles[Row.Role] <> Undefined Then
				If DataSeparationEnabled
				   AND UnavailableRoles.Get(Row.Role) <> Undefined Then
					
					RegisterUnavailableRole(Row, CurrentUser);
					RolesForDeletion.Insert(Row.Role, True);
				EndIf;
				Continue;
			EndIf;
			
			If AllRoles.Get(Row.Role) = Undefined Then
				RegisterNotFoundRole(Row, CurrentUser);
				Continue;
			EndIf;
			
			If UnavailableRoles.Get(Row.Role) <> Undefined Then
				RegisterUnavailableRole(Row, CurrentUser);
				Continue;
			EndIf;
			
			RolesForAdding.Insert(Row.Role, True);
			
			If Row.Role = "SystemAdministrator" Then
				NewIBAdministrator = True;
			EndIf;
		EndDo;
		
		// Completing the current user processing.
		If RolesForAdding.Count() = 0
		   AND RolesForDeletion.Count()   = 0 Then
			Continue;
		EndIf;
		
		RolesChanges = New Structure;
		RolesChanges.Insert("UserRef", CurrentUser);
		RolesChanges.Insert("InfobaseUser",     InfobaseUser);
		RolesChanges.Insert("RolesForAdding",  RolesForAdding);
		RolesChanges.Insert("RolesForDeletion",    RolesForDeletion);
		
		If NewIBAdministrator Then
			NewIBAdministrators.Insert(CurrentUser, RolesChanges);
		Else
			IBUsersToUpdate.Insert(CurrentUser, RolesChanges);
		EndIf;
		
		HasChanges = True;
	EndDo;
	
	// Adding new administrators.
	If NewIBAdministrators.Count() > 0 Then
		UpdateIBUsersRoles(NewIBAdministrators, ServiceUserPassword);
	EndIf;
	
	// Deleting old administrators and updating other users.
	If IBUsersToUpdate.Count() > 0 Then
		UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword);
	EndIf;
	
EndProcedure

// Checking the Administrators access group before writing.
Procedure CheckAdministratorsAccessGroupForIBUser(GroupUsers, ErrorDescription) Export
	
	Users.FindAmbiguousIBUsers(Undefined);
	
	// Checking a blank list of infobase users in the Administrators access group.
	SetPrivilegedMode(True);
	ValidAdministratorFound = False;
	
	For Each UserDetails In GroupUsers Do
		
		If Not ValueIsFilled(UserDetails.User)
		 Or TypeOf(UserDetails.User) <> Type("CatalogRef.Users")
		   AND TypeOf(UserDetails.User) <> Type("CatalogRef.Users") Then
			Continue;
		EndIf;
		
		InfobaseUser = InfoBaseUsers.FindByUUID(
			UserDetails.User.IBUserID);
		
		If InfobaseUser <> Undefined
		   AND Users.CanSignIn(InfobaseUser) Then
			
			ValidAdministratorFound = True;
			Break;
		EndIf;
	EndDo;
	
	If NOT ValidAdministratorFound Then
		ErrorDescription =
			NStr("ru = 'В группе доступа Администраторы
			           |должен быть хотя бы один пользователь,
			           |которому разрешен вход в программу.'; 
			           |en = 'At least one user authorized to access
			           |the application must be included in
			           |the Administrators access group.'; 
			           |pl = 'W grupie dostępu Administratorzy
			           |musi być przynajmniej jeden użytkownik,
			           |któremu zezwolono na wejście do programu.';
			           |de = 'Die Administratoren müssen mindestens einen Benutzer in der Zugriffsgruppe
			           |haben,
			           |der sich am Programm anmelden darf.';
			           |ro = 'În grupul de acces Administratori
			           |trebuie să existe cel puțin un utilizator
			           |care are permisiunea de a accesa aplicația.';
			           |tr = 'Yöneticiler 
			           |erişim grubunda, uygulamaya erişebilecek 
			           |en az bir kullanıcı olmalıdır.'; 
			           |es_ES = 'En el grupo de acceso Administradores
			           |debe ser incluido aunque se un usuario
			           |al que le está permitido entrar en el programa.'");
	EndIf;
	
EndProcedure

// See AccessManagement.HasTableRestrictionByAccessKind. 
Function HasTableRestrictionByAccessKind(Table, AccessKind, AllAccessKinds) Export
	
	SetPrivilegedMode(True);
	
	DisabledAccessKinds = SessionParameters.DisabledAccessKinds;
	If DisabledAccessKinds = "All"
	 Or StrFind(DisabledAccessKinds, "," + AccessKind + ",") > 0 Then
		Return False;
	EndIf;
	
	AccessKindsArray = StrSplit(AllAccessKinds, ",", False);
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	ErrorTitle =
		NStr("ru = 'Ошибка в функции ЕстьОграничениеТаблицыПоВидуДоступа общего модуля УправлениеДоступом.'; en = 'An error occurred in the HasTableRestrictionByAccessKind function of the AccessManagement common module.'; pl = 'Błąd w funkcji ЕстьОграничениеТаблицыПоВидуДоступа wspólnego modułu УправлениеДоступом.';de = 'Fehler in der Funktion GibtEinschränkungenDerTabelleNachZugriffsArt des allgemeinen Moduls ZugriffsKontrolle.';ro = 'Eroare în funcția ЕстьОграничениеТаблицыПоВидуДоступа a modulului general УправлениеДоступом.';tr = 'ErişimKontrolü genel modülünün VeriDeğişiklikYasağıBulunmuştur işlevinde bir hata oluştu.'; es_ES = 'Error en la función HasTableRestrictionByAccessKind del módulo común AccessManagement.'")
		+ Chars.LF;
	
	AccessKindProperties = AccessKindsProperties.ByNames.Get(AccessKind);
	If AccessKindProperties = Undefined Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не найден вид доступа ""%1"", указанный в параметре ВидДоступа.'; en = 'The ""%1"" access kind specified in the AccessKind parameter is not found.'; pl = 'Nie znaleziono rodzaj dostępu ""%1"", określony w parametrze ВидДоступа.';de = 'Die im Parameter ""%1"" ZugriffsArt angegebene Zugriffsart wurde nicht gefunden.';ro = 'Nu a fost găsit tipul de acces ""%1"" indicat în parametrul ВидДоступа.';tr = 'ErişimTürü parametresinde belirtilen ""%1"" erişim türü bulunamadı.'; es_ES = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro AccessKind.'"), AccessKind);
		Raise ErrorText;
	EndIf;
	AccessKindRef = AccessKindProperties.Ref;
	
	AllDisabledTableAccessKinds = True;
	AccessKindsUse = New Map;
	AccessKindSpecifiedInAllAccessKinds = False;
	
	For Each CurrentAccessKind In AccessKindsArray Do
		CurrentAccessKind = TrimAll(CurrentAccessKind);
		AccessKindProperties = AccessKindsProperties.ByNames.Get(CurrentAccessKind);
		If AccessKindProperties = Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не найден вид доступа ""%1"", указанный в параметре
				           |ВсеВидыДоступа: ""%2"".'; 
				           |en = 'The ""%1"" access kind specified in the AllAccessKinds parameter
				           |is not found: ""%2"".'; 
				           |pl = 'Nie znaleziono rodzaj dostępu ""%1"", określony w parametrze
				           | ВсеВидыДоступа: ""%2"".';
				           |de = 'Der im Parameter ""%1"" AlleZugriffsArten angegebene 
				           |Zugriffsart wurde nicht gefunden:""%2"".';
				           |ro = 'Nu a fost găsit tipul de acces ""%1"" indicat în parametrul
				           |ВсеВидыДоступа: ""%2"".';
				           |tr = 'TümErişimTürleri
				           | parametresinde belirtilen ""%1"" erişim türü %2bulunamadı.'; 
				           |es_ES = 'No se ha encontrado el tipo de acceso ""%1"" indicado en el parámetro
				           |AllAccessKinds ""%2"".'"), CurrentAccessKind, AllAccessKinds);
			Raise ErrorText;
		EndIf;
		If AccessKindProperties.Name = AccessKind Then
			AccessKindSpecifiedInAllAccessKinds = True;
		EndIf;
		Used = StrFind(DisabledAccessKinds, "," + AccessKindProperties.Name + ",") = 0;
		AccessKindsUse.Insert(AccessKindProperties.Ref, Used);
		If Used Then
			AllDisabledTableAccessKinds = False;
		EndIf;
	EndDo;
	
	If Not AccessKindSpecifiedInAllAccessKinds Then
		ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Вид доступа ""%1"", указанный в параметре ВидДоступа не найден в параметре
			           |ВсеВидыДоступа: ""%2"".'; 
			           |en = 'The ""%1"" access kind specified in the AccessKind parameter is not found in
			           |the AllAccessKinds parameter: ""%2"".'; 
			           |pl = 'Rodzaj dostępu ""%1"", określony w parametrze ВидДоступа nie znaleziony w parametrze
			           |ВсеВидыДоступа: ""%2"".';
			           |de = 'Der im Parameter ZugriffsArt angegebene Zugriffstyp ""%1"" wurde im Parameter
			           |AlleZugriffsArten nicht gefunden: ""%2"".';
			           |ro = 'Tipul de acces ""%1"", indicat în parametrul ВидДоступа nu a fost găsit în parametrul
			           |ВсеВидыДоступа: ""%2"".';
			           |tr = 'ErişimTürü parametresinde belirtilen erişim türü ""%1"" TümErişimTürleri parametresinde
			           | bulunamadı: ""%2"".'; 
			           |es_ES = 'El tipo de acceso ""%1"" indicado en el parámetro AccessKind no se ha encontrado en el parámetro
			           | AllAccessKinds: ""%2"".'"), AccessKind, AllAccessKinds);
		Raise ErrorText;
	EndIf;
	
	If AllDisabledTableAccessKinds Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("MainListTableName", Table);
	Query.SetParameter("AuthorizedUser", Users.AuthorizedUser());
	
	Query.Text = AccessGroupsRequestText();
	
	QueryText =
	"SELECT
	|	DefaultValues.AccessGroup AS AccessGroup,
	|	DefaultValues.AccessValuesType AS AccessKind
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultValues
	|		INNER JOIN UserAccessGroups AS UserAccessGroups
	|		ON DefaultValues.AccessGroup = UserAccessGroups.Ref
	|WHERE
	|	NOT DefaultValues.AllAllowedWithoutExceptions
	|	AND TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				Catalog.AccessGroups.Users AS AccessGroupsUsers
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						AccessGroupsUsers.Ref = DefaultValues.AccessGroup
	|							AND AccessGroupsUsers.User = UserGroupCompositions.UsersGroup
	|							AND UserGroupCompositions.User = &AuthorizedUser)";
	
	AddQueryToPackage(Query.Text, QueryText);
	Selection = Query.Execute().Select();
	
	SetAccessGroupsOfAccessKinds = New Map;
	HasAccessGroupWithRestrictionByAccessKind = False;
	
	While Selection.Next() Do
		SetAccessKinds = SetAccessGroupsOfAccessKinds.Get(Selection.AccessGroup);
		If SetAccessKinds = Undefined Then
			SetAccessKinds = New Map;
			SetAccessGroupsOfAccessKinds.Insert(Selection.AccessGroup, SetAccessKinds);
		EndIf;
		If AccessKindsUse.Get(Selection.AccessKind) = Undefined Then
			Continue;
		EndIf;
		SetAccessKinds.Insert(Selection.AccessKind, True);
		If Selection.AccessKind = AccessKindRef Then
			HasAccessGroupWithRestrictionByAccessKind = True;
		EndIf;
	EndDo;
	
	HasAccessGroupWithoutRestrictionsByAllAccessKinds = False;
	
	For Each AccessGroupDetails In SetAccessGroupsOfAccessKinds Do
		SetAccessKinds = AccessGroupDetails.Value;
		AllTableAccessKindsWithoutRestrictionsInAccessGroup = True;
		For Each AccessKindUsageDetails In AccessKindsUse Do
			If Not AccessKindUsageDetails.Value Then
				Continue; // Obsolete attribute.
			EndIf;
			If SetAccessKinds.Get(AccessKindUsageDetails.Key) = Undefined Then
				Continue; // AllAllowedWithoutExceptions or there are no restrictions by access kind.
			EndIf;
			AllTableAccessKindsWithoutRestrictionsInAccessGroup = False;
			Break;
		EndDo;
		If AllTableAccessKindsWithoutRestrictionsInAccessGroup Then
			HasAccessGroupWithoutRestrictionsByAllAccessKinds = True;
			Break;
		EndIf;
	EndDo;
	
	If HasAccessGroupWithoutRestrictionsByAllAccessKinds Then
		Return False;
	EndIf;
	
	Return HasAccessGroupWithRestrictionByAccessKind;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// UpdateAccessValuesGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording access value groups to the AccessValuesGroups information register for 
//   required metadata objects
//
Procedure UpdateAccessValuesGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If AccessValuesWithGroups.ByTypesForUpdate.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Object);
	EndIf;
	
EndProcedure

// The UpdateRightsSettingsOwnersGroups subscription handler responds to the BeforeWrite event by calling:
// - a method for recording a hierarchy of the object right settings owner to the 
//   InheritObjectsRightsSettings information register for required metadata objects.
//
Procedure UpdateRightsSettingsOwnersGroups(Val Object, Cancel) Export
	
	If Object.DataExchange.Load Then
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	AvailableRightsByTypes = AvailableRights.ByTypes;
	
	If AvailableRightsByTypes.Get(TypeOf(Object)) <> Undefined Then
		InformationRegisters.ObjectRightsSettingsInheritance.UpdateRegisterData(Object);
	EndIf;
	
EndProcedure

// The WriteAccessValuesSets subscription handler responds to the OnWrite event by calling the 
// method used for recording object access values to InformationRegister.AccessValuesSets.
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if access value sets are not applied.
//
Procedure WriteAccessValuesSetsOnWrite(Val Object, Cancel) Export
	
	// Check of the DataExchange.Import is ignored only when the WriteAccessValuesSets property is set.
	// 
	// In this case, when recording the leading object for its correct RLS operations, a program 
	// recording of the subordinate object is performed to update the AccessValuesSets service tabular section.
	If Object.DataExchange.Load
	   AND NOT Object.AdditionalProperties.Property("WriteAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteAccessValuesSets(Object, , Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

// WriteDependentAccessValuesSets subscription handler responds to the OnWrite event by overwriting 
// dependent access value sets in the AccessValuesSets information register.
//
//  The AccessManagement subsystem can be used when
// the specified subscription does not exist if dependent access value sets are not applied.
//
Procedure WriteDependentAccessValuesSetsOnWrite(Val Object, Cancel) Export
	
	// Check of the DataExchange.Import is ignored only when the WriteAccessValuesSets property is set.
	// 
	// In this case, when recording the leading object for its correct RLS operations, a program 
	// recording of the subordinate object is performed to update the AccessValuesSets service tabular section.
	If Object.DataExchange.Load
	   AND NOT Object.AdditionalProperties.Property("WriteDependentAccessValuesSets") Then
		
		Return;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Object) Then
		Return;
	EndIf;
	
	WriteDependentAccessValuesSets(Object, Object.AdditionalProperties.Property(
		"WriteAccessValueSetsOnUpdateIB"));
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Scheduled job handlers.

// DataFillingForAccessRestriction scheduled job handler.
Procedure DataFillingForAccessRestrictionJobHandler() Export
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction);
	
	DataFillingForAccessRestriction();
	
EndProcedure

// Sequentially fills and updates the data required for the AccessManagement subsystem in the access 
// restriction mode at the record level.
// 
//  Fills sets of access values when the access restriction mode is enabled
//  at the record level. The sets are filled in by portions during each run, until all access value 
// sets are filled in.
//  When the access restriction mode at the record level is disabled, access value sets
// (filled previously) are deleted upon overwriting objects, not all at once.
//  The procedure updates cache attributes at the record level regardless of the access restriction mode.
//  Disables the scheduled job after all updates are completed and data is filled.
//
//  The progress information is written to the event log.
//
//  The procedure can be called programmatically, for example, when updating the infobase.
// For data update purposes, the Catalog.AccessGroups.UpdateDataRestrictionAccess form is available. 
// This form can be used for interactive update of access restriction data when updating the 
// infobase.
//
Procedure DataFillingForAccessRestriction(DataVolume = 0, OnlyCacheAttributes = False, HasChanges = Undefined) Export
	
	SetPrivilegedMode(True);
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	AccessValuesWithGroups = AccessKindsProperties.AccessValuesWithGroups;
	
	If AccessManagement.LimitAccessAtRecordLevel() AND NOT OnlyCacheAttributes Then
		
		// Filling access value groups in the AccessValuesGroups information register.
		For Each TableName In AccessValuesWithGroups.NamesOfTablesToUpdate Do
			
			If DataVolume < 10000 Then
				
				Query = New Query;
				Query.Text =
				"SELECT TOP 10000
				|	CurrentTable.Ref AS Ref
				|FROM
				|	&CurrentTable AS CurrentTable
				|		LEFT JOIN InformationRegister.AccessValuesGroups AS AccessValuesGroups
				|		ON CurrentTable.Ref = AccessValuesGroups.AccessValue
				|			AND (AccessValuesGroups.DataGroup = 0)
				|WHERE
				|	AccessValuesGroups.AccessValue IS NULL ";
				
				Query.Text = StrReplace(Query.Text, "&CurrentTable", TableName);
				Values = Query.Execute().Unload().UnloadColumn("Ref");
				
				InformationRegisters.AccessValuesGroups.UpdateAccessValuesGroups(Values, HasChanges);
				
				DataVolume = DataVolume + Values.Count();
			EndIf;
			
		EndDo;
		
		If DataVolume < 10000
		   AND NOT InformationRegisters.DeleteAccessValuesSets.MoveDataToNewRegister() Then
			// Before filling the access value sets, all access value sets are moved from the old register.
			// 
			Return;
			
		ElsIf DataVolume < 10000 Then
			
			// Filling the AccessValuesSets information register.
			ObjectsTypes = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"WriteAccessValuesSets");
			
			For each TypeDetails In ObjectsTypes Do
				Type = TypeDetails.Key;
				
				If DataVolume < 10000 AND Type <> Type("String") Then
				
					Query = New Query;
					Query.Text =
					"SELECT TOP 10000
					|	CurrentTable.Ref AS Ref
					|FROM
					|	&CurrentTable AS CurrentTable
					|		LEFT JOIN InformationRegister.AccessValuesSets AS InformationRegisterAccessValuesSets
					|		ON CurrentTable.Ref = InformationRegisterAccessValuesSets.Object
					|WHERE
					|	InformationRegisterAccessValuesSets.Object IS NULL ";
					Query.Text = StrReplace(Query.Text, "&CurrentTable", Metadata.FindByType(Type).FullName());
					Selection = Query.Execute().Select();
					DataVolume = DataVolume + Selection.Count();
					
					While Selection.Next() Do
						UpdateAccessValuesSets(Selection.Ref, HasChanges);
					EndDo;
				EndIf;
			EndDo;
		EndIf;
	Else
		InformationRegisters.DeleteAccessValuesSets.MoveDataToNewRegister();
	EndIf;
	
	// Updating cache attributes in access value sets.
	If DataVolume < 10000 Then
		
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		
		ValuesTypesTable = New ValueTable;
		ValuesTypesTable.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For each KeyAndValue In AccessValuesTypes Do
			ValuesTypesTable.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		TableOfValuesTypesWithGroups = New ValueTable;
		TableOfValuesTypesWithGroups.Columns.Add("ValuesType", Metadata.DefinedTypes.AccessValue.Type);
		For each KeyAndValue In AccessValuesTypesWithGroups Do
			TableOfValuesTypesWithGroups.Add().ValuesType = MetadataObjectEmptyRef(KeyAndValue.Key);
		EndDo;
		
		Query = New Query;
		Query.SetParameter("ValuesTypesTable", ValuesTypesTable);
		Query.SetParameter("TableOfValuesTypesWithGroups", TableOfValuesTypesWithGroups);
		Query.Text =
		"SELECT
		|	TypesTable.ValuesType
		|INTO ValuesTypesTable
		|FROM
		|	&ValuesTypesTable AS TypesTable
		|
		|INDEX BY
		|	TypesTable.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	TypesTable.ValuesType
		|INTO TableOfValuesTypesWithGroups
		|FROM
		|	&TableOfValuesTypesWithGroups AS TypesTable
		|
		|INDEX BY
		|	TypesTable.ValuesType
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT TOP 10000
		|	AccessValuesSets.Object,
		|	AccessValuesSets.SetNumber,
		|	AccessValuesSets.AccessValue,
		|	AccessValuesSets.Clarification,
		|	AccessValuesSets.Read,
		|	AccessValuesSets.Update
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	CASE
		|			WHEN AccessValuesSets.StandardValue <> TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						ValuesTypesTable AS ValuesTypesTable
		|					WHERE
		|						VALUETYPE(ValuesTypesTable.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|				THEN TRUE
		|			WHEN AccessValuesSets.StandardValue = TRUE
		|				THEN AccessValuesSets.ValueWithoutGroups = TRUE IN
		|						(SELECT TOP 1
		|							TRUE
		|						FROM
		|							TableOfValuesTypesWithGroups AS TableOfValuesTypesWithGroups
		|						WHERE
		|							VALUETYPE(TableOfValuesTypesWithGroups.ValuesType) = VALUETYPE(AccessValuesSets.AccessValue))
		|			ELSE AccessValuesSets.ValueWithoutGroups = TRUE
		|		END";
		Selection = Query.Execute().Select();
		DataVolume = DataVolume + Selection.Count();
		
		While Selection.Next() Do
			RecordManager = InformationRegisters.AccessValuesSets.CreateRecordManager();
			FillPropertyValues(RecordManager, Selection);
			
			AccessValueType = TypeOf(Selection.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				RecordManager.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					RecordManager.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
			RecordManager.Write();
			HasChanges = True;
		EndDo;
	EndIf;
	
	If DataVolume < 10000 Then
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Populate access restrictions data'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung';ro = 'Administrarea accesului.Completarea datelor pentru restricționarea accesului';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması'; es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso'",
				 Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Завершено заполнение данных для ограничения доступа.'; en = 'Data filling for access restriction is completed.'; pl = 'Zakończono wprowadzenie danych w celu ograniczenia dostępu.';de = 'Die Datenpopulation für die Zugriffsbeschränkung ist abgeschlossen.';ro = 'Completarea datelor pentru restricționarea accesului este finalizată.';tr = 'Erişim kısıtlaması için veri doldurulma işlemi tamamlandı.'; es_ES = 'Población de datos para la restricción de acceso se ha finalizado.'"),
			EventLogEntryTransactionMode.Transactional);
			
		SetDataFillingForAccessRestriction(False);
	Else
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Populate access restrictions data'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung';ro = 'Administrarea accesului.Completarea datelor pentru restricționarea accesului';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması'; es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso'",
				 Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Выполнена запись части данных для ограничения доступа.'; en = 'A part of data was recorded for access restriction.'; pl = 'Część danych dotyczących ograniczeń dostępu jest zapisana.';de = 'Ein Teil der Daten für die Zugriffsbeschränkung wird geschrieben.';ro = 'Este înregistrată o parte din datele pentru restricționarea accesului.';tr = 'Erişim kısıtlaması için verilerin bir kısmı yazılmıştır.'; es_ES = 'Parte de los datos para la restricción de acceso se ha grabado.'"),
			EventLogEntryTransactionMode.Transactional);
	EndIf;
	
EndProcedure

// Determines usage of a scheduled job for filling access management data.
//
// Parameters:
//   Use - Boolean - True if the job must be enabled, otherwise, False.
//
Procedure SetDataFillingForAccessRestriction(Val Usage) Export
	
	ScheduledJobsServer.SetPredefinedScheduledJobUsage(
		Metadata.ScheduledJobs.DataFillingForAccessRestriction, Usage);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access kind management.

// Returns True if the access kind is enabled by functional options for all sessions.
//
// Parameters:
//  AccessKind - String - a blank reference of the main type.
//             - String - an access kind name.
//
// Returns:
//  Boolean.
//
Function AccessKindUsed(Val AccessKind) Export
	
	If Not AccessManagement.LimitAccessAtRecordLevel() Then
		Return False;
	EndIf;
	
	Used = False;
	
	AccessKindProperties = AccessKindProperties(AccessKind);
	If AccessKindProperties = Undefined Then
		Return Used;
	EndIf;
	
	If AccessKindProperties.Name = "ExternalUsers"
	 Or AccessKindProperties.Name = "Users" Then
		// These access kinds cannot be disabled by functional options.
		Return True;
	EndIf;
	
	Used = True;
	
	SSLSubsystemsIntegration.OnFillAccessKindUsage(AccessKindProperties.Name, Used);
	AccessManagementOverridable.OnFillAccessKindUsage(AccessKindProperties.Name, Used);
	
	Return Used;
	
EndFunction

// Returns the properties of an access kind or all access kinds.
//
// Parameters:
//  AccessKind - String - a blank reference of the main type.
//             - String - an access kind name.
//             - Undefined - return an array of properties of all access kinds.
//
// Returns:
//  Undefined - when no properties are found for an access kind.
//  Structure    - properties of the found access kind. For the description of the properties, see 
//                 comments to the AccessKindsProperties function of this module.
//  Array - with the following values:
//    * Structure - with properties like of the structure specified above.
//
Function AccessKindProperties(Val AccessKind = Undefined) Export
	
	Properties = AccessManagementInternalCached.AccessKindsProperties();
	
	If AccessKind = Undefined Then
		Return Properties.Array;
	EndIf;
	
	AccessKindProperties = Properties.ByNames.Get(AccessKind);
	
	If AccessKindProperties = Undefined Then
		AccessKindProperties = Properties.ByRefs.Get(AccessKind);
	EndIf;
	
	Return AccessKindProperties;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for access value set management.

// Returns new sets to be used to fill a tabular section.
Function GetAccessValuesSetsOfTabularSection(Object) Export
	
	ValueTypeObject = TypeOf(Object);
	
	If Object.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |У объекта типа ""%1""
			           |не найдена табличная часть ""Наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Tabular section 
			           |""Access value sets"" of object ""%1"" is not found.'; 
			           |pl = 'Nieprawidłowe ustawienia.
			           |Obiekt typu ""%1""
			           |nie znaleziono arkusza kalkulacyjnego część ""Zestawy wartości dostępu"".';
			           |de = 'Falsche Parameter.
			           |Der tabellarische Teil von ""Zugriffswerte-Sets"" befindet sich nicht im Objekt vom Typ%1"
".';
			           |ro = 'Parametrii incorecți.
			           |Secțiunea tabelară ""Seturile valorilor de acces"" nu se găsește în obiectul de tipul ""%1""
			           |.';
			           |tr = 'Yanlış parametreler. "
"Erişim değeri kümeleri 
			           |""sekmeli bölüm, "" %1"" türündeki nesnede bulunamadı.'; 
			           |es_ES = 'Parámetros incorrectos.
			           |El objeto del tipo ""%1"" 
			           |no tiene sección tabular ""Conjuntos de valores de acceso"".'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	Table = AccessManagement.AccessValuesSetsTable();
	
	If NOT AccessManagement.LimitAccessAtRecordLevel() Then
		Return Table;
	EndIf;
	
	AccessManagement.FillAccessValuesSets(Object, Table);
	
	AccessManagement.AddAccessValuesSets(
		Table, AccessManagement.AccessValuesSetsTable(), False, True);
	
	Return Table;
	
EndFunction

// Updates object access value sets if they are changed.
// The sets are updated both in the tabular section (if used) and in the AccessValuesSets 
// information register.
//
// Parameters:
//  RefOrObject - CatalogRef, DocumentRef and other reference or object types - a reference or an 
//                    object, for which the access value sets are filled.
//
//  IBUpdate - Boolean - if True, it is necessary to write data without doing unnecessary redundant 
//                            actions with the data.
//                            See InfobaseUpdate.WriteData. 
//
Procedure UpdateAccessValuesSets(ReferenceOrObject, HasChanges = Undefined, IBUpdate = False) Export
	
	SetPrivilegedMode(True);
	
	Object = ?(ReferenceOrObject = ReferenceOrObject.Ref, ReferenceOrObject.GetObject(), ReferenceOrObject);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in event subscription
			           |""Write access value sets"".'; 
			           |pl = 'Nieprawidłowe ustawienia.
			           |Obiekt typu ""%1""
			           |nie znaleziono w subskrypcji zdarzeń
			           |""Zapisz zestawy znaczeń dostępu"".';
			           |de = 'Ungültige Parameter.
			           |Der Objekttyp ""%1""
			           |wurde in der Subskription des Ereignisses 
			           |""Aufzeichnen von Zugriffswerte-Sets"" nicht gefunden.';
			           |ro = 'Parametrii incorecți.
			           |Tipul obiectului ""%1""
			           |nu se găsește în subscrierile la evenimentele
			           | ""Înregistrare seturile valorilor de acces"".';
			           |tr = 'Yanlış parametreler. %1""Erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Ntürü "
" bulunmadı.'; 
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos de valores de acceso"".'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	If Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type.Types().Find(TypeOf(ObjectRef)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип %1'; 
			           |en = 'An error occurred when writing access value sets:
			           |in the AccessValuesSets information register in dimension 
			           |Object, type %1 is not specified'; 
			           |pl = 'Błąd podczas zapisywania zestawów wartości dostępu:
			           |w rejestrze informacji НаборыЗначенийДоступа w wymiarze Obiekt
			           |nie został określony typ %1';
			           |de = 'Fehler beim Schreiben von Zugriffswerte-Sets:
			           |im Informationsregister ZugriffsWertSets in der Dimension Objekt
			           |ist kein Typ %1angegeben';
			           |ro = 'Eroare la înregistrarea seturilor valorilor de acces:
			           |în registrul de date НаборыЗначенийДоступа în dimensiunea Obiectul
			           |nu este specificat tipul %1';
			           |tr = 'Erişim değeri kümeleri yazılırken %1 bir  hata oluştu: "
" türü, 
			           |Nesne boyutunda ErişimDeğerKümeleri bilgi kaydında belirtilmemiş.'; 
			           |es_ES = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información НаборыЗначенийДоступа en la dimensión Objeto
			           |no se ha establecido el tipo %1'"),
			ObjectRef.Metadata().FullName());
		Raise ErrorText;
	EndIf;
	
	If ObjectRef.Metadata().TabularSections.Find("AccessValuesSets") <> Undefined Then
		// Object update is required.
		Table = GetAccessValuesSetsOfTabularSection(Object);
		
		If AccessValuesSetsOfTabularSectionChanged(ObjectRef, Table) Then
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			
			Object.AdditionalProperties.Insert("WriteAccessValuesSets");
			Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
			Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
			Object.AccessValuesSets.Load(Table);
			If IBUpdate Then
				Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
				InfobaseUpdate.WriteData(Object);
			Else
				Object.DataExchange.Load = True;
				Object.Write();
			EndIf;
			HasChanges = True;
		EndIf;
	EndIf;
	
	// Object update is not required, or it has already been updated.
	WriteAccessValuesSets(Object, HasChanges, IBUpdate);
	
EndProcedure

// Fills auxiliary data that speeds up access restriction template operations.
//  It is executed before writing to the AccessValuesSets register.
//
// Parameters:
//  ObjectRef - CatalogRef.*, DocumentRef.*, ...
//  Table - ValueTable.
//
Procedure PrepareAccessValuesSetsForWrite(ObjectRef, Table, AddCacheAttributes = False) Export
	
	If AddCacheAttributes Then
		
		Table.Columns.Add("Object", Metadata.InformationRegisters.AccessValuesSets.Dimensions.Object.Type);
		Table.Columns.Add("StandardValue", New TypeDescription("Boolean"));
		Table.Columns.Add("ValueWithoutGroups", New TypeDescription("Boolean"));
		
		AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
		
		AccessValuesTypesWithGroups = AccessKindsProperties.AccessValuesTypesWithGroups;
		AccessValuesTypes          = AccessKindsProperties.ByValuesTypes;
	EndIf;
	
	// Normalizing Read, Update resources
	SetNumber = -1;
	For each Row In Table Do
		
		If AddCacheAttributes Then
			// Setting the Object dimension value.
			Row.Object = ObjectRef;
			
			AccessValueType = TypeOf(Row.AccessValue);
			
			If AccessValuesTypes.Get(AccessValueType) <> Undefined Then
				Row.StandardValue = True;
				If AccessValuesTypesWithGroups.Get(AccessValueType) = Undefined Then
					Row.ValueWithoutGroups = True;
				EndIf;
			EndIf;
			
		EndIf;
		
		// Clearing rights and matching secondary data for all rows of each set except for the first row.
		// 
		If SetNumber = Row.SetNumber Then
			Row.Read    = False;
			Row.Update = False;
		Else
			SetNumber = Row.SetNumber;
		EndIf;
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Procedures and functions for actions performed upon changing subsystem settings.

// Enables data filling for access restriction and updates some data immediately if necessary.
// 
//
// The procedure is called from the OnWrite handler of the LimitAccessAtRecordLevel constant.
//
Procedure OnChangeAccessRestrictionAtRecordLevel(AccessRestrictionAtRecordLevelEnabled) Export
	
	SetPrivilegedMode(True);
	
	If AccessRestrictionAtRecordLevelEnabled Then
		
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Заполнение данных для ограничения доступа'; en = 'Access management.Populate access restrictions data'; pl = 'Zarządzanie dostępem. Wprowadzenie danych w celu ograniczenia dostępu';de = 'Zugriffsverwaltung. Datenausfüllung für Zugriffsbeschränkung';ro = 'Administrarea accesului.Completarea datelor pentru restricționarea accesului';tr = 'Erişim yönetimi. Erişim kısıtlaması için veri doldurulması'; es_ES = 'Gestión de acceso.Población de datos para la restricción de acceso'",
			     Common.DefaultLanguageCode()),
			EventLogLevel.Information,
			,
			,
			NStr("ru = 'Начато заполнение данных для ограничения доступа.'; en = 'Data filling for access restriction is started.'; pl = 'Rozpoczęto wprowadzenia danych w celu ograniczenia dostępu.';de = 'Die Datenpopulation für die Zugriffsbeschränkung wird gestartet.';ro = 'Este începută completarea datelor pentru restricționarea accesului.';tr = 'Erişim kısıtlaması için veri doldurulma işlemi başladı.'; es_ES = 'Población de datos para la restricción de acceso se ha empezado.'"),
			EventLogEntryTransactionMode.Transactional);
		
		SetDataFillingForAccessRestriction(True);
	EndIf;
	
	// Updating session parameters.
	// It is required so that the administrator does not have to restart.
	SpecifiedParameters = New Array;
	SessionParametersSetting("", SpecifiedParameters);
	RefreshReusableValues();
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Management of AccessKinds and AccessValues tables in edit forms.

// Fills the auxiliary data required for the form. The data does not depend on the object content or 
// filled for a new object.
//
// The form has to contain the attributes listed below.
// Attributes marked with an asterisk (*) are filled automatically, but they must be created in the form.
// Attributes marked with a number sign (#) must be created in the form if the CurrentAccessGroup 
// attribute is to be created in the form (see below).
// Attributes marked with the at sign (@) are created automatically.
//
//  CurrentAccessGroup - an optional attribute, it is not used unless created in the form.
//                         
//
//  AccessKinds - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    AccessKind - DefinedType.AccessValue,
//    PresetAccessKind - Boolean (for the profile only),
//    AllAllowed - Boolean,
//    *AccessKindPresentation - String - a setting presentation,
//    *AllAllowedPresentation - String - a setting presentation,
//    @IsInUse - Boolean.
//
//  AccessValues - a table with the following fields:
//    #AccessGroup - CatalogRef.AccessGroups,
//    *AccessKind - DefinedType.AccessValue,
//    AccessValue - DefinedType.AccessValue,
//    *RowNumberByKind - Number.
//
//  *EnableExternalUsers - Boolean - an attribute will be created if it is not in the form.
//  *AccessKindLabel - String - a presentation of the current access kind in the form.
//  @IsAccessGroupsProfile - Boolean.
//  @CurrentAccessKind - DefinedType.AccessValue.
//  @CurrentTypesOfValuesToSelect - ValueList.
//  @CurrentTypeOfValuesToSelect - DefinedType.AccessValue.
//  @TablesStorageAttributeName - String.
//  @AccessKindUsers - DefinedType.AccessValue.
//  @AccessKindExternalUsers - DefinedType.AccessValue.
//  
//  @AllAccessKinds - a table with the following fields:
//    @Ref - DefinedType.AccessValue,
//    @Presentation - String
//    @IsInUse - Boolean
//
//  @PresentationsAllAllowed - a table with the following fields:
//    @Name - String
//    @Presentation - String
//
//  @AllTypesOfValuesToSelect - a table with the following fields:
//    @AccessKind - DefinedType.AccessValue
//    @ValuesType - DefinedType.AccessValue
//    @TypePresentation - String
//    @TableName - String
//
// Parameters:
//  Form - ManagedForm that must be set up to edit allowed values.
//               
//
//  IsProfile - Boolean - indicates that access kinds can be set up, also settings presentation 
//               contains 4 values, not 2.
//
//  TablesStorageAttributeName - a row containing, for example, the Object row that contains the 
//               AccessKinds and AccessValues tables (see below).
//               If a blank row is specified, the tables are considered to be stored in the form 
//               attributes.
//
Procedure OnCreateAtServerAllowedValuesEditForm(Form, ThisProfile = False, TablesStorageAttributeName = "Object") Export
	
	AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName);
	
	Form.TablesStorageAttributeName = TablesStorageAttributeName;
	Form.IsAccessGroupProfile = ThisProfile;
	
	// Filling access value types of all access kinds.
	For each AccessKindProperties In AccessKindProperties() Do
		For each Type In AccessKindProperties.TypesOfValuesToSelect Do
			TypesArray = New Array;
			TypesArray.Add(Type);
			TypeDetails = New TypeDescription(TypesArray);
			
			TypeMetadata = Metadata.FindByType(Type);
			If Metadata.Enums.Find(TypeMetadata.Name) = TypeMetadata Then
				TypePresentation = TypeMetadata.Presentation();
			Else
				TypePresentation = ?(ValueIsFilled(TypeMetadata.ObjectPresentation),
					TypeMetadata.ObjectPresentation,
					TypeMetadata.Presentation());
			EndIf;
			
			NewRow = Form.AllTypesOfValuesToSelect.Add();
			NewRow.AccessKind        = AccessKindProperties.Ref;
			NewRow.ValuesType       = TypeDetails.AdjustValue(Undefined);
			NewRow.TypePresentation = TypePresentation;
			NewRow.TableName        = TypeMetadata.FullName();
		EndDo;
	EndDo;
	
	Form.AccessKindUsers           = Catalogs.Users.EmptyRef();
	Form.AccessKindExternalUsers    = Catalogs.ExternalUsers.EmptyRef();
	Form.UseExternalUsers = ExternalUsers.UseExternalUsers();
	
	FillTableAllAccessKindsInForm(Form);
	
	FillPresentationTableAllAllowedInForm(Form, ThisProfile);
	
	ApplyTableAccessKindsInForm(Form);
	
	DeleteNonExistentAccessKindsAndValues(Form);
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	RefreshUnusedAccessKindsRepresentation(Form, True);
	
	StandardSubsystemsServer.SetGroupTitleRepresentation(
		Form, "AccessValuesByAccessKind");
	
	// Parameter settings of access value selection.
	ChoiceParameters = New Array;
	ChoiceParameters.Add(New ChoiceParameter("IsAccessValueSelection", True));
	Form.Items.AccessValuesAccessValue.ChoiceParameters = New FixedArray(ChoiceParameters);
	
EndProcedure

// When rereading data, it fills or updates required auxiliary data that depends on the object 
// content.
//
Procedure OnRereadAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteNonExistentAccessKindsAndValues(Form, CurrentObject);
	DeleteNonExistentAccessKindsAndValues(Form);
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
	AccessManagementInternalClientServer.OnChangeCurrentAccessKind(Form, False);
	
EndProcedure

// Deletes unused access values before writing.
// Unused access values are sometimes created when you replace or delete an access kind with filled 
// access values.
//
Procedure BeforeWriteAtServerAllowedValuesEditForm(Form, CurrentObject) Export
	
	DeleteExcessAccessValues(Form, CurrentObject);
	DeleteExcessAccessValues(Form);
	
EndProcedure

// Updates access kind properties.
Procedure AfterWriteAtServerAllowedValuesEditForm(Form, CurrentObject, WriteParameters) Export
	
	AccessManagementInternalClientServer.FillAccessKindsPropertiesInForm(Form);
	
EndProcedure

// Hides or shows unused access kinds.
Procedure RefreshUnusedAccessKindsRepresentation(Form, OnCreateAtServer = False) Export
	
	Items = Form.Items;
	
	If Not OnCreateAtServer Then
		Items.SnowUnusedAccessKinds.Check =
			NOT Items.SnowUnusedAccessKinds.Check;
	EndIf;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form);
	
	If Not Items.SnowUnusedAccessKinds.Check Then
		Filter.Insert("Used", True);
	EndIf;
	
	Items.AccessKinds.RowFilter = New FixedStructure(Filter);
	
	Items.AccessKindsAccessKindPresentation.ChoiceList.Clear();
	
	For each Row In Form.AllAccessKinds Do
		
		If Not Items.SnowUnusedAccessKinds.Check
		   AND Not Row.Used Then
			
			Continue;
		EndIf;
		
		Items.AccessKindsAccessKindPresentation.ChoiceList.Add(Row.Presentation);
	EndDo;
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal procedures and functions.

// For internal use only.
Procedure SetFilterCriterionInQuery(Val Query, Val Values, Val ValuesParameterName, Val ParameterNameFilterConditionsFieldName) Export
	
	If Values = Undefined Then
		
	ElsIf TypeOf(Values) <> Type("Array")
	        AND TypeOf(Values) <> Type("FixedArray") Then
		
		Query.SetParameter(ValuesParameterName, Values);
		
	ElsIf Values.Count() = 1 Then
		Query.SetParameter(ValuesParameterName, Values[0]);
	Else
		Query.SetParameter(ValuesParameterName, Values);
	EndIf;
	
	For RowNumber = 1 To StrLineCount(ParameterNameFilterConditionsFieldName) Do
		CurrentRow = StrGetLine(ParameterNameFilterConditionsFieldName, RowNumber);
		If NOT ValueIsFilled(CurrentRow) Then
			Continue;
		EndIf;
		SeparatorIndex = StrFind(CurrentRow, ":");
		If SeparatorIndex = 0 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ошибка при выполнении процедуры УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |В параметре ИмяПараметраУсловияОтбораИмяПоля не найден разделитель (двоеточие)
				           |в следующей строке формата ""<Имя параметра условия>:<Имя поля>""
				           |""%1"".'; 
				           |en = 'An error occurred when executing the AccessManagement.SetFilterCriterionInQuery() procedure.
				           |
				           |Separator (a colon) is not found in the ParameterNameFilterConditionsFieldName parameter
				           |in the following string of format ""<Condition parameter name>:<Field name>"
"%1"".'; 
				           |pl = 'Błąd podczas wykonywania procedury УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |W parametrze ИмяПараметраУсловияОтбораИмяПоля nie odnaleziony rozdzielnik (dwukropek)
				           |w następującym wierszu formatu ""<Imię parametru warunku>:<Imię pola>"
"%1"".';
				           |de = 'Beim Ausführen der Zugriffssteuerung.FestlegenEinerAnforderungsAuswahlBedingung() ist ein Fehler aufgetreten.
				           |
				           |Im Parameter ParameterNameAuswahlBedingungenFeldName wurde das Trennzeichen (Doppelpunkt)
				           |in der folgenden Zeile des Formats ""<Name des Bedingungsparameters>: <Feldname>"
"%1"" nicht gefunden.';
				           |ro = 'Eroare la executarea procedurii УправлениеДоступом.УстановитьУсловиеОтбораВЗапросе().
				           |
				           |În parametrul ИмяПараметраУсловияОтбораИмяПоля nu a fost găsit separatorul (două puncte)
				           |în următorul rând al formatului ""<Numele parametrului condiției>:<Numele câmpuli>"
"%1"".';
				           |tr = 'ErişimYönetimi prosedürü yürütülürken bir hata oluştu. TalepteSeçimKoşulunuBelirle (). 
				           |
				           |ParametreAdıSeçimKoşullarıAlanAdı 
				           |parametresinde ""<Koşul parametresinin adı> formatın satırında ayırıcı (iki nokta) bulunamadı:  <Alan  adı>"" ""%1"
".'; 
				           |es_ES = 'Error al realizar el procedimiento AccessManagement.SetFilterCriterionInQuery().
				           |
				           |En el parámetro NameFilterConditionsFieldName no se ha encontrado separador (dos puntos)
				           |en la siguiente línea del formato ""<Nombre del parámetro de condición>:<Nombre del campo>"
"%1"".'"),
				CurrentRow);
			Raise ErrorText;
		EndIf;
		FilterCriterionParameterName = Left(CurrentRow, SeparatorIndex-1);
		FieldName = Mid(CurrentRow, SeparatorIndex+1);
		If Values = Undefined Then
			FilterCriterion = "True";
			
		ElsIf TypeOf(Values) <> Type("Array")
		        AND TypeOf(Values) <> Type("FixedArray") Then
			
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
			
		ElsIf Values.Count() = 1 Then
			FilterCriterion = FieldName + " = &" + ValuesParameterName;
		Else
			FilterCriterion = FieldName + " IN (&" + ValuesParameterName + ")";
		EndIf;
		Query.Text = StrReplace(Query.Text, FilterCriterionParameterName, FilterCriterion);
	EndDo;
	
EndProcedure

// Updates a record set in the database if the set records do not match the database records.
// 
//
// Parameters:
//  Data - Structure - with the following properties:
//    * RecordSet - a blank or read RecordSet with or without set filter.
//                              Register manager to create a record set.
//
//    * NewRecords - a ValueTable in a register format.
//
//    * ComparisonFields - String - contains a list of fields whose values are required to calculate 
//                               record set differences. For example, "Dimension1, Dimension2, 
//                               Resource1" but DimensionData attribute does not belong to the list.
//
//    * FilterField - Undefined - an entire registry is written or the filter is already set in a 
//                                              record set.
//                               String - a field name, for which the filter is to be set.
//
//    * FilterValue - a value that will be set as a filter by a filter field if the filter field is 
//                               set.
//
//    * RecordSetRead - Boolean, if True, then not specified record set already contains the read 
//                               records. Data lock of these records is set and transaction is open.
//                               
//
//    * CheckOnly - Boolean - if True, do not write, only find out if writing is required and set 
//                               the HasChanges property.
//                               
//
//    * AdditionalProperties - Undefined, Structure. If Structure, all structure parameters will be 
//                               added to the AdditionalProperties property of the 
//                               <Register*>RecordSet objects.
//
//    * IBUpdate - Boolean - if True, write data without performing unnecessary and redundant 
//                               actions with the data.
//                               See InfobaseUpdate.WriteData. 
//                               If the property is not inserted, the value is calculated by Or using the following functions:
//                               InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                               InfobaseUpdate common module.
//
//  HasChanges - Boolean (return value) - if recorded, True is set, otherwise, it does not change.
//                          
//
//  ModifiedRecords - Undefined - no actions, otherwise, it returns a value table in the register 
//                          format with the RowChangeKind field of the Number type (-1 the record is 
//                          deleted, 1 the record is added).
//
Procedure UpdateRecordSet(Val Data, HasChanges = Undefined, ModifiedRecords = Undefined) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RecordSet");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FilterField");
	AllParameters.Insert("FilterValue");
	AllParameters.Insert("RecordSetRead", False);
	AllParameters.Insert("NoOverwriting", False);
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RecordSet, NewRecords");
	
	FullRegisterName = Metadata.FindByType(TypeOf(Data.RecordSet)).FullName();
	RegisterManager = Common.ObjectManagerByFullName(FullRegisterName);
	If Data.RecordSet = RegisterManager Then
		Data.RecordSet = RegisterManager.CreateRecordSet();
	EndIf;
	
	If ValueIsFilled(Data.FilterField) Then
		SetFilter(Data.RecordSet.Filter[Data.FilterField], Data.FilterValue);
	EndIf;
	
	If NOT Data.RecordSetRead Then
		LockRecordSetArea(Data.RecordSet, FullRegisterName);
		Data.RecordSet.Read();
	EndIf;
	
	Data.ComparisonFields = ?(Data.ComparisonFields = Undefined,
		RecordSetFields(Data.RecordSet), Data.ComparisonFields);
	
	If Data.NoOverwriting Then
		SingleRecordSet = RegisterManager.CreateRecordSet();
		RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(FullRegisterName);
		FilterRecords = New Structure(RecordKeyDetails.FieldsString);
		OtherDimensionsFields = New Array;
		For each Field In RecordKeyDetails.FieldArray Do
			If Field <> Data.FilterField Then
				OtherDimensionsFields.Add(Field);
			EndIf;
		EndDo;
		RecordsToDelete = New ValueTable;
		For each Field In OtherDimensionsFields Do
			RecordsToDelete.Columns.Add(Field);
		EndDo;
		Data.NewRecords = Data.NewRecords.Copy();
	EndIf;
	
	HasCurrentChanges = False;
	If ModifiedRecords = Undefined Then
		If Data.RecordSet.Count() = Data.NewRecords.Count() OR Data.NoOverwriting Then
			Filter = New Structure(Data.ComparisonFields);
			Data.NewRecords.Indexes.Add(Data.ComparisonFields);
			For each Record In Data.RecordSet Do
				FillPropertyValues(Filter, Record);
				FoundRows = Data.NewRecords.FindRows(Filter);
				If FoundRows.Count() = 0 Then
					HasCurrentChanges = True;
					HasChanges = True;
					If Data.NoOverwriting Then
						FillPropertyValues(FilterRecords, Record);
						If Data.NewRecords.FindRows(FilterRecords).Count() = 0 Then
							FillPropertyValues(RecordsToDelete.Add(), FilterRecords);
						EndIf;
					Else
						Break;
					EndIf;
				ElsIf Data.NoOverwriting Then
					Data.NewRecords.Delete(FoundRows[0]);
				EndIf;
			EndDo;
			If Data.NoOverwriting AND Data.NewRecords.Count() > 0 Then
				HasCurrentChanges = True;
				HasChanges = True;
			EndIf;
		Else
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
	Else
		If Data.RecordSet.Count() <> Data.NewRecords.Count() Then
			HasCurrentChanges = True;
			HasChanges = True;
		EndIf;
		If Data.RecordSet.Count() > Data.NewRecords.Count() Then
			ModifiedRecords = Data.RecordSet.Unload();
			SearchedRecords   = Data.NewRecords;
			RowChangeKind = -1;
		Else
			ModifiedRecords = Data.NewRecords.Copy();
			SearchedRecords   = Data.RecordSet.Unload();
			RowChangeKind = 1;
		EndIf;
		ModifiedRecords.Columns.Add("RowChangeKind", New TypeDescription("Number"));
		ModifiedRecords.FillValues(RowChangeKind, "RowChangeKind");
		RowChangeKind = ?(RowChangeKind = 1, -1, 1);
		Filter = New Structure(Data.ComparisonFields);
		
		For each Row In SearchedRecords Do
			FillPropertyValues(Filter, Row);
			Rows = ModifiedRecords.FindRows(Filter);
			If Rows.Count() = 0 Then
				NewRow = ModifiedRecords.Add();
				FillPropertyValues(NewRow, Filter);
				NewRow.RowChangeKind = RowChangeKind;
				HasCurrentChanges = True;
				HasChanges = True;
			Else
				ModifiedRecords.Delete(Rows[0]);
			EndIf;
		EndDo;
	EndIf;
	
	If HasCurrentChanges Then
		If Data.CheckOnly Then
			Return;
		EndIf;
		If Data.NoOverwriting Then
			SetAdditionalProperties(SingleRecordSet, Data.AdditionalProperties);
			For each Row In RecordsToDelete Do
				If ValueIsFilled(Data.FilterField) Then
					SetFilter(SingleRecordSet.Filter[Data.FilterField], Data.FilterValue);
				EndIf;
				For each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], Row[Field]);
				EndDo;
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
			SingleRecordSet.Add();
			For each Row In Data.NewRecords Do
				If ValueIsFilled(Data.FilterField) Then
					SetFilter(SingleRecordSet.Filter[Data.FilterField], Data.FilterValue);
				EndIf;
				For each Field In OtherDimensionsFields Do
					SetFilter(SingleRecordSet.Filter[Field], Row[Field]);
				EndDo;
				FillPropertyValues(SingleRecordSet[0], Row);
				WriteObjectOrRecordSet(Data, SingleRecordSet);
			EndDo;
		Else
			SetAdditionalProperties(Data.RecordSet, Data.AdditionalProperties);
			Data.RecordSet.Load(Data.NewRecords);
			WriteObjectOrRecordSet(Data, Data.RecordSet);
		EndIf;
	EndIf;
	
EndProcedure

// Updates register rows with a multiple-value filter for one or two register dimensions. Checks for 
// changes; if no changes are found, no data is overwritten.
// 
//
// Parameters:
//  Data - Structure - with the following properties:
//    * RegisterManager - a register manager used to create the <Register*>RecordSet type.
//
//    * NewRecords - a ValueTable in a register format.
//
//    * ComparisonFields - String - contains a list of fields whose values are required to calculate 
//                                  record set differences, for example, Dimension1, Dimension2,
//                                  Source1. The ChangeDate attribute is not included in the list.
//
//    * FirstDimensionName - Undefined - there is no filter by dimension.
//                                  String - contains the first dimension name, for which multiple 
//                                                 values are set.
//
//    * FirstDimensionValues  - Undefined - there is no filter by dimension, similar to
//                                                 FirstDimensionName = Undefined.
//                                  AnyRef - contains one register filter value for the records 
//                                                 being updated.
//                                  Array       - contains a register filter value array for the 
//                                                 records being updated. If the array is blank, no 
//                                                 action is required.
//
//    * SecondDimensionName       - similar to FirstDimensionName.
//    * SecondDimensionValues  - similar to FirstDimensionValues.
//    * ThirdDimensionName      - similar to FirstDimensionName.
//    * ThirdDimensionValues - similar to FirstDimensionValues.
//
//    * CheckOnly            - Boolean - if True, do not write, only find out if writing is required 
//                                  and set the HasChanges property.
//                                  
//
//    * AdditionalProperties    - Undefined, Structure. If Structure,  all structure parameters will 
//                                  be added to the 
//                                  AdditionalProperties all structure parameters will be inserted.
//
//    * IBUpdate              - Boolean - if True, write data without performing unnecessary and 
//                                  redundant actions with the data.
//                                  See InfobaseUpdate.WriteData. 
//                                  If the property is not inserted, the value is calculated by Or using the following functions:
//                                  InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                                  InfobaseUpdate common module.
//
//  HasChanges             - Boolean (return value) - if recorded, True is set, otherwise, it does 
//                              not change.
//
Procedure UpdateRecordSets(Val Data, HasChanges) Export
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("NewRecords");
	AllParameters.Insert("ComparisonFields");
	AllParameters.Insert("FirstDimensionName");
	AllParameters.Insert("FirstDimensionValues");
	AllParameters.Insert("SecondDimensionName");
	AllParameters.Insert("SecondDimensionValues");
	AllParameters.Insert("ThirdDimensionName");
	AllParameters.Insert("ThirdDimensionValues");
	AllParameters.Insert("NewRecordsContainOnlyDifferences", False);
	AllParameters.Insert("FixedFilter");
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RegisterManager, NewRecords");
	
	// Preprocessing parameters.
	
	If NOT DimensionParametersGroupProcessed(Data.FirstDimensionName, Data.FirstDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If NOT DimensionParametersGroupProcessed(Data.SecondDimensionName, Data.SecondDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	If NOT DimensionParametersGroupProcessed(Data.ThirdDimensionName, Data.ThirdDimensionValues) Then
		HasChanges = True;
		Return;
	EndIf;
	
	OrderDimensionsParametersGroups(Data);
	
	// Checking and updating data.
	Data.Insert("RecordSet",       Data.RegisterManager.CreateRecordSet());
	Data.Insert("RegisterMetadata", Metadata.FindByType(TypeOf(Data.RecordSet)));
	Data.Insert("FullRegisterName",  Data.RegisterMetadata.FullName());
	
	If Data.NewRecordsContainOnlyDifferences Then
		Data.Insert("SetForSingleRecord", Data.RegisterManager.CreateRecordSet());
	EndIf;
	
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			SetFilter(Data.RecordSet.Filter[KeyAndValue.Key], KeyAndValue.Value);
		EndDo;
	EndIf;
	
	If Data.NewRecordsContainOnlyDifferences Then
		
		If Data.FirstDimensionName = Undefined Then
			ErrorText = NStr("ru = 'Некорректные параметры в процедуре ОбновитьНаборыЗаписей.'; en = 'Invalid UpdateRecordSets procedure parameters.'; pl = 'Niepoprawne parametry w procedurze UpdateRecordsets.';de = 'Falsche Parameter in der Prozedur DatensatzsätzeAktualisieren.';ro = 'Parametrii incorecți în cadrul procedurii ОбновитьНаборыЗаписей.';tr = 'KayıtKümeleriniYenile prosedüründe yanlış parametreler.'; es_ES = 'Parámetros incorrectos en el procedimiento UpdateRecordsets.'");
			Raise ErrorText;
		Else
			If Data.SecondDimensionName = Undefined Then
				RecordByMultipleSets = False;
			Else
				RecordByMultipleSets = RecordByMultipleSets(
					Data, New Structure, Data.FirstDimensionName, Data.FirstDimensionValues);
			EndIf;
			
			If RecordByMultipleSets Then
				FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
				Data.NewRecords.Indexes.Add(FieldsList);
				
				CountByFirstDimensionValues = Data.CountByValues;
				
				For each FirstValue In Data.FirstDimensionValues Do
					Filter = New Structure(Data.FirstDimensionName, FirstValue);
					SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
					
					If Data.ThirdDimensionName = Undefined Then
						RecordByMultipleSets = False;
					Else
						RecordByMultipleSets = RecordByMultipleSets(
							Data, Filter, Data.SecondDimensionName, Data.SecondDimensionValues);
					EndIf;
					
					If RecordByMultipleSets Then
						For each SecondValue In Data.SecondDimensionValues Do
							Filter.Insert(Data.SecondDimensionName, SecondValue);
							SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
							
							// Updating by three dimensions.
							RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
						EndDo;
						Data.RecordSet.Filter[Data.SecondDimensionName].Use = False;
					Else
						// Updating by two dimensions.
						Data.Insert("CountByValues", CountByFirstDimensionValues);
						RefreshNewSetRecordsByVariousNewRecords(Data, Filter, HasChanges);
					EndIf;
				EndDo;
			Else
				// Updating by one dimension.
				ReadCountForReading(Data);
				RefreshNewSetRecordsByVariousNewRecords(Data, New Structure, HasChanges);
			EndIf;
		EndIf;
	Else
		If Data.FirstDimensionName = Undefined Then
			// Updating all records.
			
			CurrentData = New Structure("RecordSet, NewRecords, ComparisonFields,
				|CheckOnly, AdditionalProperties, IBUpdate");
			FillPropertyValues(CurrentData, Data);
			UpdateRecordSet(CurrentData, HasChanges);
			
		ElsIf Data.SecondDimensionName = Undefined Then
			// Updating by one dimension.
			Filter = New Structure(Data.FirstDimensionName);
			For each Value In Data.FirstDimensionValues Do
				
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], Value);
				Filter[Data.FirstDimensionName] = Value;
				
				If Data.FirstDimensionValues.Count() <> 1 Then
					NewSetRecords = Data.NewRecords;
				Else
					NewSetRecords = Data.NewRecords.Copy(Filter);
				EndIf;
				
				CurrentData = New Structure("RecordSet, ComparisonFields,
					|CheckOnly, AdditionalProperties, IBUpdate");
				FillPropertyValues(CurrentData, Data);
				CurrentData.Insert("NewRecords", NewSetRecords);
				
				UpdateRecordSet(CurrentData, HasChanges);
			EndDo;
			
		ElsIf Data.ThirdDimensionName = Undefined Then
			// Updating by two dimensions.
			FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName;
			Data.NewRecords.Indexes.Add(FieldsList);
			Filter = New Structure(FieldsList);
			
			For each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				UpdateNewSetRecordsByAllNewRecords(
					Data,
					Filter,
					FieldsList,
					Data.SecondDimensionName,
					Data.SecondDimensionValues,
					HasChanges);
			EndDo;
		Else
			// Updating by three dimensions.
			FieldsList = Data.FirstDimensionName + ", " + Data.SecondDimensionName + ", " + Data.ThirdDimensionName;
			Data.NewRecords.Indexes.Add(FieldsList);
			Filter = New Structure(FieldsList);
			
			For each FirstValue In Data.FirstDimensionValues Do
				SetFilter(Data.RecordSet.Filter[Data.FirstDimensionName], FirstValue);
				Filter[Data.FirstDimensionName] = FirstValue;
				
				For each SecondValue In Data.SecondDimensionValues Do
					SetFilter(Data.RecordSet.Filter[Data.SecondDimensionName], SecondValue);
					Filter[Data.SecondDimensionName] = SecondValue;
					
					UpdateNewSetRecordsByAllNewRecords(
						Data,
						Filter,
						FieldsList,
						Data.SecondDimensionName,
						Data.SecondDimensionValues,
						HasChanges);
				EndDo;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// Updates an information register by data in the RowsChanges value table.
//
// Parameters:
//  Data - Structure - with the following properties:
//
//  * RegisterManager - a register manager used to create the <Register*>RecordSet type.
//
//  * RowComponentsChanges - a ValueTable containing the register fields and the RowChangeKind field 
//                             (Number):
//                                1 means that a row must be added.
//                               -1 means that a row must be deleted.
//
//  * FixedFilter     - Structure containing a dimension name in the key and a filter value in the 
//                             value. It can be used when there are more than 3 dimensions and it is 
//                             known in advance that the dimensions above 3 will have a single value.
//                              Dimensions specified in a fixed filter are not used when generating 
//                             record sets for updating.
//                             
//
//  * FilterDimensions        - a string of comma-separated dimensions that must be used when 
//                             generating record sets for updating (no more than 3).
//                              Any unspecified dimensions will be converted to a fixed filter if 
//                             all their values match.
//                             
//
//  * CheckOnly - Boolean - if True, do not write, only find out if writing is required and set the 
//                             HasChanges property.
//                             
//
//  * AdditionalProperties - Undefined, Structure. If Structure,  all structure parameters will be 
//                             added to the 
//                             AdditionalProperties all structure parameters will be inserted.
//
//  * IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                             with the data.
//                             See InfobaseUpdate.WriteData. 
//                             If the property is not inserted, the value is calculated by Or using the following functions:
//                             InfobaseUpdateInProgress and IsCallFromUpdateHandler of the 
//                             InfobaseUpdate common module.
//
//  HasChanges - Boolean (return value) - if recorded, True is set, otherwise, it does not change.
//                          
//
Procedure UpdateInformationRegister(Val Data, HasChanges = Undefined) Export
	
	If Data.EditStringContent.Count() = 0 Then
		Return;
	EndIf;
	
	AllParameters = New Structure;
	AllParameters.Insert("RegisterManager");
	AllParameters.Insert("EditStringContent");
	AllParameters.Insert("FixedFilter", New Structure);
	AllParameters.Insert("FilterDimensions");
	AllParameters.Insert("CheckOnly", False);
	AllParameters.Insert("AdditionalProperties");
	AllParameters.Insert("IBUpdate",
		    InfobaseUpdate.InfobaseUpdateInProgress()
		Or InfobaseUpdate.IsCallFromUpdateHandler());
	
	FillParameters(Data, AllParameters, "RegisterManager, EditStringContent");
	
	RegisterMetadata = Metadata.FindByType(TypeOf(Data.RegisterManager.EmptyKey()));
	RecordKeyDetails = AccessManagementInternalCached.RecordKeyDetails(RegisterMetadata.FullName());
	
	If Data.FilterDimensions <> Undefined Then
		Data.FilterDimensions = New Structure(Data.FilterDimensions);
	EndIf;
	
	FilterDimensionsArray   = New Array;
	FilterDimensionsValues = New Structure;
	ChangeWithoutFixedFilter = New Structure;
	
	For Each Field In RecordKeyDetails.FieldArray Do
		If Not Data.FixedFilter.Property(Field) Then
			Values = TableColumnValues(Data.EditStringContent, Field);
			
			If Values.Count() = 1 Then
				Data.FixedFilter.Insert(Field, Values[0]);
				Continue;
			EndIf;
			
			If Data.FilterDimensions = Undefined
			 Or Data.FilterDimensions.Property(Field) Then
				
				FilterDimensionsArray.Add(Field);
				FilterDimensionsValues.Insert(Field, Values);
				
			ElsIf Not ValueIsFilled(ChangeWithoutFixedFilter) Then
				ChangeWithoutFixedFilter.Insert("Field",     Field);
				ChangeWithoutFixedFilter.Insert("Values", Values);
			EndIf;
		EndIf;
	EndDo;
	
	If FilterDimensionsArray.Count() = 0 Then
		If ValueIsFilled(ChangeWithoutFixedFilter) Then
			Field     = ChangeWithoutFixedFilter.Field;
			Values = ChangeWithoutFixedFilter.Values;
		EndIf;
		FilterDimensionsArray.Add(Field);
		FilterDimensionsValues.Insert(Field, Values);
	EndIf;
	
	Data.Insert("FirstDimensionName", FilterDimensionsArray[0]);
	Data.Insert("FirstDimensionValues", FilterDimensionsValues[Data.FirstDimensionName]);
	
	If FilterDimensionsArray.Count() > 1 Then
		Data.Insert("SecondDimensionName", FilterDimensionsArray[1]);
		Data.Insert("SecondDimensionValues", FilterDimensionsValues[Data.SecondDimensionName]);
	Else
		Data.Insert("SecondDimensionName", Undefined);
		Data.Insert("SecondDimensionValues", Undefined);
	EndIf;
	
	If FilterDimensionsArray.Count() > 2 Then
		Data.Insert("ThirdDimensionName", FilterDimensionsArray[2]);
		Data.Insert("ThirdDimensionValues", FilterDimensionsValues[Data.ThirdDimensionName]);
	Else
		Data.Insert("ThirdDimensionName", Undefined);
		Data.Insert("ThirdDimensionValues", Undefined);
	EndIf;
	
	Data.Insert("ComparisonFields", RecordKeyDetails.FieldsString);
	Data.Insert("NewRecordsContainOnlyDifferences", True);
	Data.Insert("NewRecords", Data.EditStringContent);
	Data.Delete("EditStringContent");
	Data.Delete("FilterDimensions");
	
	UpdateRecordSets(Data, HasChanges);
	
EndProcedure

// Returns a blank reference of a metadata object of a reference type.
//
// Parameters:
//  MetadataObjectDetails - MetadataObject,
//                            - Type used to find a metadata object.
//                            - String - a full metadata object name.
// Returns:
//  Ref.
//
Function MetadataObjectEmptyRef(MetadataObjectDetails) Export
	
	If TypeOf(MetadataObjectDetails) = Type("MetadataObject") Then
		MetadataObject = MetadataObjectDetails;
		
	ElsIf TypeOf(MetadataObjectDetails) = Type("Type") Then
		MetadataObject = Metadata.FindByType(MetadataObjectDetails);
	Else
		MetadataObject = Metadata.FindByFullName(MetadataObjectDetails);
	EndIf;
	
	If MetadataObject = Undefined Then
		ErrorText =
			NStr("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Неверный параметр ОписаниеОбъектаМетаданных.'; 
			           |en = 'An error occurred in the MetadataObjectEmptyRef
			           |function of the AccessManagementInternal common module.
			           |
			           |Incorrect parameter MetadataObjectsDetails.'; 
			           |pl = 'Błąd funkcji ПустаяСсылкаОбъектаМетаданных
			           |wspólnego modułu УправлениеДоступомСлужебный.
			           |
			           |Nieprawidłowy parametr MetadataObjectsDetails.';
			           |de = 'Fehler in der Funktion LeereMetadatenObjektreferenz
			           |des allgemeinen Moduls ServiceZugriffsKontrolle.
			           |
			           |Falscher Parameter MetadataObjectsDetails.';
			           |ro = 'Eroare în funcția ПустаяСсылкаОбъектаМетаданных
			           |a modulului de acces УправлениеДоступомСлужебный.
			           |
			           |Parametrul incorect MetadataObjectsDetails.';
			           |tr = 'ErişimYönetimiServis 
			           |genel modülünün MetaveriNesneBoşRef işlevinde bir hata oluştu. 
			           |
			           |Yanlış parametre MetadataObjectsDetails.'; 
			           |es_ES = 'Error en la función MetadataObjectEmptyRef
			           |del módulo común AccessManagementInternal.
			           |
			           |Parámetro incorrecto MetadataObjectsDetails.'");
		Raise ErrorText;
	EndIf;
	
	EmptyRef = Undefined;
	Try
		ObjectManager = Common.ObjectManagerByFullName(MetadataObject.FullName());
		EmptyRef = ObjectManager.EmptyRef();
	Except
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в функции ПустаяСсылкаОбъектаМетаданных
			           |общего модуля УправлениеДоступомСлужебный.
			           |
			           |Не удалось получить пустую ссылка для объекта метаданных
			           |""%1"".'; 
			           |en = 'An error occurred in the MetadataObjectEmptyRef function
			           |of the AccessManagementInternal common module.
			           |
			           |Cannot get an empty reference for metadata object
			           |""%1"".'; 
			           |pl = 'Wystąpił błąd
			           |w funkcji MetadataObjectEmptyRef modułu ogólnego AccessManagementService.
			           |
			           |Nie można odebrać pustego linku
			           |dla obiektu metadanych ""%1"".';
			           |de = 'Ein Fehler ist
			           | in der MetadatenObjektLeerRefFunktion des allgemeinen ZugriffsManagementService-Moduls aufgetreten. 
			           |
			           |Es konnte keine leere Referenz für 
			           |das Metadatenobjekt ""%1"" empfangen werden.';
			           |ro = 'Eroare în funcția ПустаяСсылкаОбъектаМетаданных
			           |a modulului general УправлениеДоступомСлужебный.
			           |
			           |Eșec la obținerea referinței goale pentru obiectul de metadate 
			           |""%1"".';
			           |tr = 'ErişimYönetimiServis 
			           |genel modülünün MetaveriNesneBoşRef işlevinde bir hata oluştu. 
			           |
			           | Meta veri nesnesi "
" için boş bir ref alınamıyor.%1'; 
			           |es_ES = 'Ha ocurrido un error
			           |en la función MetadataObjectEmptyRef del módulo general AccessManagementService.
			           |
			           |No se puede recibir una referencia vacía para
			           |el objeto de metadatos ""%1"".'"),
			MetadataObject.FullName());
		Raise ErrorText;
	EndTry;
	
	Return EmptyRef;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Other procedures and functions

// Creates a query to find differences between the register rows in the specified data area (based 
// on filters in the FieldsAndFilter parameter).
//
// Parameters:
//  NewDataSelectionQueryText - String.
//
//  FieldsAndFilter   - an array of Structure type items (FieldName, FilterConditionParameterName).
//
//  FullRegisterName
//               - String - a query for old data is generated automatically.
//                 Undefined - a query for old data is received from the next parameter.
//
//  OldDataSelectionQueryText
//               - String - a query for old data, with nonstandard filters.
//               - Undefined - used when a full register name is defined.
//
// Returns:
//  String - a query text optimized for PostgreSQL DBMS.
//
Function ChangesSelectionQueryText(NewDataSelectionQueryText,
                                    FieldsAndFilter,
                                    FullRegisterName            = Undefined,
                                    TemporaryTablesQueriesText = Undefined,
                                    OldDataSelectionQueryText     = Undefined) Export
	
	// Preparing the old data query text.
	If FullRegisterName <> Undefined Then
		OldDataSelectionQueryText =
		"SELECT
		|	&SelectedFields,
		|	&RowChangeKindFieldSubstitution
		|FROM
		|	FullRegisterName AS OldData
		|WHERE
		|	&FilterConditions";
	EndIf;
	
	FieldsToSelect = "";
	FilterConditions = "True";
	For each FieldDetails In FieldsAndFilter Do
		// Aggregating the selected fields.
		FieldsToSelect = FieldsToSelect + StrReplace(
			"
			|	OldData.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
			
		// Assembling filter conditions.
		If ValueIsFilled(KeyAndValue(FieldDetails).Value) Then
			FilterConditions = FilterConditions + StrReplace(
				"
				|	AND &FilterCriterionParameterName", "&FilterCriterionParameterName",
				KeyAndValue(FieldDetails).Value);
		EndIf;
	EndDo;
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&SelectedFields,",  FieldsToSelect);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "&FilterConditions",    FilterConditions);
	
	OldDataSelectionQueryText =
		StrReplace(OldDataSelectionQueryText, "FullRegisterName", FullRegisterName);
	
	If StrFind(NewDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораСтарых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""%1"".'; 
			           |en = 'An error occurred in the OldDataSelectionQueryText
			           |parameter value of the ChangesSelectionQueryText procedure of the AccessManagementInternal module.
			           |
			           |The ""%1"" string is not found in the query text.'; 
			           |pl = 'Błąd w ustawieniu parametru ТекстЗапросаВыбораСтарых
			           | procedury ТекстЗапросаВыбораИзменений modułu УправлениеДоступомСлужебный.
			           |
			           |W treści zapytania brakuje wiersza ""%1"".';
			           |de = 'Fehler im Wert des Parameters AlterAuswahlAnforderungsText
			           |der Prozedur AuswahlAnforderungsTextÄndern des Moduls ServiceZugangsKontrolle.
			           |
			           |Die Zeile ""%1"" wurde nicht im Anforderungstext gefunden.';
			           |ro = 'Eroare în valoarea parametrului ТекстЗапросаВыбораСтарых
			           |a procedurii ТекстЗапросаВыбораИзменений din modulul УправлениеДоступомСлужебный.
			           |
			           |În textul interogării nu a fost găsit rândul ""%1"".';
			           |tr = 'ErişimYönetimiServis 
			           |genel modülünün DeğişiklikSeçimTalepMetni prosedürün EskiSeçimTalepMetni parametresinin değerinde bir hata oluştu. 
			           |
			           | Dize ""%1"" sorgu metninde bulunamadı.'; 
			           |es_ES = 'Error en el valor del parámetro OldDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de la solicitud no se ha encontrado línea ""%1"".'"),
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	OldDataSelectionQueryText = StrReplace(
		OldDataSelectionQueryText, "&RowChangeKindFieldSubstitution", "-1 AS RowChangeKind");
	
	If StrFind(NewDataSelectionQueryText, "&RowChangeKindFieldSubstitution") = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка в значении параметра ТекстЗапросаВыбораНовых
			           |процедуры ТекстЗапросаВыбораИзменений модуля УправлениеДоступомСлужебный.
			           |
			           |В тексте запроса не найдена строка ""%1"".'; 
			           |en = 'An error occurred in the NewDataSelectionQueryText
			           |parameter value of the ChangesSelectionQueryText procedure of the AccessManagementInternal module.
			           |
			           |The ""%1"" string is not found in the query text.'; 
			           |pl = 'Błąd w ustawieniu parametru ТекстЗапросаВыбораНовых
			           |procedury ТекстЗапросаВыбораИзменений modułu УправлениеДоступомСлужебный.
			           |
			           |W treści zapytania brakuje wiersza ""%1"".';
			           |de = 'Fehler im Wert des Parameters NeueAuswahlTextAnforderung
			           |der Prozedur AuswahlTextAnforderungÄndern des Moduls ServiceZugangsKontrolle.
			           |
			           |Der Anforderungstext enthält nicht die Zeile ""%1"".';
			           |ro = 'Eroare în valoarea parametrului ТекстЗапросаВыбораНовых
			           |a procedurii ТекстЗапросаВыбораИзменений din modulul УправлениеДоступомСлужебный.
			           |
			           |În textul interogării nu a fost găsit rândul ""%1"".';
			           |tr = 'ErişimYönetimiServis 
			           |genel modülünün DeğişiklikSeçimTalepMetni prosedürün EskiSeçimTalepMetni parametresinin değerinde bir hata oluştu. 
			           |
			           | Dize ""%1"" sorgu metninde bulunamadı.'; 
			           |es_ES = 'Error en el valor del parámetro NewDataSelectionQueryText
			           |del procedimiento ChangesSelectionQueryText del módulo AccessManagementInternal.
			           |
			           |En el texto de solicitud no se ha encontrado línea ""%1"".'"),
			"&RowChangeKindFieldSubstitution");
		Raise ErrorText;
	EndIf;
	
	NewDataSelectionQueryText = StrReplace(
		NewDataSelectionQueryText,  "&RowChangeKindFieldSubstitution", "1 AS RowChangeKind");
	
	// Preparing a text of change selection query.
	QueryText =
	"SELECT
	|	&SelectedFields,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(NewDataSelectionQueryText
	|	
	|	UNION ALL
	|	
	|	OldDataSelectionQueryText) AS AllRows
	|	
	|GROUP BY
	|	&GroupFields
	|	
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0";
	
	FieldsToSelect = "";
	GroupFields = "";
	For each FieldDetails In FieldsAndFilter Do
		// Aggregating the selected fields.
		FieldsToSelect = FieldsToSelect + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
		
		// Assembling join fields.
		GroupFields = GroupFields + StrReplace(
			"
			|	AllRows.Field,",
			"Field",
			KeyAndValue(FieldDetails).Key);
	EndDo;
	GroupFields = Left(GroupFields, StrLen(GroupFields)-1);
	QueryText = StrReplace(QueryText, "&SelectedFields,",  FieldsToSelect);
	QueryText = StrReplace(QueryText, "&GroupFields", GroupFields);
	
	QueryText = StrReplace(
		QueryText, "NewDataSelectionQueryText",  NewDataSelectionQueryText);
	
	QueryText = StrReplace(
		QueryText, "OldDataSelectionQueryText", OldDataSelectionQueryText);
	
	If ValueIsFilled(TemporaryTablesQueriesText) Then
		QueryText = TemporaryTablesQueriesText
		+ "
		  |;
		  |" + QueryText;
	EndIf;
	
	Return QueryText;
	
EndFunction

////////////////////////////////////////////////////////////////////////////////
// Updating an infobase.

// Fills in separated data handler that depends on shared data change.
//
// Parameters:
//   Handlers - ValueTable, Undefined - see description of the NewUpdateHandlersTable function of 
//    the common module.
//    InfobaseUpdate.
//    Undefined is passed upon direct call (without using the infobase version update functionality).
//    
// 
Procedure FillSeparatedDataHandlers(Parameters = Undefined) Export
	
	If Parameters <> Undefined AND HasChangesOfAccessRestrictionParameters() Then
		Handlers = Parameters.SeparatedHandlers;
		Handler = Handlers.Add();
		Handler.Version = "*";
		Handler.ExecutionMode = "Seamless";
		Handler.Procedure = "AccessManagementInternal.UpdateAuxiliaryRegisterDataByConfigurationChanges";
	EndIf;
	
EndProcedure

// Updates auxiliary data that partially depends on the configuration.
//
// Updated when there are configuration changes recorded in access restriction parameters when 
// updating the infobase to the current configuration version.
//
Procedure UpdateAuxiliaryRegisterDataByConfigurationChanges(Parameters = Undefined) Export
	
	Lock = New DataLock;
	Lock.Add("InformationRegister.AccessGroupsTables");
	Lock.Add("InformationRegister.ObjectsRightsSettings");
	Lock.Add("Catalog.AccessGroupProfiles");
	Lock.Add("Catalog.AccessGroups");
	
	BeginTransaction();
	Try
		Lock.Lock();
		
		InformationRegisters.AccessGroupsTables.UpdateRegisterDataByConfigurationChanges();
		InformationRegisters.AccessValuesGroups.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		InformationRegisters.ObjectsRightsSettings.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		Catalogs.AccessGroupProfiles.UpdateSuppliedProfilesByConfigurationChanges();
		Catalogs.AccessGroups.MarkForDeletionSelectedProfilesAccessGroups();
		InformationRegisters.AccessValuesSets.UpdateAuxiliaryRegisterDataByConfigurationChanges();
		InformationRegisters.AccessRestrictionParameters.UpdateRegisterData();
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// Converts the DeleteRole attribute to the Role attribute in the Roles tabular section of the 
// Access group profiles catalog.
//
Procedure ConvertRoleNamesToIDs() Export
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	Roles.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupProfiles.Roles AS Roles
	|WHERE
	|	NOT(Roles.Role <> VALUE(Catalog.MetadataObjectIDs.EmptyRef)
	|				AND Roles.DeleteRole = """")";
	
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		Object = Selection.Ref.GetObject();
		Index = Object.Roles.Count()-1;
		While Index >= 0 Do
			Row = Object.Roles[Index];
			If ValueIsFilled(Row.Role) Then
				Row.DeleteRole = "";
			ElsIf ValueIsFilled(Row.DeleteRole) Then
				RoleMetadata = Metadata.Roles.Find(Row.DeleteRole);
				If RoleMetadata <> Undefined Then
					Row.DeleteRole = "";
					Row.Role = Common.MetadataObjectID(
						RoleMetadata);
				Else
					Object.Roles.Delete(Index);
				EndIf;
			Else
				Object.Roles.Delete(Index);
			EndIf;
			Index = Index-1;
		EndDo;
		InfobaseUpdate.WriteData(Object);
	EndDo;
	
EndProcedure

// Updates settings and enables a scheduled job.
Procedure EnableDataFillingForAccessRestriction() Export
	
	Usage = Constants.LimitAccessAtRecordLevel.Get();
	
	If Common.DataSeparationEnabled() Then
		SetDataFillingForAccessRestriction(Usage);
	Else
		Schedule = New JobSchedule;
		Schedule.WeeksPeriod = 1;
		Schedule.DaysRepeatPeriod = 1;
		Schedule.RepeatPeriodInDay = 300;
		Schedule.RepeatPause = 90;
		
		MetadataJob = Metadata.ScheduledJobs.DataFillingForAccessRestriction;
		Job = ScheduledJobsServer.GetScheduledJob(MetadataJob);
		
		Job.Use = Usage;
		Job.Schedule = Schedule;
		
		Job.RestartIntervalOnFailure
			= MetadataJob.RestartIntervalOnFailure;
		
		Job.RestartCountOnFailure
			= MetadataJob.RestartCountOnFailure;
		
		Job.Write();
	EndIf;
	
EndProcedure

// Fills an assignment of access group profiles.
Procedure FillAccessGroupsProfilesAssignment() Export
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	AccessGroupProfiles.Ref AS Ref
	|FROM
	|	Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|WHERE
	|	NOT(AccessGroupProfiles.SuppliedDataID <> &BlankUUID
	|				AND NOT AccessGroupProfiles.SuppliedProfileChanged)
	|	AND NOT AccessGroupProfiles.IsFolder
	|	AND NOT AccessGroupProfiles.Ref IN
	|				(SELECT DISTINCT
	|					AccessGroupProfilesAssignment.Ref
	|				FROM
	|					Catalog.AccessGroupProfiles.Purpose AS AccessGroupProfilesAssignment)";
	
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
		
	Result = Query.Execute();
	Selection = Result.Select();
	
	While Selection.Next() Do
		ProfileObject = Selection.Ref.GetObject();
		NewRow = ProfileObject.Purpose.Add();
		NewRow.UsersType = Catalogs.Users.EmptyRef();
		InfobaseUpdate.WriteData(ProfileObject);
	EndDo;
	
EndProcedure

// Replaces deleted roles with the new ones.
Procedure ReplaceDeletedRolesInAccessGroupProfiles() Export
	
	// Filling a list of deleted roles and the matching new roles.
	RolesMap = New Map;
	
	// AddEditBasicMasterData
	RoleName = "? AddEditBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.Properties") Then
		RolesArray.Add("AddEditAdditionalAttributesAndInfo");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Currencies") Then
		RolesArray.Add("AddEditCurrencyRates");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.WorkSchedules") Then
		RolesArray.Add("AddEditWorkSchedules");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.ContactInformation") Then
		RolesArray.Add("AddEditContactInfoKind");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// AddEditCommonBasicMasterData
	RoleName = "? AddEditCommonBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.AddressClassifier") Then
		RolesArray.Add("AddEditAddressInfo");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Banks") Then
		RolesArray.Add("AddEditBanks");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.CalendarSchedules") Then
		RolesArray.Add("AddEditCalendarSchedules");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// EditCurrentUser
	RoleName = "? EditCurrentUser";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// EditCurrentExternalUser
	RoleName = "? EditCurrentExternalUser";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// ReadBasicMasterData
	RoleName = "? ReadBasicMasterData";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.WorkSchedules") Then
		RolesArray.Add("ReadWorkSchedules");
	EndIf;
	If Common.SubsystemExists("StandardSubsystems.Currencies") Then
		RolesArray.Add("ReadCurrencyRates");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	// ReadCommonBasicMasterData
	RoleName = "? ReadCommonBasicMasterData";
	
	RolesArray = New Array;
	RolesMap.Insert(RoleName, RolesArray);
	
	// AddEditWorldCountries
	RoleName = "? AddEditWorldCountries";
	
	RolesArray = New Array;
	If Common.SubsystemExists("StandardSubsystems.ContactInformation") Then
		RolesArray.Add("AddEditContactInfoKind");
	EndIf;
	RolesMap.Insert(RoleName, RolesArray);
	
	AccessManagement.ReplaceRolesInProfiles(RolesMap);
	
EndProcedure

// Updates data of the InteractiveOpenOfExternalReportsAndDataProcessors profile.
Procedure UpdateProfileDataOpenExternalReportsAndDataProcessors() Export
	
	ProfileUUID = New UUID(
		OpenExternalReportsAndDataProcessorsProfileID());
	
	Ref = Catalogs.AccessGroupProfiles.GetRef(ProfileUUID);
	If Common.ObjectAttributeValue(Ref, "Ref") = Undefined Then
		Return;
	EndIf;
	MarkForDeletionRef = False;
	
	If Common.DataSeparationEnabled() Then
		MarkForDeletionRef = True;
	Else
		ProfileDetails = OpenExternalReportsAndDataProcessorsProfileDetails();
		SuppliedProfileReference = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
			ProfileDetails.Name);
		
		If Ref <> SuppliedProfileReference Then
			If SuppliedProfileReference <> Undefined Then
				MarkForDeletionRef = True;
			Else
				// Setting a supplied data ID.
				ProfileObject = Ref.GetObject();
				ProfileObject.SuppliedDataID = ProfileUUID;
				ProfileObject.Comment = "";
				InfobaseUpdate.WriteObject(ProfileObject, False);
			EndIf;
		EndIf;
	EndIf;
	
	If MarkForDeletionRef Then
		ProfileObject = Ref.GetObject();
		ProfileObject.DeletionMark = True;
		InfobaseUpdate.WriteObject(ProfileObject, False);
		
		ProfileGroups = ProfileGroups(Ref, False);
		For Each GroupRef In ProfileGroups Do
			GroupObject = GroupRef.GetObject();
			GroupObject.DeletionMark = True;
			InfobaseUpdate.WriteObject(GroupObject, False);
		EndDo;
	EndIf;
	
EndProcedure

// Populates descriptions of the Administrator predefined role and the Administrators group.
Procedure FillPredefinedItemsDescription() Export
	
	ProfileAdministrator = Catalogs.AccessGroupProfiles.Administrator.GetObject();
	ProfileAdministrator.Description = NStr("ru='Администратор'; en = 'Administrator'; pl = 'Administrator';de = 'Administrator';ro = 'Administrator';tr = 'Yönetici'; es_ES = 'Administrador'");
	InfobaseUpdate.WriteObject(ProfileAdministrator);
	
	AdministratorsGroup = Catalogs.AccessGroups.Administrators.GetObject();
	AdministratorsGroup.Description = NStr("ru='Администраторы'; en = 'Administrators'; pl = 'Administratorzy';de = 'Administratoren';ro = 'Administratori';tr = 'Yardımcı hak ayarları verilerini güncelle.'; es_ES = 'Administradores'");
	InfobaseUpdate.WriteObject(AdministratorsGroup);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Auxiliary procedures and functions.

Function ExtensionsRolesRights() Export
	
	ExtensionsRolesRights = Undefined;
	
	UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights);
	
	Return ExtensionsRolesRights;
	
EndFunction

Procedure UpdateAccessGroupsTablesForEnabledExtensions(ExtensionsRolesRights = Undefined)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Common.SubsystemExists("StandardSubsystems.DataExchange") Then
		ModuleDataExchangeServer = Common.CommonModule("DataExchangeServer");
		If ModuleDataExchangeServer.SubordinateDIBNodeSetup() Then
			ExtensionsRolesRights = InformationRegisters.RolesRights.RolesRightsTable(True, True);
			Return;
		EndIf;
	EndIf;
	
	CurrentExtensionsVersion = SessionParameters.AttachedExtensions;
	
	// Filling rights of extension roles, which consist of right changes to configuration objects and 
	// rights to extension objects.
	SetNewExtenstionsRolesRights = False;
	If ValueIsFilled(CurrentExtensionsVersion) Then
		ExtensionsRolesRights = StandardSubsystemsServer.ExtensionParameter(
			"StandardSubsystems.AccessManagement.RolesRights");
		
		If ExtensionsRolesRights = Undefined Then
			Query = InformationRegisters.RolesRights.ChangesQuery(True);
			ExtensionsRolesRights = Query.Execute().Unload();
			SetNewExtenstionsRolesRights = True;
		Else
			ExtensionsRolesRights = ExtensionsRolesRights.Get();
		EndIf;
	Else
		ExtensionsRolesRights = InformationRegisters.RolesRights.RolesRightsTable(True, True);
	EndIf;
	
	// Checking whether it is required to update the AccessGroupsTables register.
	UpdateParameters = StandardSubsystemsServer.ExtensionParameter(
		"StandardSubsystems.AccessManagement.AccessGroupTablesUpdateParameters", True);
	
	If TypeOf(UpdateParameters) <> Type("Structure")
	 Or Not UpdateParameters.Property("LastExtensionsVersion")
	 Or Not UpdateParameters.Property("LastObjectsWithRightsChanges")
	 Or TypeOf(UpdateParameters.LastObjectsWithRightsChanges) <> Type("FixedArray") Then
		
		UpdateRequired = True;
		LastObjectsWithRightsChanges = Undefined;
	Else
		LastObjectsWithRightsChanges = UpdateParameters.LastObjectsWithRightsChanges;
		UpdateRequired = UpdateParameters.LastExtensionsVersion <> CurrentExtensionsVersion;
	EndIf;
	
	If Not UpdateRequired Then
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights", New ValueStorage(ExtensionsRolesRights));
		EndIf;
		Return;
	EndIf;
	
	CurrentObjectsWithRightsChanges = InformationRegisters.RolesRights.ChangedMetadataObjects(
		ExtensionsRolesRights.Copy());
	
	If LastObjectsWithRightsChanges = Undefined Then
		// Since the latest changes are unavailable, you need to update the entire register.
		ObjectsWithUpdateRightsChanges = Undefined;
	Else
		ObjectsWithUpdateRightsChanges = New Array(CurrentObjectsWithRightsChanges);
		For Each ID In LastObjectsWithRightsChanges Do
			ObjectsWithUpdateRightsChanges.Add(ID);
		EndDo;
	EndIf;
	
	UpdateParameters = New Structure;
	UpdateParameters.Insert("LastExtensionsVersion",       CurrentExtensionsVersion);
	UpdateParameters.Insert("LastObjectsWithRightsChanges", CurrentObjectsWithRightsChanges);
	
	Lock = New DataLock;
	Lock.Add("InformationRegister.AccessGroupsTables");
	BeginTransaction();
	Try
		Lock.Lock();
		If SetNewExtenstionsRolesRights Then;
			StandardSubsystemsServer.SetExtensionParameter(
				"StandardSubsystems.AccessManagement.RolesRights", New ValueStorage(ExtensionsRolesRights));
		EndIf;
		StandardSubsystemsServer.SetExtensionParameter(
			"StandardSubsystems.AccessManagement.AccessGroupTablesUpdateParameters", UpdateParameters, True);
		InformationRegisters.AccessGroupsTables.UpdateRegisterData(, ObjectsWithUpdateRightsChanges);
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

Procedure OnChangeAccessValuesSets(Val ObjectRef, IBUpdate = False)
	
	RefsToDependentObjects = New Array;
	
	AccessManagementOverridable.OnChangeAccessValuesSets(
		ObjectRef, RefsToDependentObjects);
	
	For each DependentObjectRef In RefsToDependentObjects Do
		
		If DependentObjectRef.Metadata().TabularSections.Find("AccessValuesSets") = Undefined Then
			// No object change is required.
			WriteAccessValuesSets(DependentObjectRef, , IBUpdate);
		Else
			// Object change is required.
			Object = DependentObjectRef.GetObject();
			Table = GetAccessValuesSetsOfTabularSection(Object);
			If NOT AccessValuesSetsOfTabularSectionChanged(DependentObjectRef, Table) Then
				Continue;
			EndIf;
			PrepareAccessValuesSetsForWrite(Undefined, Table, False);
			Try
				LockDataForEdit(DependentObjectRef, Object.DataVersion);
				Object.AdditionalProperties.Insert("WriteAccessValuesSets");
				Object.AdditionalProperties.Insert("WriteDependentAccessValuesSets");
				Object.AdditionalProperties.Insert("AccessValuesSetsOfTabularSectionAreFilled");
				Object.AccessValuesSets.Load(Table);
				If IBUpdate Then
					Object.AdditionalProperties.Insert("WriteAccessValueSetsOnUpdateIB");
					InfobaseUpdate.WriteData(Object);
				Else
					Object.DataExchange.Load = True;
					Object.Write();
				EndIf;
				UnlockDataForEdit(DependentObjectRef);
			Except
				ErrorInformation = ErrorInfo();
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'При обновлении зависимого набора значений доступа объекта
					           |""%1"" возникла ошибка:
					           |
					           |%2'; 
					           |en = 'An error occurred while updating a dependent set of access values for
					           |the ""%1"" object: 
					           |
					           |%2'; 
					           |pl = 'Podczas aktualizacji niezależnego zestawu wartości dostępu do obiektu
					           |""%1"" wystąpił błąd:
					           |
					           |%2';
					           |de = 'Beim Aktualisieren des abhängigen Sets von Zugriffswerten des Objekts
					           |""%1"" ist ein Fehler aufgetreten:
					           |
					           |%2';
					           |ro = 'La actualizarea setului dependent al valorilor de acces ale obiectului
					           |""%1"" s-a produs eroarea:
					           |
					           |%2';
					           |tr = 'Bağımlı nesne erişim değerleri kümesini güncelleştirirken %1"
" bir hata oluştu:
					           |
					           |%2'; 
					           |es_ES = 'Al actualizar el conjunto dependiente de valores de acceso del objeto
					           |""%1"" se ha producido un error: 
					           |
					           |%2'"),
					String(DependentObjectRef),
					BriefErrorDescription(ErrorInformation));
				Raise ErrorText;
			EndTry;
		EndIf;
	EndDo;
	
EndProcedure

Function OpenExternalReportsAndDataProcessorsProfileID()
	
	Return "1b3472f6-4d87-11e6-8264-5404a6a6895d";
	
EndFunction

Function IsProfileOpenExternalReportsAndDataProcessors(Profile) Export
	
	If TypeOf(Profile) = Type("CatalogRef.AccessGroupProfiles") Then
		ProfileID = Common.ObjectAttributeValue(Profile, "SuppliedDataID");
		
	ElsIf Not Profile.IsFolder Then
		ProfileID = Profile.SuppliedDataID;
	Else
		Return False;
	EndIf;
	
	Return Upper(String(ProfileID)) = Upper(OpenExternalReportsAndDataProcessorsProfileID());
	
EndFunction

Function OpenExternalReportsAndDataProcessorsProfileDetails() Export
	
	ProfileDetails = AccessManagement.NewAccessGroupProfileDescription();
	ProfileDetails.Name           = "OpenExternalReportsAndDataProcessors";
	ProfileDetails.ID = OpenExternalReportsAndDataProcessorsProfileID();
	
	ProfileDetails.Description =
		NStr("ru = 'Открытие внешних отчетов и обработок'; en = 'Open external reports and data processors'; pl = 'Otwieranie zewnętrznych raportów i traktowania';de = 'Öffnung von externen Berichten und Bearbeitungen';ro = 'Deschiderea rapoartelor și procesărilor externe';tr = 'Harici rapoların ve veri işlemcilerinin açılması'; es_ES = 'Abrir informes y procesamientos externos'", Metadata.DefaultLanguage.LanguageCode);
	
	ProfileDetails.Details =
		NStr("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".
		           |Состав ролей профиля не рекомендуется изменять.'; 
		           |en = 'Allows you to open external reports and data processors from the File-Open menu.
		           |It is not recommended that you change profile roles.'; 
		           |pl = 'Daje prawo do otwierania zewnętrznych raportów i zabiegów z menu Plik - Otwórz.
		           |Nie zaleca się zmiany składu ról profilu.';
		           |de = 'Bietet das Recht, externe Berichte und Prozesse aus dem Menü ""Datei- Öffnen"" zu öffnen.
		           |Es wird nicht empfohlen, die Zusammensetzung der Profilrollen zu ändern.';
		           |ro = 'Oferă dreptul de deschidere a rapoartelor și procesărilor suplimentare din meniul ""Fișier - Deschide"".
		           |Nu recomandăm să modificați componența rolurilor profilului.';
		           |tr = '""Dosya Aç"" menüsünden Dış raporları ve işlemleri açma hakkını sağlar. 
		           |Profil rollerinin kapsamının değiştirilmesi önerilmez.'; 
		           |es_ES = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".
		           |No se recomienda cambiar el contenido de roles de perfiles.'", Metadata.DefaultLanguage.LanguageCode);
	
	ProfileDetails.Roles.Add("InteractiveOpenExtReportsAndDataProcessors");
	
	Return ProfileDetails;
	
EndFunction

Function OpenExternalReportsAndDataProcessorsAccessGroup(ProfileProperties)
	
	// Search by ID.
	UUID = New UUID("f6929bcb-532f-11e6-a20f-5404a6a6895d");
	Ref = Catalogs.AccessGroups.GetRef(UUID);
	RefExists = (Common.ObjectAttributeValue(Ref, "Ref") <> Undefined);
	If RefExists Then
		Return Ref;
	EndIf;
	
	// Search by profile.
	ProfileGroups = ProfileGroups(ProfileProperties.Ref, Undefined);
	If ProfileGroups.Count() > 0 Then
		Return ProfileGroups[0];
	EndIf;
	
	// Creating a group.
	AccessGroupObject = Catalogs.AccessGroups.CreateItem();
	AccessGroupObject.SetNewObjectRef(Ref);
	AccessGroupObject.Description = ProfileProperties.Description;
	AccessGroupObject.Profile      = ProfileProperties.Ref;
	AccessGroupObject.Comment  =
		NStr("ru = 'Предоставляет право открытия внешних отчетов и обработок из меню ""Файл - Открыть"".'; en = 'Allows you to open external reports and data processors from the File-Open menu.'; pl = 'Daje prawo do otwierania zewnętrznych raportów i zabiegów z menu ""Plik - Otwórz"".';de = 'Gibt das Recht, externe Berichte und Prozesse aus dem Menü ""Datei- Öffnen"" zu öffnen.';ro = 'Oferă dreptul de deschidere a rapoartelor și procesărilor suplimentare din meniul ""Fișier - Deschide"".';tr = '""Dosya Aç"" menüsünden Dış raporları ve işlemleri açma hakkını sağlar.'; es_ES = 'Permite abrir informes y procesamientos externos del menú ""Archivo - Abrir"".'",
			Metadata.DefaultLanguage.LanguageCode);
	
	AccessGroupObject.Write(); // It is important that the created group belongs to the subordinate node.
	
	Return AccessGroupObject.Ref;
	
EndFunction

Function ProfileGroups(ProfileRef, DeletionMark)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	AccessGroups.Ref
	|FROM
	|	Catalog.AccessGroups AS AccessGroups
	|WHERE
	|	AccessGroups.Profile = &Profile
	|	AND AccessGroups.DeletionMark = &DeletionMark
	|
	|ORDER BY
	|	AccessGroups.DeletionMark";
	
	Query.SetParameter("Profile", ProfileRef);
	
	If DeletionMark = Undefined Then
		Query.Text = StrReplace(Query.Text, "AND AccessGroups.DeletionMark = &DeletionMark", "");
	Else
		Query.SetParameter("DeletionMark", DeletionMark);
	EndIf;
	
	Return Query.Execute().Unload().UnloadColumn("Ref");
	
EndFunction

// For AllowedDynamicListValues and HasRestrictionByAccessKind functions.
Function AccessGroupsRequestText()
	
	Return
	"SELECT
	|	AccessGroups.Ref AS Ref
	|INTO UserAccessGroups
	|FROM
	|	Catalog.MetadataObjectIDs AS CurrentTableProperties
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (CurrentTableProperties.FullName = &MainListTableName)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|				WHERE
	|					AccessGroupsTables.Table = CurrentTableProperties.Ref
	|					AND AccessGroupsTables.AccessGroup = AccessGroups.Ref))
	|			AND (AccessGroups.Ref IN
	|				(SELECT
	|					AccessGroupsUsers.Ref AS AccessGroup
	|				FROM
	|					Catalog.AccessGroups.Users AS AccessGroupsUsers
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User))";
	
EndFunction

// For the UpdateRecordSet, UpdateRecordSets, and UpdateInformationRegister procedures.
Procedure FillParameters(InputParameters, Val AllParameters, Val RequiredParameters = "")
	
	If TypeOf(InputParameters) = Type("Structure") Then
		Parameters = InputParameters;
	ElsIf InputParameters = Undefined Then
		Parameters = New Structure;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректный тип набора свойств ""%1"".
			           |Допустимые типы: Структура, Неопределено.'; 
			           |en = 'Incorrect type of property set ""%1"".
			           |Available types: Structure, Undefined.'; 
			           |pl = 'Niepoprawny typ zestawu właściwości ""%1"".
			           |Dozwolone typy: Struktura, Nieokreślony.';
			           |de = 'Inkorrekte Eigenschaften legen den Typ ""%1"" fest. 
			           |Zulässige Typen: Struktur, Nicht definiert.';
			           |ro = 'Tip incorect al setului de proprietăți ""%1"".
			           |Tipuri admise: Structură, Nedefinit.';
			           |tr = 'Yanlış özellikler kümesi türü ""%1"". 
			           | İzin verilen türler: Yapı, Belirlenmemiş.'; 
			           |es_ES = 'Tipo del conjunto de propiedades incorrectas ""%1"".
			           |Tipos permitidos: Estructura, No definida.'"),
			TypeOf(InputParameters));
		Raise ErrorText;
	EndIf;
	
	For each KeyAndValue In Parameters Do
		If Not AllParameters.Property(KeyAndValue.Key) Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Указан несуществующий параметр %1'; en = 'Non-existing parameter %1 is specified'; pl = 'Określono nieistniejący parametr %1';de = 'Nicht existierender Parameter %1 ist angegeben';ro = 'Parametrul non-existent %1 este specificat';tr = 'Mevcut olmayan parametre %1 belirlendi'; es_ES = 'Parámetro no existente %1 está especificado'"),
				KeyAndValue.Key);
			Raise ErrorText;
		EndIf;
		AllParameters[KeyAndValue.Key] = Parameters[KeyAndValue.Key];
	EndDo;
	
	If ValueIsFilled(RequiredParameters) Then
		RequiredParameters = New Structure(RequiredParameters);
		
		For each KeyAndValue In RequiredParameters Do
			If Not Parameters.Property(KeyAndValue.Key) Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не указан обязательный параметр %1'; en = 'Required parameter %1 is not specified'; pl = 'Wymagany parametr %1 nie został określony';de = 'Erforderlicher Parameter %1 ist nicht angegeben';ro = 'Parametrul necesar %1 nu este specificat';tr = 'Gerekli parametre %1 belirlenmedi'; es_ES = 'Parámetro requerido %1 no está especificado'"),
					KeyAndValue.Key);
				Raise ErrorText;
			EndIf;
		EndDo;
	EndIf;
	
	InputParameters = AllParameters;
	
EndProcedure

// For procedures OnSendDataToMaster, OnSendDataToSlave,
// OnReceiveDataFromMaster, OnReceiveDataFromSlave.
//
Function AccessManagementSubsystemObjectNameStartsWithDelete(DataItem)
	
	Return TypeOf(DataItem) = Type("ChartOfCharacteristicTypesObject.DeleteAccessKinds")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteAccessValuesGroups")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteAccessValuesSets")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DeleteRightsByAccessValues");
	
EndFunction

// For procedures OnSendDataToMaster, OnSendDataToSlave,
// OnReceiveDataFromMaster, OnReceiveDataFromSlave.
//
Function AccessManagementSubsystemObjectOnlyToCreateInitialImage(DataItem)
	
	Return TypeOf(DataItem) = Type("InformationRegisterRecordSet.RolesRights")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessRightsDependencies")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsTables")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsValues")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DefaultAccessGroupsValues")
	    Or TypeOf(DataItem) = Type("CatalogObject.AccessKeys")
	    Or TypeOf(DataItem) = Type("CatalogObject.SetsOfAccessGroups")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.ExternalUsersAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupsAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessGroupSetsAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessKeysForObjects")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessKeysForRegisters")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.UsersAccessKeys")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.DataAccessKeysUpdate")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.UsersAccessKeysUpdate")
	    Or TypeOf(DataItem) = Type("InformationRegisterRecordSet.AccessRestrictionParameters")
	    Or TypeOf(DataItem) = Type("ConstantValueManager.FirstAccessUpdateCompleted");
	
EndFunction

// For procedures OnReceiveDataFromMaster, OnReceiveDataFromSlave
Procedure OnReceiveDataFromMasterOrSlave(DataItem)
	
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroupProfiles") Then
		// Extension roles are assigned independently in all DIB nodes.
		Catalogs.AccessGroupProfiles.RestoreExtensionsRolesComponents(DataItem);
		// Registering a modified profile to update auxiliary data.
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataItem);
	EndIf;
	
	If TypeOf(DataItem) = Type("CatalogObject.AccessGroups") Then
		// Administrators are assigned independently in all DIB nodes.
		Catalogs.AccessGroups.RestoreAdministratorsAccessGroupMembers(DataItem);
		// Registering a modified access group to update auxiliary data.
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering users changed in a user group to update roles after receiving data.
	If TypeOf(DataItem) = Type("CatalogObject.UserGroups")
	 Or TypeOf(DataItem) = Type("CatalogObject.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataItem) = Type("CatalogObject.Users")
	 Or TypeOf(DataItem) = Type("CatalogObject.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataItem);
	EndIf;
	
	If TypeOf(DataItem) <> Type("ObjectDeletion") Then
		Return;
	EndIf;
	
	// Registering a changed profile to update auxiliary data after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.AccessGroupProfiles") Then
		Catalogs.AccessGroupProfiles.RegisterProfileChangedOnImport(DataItem);
	EndIf;
	
	// Registering a changed access group to update auxiliary data after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.AccessGroups") Then
		Catalogs.AccessGroups.RegisterAccessGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering users changed in a user group to update roles after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.UserGroups")
	 Or TypeOf(DataItem.Ref) = Type("CatalogRef.ExternalUsersGroups") Then
		Catalogs.AccessGroups.RegisterUsersOfUserGroupChangedOnImport(DataItem);
	EndIf;
	
	// Registering a user changed upon import to update roles after importing.
	If TypeOf(DataItem.Ref) = Type("CatalogRef.Users")
	 Or TypeOf(DataItem.Ref) = Type("CatalogRef.ExternalUsers") Then
		Catalogs.AccessGroups.RegisterUserChangedOnImport(DataItem);
	EndIf;
	
EndProcedure

// For AfterReceiveData and AfterUpdateInfobase procedures.
Procedure UpdateAuxiliaryDataOfItemsChangedOnImport()
	
	Catalogs.AccessGroupProfiles.UpdateAuxiliaryProfilesDataChangedOnImport();
	Catalogs.AccessGroups.UpdateAccessGroupsAuxiliaryDataChangedOnImport();
	Catalogs.AccessGroups.UpdateUsersRolesChangedOnImport();
	
EndProcedure

// For AddUserToAccessGroup procedure, RemoveUserFromAccessGroup procedure, and 
// FindUserInAccessGroup function.

Function ProcessUserLinkToAccessGroup(User, SuppliedProfile, Enable = Undefined)
	
	If TypeOf(User) <> Type("CatalogRef.Users")
	   AND TypeOf(User) <> Type("CatalogRef.UserGroups")
	   AND TypeOf(User) <> Type("CatalogRef.ExternalUsers")
	   AND TypeOf(User) <> Type("CatalogRef.ExternalUsersGroups") Then
		
		Return False;
	EndIf;
	
	SuppliedProfileID = Undefined;
	
	If TypeOf(SuppliedProfile) = Type("String") Then
		If StringFunctionsClientServer.IsUUID(SuppliedProfile) Then
			
			SuppliedProfileID = SuppliedProfile;
			
			SuppliedProfile = Catalogs.AccessGroupProfiles.SuppliedProfileByID(
				SuppliedProfileID);
		Else
			Return False;
		EndIf;
	EndIf;
	
	If TypeOf(SuppliedProfile) <> Type("CatalogRef.AccessGroupProfiles") Then
		Return False;
	EndIf;
	
	If SuppliedProfileID = Undefined Then
		SuppliedProfileID =
			Catalogs.AccessGroupProfiles.SuppliedProfileID(SuppliedProfile);
	EndIf;
	
	If SuppliedProfileID = Catalogs.AccessGroupProfiles.AdministratorProfileID() Then
		Return False;
	EndIf;
	
	SuppliedProfiles = AccessManagementInternalCached.SuppliedProfilesDescription();
	ProfileProperties = SuppliedProfiles.ProfilesDetails.Get(SuppliedProfileID);
	
	If ProfileProperties = Undefined
	 OR ProfileProperties.AccessKinds.Count() <> 0 Then
		
		Return False;
	EndIf;
	
	AccessGroup = Undefined;
	
	If SimplifiedAccessRightsSetupInterface() Then
		
		If TypeOf(User) <> Type("CatalogRef.Users")
		   AND TypeOf(User) <> Type("CatalogRef.ExternalUsers") Then
			
			Return False;
		EndIf;
		
		Query = New Query;
		Query.SetParameter("Profile", SuppliedProfile);
		Query.SetParameter("User", User);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &Profile
		|	AND AccessGroups.User = &User";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref;
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile      = SuppliedProfile;
				AccessGroup.User = User;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	Else
		Query = New Query;
		Query.SetParameter("SuppliedProfile", SuppliedProfile);
		Query.Text =
		"SELECT
		|	AccessGroups.Ref AS Ref,
		|	AccessGroups.MainSuppliedProfileAccessGroup
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile = &SuppliedProfile
		|
		|ORDER BY
		|	AccessGroups.MainSuppliedProfileAccessGroup DESC";
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AccessGroup = Selection.Ref;
		EndIf;
		
		If AccessGroup = Undefined Then
			If Enable <> True Then
				Return False;
			Else
				AccessGroup = Catalogs.AccessGroups.CreateItem();
				AccessGroup.MainSuppliedProfileAccessGroup = True;
				AccessGroup.Description = ProfileProperties.Description;
				AccessGroup.Profile = SuppliedProfile;
				AccessGroup.Users.Add().User = User;
				AccessGroup.Write();
				Return True;
			EndIf;
		EndIf;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Ref", AccessGroup);
	Query.SetParameter("User", User);
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessGroups.Users AS GroupMembers
	|WHERE
	|	GroupMembers.Ref = &Ref
	|	AND GroupMembers.User = &User";
	UserFound = NOT Query.Execute().IsEmpty();
	
	If Enable = Undefined Then
		Return UserFound;
	EndIf;
	
	If Enable AND UserFound Then
		Return True;
	EndIf;
	
	If NOT Enable AND NOT UserFound Then
		Return True;
	EndIf;
	
	AccessGroup = AccessGroup.GetObject();
	
	If NOT SimplifiedAccessRightsSetupInterface()
	   AND NOT AccessGroup.MainSuppliedProfileAccessGroup Then
		
		AccessGroup.MainSuppliedProfileAccessGroup = True;
	EndIf;
	
	If Enable Then
		AccessGroup.Users.Add().User = User;
	Else
		Filter = New Structure("User", User);
		Rows = AccessGroup.Users.FindRows(Filter);
		For each Row In Rows Do
			AccessGroup.Users.Delete(Row);
		EndDo;
	EndIf;
	
	AccessGroup.Write();
	
	Return True;
	
EndFunction

// For the WriteAccessValuesSetsOnWrite procedure.

// Overwrites access value sets of the object being checked in InformationRegister.AccessValuesSets 
// using the
// AccessManagement.FillAccessValuesSets() procedure.
//
// Procedure is called from AccessManagementInternal.WriteAccessValuesSets() but it can be called 
// from anywhere, for example, when you enable access restrictions at the record level.
// 
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValuesSets() used to rewrite dependent access value 
// sets.
//
// Parameters:
//  Object - CatalogObject, DocumentObject, ..., or CatalogRef, DocumentRef, ...
//                 The client call can pass only a reference, while an object is required.
//                 The object can be obtained by reference.
//  IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                 with the data.
//                 See InfobaseUpdate.WriteData. 
//
Procedure WriteAccessValuesSets(Val Object, HasChanges = Undefined, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// If the Object parameter is passed from client to server, a reference is passed and the object 
	// must be obtained.
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	SetsRecorded = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT SetsRecorded Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписках на события
			           |""Записать наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in subscriptions of the
			           |""Write access value sets"" events.'; 
			           |pl = 'Nieprawidłowe parametry.
			           |Typ obiektu ""%1""
			           |nie został znaleziony w subskrypcjach zdarzenia
			           |""Zapisuj zestawy wartości dostępu"".';
			           |de = 'Falsche Parameter.
			           |Der Objekttyp ""%1""
			           | ist in den Ereignis-Abonnements
			           |""Schreiben von Zugriffswerte-Sets"" nicht enthalten.';
			           |ro = 'Parametrii incorecți.
			           |Tipul obiectului ""%1""
			           |nu se găsește în subscrierile la evenimentele
			           | ""Înregistrare seturile valorilor de acces"".';
			           |tr = 'Yanlış parametreler. %1""Erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Nesne türü "
" bulunmadı.'; 
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en las suscripciones de eventos
			           | ""Guardar conjuntos de valores de acceso"".'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	PossibleObjectsTypes = AccessManagementInternalCached.TableFieldTypes(
		"InformationRegister.AccessValuesSets.Dimension.Object");
	
	If PossibleObjectsTypes.Get(TypeOf(ObjectRef)) = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ошибка при записи наборов значений доступа:
			           |в регистре сведений НаборыЗначенийДоступа в измерении Объект
			           |не задан тип ""%1"".'; 
			           |en = 'An error occurred when writing access value sets:
			           |type ""%1"" is not specified
			           |in the AccessValuesSets information register in the Object dimension.'; 
			           |pl = 'Błąd podczas zapisywania zestawów wartości dostępu:
			           |w rejestrze informacyjnym НаборыЗначенийДоступа w wymiarze Obiekt
			           |nie jest określony typ ""%1"".';
			           |de = 'Fehler beim Schreiben von Zugriffswerte-Sets:
			           |Informationsregister ZugriffsWerteSets Das Objekt wird in der Messung
			           |nicht als Typ ""%1"" angegeben.';
			           |ro = 'Eroare la înregistrarea seturilor valorilor de acces:
			           |în registrul de date НаборыЗначенийДоступа în dimensiunea Obiectul
			           |nu este specificat tipul ""%1"".';
			           |tr = 'Erişim değeri kümeleri yazılırken %1 bir  hata oluştu: "
" türü, 
			           |Nesne boyutunda ErişimDeğerKümeleri bilgi kaydında belirtilmemiş.'; 
			           |es_ES = 'Error al guardar los conjuntos de valores de acceso: 
			           |en el registro de información AccessValuesSets en la dimensión Objeto
			           |no se ha establecido el tipo ""%1"".'"),
			ObjectRef.Metadata().FullName());
		Raise ErrorText;
	EndIf;
	
	If AccessManagement.LimitAccessAtRecordLevel()
	   AND Not LimitAccessAtRecordLevelUniversally(, True) Then
		
		If Metadata.FindByType(ValueTypeObject).TabularSections.Find("AccessValuesSets") = Undefined Then
			
			Table = AccessManagement.AccessValuesSetsTable();
			AccessManagement.FillAccessValuesSets(Object, Table);
			
			AccessManagement.AddAccessValuesSets(
				Table, AccessManagement.AccessValuesSetsTable(), False, True);
		Else
			TabularSectionBeingFilled = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
				"FillAccessValuesSetsForTabularSections").Get(ValueTypeObject) <> Undefined;
			
			If NOT TabularSectionBeingFilled Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Неверные параметры.
					           |Тип объекта ""%1""
					           |не найден в подписках на события
					           |""Заполнить наборы значений доступа табличных частей"".'; 
					           |en = 'Incorrect parameters.
					           |Object type ""%1""
					           |is not found in subscriptions to the
					           |""Fill access value sets of tabular sections"" events.'; 
					           |pl = 'Nieprawidłowe parametry.
					           |Typ obiektu ""%1""
					           |nie został znaleziony w subskrypcjach zdarzenia
					           |""Zapisuj zestawy wartości dostępu części tabelarycznych"".';
					           |de = 'Falsche Parameter.
					           |Der Objekttyp ""%1""
					           |ist in den Abonnements der Ereignisse
					           |""Füllen Sie die Mengen der Zugriffswerte für Tabellenteile aus"" nicht enthalten.';
					           |ro = 'Parametri incorecți.
					           |Tipul obiectului ""%1""
					           |nu se găsește în subscrierile la evenimentele
					           | ""Completare seturile valorilor de acces ale secțiunilor tabelare"".';
					           |tr = 'Yanlış parametreler. %1""Sekmeli bölümlerin erişim değeri kümeleri yaz"" 
					           |olaylarına aboneliklerde 
					           |Nesne türü "
" bulunmadı.'; 
					           |es_ES = 'Parámetros incorrectos.
					           |Tipo del objeto ""%1""
					           |no se ha encontrado en las suscripciones de eventos
					           | ""Rellenar los conjuntos de valores de secciones tabulares"".'"),
					ValueTypeObject);
				Raise ErrorText;
			EndIf;
			// The object with already filled AccessValuesSets tabular section is written.
			Table = Object.AccessValuesSets.Unload();
		EndIf;
		
		PrepareAccessValuesSetsForWrite(ObjectRef, Table, True);
		
		Data = New Structure;
		Data.Insert("RegisterManager",   InformationRegisters.AccessValuesSets);
		Data.Insert("FixedFilter", New Structure("Object", ObjectRef));
		Data.Insert("NewRecords",        Table);
		Data.Insert("IBUpdate",       IBUpdate);
		
		BeginTransaction();
		Try
			UpdateRecordSets(Data, HasChanges);
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If HasChanges = True Then
			OnChangeAccessValuesSets(ObjectRef, IBUpdate);
		EndIf;
	Else
		Query = New Query(
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.AccessValuesSets AS AccessValuesSets
		|WHERE
		|	AccessValuesSets.Object = &ObjectRef");
		
		Query.SetParameter("ObjectRef", ObjectRef);
		
		If NOT Query.Execute().IsEmpty() Then
			// Clearing an obsolete set.
			// A new set will be written using a scheduled job after enabling restriction at the record level.
			// 
			RecordSet = InformationRegisters.AccessValuesSets.CreateRecordSet();
			RecordSet.Filter.Object.Set(ObjectRef);
			RecordSet.Write();
			HasChanges = True;
			
			// Clearing obsolete dependent sets.
			OnChangeAccessValuesSets(ObjectRef, IBUpdate);
		EndIf;
	EndIf;
	
EndProcedure

// For the WriteDependentAccessValuesSetsOnWrite procedure.

// Overwrites access value sets of dependent objects.
//
//  Procedure is called from AccessManagementInternal.WriteDependentAccessValuesSets()
// The subscription type content complements (without overlapping) the WriteAccessValuesSets 
// subscription type content with types that do not require recording sets to the AccessValuesSets 
// information register but the sets themselves belong to other sets. Example: a set of files from 
// the Files catalog might belong to several Job business processes created based on files. 
// Recording the file sets to the register is not required.
//
// Calls the applied developer procedure
// AccessManagementOverridable.OnChangeAccessValuesSets() used for overwriting dependent value sets, 
// thus creating a recursion.
// 
//
// Parameters:
//  Object - CatalogObject, DocumentObject, ..., or CatalogRef, DocumentRef, ...
//                 The client call can pass only a reference, while an object is required.
//                 The object can be obtained by reference.
//
//  IBUpdate - Boolean - if True, write data without performing unnecessary and redundant actions 
//                 with the data.
//                 See InfobaseUpdate.WriteData. 
//
Procedure WriteDependentAccessValuesSets(Val Object, IBUpdate = False)
	
	SetPrivilegedMode(True);
	
	// If the Object parameter is passed from client to server, a reference is passed and the object 
	// must be obtained.
	Object = ?(Object = Object.Ref, Object.GetObject(), Object);
	ObjectRef = Object.Ref;
	ValueTypeObject = TypeOf(Object);
	
	IsLeadingObject = AccessManagementInternalCached.ObjectsTypesInSubscriptionsToEvents(
		"WriteDependentAccessValuesSets").Get(ValueTypeObject) <> Undefined;
	
	If NOT IsLeadingObject Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Неверные параметры.
			           |Тип объекта ""%1""
			           |не найден в подписке на события
			           |""Записать зависимые наборы значений доступа"".'; 
			           |en = 'Incorrect parameters.
			           |Object type ""%1""
			           |is not found in subscriptions to the
			           |""Write dependent access value sets"" events.'; 
			           |pl = 'Nieprawidłowe parametry.
			           |Typ obiektu ""%1""
			           |nie został znaleziony w subskrypcjach zdarzenia
			           |""Zapisuj zależne zestawy wartości dostępu"".';
			           |de = ' Falsche Parameter.
			           |Der Objekttyp ""%1""
			           |wird im Ereignisabonnement 
			           |""Abhängige Zugriffswerte schreiben"" nicht gefunden.';
			           |ro = 'Parametrii incorecți.
			           |Tipul obiectului ""%1""
			           |nu se găsește în subscrierile la evenimentele
			           | ""Înregistrare seturile dependente ale valorilor de acces"".';
			           |tr = 'Yanlış parametreler. %1""Bağımlı erişim değeri kümeleri yaz"" 
			           |olaylarına aboneliklerde 
			           |Nesne türü "
" bulunmadı.'; 
			           |es_ES = 'Parámetros incorrectos.
			           |Tipo del objeto ""%1""
			           |no se ha encontrado en la suscripción de eventos
			           | ""Guardar conjuntos dependientes de valores de acceso"".'"),
			ValueTypeObject);
		Raise ErrorText;
	EndIf;
	
	OnChangeAccessValuesSets(ObjectRef, IBUpdate);
	
EndProcedure

// For the UpdateAuxiliaryDataByConfigurationChanges and
// FillSeparatedDataHandlers procedures.

// Checks whether shared data was changed for any data area.
Function HasChangesOfAccessRestrictionParameters()
	
	SetPrivilegedMode(True);
	
	Parameters = New Array;
	Parameters.Add("StandardSubsystems.AccessManagement.RoleRightMetadataObjects");
	Parameters.Add("StandardSubsystems.AccessManagement.RightsForObjectsRightsSettingsAvailable");
	Parameters.Add("StandardSubsystems.AccessManagement.SuppliedProfilesDescription");
	Parameters.Add("StandardSubsystems.AccessManagement.AccessGroupPredefinedProfiles");
	Parameters.Add("StandardSubsystems.AccessManagement.GroupAndAccessValueTypes");
	
	For Each Parameter In Parameters Do
		
		LastChanges = StandardSubsystemsServer.ApplicationParameterChanges(Parameter);
		
		If LastChanges = Undefined
		 OR LastChanges.Count() > 0 Then
			
			Return True;
		EndIf;
		
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateUsersRoles procedure.

Function CurrentUsersProperties(UsersArray)
	
	Query = New Query;
	
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	If UsersArray = Undefined Then
		Query.Text =
		"SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|WHERE
		|	Users.Internal = FALSE
		|	AND Users.IBUserID <> &BlankID
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|WHERE
		|	ExternalUsers.IBUserID <> &BlankID";
		
	ElsIf TypeOf(UsersArray) = Type("Type") Then
		If Metadata.FindByType(UsersArray) = Metadata.Catalogs.ExternalUsers Then
			Query.Text =
			"SELECT
			|	ExternalUsers.Ref AS User,
			|	ExternalUsers.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.ExternalUsers AS ExternalUsers
			|WHERE
			|	ExternalUsers.IBUserID <> &BlankID";
		Else
			Query.Text =
			"SELECT
			|	Users.Ref AS User,
			|	Users.IBUserID
			|INTO UsersToCheck
			|FROM
			|	Catalog.Users AS Users
			|WHERE
			|	Users.Internal = FALSE
			|	AND Users.IBUserID <> &BlankID";
		EndIf;
	Else
		InitialUsers = New ValueTable;
		InitialUsers.Columns.Add("User", New TypeDescription(
			"CatalogRef.Users, CatalogRef.ExternalUsers"));
		
		For each User In UsersArray Do
			InitialUsers.Add().User = User;
		EndDo;
		
		Query.SetParameter("InitialUsers", InitialUsers);
		Query.Text =
		"SELECT DISTINCT
		|	InitialUsers.User
		|INTO InitialUsers
		|FROM
		|	&InitialUsers AS InitialUsers
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	Users.Ref AS User,
		|	Users.IBUserID
		|INTO UsersToCheck
		|FROM
		|	Catalog.Users AS Users
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON Users.Ref = InitialUsers.User
		|			AND (Users.Internal = FALSE)
		|			AND (Users.IBUserID <> &BlankID)
		|
		|UNION ALL
		|
		|SELECT
		|	ExternalUsers.Ref,
		|	ExternalUsers.IBUserID
		|FROM
		|	Catalog.ExternalUsers AS ExternalUsers
		|		INNER JOIN InitialUsers AS InitialUsers
		|		ON ExternalUsers.Ref = InitialUsers.User
		|			AND (ExternalUsers.IBUserID <> &BlankID)";
	EndIf;
	
	QueryText =
	"SELECT
	|	Users.Ref AS Ref,
	|	Users.IBUserID
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		INNER JOIN Catalog.Users AS Users
	|		ON (AccessGroupsUsers.Ref = VALUE(Catalog.AccessGroups.Administrators))
	|			AND AccessGroupsUsers.User = Users.Ref
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UsersToCheck.User,
	|	UsersToCheck.IBUserID
	|FROM
	|	UsersToCheck AS UsersToCheck
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersToCheck.User AS User,
	|	AccessGroupsUsers.Ref.Profile AS Profile
	|INTO UsersProfiles
	|FROM
	|	UsersToCheck AS UsersToCheck
	|		INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		ON UsersToCheck.User = UserGroupCompositions.User
	|			AND (UserGroupCompositions.Used)
	|			AND (&ExcludeExternalUsers)
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers.User)
	|			AND (NOT AccessGroupsUsers.Ref.DeletionMark)
	|			AND (NOT AccessGroupsUsers.Ref.Profile.DeletionMark)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersProfiles.User,
	|	Roles.Role AS RoleRef,
	|	Roles.Role.Name AS Role
	|FROM
	|	UsersProfiles AS UsersProfiles
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = UsersProfiles.Profile)
	|WHERE
	|	Roles.Role <> UNDEFINED";
	
	Query.Text = Query.Text + "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|" + QueryText;
	
	If Constants.UseExternalUsers.Get() Then
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers", "True");
	Else
		Query.Text = StrReplace(Query.Text, "&ExcludeExternalUsers",
			"VALUETYPE(UsersToCheck.User) = TYPE(Catalog.Users)");
	EndIf;
	
	QueriesResults = Query.ExecuteBatch();
	LastResult = QueriesResults.Count()-1;
	Total = New Structure;
	
	Total.Insert("Administrators", New Map);
	
	For each Row In QueriesResults[LastResult-3].Unload() Do
		Total.Administrators.Insert(Row.Ref, True);
	EndDo;
	
	Total.Insert("IBUsersIDs", QueriesResults[LastResult-2].Unload());
	Total.IBUsersIDs.Indexes.Add("User");
	
	Total.Insert("UsersRoles", QueriesResults[LastResult].Unload());
	Total.UsersRoles.Indexes.Add("User");
	
	RoleIDs = Total.UsersRoles.UnloadColumn("RoleRef");
	RolesMetadata = Common.MetadataObjectsByIDs(RoleIDs, False);
	
	For Each Row In Total.UsersRoles Do
		RoleMetadata = RolesMetadata.Get(Row.RoleRef);
		If TypeOf(RoleMetadata) = Type("MetadataObject") Then
			Row.Role = RoleMetadata.Name;
		EndIf;
	EndDo;
	
	Return Total;
	
EndFunction

Procedure RegisterUnavailableRole(RoleDetails, User)
	
	// Unavailable roles in profiles.
	Profiles = UserWithRoleProfiles(User, RoleDetails.RoleRef);
	
	For Each Profile In Profiles Do
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Роль не доступна пользователю'; en = 'Access management.Role is unavailable to the user'; pl = 'Kontrola dostępu.Rola niedostępna dla użytkownika';de = 'Zugriffskontrolle. Die Rolle steht dem Benutzer nicht zur Verfügung';ro = 'Administrarea accesului.Rolul nu este accesibil utilizatorului';tr = 'Erişim kontrolü.  Rol kullanıcı tarafından kullanılmaz'; es_ES = 'Gestión de acceso.El rol no está disponible al usuario'",
			     Common.DefaultLanguageCode()),
			EventLogLevel.Error,
			Metadata.Catalogs.AccessGroupProfiles,
			Profile,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru= 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |недоступна пользователю.'; 
				          |en = 'While updating the ""%1"" user roles,
				          |the ""%2"" role
				          |of the ""%3"" access group profile
				          |is not available to the user.'; 
				          |pl = 'Podczas aktualizowania ról użytkownika ""%1""
				          | rola ""%2""
				          |profilu grupy dostępu ""%3""
				          |nie jest dostępna dla użytkownika.';
				          |de = 'Beim Aktualisieren von Benutzerrollen ""%1""
				          |steht die Rolle ""%2""
				          |des Zugriffsgruppenprofils ""%3""
				          |dem Benutzer nicht zur Verfügung.';
				          |ro = 'La actualizarea rolurilor utilizatorului ""%1""
				          |rolul ""%2""
				          |al profilului de acces ""%3""
				          |nu este accesibil utilizatorului.';
				          |tr = 'Erişim grubu profili 
				          |""%1"" rol ""%2"" 
				          |kullanıcı rollerini güncelleştirildiğinde, "
"%3kullanıcı tarafından kullanılamaz.'; 
				          |es_ES = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no está disponible al usuario.'"),
				String(User),
				RoleDetails.Role,
				String(Profile)),
			EventLogEntryTransactionMode.Transactional);
	EndDo;
	
EndProcedure

Procedure RegisterNotFoundRole(RoleDetails, User)
	
	// New roles not found in the metadata.
	Profiles = UserWithRoleProfiles(User, RoleDetails.RoleRef);
	
	For Each Profile In Profiles Do
		WriteLogEvent(
			NStr("ru = 'Управление доступом.Роль не найдена в метаданных'; en = 'Access management.Role is not found in the metadata'; pl = 'Zarządzanie dostępem. W metadanych nie znaleziono roli';de = 'Zugriffsverwaltung. Die Rolle wurde in Metadaten nicht gefunden';ro = 'Administrarea accesului.Rolul nu este găsit în metadate';tr = 'Erişim yönetimi.  Meta veride rol bulunmadı.'; es_ES = 'Gestión de acceso.Rol no encontrado en los metadatos.'",
			     Common.DefaultLanguageCode()),
			EventLogLevel.Error,
			Metadata.Catalogs.AccessGroupProfiles,
			Profile,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru= 'При обновлении ролей пользователя ""%1""
				          |роль ""%2""
				          |профиля групп доступа ""%3""
				          |не найдена в метаданных.'; 
				          |en = 'While updating roles of the ""%1"" user, the ""%2""
				          |role of the ""%3""
				          |access group profile
				          |was not found in the metadata.'; 
				          |pl = 'Podczas aktualizacji ról użytkownika""%1""
				          |rola ""%2""
				          |profilu grup dostępu""%3""
				          |nie znaleziona w metadanych.';
				          |de = 'Bei der Aktualisierung von Benutzerrollen ""%1""
				          |wird die Rolle ""%2""
				          |des Zugriffsgruppenprofils ""%3""
				          |in den Metadaten nicht gefunden.';
				          |ro = 'La actualizarea rolurilor utilizatorului ""%1""
				          |rolul ""%2""
				          |al profilului de acces ""%3""
				          |nu a fost găsit în metadate.';
				          |tr = 'Erişim grubu profili 
				          |""%1"" rol ""%2"" 
				          |kullanıcı rollerini güncelleştirildiğinde, "
"%3metaverilerde bulunamadı.'; 
				          |es_ES = 'Al actualizar los roles de usuario ""%1""
				          | el rol ""%2""
				          |del perfil del grupo de acceso ""%3"" 
				          |no se ha encontrado en metadatos.'"),
				String(User),
				RoleDetails.Role,
				String(Profile)),
			EventLogEntryTransactionMode.Transactional);
	EndDo;
	
EndProcedure

Procedure UpdateIBUsersRoles(IBUsersToUpdate, ServiceUserPassword)
	
	StandardSubsystemsServer.CheckApplicationVersionDynamicUpdate();
	
	For Each KeyAndValue In IBUsersToUpdate Do
		RolesForAdding  = KeyAndValue.Value.RolesForAdding;
		RolesForDeletion    = KeyAndValue.Value.RolesForDeletion;
		InfobaseUser     = KeyAndValue.Value.InfobaseUser;
		UserRef = KeyAndValue.Value.UserRef;
		
		HadFullRights = InfobaseUser.Roles.Contains(Metadata.Roles.FullRights);
		
		For each KeyAndValue In RolesForAdding Do
			InfobaseUser.Roles.Add(Metadata.Roles[KeyAndValue.Key]);
		EndDo;
		
		For each KeyAndValue In RolesForDeletion Do
			InfobaseUser.Roles.Delete(Metadata.Roles[KeyAndValue.Key]);
		EndDo;
		
		BeginTransaction();
		Try
			WriteUserOnRolesUpdate(UserRef,
				InfobaseUser, HadFullRights, ServiceUserPassword);
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the RegisterUnavailableRole and RegisterNotFoundRole procedures.
Function UserWithRoleProfiles(User, Role)
	
	Query = New Query;
	Query.SetParameter("CurrentUser", User);
	Query.SetParameter("Role", Role);
	
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	Query.Text =
	"SELECT DISTINCT
	|	Roles.Ref AS Profile
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsUsers
	|		ON (UserGroupCompositions.User = &CurrentUser)
	|			AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
	|			AND (UserGroupCompositions.Used)
	|			AND (NOT AccessGroupsUsers.Ref.DeletionMark)
	|		INNER JOIN Catalog.AccessGroupProfiles.Roles AS Roles
	|		ON (Roles.Ref = AccessGroupsUsers.Ref.Profile)
	|			AND (NOT Roles.Ref.DeletionMark)
	|			AND (Roles.Role = &Role)";
	
	Return Query.Execute().Unload().UnloadColumn("Profile");
	
EndFunction

// This method is required by UpdateIBUsersRoles procedure.
Procedure WriteUserOnRolesUpdate(UserRef, InfobaseUser, HadFullRights, ServiceUserPassword)
	
	UsersInternal.WriteInfobaseUser(InfobaseUser, 
		TypeOf(UserRef) = Type("CatalogRef.ExternalUsers"));
	
	If Not Common.DataSeparationEnabled() Then
		Return;
	EndIf;
	
	HasFullRights = InfobaseUser.Roles.Contains(Metadata.Roles.FullRights);
	If HasFullRights = HadFullRights Then
		Return;
	EndIf;
	
	If ServiceUserPassword = Undefined Then
		If Common.SubsystemExists("StandardSubsystems.SaaS") Then
			ModuleSaaS = Common.CommonModule("SaaS");
			SessionWithoutSeparators = ModuleSaaS.SessionWithoutSeparators();
		Else
			SessionWithoutSeparators = True;
		EndIf;
		If SessionWithoutSeparators Then
			Return;
		EndIf;
		
		ErrorText =
			NStr("ru = 'Для изменения административного доступа
			           |требуется пароль пользователя сервиса.
			           |
			           |Операция может быть выполнена только интерактивно.'; 
			           |en = 'To change administration access,
			           |service user password is required.
			           |
			           |The operation can be performed only interactively.'; 
			           |pl = 'Aby zmienić administracyjnego dostępu
			           |wymagane jest hasło użytkownika serwisu.
			           |
			           |Operacja może być wykonana tylko interaktywnie.';
			           |de = 'Für die Änderung des Administrator-Zugriffs
			           |ist ein Service-Benutzerpasswort erforderlich.
			           |
			           |Der Vorgang kann nur interaktiv durchgeführt werden.';
			           |ro = 'Pentru a modifica accesul administrativ
			           |este necesară parola de utilizator al serviciului.
			           |
			           |Operația poate fi efectuată numai interactiv.';
			           |tr = 'Yönetici 
			           |erişimini değiştirmek için servis kullanıcı şifresi gereklidir. 
			           |
			           |Operasyon sadece etkileşimli olarak yapılabilir.'; 
			           |es_ES = 'Para cambiar el acceso administrativo
			           |, se requiere la contraseña del usuario de servicio.
			           |
			           |Operación puede realizarse solo de forma interactiva.'");
		Raise ErrorText;
	EndIf;
	
	If Common.SubsystemExists("StandardSubsystems.SaaS.UsersSaaS") Then
		ModuleUsersInternalSaaS = Common.CommonModule("UsersInternalSaaS");
		ModuleUsersInternalSaaS.WriteSaaSUser(UserRef, False, ServiceUserPassword);
	EndIf;
	
EndProcedure

// For the ChangesSelectionQueryText procedure.

Function KeyAndValue(Structure)
	
	For each KeyAndValue In Structure Do
		Return KeyAndValue;
	EndDo;
	
EndFunction

// For the UpdateRecordSet and UpdateNewSetRecordsByVariousNewRecords procedures.

Procedure WriteObjectOrRecordSet(Data, ObjectOrRecordSet)
	
	If Data.IBUpdate Then
		InfobaseUpdate.WriteData(ObjectOrRecordSet);
	Else
		ObjectOrRecordSet.Write();
	EndIf;
	
EndProcedure

// For the UpdateRecordSet and UpdateRecordSets procedures.

Function DimensionParametersGroupProcessed(DimensionName, DimensionValues)
	
	If DimensionName = Undefined Then
		DimensionValues = Undefined;
		
	ElsIf DimensionValues = Undefined Then
		DimensionName = Undefined;
		
	ElsIf TypeOf(DimensionValues) <> Type("Array")
	        AND TypeOf(DimensionValues) <> Type("FixedArray") Then
		
		DimensionValue = DimensionValues;
		DimensionValues = New Array;
		DimensionValues.Add(DimensionValue);
		
	ElsIf DimensionValues.Count() = 0 Then
		Return False;
	EndIf;
	
	Return True;
	
EndFunction

Procedure OrderDimensionsParametersGroups(Data)
	
	If Data.SecondDimensionName = Undefined Then
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.FirstDimensionName = Undefined Then
		Data.FirstDimensionName       = Data.SecondDimensionName;
		Data.FirstDimensionValues  = Data.SecondDimensionValues;
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = Undefined;
		Data.ThirdDimensionValues = Undefined;
	EndIf;
	
	If Data.SecondDimensionValues  <> Undefined
	   AND Data.ThirdDimensionValues <> Undefined
	   AND Data.SecondDimensionValues.Count()
	   > Data.ThirdDimensionValues.Count() Then
		
		DimensionName      = Data.SecondDimensionName;
		DimensionValues = Data.SecondDimensionValues;
		
		Data.SecondDimensionName       = Data.ThirdDimensionName;
		Data.SecondDimensionValues  = Data.ThirdDimensionValues;
		Data.ThirdDimensionName      = DimensionName;
		Data.ThirdDimensionValues = DimensionValues;
	EndIf;
	
	If Data.FirstDimensionValues <> Undefined
	   AND Data.SecondDimensionValues <> Undefined
	   AND Data.FirstDimensionValues.Count()
	   > Data.SecondDimensionValues.Count() Then
		
		DimensionName      = Data.FirstDimensionName;
		DimensionValues = Data.FirstDimensionValues;
		
		Data.FirstDimensionName      = Data.SecondDimensionName;
		Data.FirstDimensionValues = Data.SecondDimensionValues;
		Data.SecondDimensionName      = DimensionName;
		Data.SecondDimensionValues = DimensionValues;
	EndIf;
	
EndProcedure

Function RecordSetFields(RecordSet)
	
	ComparisonFields = "";
	Table = RecordSet.Unload(New Array);
	For each Column In Table.Columns Do
		ComparisonFields = ComparisonFields + "," + Column.Name;
	EndDo;
	ComparisonFields = Mid(ComparisonFields, 2);
	
	Return ComparisonFields;
	
EndFunction

Procedure UpdateNewSetRecordsByAllNewRecords(Val Data, Val Filter, Val FieldsList,
				Val DimensionName, Val DimensionValues, HasChanges)
	
	LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
	
	Data.RecordSet.Read();
	NewSetRecords = Data.RecordSet.Unload();
	NewSetRecords.Indexes.Add(FieldsList);
	
	For each Value In DimensionValues Do
		Filter[DimensionName] = Value;
		For each FoundRecord In NewSetRecords.FindRows(Filter) Do
			NewSetRecords.Delete(FoundRecord);
		EndDo;
		For each FoundRecord In Data.NewRecords.FindRows(Filter) Do
			FillPropertyValues(NewSetRecords.Add(), FoundRecord);
		EndDo;
	EndDo;
	
	CurrentData = New Structure("RecordSet, ComparisonFields,
		|CheckOnly, AdditionalProperties, IBUpdate");
	FillPropertyValues(CurrentData, Data);
	CurrentData.Insert("NewRecords", NewSetRecords);
	CurrentData.Insert("RecordSetRead", True);
	
	UpdateRecordSet(CurrentData, HasChanges);
	
EndProcedure

Procedure RefreshNewSetRecordsByVariousNewRecords(Val Data, Val Filter, HasChanges)
	
	// Getting a number of records to be read.
	
	If Filter.Count() = 0 Then
		CurrentNewRecords = Data.NewRecords.Copy();
		CountForReading = Data.CountForReading;
	Else
		CurrentNewRecords = Data.NewRecords.Copy(Filter);
		
		FieldName = Data.CountByValues.Columns[0].Name;
		CountRow = Data.CountByValues.Find(Filter[FieldName], FieldName);
		CountForReading = ?(CountRow = Undefined, 0, CountRow.Count);
	EndIf;
	
	NewRecordFilter = New Structure("RowChangeKind, " + Data.ComparisonFields, 1);
	CurrentNewRecords.Indexes.Add("RowChangeKind, " + Data.ComparisonFields);

	RecordsKeys = CurrentNewRecords.Copy(, "RowChangeKind, " + Data.ComparisonFields);
	RecordsKeys.GroupBy("RowChangeKind, " + Data.ComparisonFields);
	RecordsKeys.GroupBy(Data.ComparisonFields, "RowChangeKind");
	
	FilterByRecordKey = New Structure(Data.ComparisonFields);
	
	If UpdateEntireRecordSet(CountForReading, RecordsKeys) Then
		
		LockRecordSetArea(Data.RecordSet, Data.FullRegisterName);
		Data.RecordSet.Read();
		NewSetRecords = Data.RecordSet.Unload();
		NewSetRecords.Indexes.Add(Data.ComparisonFields);
		
		For each Row In RecordsKeys Do
			FillPropertyValues(FilterByRecordKey, Row);
			FoundRows = NewSetRecords.FindRows(FilterByRecordKey);
			If Row.RowChangeKind = -1 Then
				If FoundRows.Count() > 0 Then
					// Deleting an old row.
					NewSetRecords.Delete(FoundRows[0]);
				EndIf;
			Else
				// Adding a new or updating an old row.
				If FoundRows.Count() = 0 Then
					RowToFill = NewSetRecords.Add();
				Else
					RowToFill = FoundRows[0];
				EndIf;
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(RowToFill, NewRecord);
			EndIf;
		EndDo;
		// Changing a record set to make it different from the new set records.
		If Data.RecordSet.Count() = NewSetRecords.Count() Then
			Data.RecordSet.Add();
		EndIf;
		
		CurrentData = New Structure("RecordSet, ComparisonFields,
			|CheckOnly, AdditionalProperties, IBUpdate");
		FillPropertyValues(CurrentData, Data);
		CurrentData.Insert("NewRecords", NewSetRecords);
		CurrentData.Insert("RecordSetRead", True);
		
		UpdateRecordSet(CurrentData, HasChanges);
	Else
		// Updating by row.
		SetAdditionalProperties(Data.SetForSingleRecord, Data.AdditionalProperties);
		For each Row In RecordsKeys Do
			Data.SetForSingleRecord.Clear();
			FillPropertyValues(FilterByRecordKey, Row);
			For each KeyAndValue In FilterByRecordKey Do
				SetFilter(
					Data.SetForSingleRecord.Filter[KeyAndValue.Key], KeyAndValue.Value);
			EndDo;
			LockRecordSetArea(Data.SetForSingleRecord, Data.FullRegisterName);
			If Row.RowChangeKind > -1 Then
				// Adding a new row or updating the existing row.
				FillPropertyValues(NewRecordFilter, FilterByRecordKey);
				FoundRecords = CurrentNewRecords.FindRows(NewRecordFilter);
				If FoundRecords.Count() = 1 Then
					NewRecord = FoundRecords[0];
				Else // Error in the NewRecords parameter.
					ExceptionOnRecordSearchError(Data);
				EndIf;
				FillPropertyValues(Data.SetForSingleRecord.Add(), NewRecord);
			EndIf;
			HasChanges = True;
			If Data.CheckOnly Then
				Return;
			EndIf;
			WriteObjectOrRecordSet(Data, Data.SetForSingleRecord);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateNewSetRecordsByVariousNewRecords procedure.
Function UpdateEntireRecordSet(CountForReading, RecordsKeys)
	
	If CountForReading > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	CountOfItemsToDelete = RecordsKeys.FindRows(
		New Structure("RowChangeKind", -1)).Count();
	
	CountOfItemsToAdd = RecordsKeys.FindRows(
		New Structure("RowChangeKind", 1)).Count();
	
	ForWriteCount = CountForReading - CountOfItemsToDelete
		+ CountOfItemsToAdd;
	
	If ForWriteCount > 10000 Then
		Return False; // Record set is too big.
	EndIf;
	
	ItemsToChangeCount = RecordsKeys.Count()
		- (CountOfItemsToDelete + CountOfItemsToAdd);
	
	NotChangedCount = CountForReading
		- (CountOfItemsToDelete + ItemsToChangeCount);
	
	FullyRewriteCosts =
	//                Operations:   |Read|Delete|Insert|
	      CountOfItemsToDelete   * ( 0.05  +  0.1          )
	    + ItemsToChangeCount  * ( 0.05  +  0.1   +  1   )
	    + CountOfItemsToAdd * (                   1   )
	    + NotChangedCount  * ( 0.05  +  0.1   +  1   );
	
	CostsToRewriteOneRecord =
	//                Operations:   |Delete|Insert|
	      CountOfItemsToDelete   * (   0.5          )
	    + ItemsToChangeCount  * (   0.5  +  1.2  )
	    + CountOfItemsToAdd * (   0.5  +  1.2  );
	
	Return FullyRewriteCosts < CostsToRewriteOneRecord;
	
EndFunction

Procedure ExceptionOnRecordSearchError(Parameters)
	
	For each ChangesRow In Parameters.NewRecords Do
		If ChangesRow.RowChangeKind <>  1
		   AND ChangesRow.RowChangeKind <> -1 Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
				           |общего модуля УправлениеДоступомСлужебный.
				           |
				           |Неверное значение параметра НовыеЗаписи - колонка
				           |ВидИзмененияСтроки содержит недопустимое значение ""%1"".
				           |
				           |Допустимо только 2 значения: ""1"" и ""-1"".'; 
				           |en = 'An error occurred in the UpdateRecordSets procedure
				           |of the AccessManagementInternal common module.
				           |
				           |Incorrect value of the NewRecords parameter – the
				           |RowChangeKind column contains invalid value ""%1"".
				           |
				           |Only 2 values are possible: ""1"" and ""-1"".'; 
				           |pl = 'Błąd w procedurze ОбновитьНаборыЗаписей
				           |wspólnego modułu УправлениеДоступомСлужебный.
				           |
				           |Nieprawidłowa wartość parametru НовыеЗаписи - kolumna
				           |ВидИзмененияСтроки zawiera nieprawidłową wartość ""%1"".
				           |
				           |Dopuszczalne tylko 2 wartości: ""1"" i ""-1"".';
				           |de = 'Fehler in der Prozedur AktualisierenVonAufzeichnungsSets
				           |des allgemeinen Moduls ServiceZugriffsVerwaltung.
				           |
				           |Falscher Wert des Parameters NeueAufzeichnungen - Spalte
				           | ÄnderungenInZeilen enthält ungültigen Wert ""%1"".
				           |
				           |Nur 2 Werte sind erlaubt: ""1"" und ""-1"".';
				           |ro = 'Eroare în procedura ОбновитьНаборыЗаписей
				           |a modulului general УправлениеДоступомСлужебный.
				           |
				           |Valoare incorectă a parametrului НовыеЗаписи - coloana
				           |ВидИзмененияСтроки conține valoarea inadmisibilă ""%1"".
				           |
				           |Sunt admise doar 2 valori: ""1"" și ""-1"".';
				           |tr = 'ErişimYönetimiServis 
				           |genel modülünün KayıtKümeleriniYenile prosedüründe bir hata oluştu. 
				           |
				           |YeniKayıtlar parametresi 
				           |hatalı değer - SatırDeğişikliğiTürü sütunu geçersiz "
" değerini içerir. %1
				           |Sadece 2 değer mevcuttur: ""1"" ve ""-1"".'; 
				           |es_ES = 'Error en el procedimiento UpdateRecordSets procedure 
				           |del módulo común AccessManagementInternal.
				           |
				           |Valor incorrecto del parámetro NewRecords - columna
				           |RowChangeKind contiene valor incorrecto ""%1"".
				           |
				           |Se admiten solo 2 valores: ""1"" y ""-1"".'"),
				String(ChangesRow.RowChangeKind));
			Raise ErrorText;
		EndIf;
	EndDo;
	
	ErrorText =
		NStr("ru = 'Ошибка в процедуре ОбновитьНаборыЗаписей
		           |общего модуля УправлениеДоступомСлужебный.
		           |
		           |Не удалось найти требуемую в строку
		           |в значении параметра НовыеЗаписи.'; 
		           |en = 'An error occurred in the UpdateRecordSets procedure
		           |of the AccessManagementInternal common module.
		           |
		           |Cannot find the required string
		           |in the NewRecords parameter value.'; 
		           |pl = 'Błąd w procedurze ОбновитьНаборыЗаписей
		           | wspólnego modułu УправлениеДоступомСлужебный.
		           |
		           |Nie udało się znaleźć odpowiednią w wierszu
		           |в wartości parametru НовыеЗаписи.';
		           |de = 'Fehler in der Prozedur AktualisierenVonAufzeichnungsSets
		           |des allgemeinen Moduls ServiceZugriffsVerwaltung.
		           |
		           |Es war nicht möglich, den gewünschten Wert in der Zeile
		           |im Wert des Parameters NeueAufzeichnungen zu finden.';
		           |ro = 'Eroare în procedura ОбновитьНаборыЗаписей
		           |a modulului general УправлениеДоступомСлужебный.
		           |
		           |Nu a fost găsit rândul dorit
		           |în valoarea parametrului НовыеЗаписи.';
		           |tr = 'ErişimYönetimiServis 
		           |genel modülünün KayıtKümeleriniYenile prosedüründe 
		           |bir hata oluştu. 
		           |
		           | YeniKayıtlar parametre değerinde gerekli satır bulunamadı.'; 
		           |es_ES = 'Error en el procedimiento UpdateRecordSets 
		           |del módulo común AccessManagementInternal.
		           |
		           |No se ha podido encontrar una línea requerida
		           |en el valor del parámetro NewRecords.'");
	
	Raise ErrorText;
	
EndProcedure

Procedure LockRecordSetArea(RecordSet, FullRegisterName = Undefined)
	
	If NOT TransactionActive() Then
		Return;
	EndIf;
	
	If FullRegisterName = Undefined Then
		FullRegisterName = Metadata.FindByType(TypeOf(RecordSet)).FullName();
	EndIf;
	
	Lock = New DataLock;
	LockItem = Lock.Add(FullRegisterName);
	For each FilterItem In RecordSet.Filter Do
		If FilterItem.Use Then
			LockItem.SetValue(FilterItem.DataPath, FilterItem.Value);
		EndIf;
	EndDo;
	Lock.Lock();
	
EndProcedure

Procedure SetFilter(FilterItem, FilterValue)
	
	FilterItem.Value = FilterValue;
	FilterItem.Use = True;
	
EndProcedure

Function RecordByMultipleSets(Data, Filter, FieldName, FieldValues)
	
	Query = New Query;
	Query.SetParameter("FieldValues", FieldValues);
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&FieldValues)
	|	AND &FilterCriterion
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	CurrentTable.FieldName AS FieldName,
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	CurrentTable.FieldName IN(&FieldValues)
	|	AND &FilterCriterion
	|
	|GROUP BY
	|	CurrentTable.FieldName";
	
	FilterCriterion = "True";
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	FilterOfItemsToAdd = New Structure;
	FilterOfItemsToAdd.Insert("RowChangeKind", 1);
	FilterOfItemsToRemove = New Structure;
	FilterOfItemsToRemove.Insert("RowChangeKind", -1);
	
	For each KeyAndValue In Filter Do
		FilterCriterion = FilterCriterion + "
		|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToAdd.Insert(KeyAndValue.Key, KeyAndValue.Value);
		FilterOfItemsToRemove.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Query.Text = StrReplace(Query.Text, "FieldName", FieldName);
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	QueriesResults = Query.ExecuteBatch();
	
	// Total number of items without filter.
	CountOfAllItems = QueriesResults[0].Unload()[0].Count;
	Data.Insert("CountForReading", CountOfAllItems);
	
	// Number of filtered items to be updated.
	CountOfItemsToUpdate = QueriesResults[1].Unload()[0].Count;
	
	CountOfItemsToAdd = Data.NewRecords.FindRows(FilterOfItemsToAdd).Count();
	If CountOfItemsToAdd > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToAdd;
	EndIf;
	
	CountOfItemsToDelete = Data.NewRecords.FindRows(FilterOfItemsToRemove).Count();
	If CountOfItemsToDelete > CountOfItemsToUpdate Then
		CountOfItemsToUpdate = CountOfItemsToDelete;
	EndIf;
	
	// Number of items to be read by filter values.
	CountByValues = QueriesResults[2].Unload();
	CountByValues.Indexes.Add(FieldName);
	Data.Insert("CountByValues", CountByValues);
	
	Return CountOfAllItems * 0.7 > CountOfItemsToUpdate;
	
EndFunction

Procedure ReadCountForReading(Data)
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	COUNT(*) AS Count
	|FROM
	|	&CurrentTable AS CurrentTable
	|WHERE
	|	&FilterCriterion";
	
	FilterCriterion = "True";
	If Data.FixedFilter <> Undefined Then
		For each KeyAndValue In Data.FixedFilter Do
			FilterCriterion = FilterCriterion + "
			|	AND CurrentTable." + KeyAndValue.Key + " = &" + KeyAndValue.Key;
			Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "&CurrentTable", Data.FullRegisterName);
	Query.Text = StrReplace(Query.Text, "&FilterCriterion", FilterCriterion);
	
	Data.Insert("CountForReading", Query.Execute().Unload()[0].Count);
	
EndProcedure

Procedure SetAdditionalProperties(RecordSet, AdditionalProperties)
	
	If TypeOf(AdditionalProperties) = Type("Structure") Then
		For each KeyAndValue In AdditionalProperties Do
			RecordSet.AdditionalProperties.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	EndIf;
	
EndProcedure

// For the UpdateInformationRegister procedure.

Function TableColumnValues(Table, ColumnName)
	
	NewTable = Table.Copy(, ColumnName);
	
	NewTable.GroupBy(ColumnName);
	
	Return NewTable.UnloadColumn(ColumnName);
	
EndFunction

// Management of AccessKinds and AccessValues tables in edit forms.

Procedure AddAuxiliaryDataAttributesToForm(Form, TablesStorageAttributeName)
	
	AttributesToAdd = New Array;
	AccessValuesTypesDetails = Metadata.DefinedTypes.AccessValue.Type;
	
	PathToObject = ?(ValueIsFilled(TablesStorageAttributeName), TablesStorageAttributeName + ".", "");
	
	// Adding attributes to the AccessKinds table.
	AttributesToAdd.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), PathToObject + "AccessKinds"));
	
	// Adding separate attributes.
	AttributesToAdd.Add(New FormAttribute(
		"CurrentAccessKind", AccessValuesTypesDetails));
	
	AttributesToAdd.Add(New FormAttribute(
		"CurrentTypesOfValuesToSelect", New TypeDescription("ValueList")));
	
	AttributesToAdd.Add(New FormAttribute(
		"CurrentTypeOfValuesToSelect", AccessValuesTypesDetails));
	
	If NOT FormAttributeExists(Form, "UseExternalUsers") Then
		AttributesToAdd.Add(New FormAttribute(
			"UseExternalUsers", New TypeDescription("Boolean")));
	EndIf;
	
	AttributesToAdd.Add(New FormAttribute(
		"TablesStorageAttributeName", New TypeDescription("String")));
	
	AttributesToAdd.Add(New FormAttribute(
		"IsAccessGroupProfile", New TypeDescription("Boolean")));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKindUsers", AccessValuesTypesDetails));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKindExternalUsers", AccessValuesTypesDetails));
	
	// Adding the AllAccessKinds table.
	AttributesToAdd.Add(New FormAttribute(
		"AllAccessKinds", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"Ref", AccessValuesTypesDetails, "AllAccessKinds"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "AllAccessKinds"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Used", New TypeDescription("Boolean"), "AllAccessKinds"));
	
	// Adding the PresentationsAllAllowed table.
	AttributesToAdd.Add(New FormAttribute(
		"PresentationsAllAllowed", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"Name", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	AttributesToAdd.Add(New FormAttribute(
		"Presentation", New TypeDescription("String"), "PresentationsAllAllowed"));
	
	// Adding the AllTypesOfValuesToSelect table.
	AttributesToAdd.Add(New FormAttribute(
		"AllTypesOfValuesToSelect", New TypeDescription("ValueTable")));
	
	AttributesToAdd.Add(New FormAttribute(
		"AccessKind", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"ValuesType", AccessValuesTypesDetails, "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"TypePresentation", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	AttributesToAdd.Add(New FormAttribute(
		"TableName", New TypeDescription("String"), "AllTypesOfValuesToSelect"));
	
	Form.ChangeAttributes(AttributesToAdd);
	
EndProcedure

Procedure FillTableAllAccessKindsInForm(Form)
	
	For each AccessKindProperties In AccessKindProperties() Do
		Row = Form.AllAccessKinds.Add();
		Row.Ref        = AccessKindProperties.Ref;
		Row.Used  = AccessKindUsed(Row.Ref);
		// Making sure the presentations are unique.
		Presentation = AccessKindProperties.Presentation;
		Filter = New Structure("Presentation", Presentation);
		While Form.AllAccessKinds.FindRows(Filter).Count() > 0 Do
			Filter.Presentation = Filter.Presentation + " ";
		EndDo;
		Row.Presentation = Presentation;
	EndDo;
	
EndProcedure

Procedure FillPresentationTableAllAllowedInForm(Form, ThisProfile)
	
	If ThisProfile Then
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDeniedByDefault";
		Row.Presentation = NStr("ru = 'Все запрещены, исключения назначаются в группах доступа'; en = 'All denied, exceptions are set in access groups'; pl = 'Wszystkie zabronione, wyjątki są określane w grupach dostępu';de = 'Alle verboten, Ausnahmen sind in Zugriffsgruppen zugeordnet';ro = 'Toate interzise, excepțiile sunt atribuite în grupurile de acces';tr = 'Hepsi yasak, istisnalar erişim gruplarında atanır'; es_ES = 'Todo prohibido, excepciones están asignadas en los grupos de acceso'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowedByDefault";
		Row.Presentation = NStr("ru = 'Все разрешены, исключения назначаются в группах доступа'; en = 'All allowed, exceptions are set in access groups'; pl = 'Wszystkie dozwolone wyjątki są określane w grupach dostępu';de = 'Alle erlaubt, Ausnahmen sind in Zugriffsgruppen zugeordnet';ro = 'Toate permise, excepțiile sunt atribuite în grupurile de acces';tr = 'Hepsine izin verilmiş,  istisnalar erişim gruplarında atanır'; es_ES = 'Todo permitido, excepciones están asignadas en los grupos de acceso'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDenied";
		Row.Presentation = NStr("ru = 'Все запрещены, исключения назначаются в профиле'; en = 'All denied, exceptions are set in profile'; pl = 'Wszystkie zabronione, wyjątki są określane w profilu';de = 'Alle verboten, Ausnahmen sind in einem Profil zugeordnet';ro = 'Toate interzise, excepțiile sunt atribuite în profil';tr = 'Hepsi yasak, istisnalar profilde atanır'; es_ES = 'Todo prohibido, excepciones están asignadas en un perfil'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowed";
		Row.Presentation = NStr("ru = 'Все разрешены, исключения назначаются в профиле'; en = 'All allowed, exceptions are set in profile'; pl = 'Wszystkie dozwolone wyjątki są określane w profilu';de = 'Alle erlaubt, Ausnahmen sind in einem Profil zugeordnet';ro = 'Toate permise, excepțiile sunt atribuite în profil';tr = 'Hepsine izin verilmiş,  istisnalar profilde atanır'; es_ES = 'Todo permitido, excepciones están asignadas en un perfil'");
	Else
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllDenied";
		Row.Presentation = NStr("ru = 'Все запрещены'; en = 'All denied'; pl = 'Wszystkie zabronione';de = 'Alle verboten';ro = 'Toate interzise';tr = 'Hepsi yasak'; es_ES = 'Todo prohibido'");
		
		Row = Form.PresentationsAllAllowed.Add();
		Row.Name = "AllAllowed";
		Row.Presentation = NStr("ru = 'Все разрешены'; en = 'All allowed'; pl = 'Wszystkie dozwolone';de = 'Alle erlaubt';ro = 'Toate permisiunile';tr = 'Tüm izin verilenler'; es_ES = 'Todo permitido'");
	EndIf;
	
	ChoiceList = Form.Items.AccessKindsAllAllowedPresentation.ChoiceList;
	
	For each Row In Form.PresentationsAllAllowed Do
		ChoiceList.Add(Row.Presentation);
	EndDo;
	
EndProcedure

Procedure ApplyTableAccessKindsInForm(Form)
	
	Parameters = AllowedValuesEditFormParameters(Form);
	
	// Appearance of representation of unused access kinds.
	ConditionalAppearanceItem = Form.ConditionalAppearance.Items.Add();
	
	AppearanceColorItem = ConditionalAppearanceItem.Appearance.Items.Find("TextColor");
	AppearanceColorItem.Value = WebColors.Gray;
	AppearanceColorItem.Use = True;
	
	DataFilterItemsGroup = ConditionalAppearanceItem.Filter.Items.Add(Type("DataCompositionFilterItemGroup"));
	DataFilterItemsGroup.GroupType = DataCompositionFilterItemsGroupType.AndGroup;
	DataFilterItemsGroup.Use = True;
	
	DataFilterItem = DataFilterItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.AccessKind");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.NotEqual;
	DataFilterItem.RightValue = Undefined;
	DataFilterItem.Use  = True;
	
	DataFilterItem = DataFilterItemsGroup.Items.Add(Type("DataCompositionFilterItem"));
	DataFilterItem.LeftValue  = New DataCompositionField(Parameters.PathToTables + "AccessKinds.Used");
	DataFilterItem.ComparisonType   = DataCompositionComparisonType.Equal;
	DataFilterItem.RightValue = False;
	DataFilterItem.Use  = True;
	
	AppearanceFieldItem = ConditionalAppearanceItem.Fields.Items.Add();
	AppearanceFieldItem.Field = New DataCompositionField("AccessKinds");
	AppearanceFieldItem.Use = True;
	
EndProcedure

Procedure DeleteExcessAccessValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	ByGroupsAndValuesTypes = AccessKindsProperties.ByGroupsAndValuesTypes;
	
	Filter = AccessManagementInternalClientServer.FilterInAllowedValuesEditFormTables(
		Form, "");
	
	Index = Parameters.AccessValues.Count()-1;
	While Index >= 0 Do
		AccessValue = Parameters.AccessValues[Index].AccessValue;
		
		AccessKindProperties = ByGroupsAndValuesTypes.Get(TypeOf(AccessValue));
		If AccessKindProperties <> Undefined Then
			FillPropertyValues(Filter, Parameters.AccessValues[Index]);
			Filter.Insert("AccessKind", AccessKindProperties.Ref);
		EndIf;
		
		If AccessKindProperties = Undefined
		 OR Parameters.AccessValues[Index].AccessKind <> Filter.AccessKind
		 OR Parameters.AccessKinds.FindRows(Filter).Count() = 0 Then
			
			Parameters.AccessValues.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
EndProcedure

Procedure DeleteNonExistentAccessKindsAndValues(Form, CurrentObject = Undefined)
	
	Parameters = AllowedValuesEditFormParameters(Form, CurrentObject);
	
	Index = Parameters.AccessKinds.Count()-1;
	While Index >= 0 Do
		AccessKind = Parameters.AccessKinds[Index].AccessKind;
		If AccessKindProperties(AccessKind) = Undefined Then
			Parameters.AccessKinds.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
	DeleteExcessAccessValues(Form, CurrentObject);
	
EndProcedure

Function AllowedValuesEditFormParameters(Form, CurrentObject = Undefined)
	
	Return AccessManagementInternalClientServer.AllowedValuesEditFormParameters(
		Form, CurrentObject);
	
EndFunction

Function FormAttributeExists(Form, AttributeName)
	
	Structure = New Structure(AttributeName, Null);
	
	FillPropertyValues(Structure, Form);
	
	Return Structure[AttributeName] <> Null;
	
EndFunction

// For the SessionParametersSetting procedure .

Function AllAccessKindsCombinations(UnorderedNamesArray)
	
	// Maximum combination length limit to prevent session parameters and RLS template preprocessor from 
	// overloading.
	MaxCombinationLength = 4;
	
	List = New ValueList;
	If TypeOf(UnorderedNamesArray) = Type("FixedArray") Then
		List.LoadValues(New Array(UnorderedNamesArray));
	Else
		List.LoadValues(UnorderedNamesArray);
	EndIf;
	List.SortByValue();
	NamesArray = List.UnloadValues();
	
	RowTotal = New Array;
	TotalRow = New Array;
	
	// Full list is always supported.
	For each Name In NamesArray Do
		TotalRow.Add(Name);
	EndDo;
	
	RowTotal.Add(TotalRow);
	
	If NamesArray.Count() < 3 Then
		Return RowsGroupsInLine(RowTotal);
	EndIf;
	
	FirstName = NamesArray[0];
	NamesArray.Delete(0);
	
	LastName = NamesArray[NamesArray.Count()-1];
	NamesArray.Delete(NamesArray.Count()-1);
	
	CountOfNamesInCombination = NamesArray.Count();
	
	If CountOfNamesInCombination > 1 Then
		
		If (CountOfNamesInCombination-1) <= MaxCombinationLength Then
			CombinationLength = CountOfNamesInCombination-1;
		Else
			CombinationLength = MaxCombinationLength;
		EndIf;
		
		NamesPositionsInCombination = New Array;
		For Counter = 1 To CombinationLength Do
			NamesPositionsInCombination.Add(Counter);
		EndDo;
		
		While CombinationLength > 0 Do
			While True Do
				// Adding a combination from the current items.
				TotalRow = New Array;
				TotalRow.Add(FirstName);
				For Index = 0 To CombinationLength-1 Do
					TotalRow.Add(NamesArray[NamesPositionsInCombination[Index]-1]);
				EndDo;
				TotalRow.Add(LastName);
				RowTotal.Add(TotalRow);
				// Increasing a position in the combination.
				Index = CombinationLength-1;
				While Index >= 0 Do
					If NamesPositionsInCombination[Index] < CountOfNamesInCombination - (CombinationLength - (Index+1)) Then
						NamesPositionsInCombination[Index] = NamesPositionsInCombination[Index] + 1;
						// Filling senior positions with initial values.
						For SeniorPositionIndex = Index+1 To CombinationLength-1 Do
							NamesPositionsInCombination[SeniorPositionIndex] =
								NamesPositionsInCombination[Index] + SeniorPositionIndex - Index;
						EndDo;
						Break;
					Else
						Index = Index - 1;
					EndIf;
				EndDo;
				If Index < 0 Then
					Break;
				EndIf;
			EndDo;
			CombinationLength = CombinationLength - 1;
			For Index = 0 To CombinationLength - 1 Do
				NamesPositionsInCombination[Index] = Index + 1;
			EndDo;
		EndDo;
	EndIf;
	
	TotalRow = New Array;
	TotalRow.Add(FirstName);
	TotalRow.Add(LastName);
	RowTotal.Add(TotalRow);
	
	Return RowsGroupsInLine(RowTotal);
	
EndFunction

Function RowsGroupsInLine(RowsGroups)
	
	RowTotal = New Array;
	
	For Each TotalRow In RowsGroups Do
		RowTotal.Add(StrConcat(TotalRow, ","));
	EndDo;
	
	Rows = StrConcat(
		RowTotal,
		",
		|,");
	
	Template =
		"%2%1%2
		|";
	
	Return StringFunctionsClientServer.SubstituteParametersToString(Template, Rows, ",");
	
EndFunction

// For the UpdateAccessValuesSets, OnChangeAccessValuesSets procedures.

// Checks whether sets in a tabular section differ from the new sets.
Function AccessValuesSetsOfTabularSectionChanged(ObjectRef, NewSets)
	
	OldSets = Common.ObjectAttributeValue(
		ObjectRef, "AccessValuesSets").Unload();
	
	If OldSets.Count() <> NewSets.Count() Then
		Return True;
	EndIf;
	
	OldSets.Columns.Add("AccessKind", New TypeDescription("String"));
	AccessManagement.AddAccessValuesSets(
		OldSets, AccessManagement.AccessValuesSetsTable(), False, True);
	
	SearchFields = "SetNumber, AccessValue, Clarification, Read, Update";
	
	NewSets.Indexes.Add(SearchFields);
	Filter = New Structure(SearchFields);
	
	For each Row In OldSets Do
		FillPropertyValues(Filter, Row);
		If NewSets.FindRows(Filter).Count() <> 1 Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// This method is required by AllowedDynamicListValues.
Procedure AddQueryToPackage(PackageText, QueryText)
	
	Separator =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
	PackageText = PackageText + Separator + QueryText;
	
EndProcedure

// This method is required by AllowedDynamicListValues.
Procedure UnionQueryWithQuery(QueryText, QueryTextToAdd)
	
	Combiner =
	"
	|
	|UNION ALL
	|
	|";
	
	QueryText = QueryText + Combiner + QueryTextToAdd;
	
EndProcedure

// Updating access kind properties.

// For the UpdateAccessKindsPropertiesDetails procedure.
// Returns properties of access kinds filled when embedding in the OnFillAccessKinds procedure of 
// the AccessManagementOverridable common module and other handlers with the same name for this 
// event.
// 
//
Function AccessKindsProperties()
	
	// 1. Filling in the data specified upon implementation.
	
	AccessKinds = New ValueTable;
	AccessKinds.Columns.Add("Name",                    New TypeDescription("String"));
	AccessKinds.Columns.Add("Presentation",          New TypeDescription("String"));
	AccessKinds.Columns.Add("ValuesType",            New TypeDescription("Type"));
	AccessKinds.Columns.Add("ValuesGroupsType",       New TypeDescription("Type"));
	AccessKinds.Columns.Add("MultipleValuesGroups", New TypeDescription("Boolean"));
	AccessKinds.Columns.Add("AdditionalTypes",     New TypeDescription("ValueTable"));
	
	SSLSubsystemsIntegration.OnFillAccessKinds(AccessKinds);
	AccessManagementOverridable.OnFillAccessKinds(AccessKinds);
	
	// Checks:
	// - an access value type is not specified for 2 access kinds
	// - access value type Users, UserGroups is used only for Users access kind.
	// the ExternalUsers, ExternalUserGroups access value type is used only for the
	// ExternalUsers access kind.
	// Names of access kinds Object, Condition, RightsSettings, ReadRight, and UpdateRight are not specified.
	// Value group type does not match the value type.
	
	// 2. Preparing various collections of access kind properties used when running the application.
	PropertiesArray         = New Array;
	ByRefs             = New Map;
	ByNames              = New Map;
	ByValuesTypes       = New Map;
	ByGroupsAndValuesTypes = New Map;
	
	AccessValuesWithGroups = New Structure;
	AccessValuesWithGroups.Insert("ByTypes",                        New Map);
	AccessValuesWithGroups.Insert("ByRefsTypes",                  New Map);
	AccessValuesWithGroups.Insert("NamesOfTablesToUpdate",       New Array);
	AccessValuesWithGroups.Insert("ValueGroupTypesForUpdate", New Map);
	AccessValuesWithGroups.Insert("ByTypesForUpdate",           New Map);
	AccessValuesWithGroups.Insert("ByRefTypesForUpdate",     New Map);
	
	Parameters = New Structure;
	Parameters.Insert("TypesOfAccessValuesToDefine",
		AccessManagementInternalCached.TableFieldTypes("DefinedType.AccessValue"));
	
	ErrorTitle =
		NStr("ru = 'Ошибка в процедуре ПриЗаполненииВидовДоступа общего модуля УправлениеДоступомПереопределяемый.'; en = 'An error occurred in the OnFillAccessKinds procedure of the AccessManagementOverridable common module.'; pl = 'Błąd w procedurze ПриЗаполненииВидовДоступа wspólnego modułu УправлениеДоступомПереопределяемый.';de = 'Fehler in der Vorgehensweise FüllenVonZugriffsarten des allgemeinen Moduls ZugriffsKontrolleÜberschreibbar.';ro = 'Eroare în procedura ПриЗаполненииВидовДоступа a modulului general УправлениеДоступомПереопределяемый.';tr = 'ErişimYönetimi ortak modülünün ErişimTürleriDoldurulduğunda prosedüründe bir hata oluştu.'; es_ES = 'Error en el procedimiento OnFillAccessKinds del módulo común AccessManagementOverridable.'")
		+ Chars.LF
		+ Chars.LF;
	
	Parameters.Insert("ErrorTitle", ErrorTitle);
	
	AllAccessKindsNames = New Map;
	AllAccessKindsNames.Insert(Upper("Object"),         True);
	AllAccessKindsNames.Insert(Upper("Condition"),        True);
	AllAccessKindsNames.Insert(Upper("RightsSettings"),  True);
	AllAccessKindsNames.Insert(Upper("ReadRight"),    True);
	AllAccessKindsNames.Insert(Upper("EditRight"), True);
	
	AllValuesTypes      = New Map;
	AllValuesGroupsTypes = New Map;
	
	For each AccessKind In AccessKinds Do
		
		If AllAccessKindsNames[Upper(AccessKind.Name)] <> Undefined Then
			ErrorText = ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Имя вида доступа ""%1"" уже определено.'; en = 'Access kind name %1 is already defined.'; pl = 'Nazwa typu dostępu ""%1"" została już zdefiniowana.';de = 'Der Name des Zugriffstyps ""%1"" wurde bereits definiert.';ro = 'Numele tipului de acces ""%1"" deja este determinat.';tr = '""%1"" Erişim türü adı zaten tanımlanmıştı.'; es_ES = 'Nombre del tipo de acceso ""%1"" ya se ha definido.'"),
				AccessKind.Name);
			Raise ErrorText;
		EndIf;
		
		// Checking for duplicate value types and group types.
		CheckType(AccessKind, AccessKind.ValuesType,      AllValuesTypes,      Parameters);
		CheckType(AccessKind, AccessKind.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
		// Checking for intersection of value types and group types.
		CheckType(AccessKind, AccessKind.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
		CheckType(AccessKind, AccessKind.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		
		For each Row In AccessKind.AdditionalTypes Do
			// Checking for duplicate value types and group types.
			CheckType(AccessKind, Row.ValuesType,      AllValuesTypes,      Parameters);
			CheckType(AccessKind, Row.ValuesGroupsType, AllValuesGroupsTypes, Parameters, True);
			// Checking for intersection of value types and group types.
			CheckType(AccessKind, Row.ValuesType,      AllValuesGroupsTypes, Parameters,       , True);
			CheckType(AccessKind, Row.ValuesGroupsType, AllValuesTypes,      Parameters, True, True);
		EndDo;
		
		ValueTypeBlankRef = Common.ObjectManagerByFullName(
			Metadata.FindByType(AccessKind.ValuesType).FullName()).EmptyRef();
		
		Properties = New Structure;
		Properties.Insert("Name",                      AccessKind.Name);
		Properties.Insert("Ref",                   ValueTypeBlankRef);
		Properties.Insert("Presentation",            AccessKind.Presentation);
		Properties.Insert("ValuesType",              AccessKind.ValuesType);
		Properties.Insert("ValuesGroupsType",         AccessKind.ValuesGroupsType);
		Properties.Insert("MultipleValuesGroups",   AccessKind.MultipleValuesGroups);
		Properties.Insert("AdditionalTypes",       New Array);
		Properties.Insert("TypesOfValuesToSelect",   New Array);
		
		PropertiesArray.Add(Properties);
		ByNames.Insert(Properties.Name, Properties);
		ByRefs.Insert(ValueTypeBlankRef, Properties);
		ByValuesTypes.Insert(Properties.ValuesType, Properties);
		ByGroupsAndValuesTypes.Insert(Properties.ValuesType, Properties);
		If Properties.ValuesGroupsType <> Type("Undefined") Then
			ByGroupsAndValuesTypes.Insert(Properties.ValuesGroupsType, Properties);
		EndIf;
		FillAccessValuesWithGroups(Properties, AccessValuesWithGroups, Properties, Parameters);
		
		For each Row In AccessKind.AdditionalTypes Do
			Item = New Structure;
			Item.Insert("ValuesType",            Row.ValuesType);
			Item.Insert("ValuesGroupsType",       Row.ValuesGroupsType);
			Item.Insert("MultipleValuesGroups", Row.MultipleValuesGroups);
			Properties.AdditionalTypes.Add(Item);
			ByValuesTypes.Insert(Row.ValuesType, Properties);
			ByGroupsAndValuesTypes.Insert(Row.ValuesType, Properties);
			If Row.ValuesGroupsType <> Type("Undefined") Then
				ByGroupsAndValuesTypes.Insert(Row.ValuesGroupsType, Properties);
			EndIf;
			FillAccessValuesWithGroups(Row, AccessValuesWithGroups, Properties, Parameters);
		EndDo;
		
	EndDo;
	
	NoGroupsForAccessValue      = New Array;
	WithOneGroupForAccessValue = New Array;
	AccessValuesTypesWithGroups    = New Map;
	
	AccessKindsWithGroups = New Map;
	
	For each KeyAndValue In AccessValuesWithGroups.ByRefsTypes Do
		AccessKindName = KeyAndValue.Value.Name;
		AccessKindsWithGroups.Insert(AccessKindName, True);
		
		EmptyRef = MetadataObjectEmptyRef(KeyAndValue.Key);
		AccessValuesTypesWithGroups.Insert(TypeOf(EmptyRef), EmptyRef);
		
		If NOT KeyAndValue.Value.MultipleValuesGroups
		   AND WithOneGroupForAccessValue.Find(AccessKindName) = Undefined Then
		   
			WithOneGroupForAccessValue.Add(AccessKindName);
		EndIf;
	EndDo;
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.Users"),
		Catalogs.Users.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.UserGroups"),
		Catalogs.UserGroups.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsers"),
		Catalogs.ExternalUsers.EmptyRef());
	
	AccessValuesTypesWithGroups.Insert(Type("CatalogRef.ExternalUsersGroups"),
		Catalogs.ExternalUsersGroups.EmptyRef());
	
	For each AccessKindProperties In PropertiesArray Do
		If AccessKindsWithGroups.Get(AccessKindProperties.Name) <> Undefined Then
			Continue;
		EndIf;
		If AccessKindProperties.Name = "Users"
		 OR AccessKindProperties.Name = "ExternalUsers" Then
			Continue;
		EndIf;
		NoGroupsForAccessValue.Add(AccessKindProperties.Name);
	EndDo;
	
	AccessKindsProperties = New Structure;
	AccessKindsProperties.Insert("Array",                          PropertiesArray);
	AccessKindsProperties.Insert("ByNames",                        ByNames);
	AccessKindsProperties.Insert("ByRefs",                       ByRefs);
	AccessKindsProperties.Insert("ByValuesTypes",                 ByValuesTypes);
	AccessKindsProperties.Insert("ByGroupsAndValuesTypes",           ByGroupsAndValuesTypes);
	AccessKindsProperties.Insert("AccessValuesWithGroups",        AccessValuesWithGroups);
	AccessKindsProperties.Insert("NoGroupsForAccessValue",      NoGroupsForAccessValue);
	AccessKindsProperties.Insert("WithOneGroupForAccessValue", WithOneGroupForAccessValue);
	AccessKindsProperties.Insert("AccessValuesTypesWithGroups",    AccessValuesTypesWithGroups);
	AccessKindsProperties.Insert("AccessValuesSetsOwner",
		DataStringForHashing(Metadata.DefinedTypes.AccessValuesSetsOwnerObject.Type));
	
	// Checking application version update compatibility.
	If Parameters.TypesOfAccessValuesToDefine.Get(
		TypeOf(ChartsOfCharacteristicTypes.DeleteAccessKinds.EmptyRef())) = Undefined Then
	
		ErrorDescription =
			NStr("ru = 'Тип ПланВидовХарактеристикСсылка.УдалитьВидыДоступа,
			           |необходимый для перехода на новые версии программы
			           |не указан в определяемом типе ""Значение доступа"".'; 
			           |en = 'The ChartOfCharacteristicTypesRef.DeleteAccessKinds type
			           |required to migrate to new application versions
			           |is not specified in the defined ""Access value"" type.'; 
			           |pl = 'Typ ПланВидовХарактеристикСсылка.УдалитьВидыДоступа,
			           |niezbędny do przejścia na nową wersję programu
			           |nie określony w określonym typie ""Wartość dostępu"".';
			           |de = 'Typ PlanDerAnsichtenMerkmalsReferenz.LöschenVonZugriffsarten,
			           |die für die Umstellung auf neue Versionen des Programms erforderlich sind,
			           |werden im definierten Typ ""Zugriffswert"" nicht angegeben.';
			           |ro = 'Tipul ПланВидовХарактеристикСсылка.УдалитьВидыДоступа,
			           |necesar pentru trecere la versiunile noi ale programului
			           |nu este indicat în tipul determinat ""Valoarea de acces"".';
			           |tr = '
			           | Uygulamanın yeni sürümüne geçmek için gereken 
			           |ÖzellikTürlerininPlanıReferans. ErişimTürleriniSil türü ""Erişim değeri"" belirlenmiş türde belirtilmedi.'; 
			           |es_ES = 'El tipo ChartOfCharacteristicTypesRef.DeleteAccessKinds
			           |necesario para pasar a nuevas versiones del programa
			           |no se ha indicado en el tipo determinado ""Valor de acceso"".'");
		
		ErrorText = Parameters.ErrorTitle + ErrorDescription;
		Raise ErrorText;
	EndIf;
	
	CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups);
	
	Return Common.FixedData(AccessKindsProperties);
	
EndFunction

// For the AccessKindsProperties function.
Procedure FillAccessValuesWithGroups(Row, AccessValuesWithGroups, Properties, Parameters)
	
	If Properties.Name = "Users" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.Users"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.UserGroups"));
		Return;
	EndIf;
	
	If Properties.Name = "ExternalUsers" Then
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsers"));
		AddToArray(Properties.TypesOfValuesToSelect, Type("CatalogRef.ExternalUsersGroups"));
		Return;
	EndIf;
	
	RefType = Row.ValuesType;
	
	ValuesTypeMetadata = Metadata.FindByType(Row.ValuesType);
	If Common.IsEnum(ValuesTypeMetadata) Then
		ObjectType = RefType;
	Else
		ObjectType = StandardSubsystemsServer.MetadataObjectOrMetadataObjectRecordSetType(
			ValuesTypeMetadata);
	EndIf;
	
	If Row.ValuesGroupsType = Type("Undefined") Then
		AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
			ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, Undefined);
		AddToArray(Properties.TypesOfValuesToSelect, Row.ValuesType);
		Return;
	EndIf;
	
	If Row.ValuesGroupsType <> Type("Undefined") Then
		AddToArray(Properties.TypesOfValuesToSelect, Row.ValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.ByTypes.Insert(RefType,  Properties);
	AccessValuesWithGroups.ByTypes.Insert(ObjectType, Properties);
	AccessValuesWithGroups.ByRefsTypes.Insert(RefType, Properties);
	
	MetadataOfValuesGroupsType = Metadata.FindByType(Row.ValuesGroupsType);
	
	AddSubscriptionTypesUpdateAccessValuesGroups(RefType,
		ObjectType, ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType);
	
EndProcedure

// For the AccessKindsProperties function and the FillAccessValuesWithGroups procedure.
Procedure AddSubscriptionTypesUpdateAccessValuesGroups(RefType, ObjectType,
			ValuesTypeMetadata, AccessValuesWithGroups, Properties, MetadataOfValuesGroupsType)
	
	ValueTypeBlankRef = PredefinedValue(ValuesTypeMetadata.FullName() + ".EmptyRef");
	
	If MetadataOfValuesGroupsType = Undefined Then
		BlankValuesGroupsTypeRef = ValueTypeBlankRef;
	Else
		BlankValuesGroupsTypeRef = MetadataObjectEmptyRef(MetadataOfValuesGroupsType);
	EndIf;
	
	AccessValuesWithGroups.NamesOfTablesToUpdate.Add(ValuesTypeMetadata.FullName());
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(RefType,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ValueGroupTypesForUpdate.Insert(ValueTypeBlankRef,
		BlankValuesGroupsTypeRef);
	
	AccessValuesWithGroups.ByRefTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(RefType, Properties);
	AccessValuesWithGroups.ByTypesForUpdate.Insert(ObjectType, Properties);
	
EndProcedure

// For the AccessKindsProperties function.
Procedure CheckSubscriptionTypesUpdateAccessValuesGroups(AccessValuesWithGroups)
	
	CurrentSubscriptionTypes = AccessManagementInternalCached.TableFieldTypes(
		"DefinedType.AccessValueObject");
	
	RequiredSubscriptionTypes = New Map;
	For Each KeyAndValue In AccessValuesWithGroups.ByTypesForUpdate Do
		If AccessValuesWithGroups.ByRefTypesForUpdate.Get(KeyAndValue.Key) <> Undefined Then
			Continue;
		EndIf;
		RequiredSubscriptionTypes.Insert(KeyAndValue.Key, True);
	EndDo;
	
	MissingTypes = New Array;
	ExcessiveTypes = New Array;
	
	For Each KeyAndValue In CurrentSubscriptionTypes Do
		If RequiredSubscriptionTypes.Get(KeyAndValue.Key) = Undefined Then
			ExcessiveTypes.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
	For Each KeyAndValue In RequiredSubscriptionTypes Do
		If CurrentSubscriptionTypes.Get(KeyAndValue.Key) = Undefined Then
			MissingTypes.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
	If MissingTypes.Count() = 0 AND ExcessiveTypes.Count() = 0 Then
		Return;
	EndIf;
	
	If MissingTypes.Count() = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект"" указаны лишние типы:
			           |- %1'; 
			           |en = 'According to the data received from the OnFillAccessKinds procedure
			           |of the AccessManagementOverridable common module,
			           |the following excess types are specified in the ""Access value object"" type to be defined:
			           |- %1'; 
			           |pl = 'Zgodnie danych, uzyskanych z procedury ПриЗаполненииВидовДоступа
			           |wspólnego modułu УправлениеДоступомПереопределяемый,
			           |w oznaczonym typie ""Wartość dostępu do obiektu"" wskazywane są typy nadmiarowe:
			           |- %1';
			           |de = 'Entsprechend den Daten, die aus der Prozedur BeimAusfüllenVonZugriffstypen
			           |des allgemeinen Moduls ZugriffskontrolleNeuDefinierbar
			           |erhalten wurden, werden in dem definierten Typ ""Objektzugriffswert"" die überschüssigen Typen angegeben:
			           |-%1';
			           |ro = 'Conform datelor obținute din procedura ПриЗаполненииВидовДоступа
			           |a modulului general УправлениеДоступомПереопределяемый,
			           |în tipul determinat ""Valoarea de acces obiect"" sunt indicate tipurile excesive:
			           |- %1';
			           |tr = 'Genel erişim kontrol modülüne erişim türlerinde doldurma prosedüründen elde edilen verilere göre, belirtilen “değer erişim nesnesi” tipinde geçersiz kılınabilir, aşırı türler gösterilir: -
			           |
			           |
			           |%1'; 
			           |es_ES = 'Por datos recibidos del procedimiento ПриЗаполненииВидовДоступа
			           |del módulo común УправлениеДоступомПереопределяемый,
			           |en el tipo determinado ""Valor de acceso objeto"" se han indicado tipos de sobra:
			           |- %1'"),
			StrConcat(ExcessiveTypes, "," + Chars.LF + "- "));
	ElsIf ExcessiveTypes.Count() = 0 Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект"" не указаны требуемые типы:
			           |- %1'; 
			           |en = 'According to the data received from the OnFillAccessKinds procedure
			           |of the AccessManagementOverridable common module,
			           |in the ""Access value object"" type be defined, required types are not specified:
			           |- %1'; 
			           |pl = 'Zgodnie danych, uzyskanych z procedury ПриЗаполненииВидовДоступа
			           |wspólnego modułu УправлениеДоступомПереопределяемый,
			           |w oznaczonym typie ""Wartość dostępu do obiektu"" nie wskazane są typy wymagane:
			           |- %1';
			           |de = 'Entsprechend den Daten, die aus der Prozedur BeimAusfüllenVonZugriffstypen
			           |des allgemeinen Moduls ZugriffskontrolleNeuDefinierbar
			           |erhalten wurden, werden in dem definierten Typ ""Objektzugriffswert"" die erforderlichen Typen nicht angegeben:
			           |- %1';
			           |ro = 'Conform datelor obținute din procedura ПриЗаполненииВидовДоступа
			           |a modulului general УправлениеДоступомПереопределяемый,
			           |în tipul determinat ""Valoarea de acces obiect"" nu sunt indicate tipurile necesare:
			           |- %1';
			           |tr = 'Genel erişim kontrol modülüne erişim türlerinde doldurma prosedüründen elde edilen verilere göre, geçersiz kılınabilir, istenen türler belirtilen nesne Erişim Değeri nesnesinde belirtilmez: -
			           |
			           |
			           |%1'; 
			           |es_ES = 'Por datos recibidos del procedimiento ПриЗаполненииВидовДоступа
			           |del módulo común УправлениеДоступомПереопределяемый,
			           |en el tipo determinado ""Valor de acceso objeto"" no se han indicado tipos requeridos:
			           |- %1'"),
			StrConcat(MissingTypes, "," + Chars.LF + "- "));
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'По данным, полученным из процедуры ПриЗаполненииВидовДоступа
			           |общего модуля УправлениеДоступомПереопределяемый,
			           |в определяемом типе ""Значение доступа объект""
			           |а) указаны лишние типы:
			           |- %1
			           |б) не указаны требуемые типы:
			           |- %2'; 
			           |en = 'According to the data received from the OnFillingAccessKinds procedure
			           |of the AccessManagementOverridable common module,
			           |in the ""Access value object"" type to be defined:
			           |a) Excess types are specified:
			           |- %1
			           |b) Required types are not specified:
			           |- %2'; 
			           |pl = 'Zgodnie danych, uzyskanych z procedury ПриЗаполненииВидовДоступа
			           |wspólnego modułu УправлениеДоступомПереопределяемый,
			           |w oznaczonym typie ""Wartość dostępu do obiektu"" 
			           |a) wskazywane są typy nadmiarowe:
			           |- %1
			           |b) nie wskazane są typy wymagane:
			           |- %2';
			           |de = 'Entsprechend den Daten, die aus der Prozedur BeimAusfüllenVonZugriffstypen
			           |des allgemeinen Moduls ZugriffskontrolleNeuDefinierbar
			           |erhalten wurden, werden in dem definierten Typ ""Objektzugriffswert""
			           |a) unnötige Typen werden angegeben:
			           |- %1
			           |b) erforderliche Typen werden nicht angegeben:
			           |- %2 ';
			           |ro = 'Conform datelor obținute din procedura ПриЗаполненииВидовДоступа
			           |a modulului general УправлениеДоступомПереопределяемый,
			           |în tipul determinat ""Valoarea de acces obiect""
			           |a) sunt indicate tipurile excesive:
			           |- %1
			           |b) nu sunt indicate tipurile necesare:
			           |- %2';
			           |tr = 'Genel erişim kontrol modülüne erişim tiplerinde doldurma prosedüründen elde edilen verilere göre, belirtilen “erişim değeri nesnesi” tipinde geçersiz kılınabilir a) fazla tipler belirtilir: - b) istenen tipler belirtilmez: -
			           |
			           |
			           |
			           |%1
			           |
			           |%2'; 
			           |es_ES = 'Por datos recibidos del procedimiento ПриЗаполненииВидовДоступа
			           |del módulo común УправлениеДоступомПереопределяемый,
			           |en el tipo determinado ""Valor de acceso objeto"" 
			           |a) se han indicado tipos de sobra:
			           |- %1
			           |b) no se han indicado tipos requeridos:
			           |- %2'"),
			StrConcat(ExcessiveTypes, "," + Chars.LF + "- "),
			StrConcat(MissingTypes, "," + Chars.LF + "- "));
	EndIf;
	
	Raise ErrorText;
	
EndProcedure

// For the AccessKindsProperties function.
Procedure CheckType(AccessKind, Type, AllTypes, Parameters, CheckGroupsTypes = False, IntersectionCheck = False)
	
	If Type = Type("Undefined") Then
		If CheckGroupsTypes Then
			Return;
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Для вида доступа ""%1"" не указан тип значений доступа.'; en = 'Access value type is not specified for the ""%1"" access kind.'; pl = 'Typ wartości dostępu ""%1"" nie jest określony dla typu dostępu.';de = 'Der Zugriffswerttyp ist für die Zugriffsart ""%1"" nicht angegeben.';ro = 'Tipul de valoare de acces nu este specificat pentru tipul de acces ""%1"".';tr = '""%1"" Erişim türü için  erişim değer türü belirtilmemiş.'; es_ES = 'Tipo de valores de acceso no está especificado para el tipo de acceso ""%1"".'"),
			AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking whether a reference type is specified.
	If NOT Common.IsReference(Type) Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'; 
				           |en = 'Type ""%1"" is specified as a value group type for access kind ""%2"".
				           |It is not a reference type.'; 
				           |pl = 'Typ ""%1"" jest określony jako typ grup wartości dla typu dostępu ""%2"".
				           |Jednak nie jest to typ linku.';
				           |de = 'Typ ""%1"" wird als Wertgruppentyp für die Zugriffsart ""%2"" angegeben. 
				           |Aber es ist kein Referenztyp.';
				           |ro = 'Tipul ""%1"" este indicat ca tipul grupurilor de valori pentru tipul de acces ""%2"".
				           |Însă acesta nu este tip de referință.';
				           |tr = '""%1"" türü, ""%2"" türünde erişim türü için değer grubu türü olarak belirtilir.
				           | Ancak referans tipi değil.'; 
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Однако это не тип ссылки.'; 
				           |en = 'Type ""%1"" is specified as a value type for access kind ""%2"".
				           |It is not a reference type.'; 
				           |pl = 'Typ ""%1"" jest określony jako typ wartości dla typu dostępu ""%2"".
				           |Jednak nie jest to typ linku.';
				           |de = 'Typ ""%1"" wird als Werttyp für die Zugriffsart ""%2"" angegeben. 
				           |Aber es ist kein Referenztyp.';
				           |ro = 'Tipul ""%1"" este indicat ca tip al valorilor pentru tipul de acces ""%2"".
				           |Însă acesta nu este tip de referință.';
				           |tr = '""%1"" türü, ""%2"" erişim türü için değer türü olarak belirlendi.  
				           |Ancak bu referans türü değil.'; 
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Pero no es el tipo de referencia.'");
		EndIf;
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
	// Checking for duplication and intersection of value types and value groups.
	ForSameAccessKindNoError = False;
	
	If CheckGroupsTypes Then
		If IntersectionCheck Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип групп значений.'; 
				           |en = 'Type ""%1"" is specified as a value type for access kind ""%2"".
				           |It cannot be specified as a value group type for access kind ""%3"".'; 
				           |pl = 'Typ ""%1"" jest określony, jako typ wartości dla typu dostępu ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić, jako typu grupy wartości.';
				           |de = 'Der Typ ""%1"" wird als Werttyp für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht als Wertgruppentyp angegeben werden.';
				           |ro = 'Tipul ""%1"" este indicat ca tip al valorilor pentru tipul de acces ""%2"".
				           |Dar nu-l puteți indica în calitate de tip al grupurilor de acces pentru tipul de acces ""%3"".';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" değerler grup tipi olarak belirtilemez.'; 
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"", no puede especificarse como el tipo de grupos de valores.'");
		Else
			ForSameAccessKindNoError = True;
			ErrorDescription =
				NStr("ru = 'Тип групп значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'; 
				           |en = 'Value group type ""%1"" is already specified for access kind ""%2"".
				           |It cannot be specified for access kind ""%3"".'; 
				           |pl = 'Dla typu dostępu ""%1"" określono typ grupy wartości ""%2"".
				           |Nie można określić rodzaju dostępu ""%3"".';
				           |de = 'Für die Zugriffsart ""%2"" ist der Wertegruppentyp ""%1"" angegeben. 
				           |Für die Zugriffsart ""%3"" kann sie nicht angegeben werden.';
				           |ro = 'Tipul grupurilor de acces ""%1"" deja este indicat pentru tipul de acces ""%2"".
				           |Dar nu-l puteți indica pentru tipul de acces ""%3"".';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" belirtilemez.'; 
				           |es_ES = 'Tipo de grupos de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.'");
		EndIf;
	Else
		If IntersectionCheck Then
			ErrorDescription =
				NStr("ru = 'Тип ""%1"" указан, как тип групп значений, для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать, как тип значений.'; 
				           |en = 'Type ""%1"" is specified as a value group type for access kind ""%2"".
				           |It cannot be specified as a value type for access kind ""%3"".'; 
				           |pl = 'Typ ""%1"" jest określony, jako typ grup wartości dla typu dostępu ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić, jako typu grup grupy wartości.';
				           |de = 'Der Typ ""%1"" wird als Wertgruppentyp für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht als Werttyp angegeben werden.';
				           |ro = 'Tipul ""%1"" este indicat ca tip al grupurilor de valori pentru tipul de acces ""%2"".
				           |Dar nu-l puteți indica în calitate de tip de valori pentru tipul de acces ""%3"".';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3"" değer tipi olarak belirtilemez.'; 
				           |es_ES = 'El tipo ""%1"" está especificado como el tipo de grupos de valores para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse como el tipo de valores.'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип значений ""%1"" уже указан для вида доступа ""%2"".
				           |Для вида доступа ""%3"" его нельзя указать.'; 
				           |en = 'Value type ""%1"" is already specified for access kind ""%2"".
				           |It cannot be specified for access kind ""%3"".'; 
				           |pl = 'Dla typu dostępu ""%1"" określony jest typ ""%2"".
				           |Dla rodzaju dostępu ""%3"" nie można go określić.';
				           |de = 'Der Werttyp ""%1"" wird für die Zugriffsart ""%2"" angegeben.
				           |Für die Zugriffsart ""%3"" kann er nicht angegeben werden.';
				           |ro = 'Tipul de valori ""%1"" deja este indicat pentru tipul de acces ""%2"".
				           |Dar nu-l puteți indica pentru tipul de acces ""%3"".';
				           |tr = '""%2"" türü, "
" erişim türü için değer türü olarak belirlendi. %1 Erişim türü için ""%3""  belirtilemez.'; 
				           |es_ES = 'El tipo de valores ""%1"" está especificado para el tipo de acceso ""%2"".
				           |Para el tipo de acceso ""%3"" no puede especificarse.'");
		EndIf;
	EndIf;
	
	If AllTypes.Get(Type) <> Undefined Then
		If NOT (ForSameAccessKindNoError AND AccessKind.Name = AllTypes.Get(Type)) Then
			ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
				ErrorDescription, Type, AllTypes.Get(Type), AccessKind.Name);
			Raise ErrorText;
		EndIf;
	ElsIf NOT IntersectionCheck Then
		AllTypes.Insert(Type, AccessKind.Name);
	EndIf;
	
	// Checking content of defined types.
	ErrorDescription = "";
	If Parameters.TypesOfAccessValuesToDefine.Get(Type) = Undefined Then
		If CheckGroupsTypes Then
			ErrorDescription =
				NStr("ru = 'Тип групп значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'; 
				           |en = 'Type of access value groups ""%1"" of access kind ""%2""
				           |is not specified in defined type ""Access value"".'; 
				           |pl = 'Typ grup wartości dostępu""%1""rodzaje dostępu""%2""
				           |nie znajduje się w określonym typie ""Wartość dostępu"".';
				           |de = 'Die Art der Zugriffswertgruppen ""%1"" vom Zugriffstyp ""%2""
				           | ist im definierten Typ ""Zugriffswert"" nicht angegeben.';
				           |ro = 'Tipul grupurilor valorilor de acces ""%1"" al tipului de acces ""%2""
				           |nu este indicat în tipul determinat ""Valoarea de acces"".';
				           |tr = '""Erişim değeri"" tanımlanmış türünde ""%1"" erişim türü "
" erişim değer grupları türü%2 belirtilmemiş.'; 
				           |es_ES = 'Tipo de grupos de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".'");
		Else
			ErrorDescription =
				NStr("ru = 'Тип значений доступа ""%1"" вида доступа ""%2""
				           |не указан в определяемом типе ""Значение доступа"".'; 
				           |en = 'Access value type ""%1"" of access kind ""%2""
				           |is not specified in defined type ""Access value"".'; 
				           |pl = 'Typ wartości dostępu ""%1"" rodzaje dostępu ""%2""
				           |nie znajduje się w określonym typie ""Wartość dostępu"".';
				           |de = 'Die Art der Zugriffswerte ""%1"" von Zugriffstyp ""%2""
				           |ist im definierten Typ ""Zugriffswert"" nicht angegeben.';
				           |ro = 'Tipul grupurilor de acces ""%1"" al tipului de acces ""%2""
				           |nu este indicat în tipul determinat ""Valoarea de acces"".';
				           |tr = '""Erişim değeri"" tanımlanmış türünde ""%1"" erişim türü "
" erişim değeri %2 türü belirtilmemiş.'; 
				           |es_ES = 'Tipo de valores de acceso ""%1"" del tipo de acceso ""%2""
				           |no se ha indicado en el tipo determinado ""Valor de acceso"".'");
		EndIf;
	EndIf;
	
	If ValueIsFilled(ErrorDescription) Then
		ErrorText = Parameters.ErrorTitle + StringFunctionsClientServer.SubstituteParametersToString(
			ErrorDescription, Type, AccessKind.Name);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the FillAccessValuesWithGroups procedure.
Procedure AddToArray(Array, Value)
	
	If Array.Find(Value) = Undefined Then
		Array.Add(Value);
	EndIf;
	
EndProcedure

// For the UpdateAccessKindsPropertiesDetails procedure.
Function HasChangesOfGroupsTypesAndAccessValues(AccessKindsProperties, SavedParameters)
	
	If NOT TypeOf(SavedParameters) = Type("FixedStructure")
	 OR NOT SavedParameters.Property("ByValuesTypes")
	 OR NOT SavedParameters.Property("AccessValuesTypesWithGroups")
	 OR NOT SavedParameters.Property("AccessValuesWithGroups")
	 OR NOT SavedParameters.Property("AccessValuesSetsOwner")
	 OR NOT TypeOf(SavedParameters.ByValuesTypes)                = Type("FixedMap")
	 OR NOT TypeOf(SavedParameters.AccessValuesTypesWithGroups)   = Type("FixedMap")
	 OR NOT TypeOf(SavedParameters.AccessValuesWithGroups)       = Type("FixedStructure")
	 OR NOT TypeOf(SavedParameters.AccessValuesSetsOwner) = Type("String")
	 OR NOT SavedParameters.AccessValuesWithGroups.Property("NamesOfTablesToUpdate")
	 OR NOT TypeOf(SavedParameters.AccessValuesWithGroups.NamesOfTablesToUpdate) = Type("FixedArray")
	 OR NOT AccessKindsProperties.Property("ByValuesTypes")
	 OR NOT AccessKindsProperties.Property("AccessValuesTypesWithGroups")
	 OR NOT AccessKindsProperties.Property("AccessValuesWithGroups")
	 OR NOT AccessKindsProperties.Property("AccessValuesSetsOwner")
	 OR NOT TypeOf(AccessKindsProperties.ByValuesTypes)                = Type("FixedMap")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesTypesWithGroups)   = Type("FixedMap")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesWithGroups)       = Type("FixedStructure")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesSetsOwner) = Type("String")
	 OR NOT AccessKindsProperties.AccessValuesWithGroups.Property("NamesOfTablesToUpdate")
	 OR NOT TypeOf(AccessKindsProperties.AccessValuesWithGroups.NamesOfTablesToUpdate) = Type("FixedArray") Then
		
		Return True;
	EndIf;
	
	If MapKeysDiffer(AccessKindsProperties.ByValuesTypes, SavedParameters.ByValuesTypes) Then
		Return True;
	EndIf;
	
	If MapKeysDiffer(AccessKindsProperties.AccessValuesTypesWithGroups,
			SavedParameters.AccessValuesTypesWithGroups) Then
		Return True;
	EndIf;
	
	If Not Common.DataMatch(AccessKindsProperties.AccessValuesWithGroups.NamesOfTablesToUpdate,
				SavedParameters.AccessValuesWithGroups.NamesOfTablesToUpdate) Then
		Return True;
	EndIf;
	
	If AccessKindsProperties.AccessValuesSetsOwner
			<> SavedParameters.AccessValuesSetsOwner Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the HasChangesOfGroupsTypesAndAccessValues function.
Function MapKeysDiffer(NewValue, Old)
	
	If NewValue.Count() <> Old.Count() Then
		Return True;
	EndIf;
	
	For each KeyAndValue In NewValue Do
		If Old.Get(KeyAndValue.Key) = Undefined Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

#Region UniversalRestriction

////////////////////////////////////////////////////////////////////////////////
// Event subscription handlers.

// The CheckAccessBeforeWrite* subscription handler checks access to the old object version, and 
// checks object field changes of the additional tables attached in access restrictions of the list.
// If changes are found, need to update access keys for the lists, which have additional tables 
// attached in access restrictions, is registered.
//
// Parameters:
//  Source        - ConstantManager,
//                    CatalogObject,
//                    DocumentObject,
//                    ChartOfCharacteristicTypesObject,
//                    ChartOfAccountsObject,
//                    ChartOfCalculationTypesObject,
//                    BusinessProcessObject,
//                    TaskObject,
//                    ExchangePlanObject - a data object passed to the BeforeWrite event subscription.
//
//  Cancel - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteMode     - DocumentWriteMode - a parameter passed to the BeforeWrite event subscription 
//                    when the Source parameter is DocumentObject.
//
//  PostingMode - DocumentPostingMode - a parameter passed to the BeforeWrite event subscription 
//                    when Source is DocumentObject.
//
Procedure CheckAccessBeforeWrite(Source, Cancel, WriteMode = Undefined, PostingMode = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessBeforeWriteRecordSet* subscription handler checks access to the old record set 
// version, and checks changes of record set fields of the additional tables attached in access restrictions of the lists.
// If changes are found, need to update access keys for the lists, which have additional tables 
// attached in access restrictions, is registered.
//
// Parameters:
//  Source - InformationRegisterRecordSet,
//                    AccumulationRegisterRecordSet,
//                    AccountingRegisterRecordSet,
//                    CalculationRegisterRecordSet,
//                    RecalculationRecordSet - a record set passed to the BeforeWrite event 
//                                             subscription.
//
//  Cancel - Boolean - a parameter passed to the BeforeWrite event subscription.
//  Overwrite       - Boolean - a parameter passed to the BeforeWrite event subscription.
//
//  WriteOnly - Boolean - a parameter passed to the BeforeWrite event subscription when the Source 
//                    is CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the BeforeWrite event subscription 
//                    when Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the BeforeWrite event subscription when 
//                    Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessBeforeWriteRecordsSet(Source, Cancel, Overwrite,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeWriteSource(Source, Cancel, True, Overwrite);
	
EndProcedure

// The CheckAccessOnWrite* subscription handler checks whether an access key of the new object 
// version is up-to-date. Updates an obsolete access key and checks the Read and Update rights of 
// the new object version.
//
// Parameters:
//  Source        - ConstantManager,
//                    CatalogObject,
//                    DocumentObject,
//                    ChartOfCharacteristicTypesObject,
//                    ChartOfAccountsObject,
//                    ChartOfCalculationTypesObject,
//                    BusinessProcessObject,
//                    TaskObject,
//                    ExchangePlanObject - a data object passed to the OnWrite event subscription.
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//
Procedure CheckAccessOnWrite(Source, Cancel) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, False, False);
	
EndProcedure

// The CheckAccessOnWriteRecordSet* subscription handler checks whether access keys of the new 
// record set version are up-to-date. Updates obsolete access keys and checks the Read and Update 
// rights of the new record set version.
//
// Parameters:
//  Source - InformationRegisterRecordSet,
//                    AccumulationRegisterRecordSet,
//                    AccountingRegisterRecordSet,
//                    CalculationRegisterRecordSet,
//                    RecalculationRecordSet - a record set passed to the OnWrite event subscription.
//                                             
//
//  Cancel           - Boolean - a parameter passed to the OnWrite event subscription.
//  Overwrite       - Boolean - the parameter passed to the OnWrite event subscription.
//
//  WriteOnly - Boolean - a parameter passed to the OnWrite event subscription when the Source is 
//                    CalculationRegisterRecordSet.
//
//  WriteActualActionPeriod - Boolean - a parameter passed to the OnWrite event subscription when 
//                    the Source is CalculationRegisterRecordSet.
//
//  WriteRecalculations - Boolean - a parameter passed to the OnWrite event subscription when the 
//                    Source is CalculationRegisterRecordSet.
//
Procedure CheckAccessOnWriteRecordsSet(Source, Cancel, Overwrite,
				WriteOnly = Undefined,
				WriteActualActionPeriod = Undefined,
				WriteRecalculations = Undefined) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessOnWriteSource(Source, Cancel, True, Overwrite);
	
EndProcedure

// The CheckAccessBeforeDelete* subscription handler checks changes to object fields of additional 
// tables that were attached in list access restrictions.
// If changes are found, need to update access keys for the lists, which have additional tables 
// attached in access restrictions, is registered.
//
// Parameters:
//  Source - CatalogObject,
//             DocumentObject,
//             ChartOfCharacteristicTypesObject,
//             ChartOfAccountsObject,
//             ChartOfCalculationTypesObject,
//             BusinessProcessObject,
//             TaskObject,
//             ExchangePlanObject - a data object passed to the BeforeDelete event subscription.
//
//  Cancel    - Boolean - a parameter passed to the BeforeDelete event subscription.
//
Procedure CheckAccessBeforeDelete(Source, Cancel) Export
	
	// DataExchange.Import is processed inside the procedure in a non-standard way (considering rights check).
	CheckAccessBeforeDeleteSource(Source, Cancel);
	
EndProcedure

////////////////////////////////////////////////////////////////////////////////
// Universal access restriction.

Function AccessAllowed(DataDetails, Update, RaiseException = False) Export
	
	If Users.IsFullUser() Then
		Return True;
	EndIf;
	
	MetadataObject = Metadata.FindByType(TypeOf(DataDetails));
	If MetadataObject = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимое значение параметра %1 в %2.
			           |Ожидалась ссылка или ключ записи.
			           |Передано значение: %3 (тип %4).'; 
			           |en = 'Invalid value of the %1 parameter in %2. 
			           |Reference or key was expected.
			           |Value passed: %3 (type %4).'; 
			           |pl = 'Niepoprawna wartość parametru  %1 w %2.
			           |Wymagany link lub klucz zapisu.
			           |Przekazana wartość: %3 (typ %4).';
			           |de = 'Ungültiger Parameterwert %1 in %2.
			           |Es wurde ein Link oder Datensatz-Schlüssel erwartet.
			           |Übertragener Wert: %3 (Typ%4).';
			           |ro = 'Valoare inadmisibilă a parametrului %1 în %2.
			           |Se aștepta referința sau cheia de înregistrare.
			           |A fost transmisă valoarea: %3 (tipul %4).';
			           |tr = '%1Parametrenin %2''deki değeri kabul edilemez. 
			           | Kayıt referansı veya anahtarı bekleniyordu. 
			           | Atanan değer: %3 (tür %4).'; 
			           |es_ES = 'Valor incorrecto del parámetro %1 en %2.
			           |Se esperaba un enlace o una clave de registro.
			           |Valor pasado: %3 (tipo %4).'"),
			"DataDetails",
			?(Update, "AccessManagement.EditionAllowed",
				"AccessManagement.ReadingAllowed"),
			String(DataDetails),
			String(TypeOf(DataDetails)));
		Raise ErrorText;
	EndIf;
	
	AccessRightName = ?(Update, "Update", "Read");
	
	If RaiseException Then
		VerifyAccessRights(AccessRightName, MetadataObject);
		
	ElsIf Not AccessRight(AccessRightName, MetadataObject) Then
		Return False;
	EndIf;
	
	FullName = MetadataObject.FullName();
	
	If Not LimitAccessAtRecordLevelUniversally(, True) Then
		Return ReadAllowed(FullName, MetadataObject, DataDetails, RaiseException);
	EndIf;
	
	TransactionID = New UUID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID);
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAllowedSetsInSessionParameters();
	
	If RestrictionParameters.RestrictionDisabled Then
		Return True;
	EndIf;
	
	If RestrictionParameters.AccessDenied Then
		AccessAllowed = False;
	Else
		Query = New Query;
		SetAllowedSetsInQueryParameters(Query);
		
		Query.Text = ?(Update, RestrictionParameters.ReadEditRightsCheckQueryText,
			RestrictionParameters.ReadRightsCheckQueryText);
		
		If RestrictionParameters.IsReferenceType Then
			ObjectRef = ?(Common.IsReference(TypeOf(DataDetails)),
				DataDetails, DataDetails.Ref);
			
			Query.SetParameter("Object", ObjectRef);
			
			If RestrictionParameters.OwnerField <> Undefined Then
				Query.SetParameter("RightSettingsTableID",
					RestrictionParameters.RightSettingsTableID);
			EndIf;
			
			AccessAllowed = Not Query.Execute().IsEmpty();
			DataToPresent = ObjectRef;
		Else
			RecordSet = Common.ObjectManagerByFullName(FullName).CreateRecordSet();
			
			If TypeOf(DataDetails) = TypeOf(RecordSet) Then
				Return True;
			EndIf;
			
			For Each FilterItem In RecordSet.Filter Do
				FilterItem.Value = DataDetails[FilterItem.Name];
				FilterItem.Use = True;
			EndDo;
			FilterByDimensions = FilterByRecordSetDimensions(RecordSet, Query);
			QueryText =
			"SELECT TOP 1
			|	TRUE AS TrueValue
			|FROM
			|	&CurrentTable AS CurrentTable
			|WHERE
			|	&FilterByDimensions";
			QueryText = StrReplace(QueryText, "&CurrentTable", FullName);
			Query.Text = Query.Text + Common.QueryBatchSeparator() + QueryText;
			Query.Text = StrReplace(Query.Text, "&FilterByDimensions", FilterByDimensions);
			
			QueryResults = Query.ExecuteBatch();
			AccessAllowed = QueryResults[0].IsEmpty() AND Not QueryResults[1].IsEmpty();
			DataToPresent = RecordSet;
		EndIf;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	If AccessAllowed Or Not RaiseException Then
		Return AccessAllowed;
	EndIf;
	
	If Update Then
		RightToRead = AccessAllowed(DataDetails, False);
	Else
		RightToRead = False;
	EndIf;
	
	ReportAccessError(DataToPresent, True, RightToRead, False, False);
	
EndFunction

// For the AccessGranted function.
Function ReadAllowed(FullName, MetadataObject, DataDetails, RaiseException)
	
	Query = New Query;
	
	If IsReferenceTableType(FullName) Then
		ObjectRef = ?(Common.IsReference(TypeOf(DataDetails)),
			DataDetails, DataDetails.Ref);
		
		Query.SetParameter("Ref", ObjectRef);
		QueryText =
		"SELECT ALLOWED TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	CurrentTable.Ref = &Ref";
		DataToPresent = ObjectRef;
	Else
		RecordSet = Common.ObjectManagerByFullName(FullName).CreateRecordSet();
		
		If TypeOf(DataDetails) = TypeOf(RecordSet) Then
			Return True;
		EndIf;
		
		For Each FilterItem In RecordSet.Filter Do
			FilterItem.Value = DataDetails[FilterItem.Name];
			FilterItem.Use = True;
		EndDo;
		FilterByDimensions = FilterByRecordSetDimensions(RecordSet, Query);
		QueryText =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	&CurrentTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		QueryText = StrReplace(QueryText, "&FilterByDimensions", FilterByDimensions);
		DataToPresent = RecordSet;
	EndIf;
	
	Query.Text = StrReplace(QueryText, "&CurrentTable", FullName);
	
	If Not Query.Execute().IsEmpty() Then
		Return True;
	EndIf;
	
	If Not RaiseException Then
		Return False;
	EndIf;
	
	ReportAccessError(DataToPresent, False, False, False, False);
	
EndFunction

// It is required as an initial maximum date when scheduling an initial access update.
Function MaxDate() Export
	
	Return '39991231235959';
	
EndFunction

// It is required as an initial maximum date when scheduling access update continuation.
Function MaxDateOnContinue()
	
	Return '39990101000000';
	
EndFunction

// For the ImplementationSettings function.
Function XMLFullName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	Return Properties.LanguageEnglish + "." + NameContent[1];
	
EndFunction

// For the AddTypesRequiredInDefinedType procedure.
Function RefTypeName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Not Properties.IsReferenceType Then
		Return "";
	EndIf;
	
	If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
		TypeName = Properties.LanguageRussian + "Ref." + NameContent[1];
	Else
		TypeName = Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function XMLRefTypeName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Ref." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the AddTypesRequiredInDefinedType function.
Function ObjectTypeOrRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	TypeName = "";
	
	If Properties.IsReferenceType Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "Object." + NameContent[1];
		Else
			TypeName = Properties.LanguageEnglish + "Object." + NameContent[1];
		EndIf;
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		If Upper(Properties.LanguageRussian) = Upper(NameContent[0]) Then
			TypeName = Properties.LanguageRussian + "RecordSet." + NameContent[1];
		Else
			TypeName = Properties.LanguageEnglish + "RecordSet." + NameContent[1];
		EndIf;
	EndIf;
	
	Return TypeName;
	
EndFunction

// For the ImplementationSettings function.
Function ObjectTypeOrXMLRecordSetName(FullName, TablesTypesByNames)
	
	NameContent = StrSplit(FullName, ".", False);
	Properties = TablesTypesByNames.Get(Upper(NameContent[0]));
	
	If Properties.IsReferenceType Then
		Return Properties.LanguageEnglish + "Object." + NameContent[1];
	EndIf;
	
	If StrStartsWith(Properties.CollectionName, "Registers") Then
		Return Properties.LanguageEnglish + "RecordSet." + NameContent[1];
	EndIf;
	
	Return "";
	
EndFunction

// For the ImplementationSettings function.
Procedure AddObjectToOwners(XMLObjectTypeName, AccessKeysValuesOwners)
	
	If StrStartsWith(XMLObjectTypeName, "DocumentObject.") Then
		AccessKeysValuesOwners.Documents.Add(XMLObjectTypeName);
		
	ElsIf StrStartsWith(XMLObjectTypeName, "CalculationRegisterRecordSet.") Then
		AccessKeysValuesOwners.CalculationRegisterRecordSets.Add(XMLObjectTypeName);
		
	ElsIf StrFind(XMLObjectTypeName, "RecordSet.") > 0 Then
		AccessKeysValuesOwners.RecordSets.Add(XMLObjectTypeName);
		
	ElsIf StrFind(XMLObjectTypeName, "Object.") > 0 Then
		AccessKeysValuesOwners.Objects.Add(XMLObjectTypeName);
	EndIf;
	
EndProcedure

// For the ImplementationSettings function.
Procedure AddRestrictionsInRoles(XMLFullName, FullName, RestrictionsInRoles,
			RestrictionsProperties, KeysRegistersDimensionsTypes, TablesTypesByNames, PredefinedIDs)
	
	Properties = RestrictionsProperties.Get(FullName);
	If Properties <> Undefined AND Properties.AccessDenied Then
		Return;
	EndIf;
	
	RestrictionInRole = New Structure("TemplateForObject, Parameters", True, New Array);
	RestrictionsInRoles.Insert(XMLFullName, RestrictionInRole);
	
	If Properties = Undefined Then
		Return;
	EndIf;
	
	If Properties.OwnerField <> Undefined Then
		RestrictionInRole.Parameters.Add(Properties.OwnerField.Name);
		Return;
	EndIf;
	
	If Properties.BasicFields = Undefined
	 Or Not ValueIsFilled(Properties.BasicFields) Then
		Return;
	EndIf;
	
	RestrictionInRole.TemplateForObject = False;
	
	If ValueIsFilled(Properties.SeparateKeysRegisterName) Then
		FirstParameter = Properties.SeparateKeysRegisterName;
		
		AddDimensionTypes(Properties.SeparateKeysRegisterName,
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
	Else
		FirstParameter =
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(FullName);
		
		AddDimensionTypes("AccessKeysForRegisters",
			Properties.BasicFields, KeysRegistersDimensionsTypes, TablesTypesByNames, FullName);
		
		PredefinedIDs.Insert(FirstParameter, FullName);
	EndIf;
	
	RestrictionInRole.Parameters.Add(FirstParameter);
	
	For Each BasicField In Properties.BasicFields.All Do
		RestrictionInRole.Parameters.Add(BasicField);
	EndDo;
	
EndProcedure

// For the AddRestrictionsInRoles procedure.
Procedure AddDimensionTypes(KeysRegisterName, BasicFields, KeysRegistersDimensionsTypes,
			TablesTypesByNames, SourceRegisterName)
	
	If BasicFields.All.Count() = 0 Then
		Return;
	EndIf;
	
	DimensionsTypes = KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName);
	
	TypesNames           = DimensionsTypes.TypesNames;
	RegistersFieldsByTypes = DimensionsTypes.RegistersFieldsByTypes;
	
	RegisterFields = New Array;
	DimensionsTypes.RegistersFields.Insert(SourceRegisterName, RegisterFields);
	
	For Each FieldName In BasicFields.All Do
		FieldTypesStorage = BasicFields.AllItemsTypes[BasicFields.All.Find(FieldName)];
		FieldTypes = FieldTypesStorage.Get();
		RegisterFields.Add(New Structure("Field, Type", FieldName, FieldTypes));
		For Each Type In FieldTypes.Types() Do
			MetadataObject = Metadata.FindByType(Type);
			If MetadataObject = Undefined Then
				TypeName = XMLType(Type).TypeName;
			Else
				TypeName = XMLRefTypeName(Metadata.FindByType(Type).FullName(), TablesTypesByNames);
			EndIf;
			If TypesNames.Find(TypeName) = Undefined Then
				TypesNames.Add(TypeName);
			EndIf;
			RegistersFieldsByType = RegistersFieldsByTypes.Get(TypeName);
			If RegistersFieldsByType = Undefined Then
				RegistersFieldsByType = New Array;
				RegistersFieldsByTypes.Insert(TypeName, RegistersFieldsByType);
			EndIf;
			FullFieldName = SourceRegisterName + "." + FieldName;
			If RegistersFieldsByType.Find(FullFieldName) = Undefined Then
				RegistersFieldsByType.Add(FullFieldName);
			EndIf;
		EndDo;
	EndDo;
	
	// For backward compatibility of the SSLImplementationCheck.epf report.
	If KeysRegisterName <> "AccessKeysForRegisters" Then
		Return;
	EndIf;
	
	XMLRegisterName = "InformationRegister." + KeysRegisterName;
	TypesNames = KeysRegistersDimensionsTypes.Get(XMLRegisterName);
	
	If TypesNames = Undefined Then
		KeysRegistersDimensionsTypes.Insert(XMLRegisterName, DimensionsTypes.TypesNames);
	EndIf;
	
EndProcedure

// For the DeploymentSettings function and AddDimensionTypes procedure.
Function KeysRegisterDimensionsTypes(KeysRegistersDimensionsTypes, KeysRegisterName)
	
	DimensionsTypes = KeysRegistersDimensionsTypes.Get(KeysRegisterName);
	If DimensionsTypes = Undefined Then
		DimensionsTypes = New Structure;
		DimensionsTypes.Insert("TypesNames", New Array);
		DimensionsTypes.Insert("RegistersFields", New Map);
		DimensionsTypes.Insert("RegistersFieldsByTypes", New Map);
		KeysRegistersDimensionsTypes.Insert(KeysRegisterName, DimensionsTypes);
		DimensionsTypes.TypesNames.Add("EnumRef.AdditionalAccessValues");
	EndIf;
	
	Return DimensionsTypes;
	
EndFunction

#Region CheckAccessOnChange

// For the BeforeWrite event subscription handlers.
Procedure CheckAccessBeforeWriteSource(Source, Cancel, IsRecordSet, Overwrite)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	If Not IsRecordSet AND Source.IsNew() AND Common.FileInfobase() Then
		Lock = New DataLock;
		Lock.Add("InformationRegister.AccessKeysForObjects");
		Lock.Lock();
	EndIf;
	
	IsFullUser = Users.IsFullUser()
		Or Not LimitAccessAtRecordLevelUniversally(, True);
	
	Source.AdditionalProperties.Insert("AccessManagementTransactionID",
		New UUID);
	
	HasOldVersion =  IsRecordSet AND Overwrite
	             Or Not IsRecordSet AND Not Source.IsNew();
	
	If HasOldVersion Then
		RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Overwrite);
		CheckAccessToSource(Source, True, IsRecordSet, Overwrite, IsFullUser);
		
	ElsIf Not IsRecordSet Then
		SetAllowedAccessKeyForNewObject(Source, IsFullUser);
	EndIf;
	
	If IsRecordSet Then
		WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser);
	EndIf;
	
EndProcedure

// For the OnWrite event subscription handlers.
Procedure CheckAccessOnWriteSource(Source, Cancel, IsRecordSet, Overwrite)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	IsFullUser = Users.IsFullUser()
		Or Not LimitAccessAtRecordLevelUniversally(, True);
	
	// Checking access to a new version.
	CheckAccessToSource(Source, False, IsRecordSet, Overwrite, IsFullUser);
	
	ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet, False);
	
EndProcedure

// For the BeforeDelete event subscription handlers.
Procedure CheckAccessBeforeDeleteSource(Source, Cancel)
	
	If SkipAccessCheck(Cancel, Source) Then
		Return;
	EndIf;
	
	Source.AdditionalProperties.Insert("AccessManagementTransactionID",
		New UUID);
	
	RememberDataAffectingDependentAccessKeys(Source, False, False);
	ScheduleUpdateOfDependentObsoleteAccessKeys(Source, False, True);
	
EndProcedure


// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Function SkipAccessCheck(Cancel, Source)
	
	If AccessManagementInternalCached.SeparatedDataUnavailable() Then
		Return True;
	EndIf;
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return True;
	EndIf;
	
	DisableUpdate = SessionParameters.DIsableAccessKeysUpdate;
	If DisableUpdate.Full Then
		Return True;
	EndIf;
	
	If DisableUpdate.Standard Then
		Cache = AccessManagementInternalCached.ChangedListsCacheOnDisabledAccessKeysUpdate();
		SourceType = TypeOf(Source);
		If Cache.Get(SourceType) <> Undefined Then
			Return True;
		EndIf;
		DisableUpdate = New Structure(DisableUpdate);
		EditedLists = DisableUpdate.EditedLists.Get();
		EditedLists.Insert(SourceType, True);
		DisableUpdate.EditedLists = New ValueStorage(EditedLists);
		
		SetSafeModeDisabled(True);
		SetPrivilegedMode(True);
		SessionParameters.DIsableAccessKeysUpdate = New FixedStructure(DisableUpdate);
		SetPrivilegedMode(True);
		SetSafeModeDisabled(True);
		
		Cache.Insert(SourceType, True);
		Return True;
	EndIf;
	
	If StandardSubsystemsServer.IsMetadataObjectID(Source) Then
		Return True;
	EndIf;
	
	If Cancel Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure RememberDataAffectingDependentAccessKeys(Source, IsRecordSet, Overwrite)
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined Then
		
		Source.AdditionalProperties.Insert(
			"FieldValueAccessManagementForChangeCheckOnWrite");
		Return;
	EndIf;
	
	Query = New Query;
	
	If IsRecordSet Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query);
		Query.Text = StrReplace(ListPropertiesAsLeadingOne.ByFieldsValues.QueryText,
			"&FilterByDimensions", FilterByDimensions);
	Else
		Query.Text = ListPropertiesAsLeadingOne.ByFieldsValues.QueryText;
		Query.SetParameter("ObjectRef", Source.Ref);
	EndIf;
	
	Source.AdditionalProperties.Insert(
		"FieldValueAccessManagementForChangeCheckOnWrite",
		Query.ExecuteBatch());
	
EndProcedure

// For the RememberDataAffectingDependentAccessKeys and CheckAccessToRecordSet procedures.
Function FilterByRecordSetDimensions(RecordSet, Query, NewCombinationsQuery = Undefined)
	
	FilterByDimensions = "";
	
	For Each FilterItem In RecordSet.Filter Do
		If Not FilterItem.Use Then
			Continue;
		EndIf;
		FilterByDimensions = FilterByDimensions + ?(FilterByDimensions = "", "", "
		|	AND ") + "CurrentTable." + FilterItem.Name + " = &FieldValue" + FilterItem.Name;
		
		Query.SetParameter("FieldValue" + FilterItem.Name, FilterItem.Value);
		If NewCombinationsQuery <> Undefined Then
			NewCombinationsQuery.SetParameter("FieldValue" + FilterItem.Name, FilterItem.Value);
		EndIf;
	EndDo;
	
	If FilterByDimensions = "" Then
		FilterByDimensions = "TRUE";
	EndIf;
	
	Return FilterByDimensions;
	
EndFunction

// For the CheckAccessBeforeWriteSource procedure.
Procedure SetAllowedAccessKeyForNewObject(Source, IsFullUser)
	
	If IsFullUser Then
		Return;
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	NewRef = UsersInternal.ObjectRef(Source);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	
	RecordSet = InformationRegisters.AccessKeysForObjects.CreateRecordSet();
	RecordSet.Filter.Object.Set(NewRef);
	
	Record = RecordSet.Add();
	Record.Object = NewRef;
	Record.UsersAccessKey        = AllowedAccessKey;
	Record.ExternalUsersAccessKey = AllowedAccessKey;
	
	RecordSet.Write();
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource and CheckAccessOnWriteSource procedures.
Procedure CheckAccessToSource(Source, BeforeWrite, IsRecordSet, Overwrite, IsFullUser)
	
	If BeforeWrite AND IsFullUser Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	RestrictionParameters = RectrictionParametersOnAccessCheck(Source, FullName, TransactionID);
	
	If RestrictionParameters.RestrictionDisabled Then
		If Not BeforeWrite AND RestrictionParameters.WriteAlwaysAllowedAccessKey Then
			SetSafeModeDisabled(True);
			SetPrivilegedMode(True);
			
			UpdateAccessKeysOfDataItemsOnWrite(Source.Ref,
				RestrictionParameters, TransactionID,,, Source);
			
			SetPrivilegedMode(False);
			SetSafeModeDisabled(False);
		EndIf;
		Return;
	EndIf;
	
	If RestrictionParameters.AccessDenied Then
		If IsFullUser Then
			Return;
		ElsIf RestrictionParameters.ForExternalUsers Then
			ErrorTemplate =
				NStr("ru = 'Внешним пользователям запрещен доступ к данным списка
				           |""%1"".'; 
				           |en = 'External users cannot access data of the
				           |""%1"" list.'; 
				           |pl = 'Zewnętrznym użytkownikom dostępu do danych listy
				           |""%1"".';
				           |de = 'Externe Benutzer dürfen nicht auf die Listendaten
				           |""%1"" zugreifen.';
				           |ro = 'Utilizatorii externi nu au acces la datele listei
				           |""%1"".';
				           |tr = 'Harici kullanıcıların 
				           |""%1"" listenin verilerine erişimleri yasaktır.'; 
				           |es_ES = 'A los usuarios externos les está prohibido el acceso a los datos de la lista
				           |""%1"".'");
		Else
			ErrorTemplate =
				NStr("ru = 'Пользователям запрещен доступ к данным списка
				           |""%1"".'; 
				           |en = 'Users cannot access data of the
				           |""%1"" list.'; 
				           |pl = 'Użytkownikom nie wolno uzyskać dostępu do danych listy
				           |""%1"".';
				           |de = 'Benutzer dürfen nicht auf die Listendaten
				           |""%1"" zugreifen.';
				           |ro = 'Utilizatorii nu au acces la datele listei
				           |""%1"".';
				           |tr = 'Kullanıcıların 
				           |""%1"" listenin verilerine erişimleri yasaktır.'; 
				           |es_ES = 'A los usuarios les está prohibido el acceso a los datos de la lista
				           |""%1"".'");
		EndIf;
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			Source.Metadata().Presentation());
		Raise ErrorText;
	EndIf;
	
	If IsRecordSet Then
		CheckAccessToRecordSet(Source,
			BeforeWrite, Overwrite, RestrictionParameters, IsFullUser);
	Else
		CheckAccessToObject(Source,
			BeforeWrite, RestrictionParameters, IsFullUser);
	EndIf;
	
EndProcedure

// For the CheckAccessToSource procedure.
Function RectrictionParametersOnAccessCheck(Source, FullName, TransactionID)
	
	Return RestrictionParameters(FullName, TransactionID);
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToObject(Source, BeforeWrite, RestrictionParameters, IsFullUser)
	
	IsNew = Not Source.AdditionalProperties.Property(
		"FieldValueAccessManagementForChangeCheckOnWrite");
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not BeforeWrite Then
		If Not IsNew AND Not SourceAccessKeyObsolete(Source.Ref, RestrictionParameters, Source) Then
			Return;
		EndIf;
		UpdateAccessKeysOfDataItemsOnWrite(Source.Ref, RestrictionParameters,
			Source.AdditionalProperties.AccessManagementTransactionID,,, Source);
	EndIf;
	
	If IsFullUser Then
		Return;
	EndIf;
	
	Query = New Query;
	AdditionCheck = Not BeforeWrite AND RestrictionParameters.OwnerField = Undefined;
	
	If AdditionCheck Then
		Query.Text = StrReplace(RestrictionParameters.ReadEditRightsCheckQueryText,
			"AllowedAccessKeys.Update", "AllowedAccessKeys.Insert");
	Else
		Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
	EndIf;
	
	UpdateAllowedSetsInSessionParameters();
	
	Query.SetParameter("Object", Source.Ref);
	SetAllowedSetsInQueryParameters(Query);
	
	If RestrictionParameters.OwnerField <> Undefined Then
		Query.SetParameter("RightSettingsTableID",
			RestrictionParameters.RightSettingsTableID);
	EndIf;
	
	If Not AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access allowed.
	EndIf;
	
	If AdditionCheck Then
		Query.Text = RestrictionParameters.ReadEditRightsCheckQueryText;
		EditRight = Not Query.Execute().IsEmpty();
	Else
		EditRight = False;
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight = True;
	Else
		Query.Text = RestrictionParameters.ReadRightsCheckQueryText;
		ReadRight = Not Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Data = ?(BeforeWrite, Source.Ref, Source);
	ReportAccessError(Data, BeforeWrite, ReadRight, EditRight, IsNew);
	
EndProcedure

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Function AccessCheckQueryResult(Query, Source)
	
	Return Query.Execute();
	
EndFunction

// For the CheckAccessToSource procedure.
Procedure CheckAccessToRecordSet(Source, BeforeWrite, Overwrite, RestrictionParameters, IsFullUser)
	
	If    BeforeWrite AND (Not Overwrite Or IsFullUser)
	 Or Not BeforeWrite AND Source.Count() = 0
	 Or IsFullUser
	   AND RestrictionParameters.UsesRestrictionByOwner Then
		
		Return;
	EndIf;
	
	Query = New Query;
	If Not BeforeWrite Then
		NewCombinationsQuery = New Query;
	EndIf;
	
	If Overwrite Then
		FilterByDimensions = FilterByRecordSetDimensions(Source, Query, NewCombinationsQuery);
	Else
		FilterByDimensions = "";
		BasicFieldsValuesCombinations = BasicFieldsValuesCombinations(Source,
			FilterByDimensions, RestrictionParameters);
		
		Query.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
		NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations", BasicFieldsValuesCombinations);
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not BeforeWrite
	   AND Not RestrictionParameters.UsesRestrictionByOwner Then
		
		UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters);
	EndIf;
	
	If IsFullUser Then
		Return;
	EndIf;
	
	Query.Text = StrReplace(RestrictionParameters.ReadEditRightsCheckQueryText,
		"&FilterByDimensions", FilterByDimensions);
	
	UpdateAllowedSetsInSessionParameters();
	SetAllowedSetsInQueryParameters(Query);
	
	If AccessCheckQueryResult(Query, Source).IsEmpty() Then
		Return; // Access allowed.
	EndIf;
	
	If RestrictionParameters.RightToWriteRestrictionDisabled Then
		ReadRight = True;
	Else
		Query.Text = StrReplace(RestrictionParameters.ReadRightsCheckQueryText,
			"&FilterByDimensions", FilterByDimensions);
		ReadRight = Query.Execute().IsEmpty();
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	ReportAccessError(Source, BeforeWrite, ReadRight, False, False);
	
EndProcedure

// For the CheckAccessBeforeWriteSource procedure.
Procedure WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite(Source, IsFullUser)
	
	If IsFullUser Or Source.Count() = 0 Then
		Return;
	EndIf;
	
	FullName = Source.Metadata().FullName();
	TransactionID = Source.AdditionalProperties.AccessManagementTransactionID;
	RestrictionParameters = RestrictionParameters(FullName, TransactionID);
	
	If RestrictionParameters.RestrictionDisabled
	 Or RestrictionParameters.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	NewCombinationsQuery = New Query;
	FilterByDimensions = "";
	
	NewCombinationsQuery.SetParameter("BasicFieldsValuesCombinations",
		BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters));
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Function BasicFieldsValuesCombinations(Source, FilterByDimensions, RestrictionParameters)
	
	Fields = StrConcat(RestrictionParameters.BasicFields.Used, ",");
	BasicFieldsValuesCombinations = Source.Unload(, Fields);
	BasicFieldsValuesCombinations.GroupBy(Fields);
	
	FilterFields = "";
	For Each Field In RestrictionParameters.BasicFields.Used Do
		FilterFields = FilterFields + ?(FilterFields = "", "", ", ") + "CurrentTable." + Field;
	EndDo;
	FilterByDimensions = "(" + FilterFields + ") IN (&BasicFieldsValuesCombinations)";
	
	Return BasicFieldsValuesCombinations;
	
EndFunction

// For the CheckAccessToRecordSet and
// WriteAccessKeysOfNewBasicFieldsCombinationsValuesBeforeWrite procedures.
//
Procedure UpdateAccessKeysOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	DataItems = DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
		FilterByDimensions, Source, RestrictionParameters);
	
	If DataItems.Count() = 0 Then
		Return;
	EndIf;
	
	UpdateAccessKeysOfDataItemsOnWrite(DataItems, RestrictionParameters,
		Source.AdditionalProperties.AccessManagementTransactionID,,, Source);
	
EndProcedure

// For the UpdateAccessKeysOfNewBasicFieldsCombinationsValues procedure.
Function DataItemsOfNewBasicFieldsCombinationsValues(NewCombinationsQuery,
			FilterByDimensions, Source, RestrictionParameters)
	
	NewCombinationsQuery.Text =
		StrReplace(RestrictionParameters.NewCombinationsOfBasicFieldsValuesQueryText,
			"&FilterByDimensions", FilterByDimensions);
	
	NewCombinationsQueryResult = NewCombinationsQuery.Execute();
	If NewCombinationsQueryResult.IsEmpty() Then
		Return New Array;
	EndIf;
	
	DataItems = NewCombinationsQueryResult.Unload();
	DataItems.Columns.Add("CurrentRef", New TypeDescription("Number"));
	Index = 0;
	For Each DataItem In DataItems Do
		DataItem.CurrentRef = Index;
		Index = Index + 1;
	EndDo;
	
	Return DataItems;
	
EndFunction

// For the CheckAccessToObject and the CheckAccessToRecordSet procedures.
Procedure ReportAccessError(Data, BeforeWrite, ReadRight, EditRight, IsNew)
	
	If BeforeWrite Then
		If ReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для изменения существующей версии:
				           |%1'; 
				           |en = 'Insufficient rights to change the current version: 
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień, aby zmienić istniejącą wersję:
				           |%1';
				           |de = 'Nicht genügend Rechte, um die bestehende Version zu ändern:
				           |%1';
				           |ro = 'Drepturi insuficiente pentru modificarea versiunii existente:
				           |%1';
				           |tr = 'Mevcut sürümün değişmesi için haklar yetersizdir: 
				           |%1'; 
				           |es_ES = 'Insuficientes derechos para cambiar la versión actual:
				           |%1'"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для чтения существующей версии:
				           |%1'; 
				           |en = 'Insufficient rights to read the current version: 
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do odczytu istniejącej wersji:
				           |%1';
				           |de = 'Nicht genügend Rechte, um die bestehende Version zu lesen:
				           |%1';
				           |ro = 'Drepturi insuficiente pentru citirea versiunii existente:
				           |%1';
				           |tr = 'Mevcut sürümün okunması için haklar yetersizdir: 
				           |%1'; 
				           |es_ES = 'Insuficientes derechos para leer la versión actual:
				           |%1'"), DataPresentation(Data));
		EndIf;
	Else
		If ReadRight AND EditRight Then
			If IsNew Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недостаточно прав для записи новой версии (нет права добавления):
					           |%1'; 
					           |en = 'Insufficient rights to record a new version (no Insert right):
					           |%1'; 
					           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie ma prawa dodawania):
					           |%1';
					           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (keine Rechte zum hinzufügen):
					           |%1';
					           |ro = 'Drepturi insuficiente pentru înregistrarea versiunii noi (lipsește dreptul de adăugare):
					           |%1';
					           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (ilave etme hakkı yok): 
					           |%1'; 
					           |es_ES = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir):
					           |%1'"), DataPresentation(Data));
			Else
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недостаточно прав для записи новой версии (нет права добавления для сделанных изменений):
					           |%1'; 
					           |en = 'Insufficient rights to record a new version (no Insert right for the changes):
					           |%1'; 
					           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie ma prawa dodawania do dokonanych zmian):
					           |%1';
					           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (keine Rechte, Änderungen hinzuzufügen):
					           |%1';
					           |ro = 'Drepturi insuficiente pentru înregistrarea versiunii noi (lipsește dreptul de adăugare pentru modificările făcute):
					           |%1';
					           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (yapılan değişiklikleri ilave etme hakkı yok): 
					           |%1'; 
					           |es_ES = 'Insuficientes derechos para guardar la versión actual (no hay derechos de añadir para los cambios realizados):
					           |%1'"), DataPresentation(Data));
			EndIf;
		ElsIf ReadRight Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для записи новой версии (ее невозможно будет изменить):
				           |%1'; 
				           |en = 'Insufficient rights to record a new version (you will not be able to change it):
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie można jej zmienić):
				           |%1';
				           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (sie kann nicht geändert werden):
				           |%1';
				           |ro = 'Drepturi insuficiente pentru înregistrarea versiunii noi (aceasta nu va putea fi modificată):
				           |%1';
				           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (bu sürüm değiştirilemez): 
				           |%1'; 
				           |es_ES = 'Insuficientes derechos para guardar la versión actual (no se podrá cambiarla):
				           |%1'"), DataPresentation(Data));
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Недостаточно прав для записи новой версии (ее невозможно будет прочитать):
				           |%1.'; 
				           |en = 'Insufficient rights to record a new version (you will not be able to read it):
				           |%1'; 
				           |pl = 'Brak wystarczających uprawnień do zapisu nowej wersji (nie można jej przeczytać):
				           |%1.';
				           |de = 'Nicht genügend Rechte, um eine neue Version zu schreiben (sie wird nicht lesbar sein):
				           |%1.';
				           |ro = 'Drepturi insuficiente pentru înregistrarea versiunii noi (aceasta nu va putea fi citită):
				           |%1.';
				           |tr = 'Yeni sürümün kaydı için haklar yetersizdir (bu sürüm okunamaz): 
				           |%1'; 
				           |es_ES = 'Insuficientes derechos para guardar la versión actual (no se podrá leerla):
				           |%1.'"), DataPresentation(Data));
		EndIf;
	EndIf;
	
	Raise ErrorText;
	
EndProcedure

// For the ReportAccessError procedure.
Function DataPresentation(Data)
	
	If TypeOf(Data) = Type("String") Then
		Return TrimAll(Data);
	EndIf;
	
	If TypeOf(Data) = Type("Structure") Then
		IsRegister = True;
		If TypeOf(Data.Register) = Type("String") Then
			MetadataObject = Metadata.FindByFullName(Data.Register);
		Else
			MetadataObject = Metadata.FindByType(TypeOf(Data.Register));
		EndIf;
	Else
		MetadataObject = Metadata.FindByType(TypeOf(Data));
		IsRegister = Common.IsRegister(MetadataObject);
	EndIf;
	
	If MetadataObject = Undefined Then
		Return "";
	EndIf;
	
	If IsRegister Then
		DataPresentation = MetadataObject.Presentation();
		
		FieldsCount = 0;
		For each FilterItem In Data.Filter Do
			If FilterItem.Use Then
				FieldsCount = FieldsCount + 1;
			EndIf;
		EndDo;
		
		If FieldsCount = 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("ru = 'с полем'; en = 'with field'; pl = 'z polem';de = 'mit Feld';ro = 'cu câmp';tr = 'alan ile'; es_ES = 'con el campo'")  + " " + String(Data.Filter);
			
		ElsIf FieldsCount > 1 Then
			DataPresentation = DataPresentation
				+ " " + NStr("ru = 'с полями'; en = 'with fields'; pl = 'z polami';de = 'mit Feldern';ro = 'cu câmpuri';tr = 'alanlar ile'; es_ES = 'con los campos'") + " " + String(Data.Filter);
		EndIf;
	Else
		DataPresentation = String(Data);
		
		Properties = New Structure("ExtendedObjectPresentation, ObjectPresentation");
		FillPropertyValues(Properties, MetadataObject);
		
		MetadataPresentation = Properties.ExtendedObjectPresentation;
		If Not ValueIsFilled(MetadataPresentation) Then
			MetadataPresentation = Properties.ObjectPresentation;
		EndIf;
		If Not ValueIsFilled(MetadataPresentation) Then
			MetadataPresentation = MetadataObject.Presentation();
		EndIf;
		
		If Not StrEndsWith(DataPresentation, "(" + MetadataPresentation + ")")
		   AND Not StrStartsWith(DataPresentation, MetadataPresentation) Then
			
			DataPresentation = StringFunctionsClientServer.SubstituteParametersToString("%1 (%2)",
				DataPresentation, MetadataPresentation);
		EndIf;
	EndIf;
		
	Return DataPresentation;
	
EndFunction

// For the CheckAccessToObject procedure and the AccessUpdateManualControl form.
Function SourceAccessKeyObsolete(ObjectRef, RestrictionParameters, Source = Undefined) Export
	
	If RestrictionParameters.DoNotWriteAccessKeys Then
		Return False;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("Ref", ObjectRef);
	
	If RestrictionParameters.WriteAlwaysAllowedAccessKey Then
		Query.Text = RestrictionParameters.DataItemWithObsoleteAllowedKeyQueryText;
		Query.SetParameter("AllowedAccessKey", AccessManagementInternalCached.AllowedAccessKey());
	Else
		Query.Text = RestrictionParameters.DataItemWithObsoleteKeysQueryText;
	EndIf;
	
	If RestrictionParameters.ListWithDate Then
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Date BETWEEN &StartDate AND &EndDate", "CurrentList.Ref = &Ref");
	Else
		Query.Text = StrReplace(Query.Text,
			"CurrentList.Ref >= &LastProcessedRef", "CurrentList.Ref = &Ref");
	EndIf;
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Query.Execute().IsEmpty() Then
		Return False;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	Return True;
	
EndFunction

// For the CheckAccessToObject and CheckAccessToRecordSet procedures, and the AccessUpdateManualControl form.
Procedure UpdateAccessKeysOfDataItemsOnWrite(DataItemsDetails, RestrictionParameters,
			TransactionID, UpdateRightsToKeys = False, HasRightsChanges = False, Source = Undefined) Export
	
	If RestrictionParameters.DoNotWriteAccessKeys Then
		Return;
	EndIf;
	
	If TypeOf(DataItemsDetails) = Type("ValueTable") Then
		DataItems = DataItemsDetails;
	Else
		DataItems = New ValueTable;
		DataItems.Columns.Add("CurrentRef");
		DataItems.Add().CurrentRef = DataItemsDetails;
	EndIf;
	
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(RestrictionParameters.List,
		TransactionID);
	UsersKindPropertyName = ?(RestrictionParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	UpdateParameters = New Structure(RestrictionParameters);
	UpdateParameters.Insert("HasRightsChanges",       HasRightsChanges);
	UpdateParameters.Insert("UpdateRightsToKeys",    UpdateRightsToKeys);
	UpdateParameters.Insert("TransactionID", TransactionID);
	UpdateParameters.Insert("ListID",
		Common.MetadataObjectID(RestrictionParameters.List));
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		UpdateParameters.Insert("DependentListsByAccessKeys", New Array);
	Else
		UpdateParameters.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
	If RestrictionParameters.WriteAlwaysAllowedAccessKey Then
		UpdateListDataItemsWithObsoleteAllowedKey(DataItems, UpdateParameters);
	Else
		UpdateAccessKeysOfListDataItemsBatch(DataItems, UpdateParameters);
	EndIf;
	
	HasRightsChanges = UpdateParameters.HasRightsChanges;
	
EndProcedure

// For the AccessValuesGroups information register.
Procedure ScheduleUpdateOfDependentListsByValuesWithGroups(ValuesWithChangesByTypes) Export
	
	If Not LimitAccessAtRecordLevelUniversally() Then
		Return;
	EndIf;
	
	TransactionID = New UUID;
	
	ListsToUpdate = New Map;
	For Each ValuesDetails In ValuesWithChangesByTypes Do
		FullLeadingListName = Metadata.FindByType(ValuesDetails.Key).FullName();
		ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullLeadingListName, TransactionID);
		If ListPropertiesAsLeadingOne = Undefined
		 Or ListPropertiesAsLeadingOne.ByValuesWithGroups = Undefined Then
			Continue;
		EndIf;
		AddListsForUsersKindUpdate(ListsToUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForUsers");
		
		AddListsForUsersKindUpdate(ListsToUpdate,
			ListPropertiesAsLeadingOne.ByValuesWithGroups, "ForExternalUsers");
	EndDo;
	
	ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate,
		TransactionID,
		"ScheduleUpdateOfDependentListsByValuesWithGroups",
		?(ValuesWithChangesByTypes.Count() <> 1 Or ValuesDetails.Value = True,
			Undefined, New Structure("ByValuesWithGroups", ValuesDetails.Value)));
	
EndProcedure

// For the ScheduleUpdateOfDependentListsByValuesWithGroups procedure.
Procedure AddListsForUsersKindUpdate(ListsToUpdate, ByValuesWithGroups, UsersKindName)
	
	FullNames = ByValuesWithGroups[UsersKindName];
	If FullNames = Undefined Then
		Return;
	EndIf;
	
	For Each FullName In FullNames Do
		ListForUpdate = ListsToUpdate.Get(FullName);
		If ListForUpdate = Undefined Then
			ListForUpdate = New Structure("ForUsers, ForExternalUsers", False, False);
			ListsToUpdate.Insert(FullName, ListForUpdate);
		EndIf;
		ListForUpdate[UsersKindName] = True;
	EndDo;
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeys, WriteObjectsAccessKeys,
// ScheduleUpdateOfDependentListsByValuesWithGroups procedures.
//
Procedure ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate, TransactionID,
			Details, LeadingObject = Undefined, IsUpdateContinuation = False)
	
	If TypeOf(ListsToUpdate) = Type("Map")
	   AND ListsToUpdate.Count() = 0
	 Or TypeOf(ListsToUpdate) = Type("Structure")
	   AND ListsToUpdate.ListsNames.Count() = 0 Then
		
		Return;
	EndIf;
	
	Lists = New Array;
	ListsForUsers = New Array;
	ListsForExternalUsers = New Array;
	
	If TypeOf(ListsToUpdate) = Type("Map") Then
		For Each ListDetails In ListsToUpdate Do
			FullName = ListDetails.Key;
			Properties  = ListDetails.Value;
			
			If Properties.ForUsers Then
				RestrictionParameters = RestrictionParameters(FullName, TransactionID, False);
				
				If RestrictionParameters.RestrictionDisabled
				 Or RestrictionParameters.AccessDenied
				 Or RestrictionParameters.UsesRestrictionByOwner Then
					
					Properties.ForUsers = False;
				EndIf;
			EndIf;
			
			If Properties.ForExternalUsers Then
				RestrictionParameters = RestrictionParameters(FullName, TransactionID, True);
				
				If RestrictionParameters.RestrictionDisabled
				 Or RestrictionParameters.AccessDenied
				 Or RestrictionParameters.UsesRestrictionByOwner Then
					
					Properties.ForExternalUsers = False;
				EndIf;
			EndIf;
			
			If Properties.ForUsers AND Properties.ForExternalUsers Then
				Lists.Add(FullName);
			
			ElsIf Properties.ForUsers Then
				ListsForUsers.Add(FullName);
				
			ElsIf Properties.ForExternalUsers Then
				ListsForExternalUsers.Add(FullName);
			EndIf;
		EndDo;
	Else
		For Each FullName In ListsToUpdate.ListsNames Do
			RestrictionParameters = RestrictionParameters(FullName,
				TransactionID, ListsToUpdate.ForExternalUsers);
			
			If RestrictionParameters.RestrictionDisabled
			 Or RestrictionParameters.AccessDenied
			 Or RestrictionParameters.UsesRestrictionByOwner Then
				
				Continue;
			EndIf;
			
			If ListsToUpdate.ForExternalUsers Then
				ListsForExternalUsers.Add(FullName);
			Else
				ListsForUsers.Add(FullName);
			EndIf;
		EndDo;
	EndIf;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.Details = Details;
	PlanningParameters.LeadingObject = LeadingObject;
	PlanningParameters.IsUpdateContinuation = IsUpdateContinuation;
	ScheduleAccessUpdate(Lists, PlanningParameters);
	
	PlanningParameters.ForExternalUsers = False;
	ScheduleAccessUpdate(ListsForUsers, PlanningParameters);
	
	PlanningParameters.ForUsers = False;
	PlanningParameters.ForExternalUsers = True;
	ScheduleAccessUpdate(ListsForExternalUsers, PlanningParameters);
	
EndProcedure

// For the CheckAccessOnWriteSource and CheckAccessBeforeDeleteSource procedures.
Procedure ScheduleUpdateOfDependentObsoleteAccessKeys(Source, IsRecordSet, Delete)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	FullName = Source.Metadata().FullName();
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(FullName,
		Source.AdditionalProperties.AccessManagementTransactionID);
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByFieldsValues = Undefined Then
		Return;
	EndIf;
	
	If Source.AdditionalProperties.Property("FieldValueAccessManagementForChangeCheckOnWrite") Then
		QueryResults = Source.AdditionalProperties.FieldValueAccessManagementForChangeCheckOnWrite;
	Else
		QueryResults = Undefined;
	EndIf;
	
	ChangesByFieldsValues = New Structure;
	ChangesByFieldsValues.Insert("Details", ?(IsRecordSet, Source.Filter, Source.Ref));
	ChangesByFieldsValues.Insert("ChangedTable", FullName);
	ChangesByFieldsValues.Insert("ChangesContent");
	
	LeadingObject = New Structure("ByFieldsValues", ChangesByFieldsValues);
	
	ListsToUpdate = New Map;
	ByFieldsValues = ListPropertiesAsLeadingOne.ByFieldsValues;
	HeaderFields = ByFieldsValues.HeaderFields;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.Details = "ScheduleUpdateOfDependentObsoleteAccessKeys";
	PlanningParameters.LeadingObject = LeadingObject;
	
	If IsRecordSet Then
		If ValueIsFilled(HeaderFields.AllFields) Then
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[0]);
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				Source, HeaderFields.FieldsSets, PlanningParameters);
		EndIf;
	Else
		If ValueIsFilled(HeaderFields.AllFields) Then
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[0]);
			NewValues = New ValueTable;
			For Each FieldName In HeaderFields.AllFields Do
				NewValues.Columns.Add(FieldName, HeaderFields.AllFieldsTypes.Get(FieldName).Get());
			EndDo;
			If Not Delete Then
				FillPropertyValues(NewValues.Add(), Source);
			EndIf;
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				NewValues, HeaderFields.FieldsSets, PlanningParameters);
			Index = 1;
		Else
			Index = 0;
		EndIf;
		For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
			QueryResult = ?(QueryResults = Undefined, Undefined, QueryResults[Index]);
			ChangesByFieldsValues.ChangedTable = FullName + "." + TabularSectionDetails.Name;
			NewValues = NewTabularSectionValues(Source, TabularSectionDetails, Delete);
			ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
				NewValues, TabularSectionDetails.FieldsSets, PlanningParameters);
			Index = Index + 1;
		EndDo;
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedure.
Function NewTabularSectionValues(Source, TabularSectionDetails, Delete)
	
	Fields = New Array(TabularSectionDetails.AllFields);
	
	FieldNameRef = "Ref";
	Index = Fields.Find(FieldNameRef);
	If Index <> Undefined Then
		Fields.Delete(Index);
	Else
		FieldNameRef = "Ref";
		Index = Fields.Find(FieldNameRef);
		If Index <> Undefined Then
			Fields.Delete(Index);
		EndIf;
	EndIf;
	
	NewValues = Source[TabularSectionDetails.Name].Unload(
		?(Delete, New Array, Undefined), StrConcat(Fields, ", "));
	
	If Index <> Undefined Then
		Types = New Array;
		Types.Add(TypeOf(Source.Ref));
		NewValues.Columns.Add(FieldNameRef, New TypeDescription(Types));
		NewValues.FillValues(Source.Ref, FieldNameRef);
	EndIf;
	
	Return NewValues;
	
EndFunction

// For the ScheduleUpdateOfDependentObsoleteAccessKeys procedure.
Procedure ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues(QueryResult,
			Source, FieldsSetsByUsersKinds, PlanningParameters)
	
	UsersKinds = New Array;
	UsersKinds.Add("ForUsers");
	UsersKinds.Add("ForExternalUsers");
	
	For Each UsersKind In UsersKinds Do
		FieldsSets = FieldsSetsByUsersKinds[UsersKind];
		If FieldsSets = Undefined Then
			Continue;
		EndIf;
		If UsersKind = "ForUsers" Then
			PlanningParameters.ForExternalUsers = False;
			PlanningParameters.ForUsers = True;
		Else
			PlanningParameters.ForExternalUsers = True;
			PlanningParameters.ForUsers = False;
		EndIf;
		For Each FieldsSetDetails In FieldsSets Do
			ChangesContent = TableChangesContent(QueryResult, Source, FieldsSetDetails.Key);
			If ChangesContent = Null Then
				Continue;
			EndIf;
			For Each DependentTablesDetails In FieldsSetDetails.Value Do
				If DependentTablesDetails.Key = FieldsSetDetails.Key Then
					CurrentChangesContent = ChangesContent;
				Else
					CurrentChangesContent = ChangesContent.Copy(, DependentTablesDetails.Key);
					CurrentChangesContent.GroupBy(DependentTablesDetails.Key);
				EndIf;
				PlanningParameters.LeadingObject.ByFieldsValues.ChangesContent = CurrentChangesContent;
				ScheduleAccessUpdate(DependentTablesDetails.Value, PlanningParameters);
			EndDo;
		EndDo;
	EndDo;
	
EndProcedure

// For the ScheduleUpdateOfDependentObsoleteAccessKeysByFieldsValues procedure.
Function TableChangesContent(QueryResult, Source, Fields)
	
	MaxCombinations = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	If QueryResult = Undefined Then
		OldCombinations = New ValueTable;
	Else
		OldCombinations = QueryResult.Unload();
		If StrSplit(Fields, ",").Count() < OldCombinations.Count() Then
			OldCombinations = OldCombinations.Copy(, Fields);
			OldCombinations.GroupBy(Fields);
		EndIf;
	EndIf;
	
	If OldCombinations.Count() >= MaxCombinations Then
		Return Undefined;
	EndIf;
	
	If TypeOf(Source) = Type("ValueTable") Then
		NewCombinations = Source.Copy(, Fields);
	Else
		NewCombinations = Source.Unload(, Fields);
	EndIf;
	NewCombinations.GroupBy(Fields);
	
	If NewCombinations.Count() >= MaxCombinations Then
		Return Undefined;
	EndIf;
	
	ChangesContent = NewCombinations.Copy(New Array);
	
	NewCombinations.Columns.Add("ChangeKind", New TypeDescription("Number"));
	NewCombinations.FillValues(1, "ChangeKind");
	For Each String In OldCombinations Do
		NewString = NewCombinations.Add();
		FillPropertyValues(NewString, String);
		NewString.ChangeKind = -1;
	EndDo;
	NewCombinations.GroupBy(Fields, "ChangeKind");
	
	For Each String In NewCombinations Do
		If String.ChangeKind <> 0 Then
			FillPropertyValues(ChangesContent.Add(), String);
		EndIf;
	EndDo;
	
	Return ?(ChangesContent.Count() > 0, ChangesContent, Null);
	
EndFunction

// For call and manager module of the AccessGroups catalog.
Procedure ScheduleAccessUpdateOnChangeAccessGroupMembers(AccessGroup,
			ChangedMembersTypes, OnImport = False) Export
	
	If Not ChangedMembersTypes.Users
	   AND Not ChangedMembersTypes.ExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("AccessGroup", AccessGroup);
	Query.Text =
	"SELECT
	|	AccessGroupsTables.Table AS Table
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|WHERE
	|	AccessGroupsTables.AccessGroup = &AccessGroup";
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Tables = Query.Execute().Unload();
	Details = ?(OnImport,
		"ScheduleAccessUpdateOnChangeAccessGroupMembersOnImport",
		"ScheduleAccessUpdateOnChangeAccessGroupMembers");
	
	ScheduleAccessKeysUsersUpdate(Tables, Details,
		ChangedMembersTypes.Users, ChangedMembersTypes.ExternalUsers, True);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the AfterUserGroupsUpdate procedure and the AccessGroups catalog manager module.
// 
//
Procedure ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers(ChangedMembers,
			OnImport = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If ChangedMembers = Undefined Then
		ForUsers        = True;
		ForExternalUsers = True;
		
		Query = New Query;
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsTables.Table AS Table
		|FROM
		|	InformationRegister.AccessGroupsTables AS AccessGroupsTables";
	Else
		ForUsers        = False;
		ForExternalUsers = False;
		
		For Each Member In ChangedMembers Do
			If TypeOf(Member) = Type("CatalogRef.Users")
			 Or TypeOf(Member) = Type("CatalogRef.UserGroups") Then
				
				ForUsers = True;
			
			ElsIf TypeOf(Member) = Type("CatalogRef.ExternalUsers")
			      Or TypeOf(Member) = Type("CatalogRef.ExternalUsersGroups") Then
				
				ForExternalUsers = True;
			EndIf;
		EndDo;
		
		Query = New Query;
		Query.SetParameter("ChangedMembers", ChangedMembers);
		Query.Text =
		"SELECT DISTINCT
		|	AccessGroupsTables.Table AS Table
		|FROM
		|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
		|		INNER JOIN Catalog.AccessGroups.Users AS AccessGroupsMembers
		|		ON AccessGroupsTables.AccessGroup = AccessGroupsMembers.Ref
		|			AND (AccessGroupsMembers.User IN (&ChangedMembers))";
	EndIf;
	
	Tables = Query.Execute().Unload();
	Details = ?(OnImport,
		"ScheduleAccessUpdateOnIndirectChangeAccessGroupMembersOnImport",
		"ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers");
	
	ScheduleAccessKeysUsersUpdate(Tables,
		Details, ForUsers, ForExternalUsers, True);
	
	ScheduleAccessGroupsSetsUpdate(Details, ForUsers, ForExternalUsers);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For calling the AccessGroupsTables register from manager module.
Procedure ScheduleAccessUpdateOnChangeAccessGroupsTables(Tables) Export
	
	ScheduleAccessKeysUsersUpdate(Tables,
		"ScheduleAccessUpdateOnChangeAccessGroupsTables", True, True);
	
EndProcedure

// For calling the AccessGroupsValues register from the manager module.
Procedure ScheduleAccessUpdateOnChangeAllowedValues(AccessGroupsAndValuesTypes) Export
	
	ClearAccessGroupsValuesCacheToCalculateRights();
	
	Query = New Query;
	Query.SetParameter("AccessGroupsAndValuesTypes", AccessGroupsAndValuesTypes);
	Query.Text =
	"SELECT
	|	AccessGroupsAndValuesTypes.AccessGroup AS AccessGroup,
	|	AccessGroupsAndValuesTypes.AccessValuesType AS AccessValuesType
	|INTO AccessGroupsAndValuesTypes
	|FROM
	|	&AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroupsTables.Table AS Table,
	|	VALUETYPE(AccessGroupsAndValuesTypes.AccessValuesType) AS AccessValuesType
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN AccessGroupsAndValuesTypes AS AccessGroupsAndValuesTypes
	|		ON AccessGroupsTables.AccessGroup = AccessGroupsAndValuesTypes.AccessGroup
	|TOTALS BY
	|	Table";
	
	TablesAndAccessValuesTypes = Query.Execute().Unload(QueryResultIteration.ByGroups);
	
	ScheduleAccessKeysUsersUpdate(TablesAndAccessValuesTypes.Rows,
		"ScheduleAccessUpdateOnChangeAllowedValues", True, True);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeAllowedValues and
// ScheduleAccessUpdate procedures, and calling from the AccessUpdateManualControl form module.
//
Procedure ClearAccessGroupsValuesCacheToCalculateRights() Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	VersionParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValuesVersion";
	StandardSubsystemsServer.SetExtensionParameter(VersionParameterName, New UUID, True);
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValues";
	StandardSubsystemsServer.SetExtensionParameter(ParameterName, Undefined, True);
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
EndProcedure

// For the ScheduleAccessUpdateOnChangeAccessGroupMembers,
// ScheduleAccessUpdateAfterUserGroupsUpdate,
// ScheduleAccessUpdateOnChangeAccessGroupsTables, and
// ScheduleAccessUpdateOnChangeAllowedValues procedures.
//
Procedure ScheduleAccessKeysUsersUpdate(ListsDetails, Details, ForUsers,
				ForExternalUsers, OnChangeAccessGroupMembers = False, LeadingObject = Undefined)
	
	If ListsDetails.Count() = 0 Then
		Return;
	EndIf;
	
	Context = New Structure;
	Context.Insert("OnChangeAccessGroupMembers", OnChangeAccessGroupMembers);
	Context.Insert("TransactionID",             New UUID);
	Context.Insert("List",                              Undefined);
	Context.Insert("FullName",                           Undefined);
	Context.Insert("AccessValuesTypes",                 Undefined);
	
	If TypeOf(ListsDetails) = Type("FixedArray") Then
		ListsIDsByFullNames = Common.MetadataObjectIDs(ListsDetails);
	Else
		FullNames = ListsDetails.UnloadColumn("Table");
		ListsMetadataObjects = Common.MetadataObjectsByIDs(FullNames, False);
	EndIf;
	
	Lists = New Array;
	ListsForUsers = New Array;
	ListsForExternalUsers = New Array;
	
	For Each ListDetails In ListsDetails Do
		If ListsIDsByFullNames <> Undefined Then
			Context.FullName = ListDetails;
			Context.List = ListsIDsByFullNames.Get(Context.FullName);
		Else
			MetadataObject = ListsMetadataObjects.Get(ListDetails.Table);
			Context.FullName = ?(TypeOf(MetadataObject) = Type("MetadataObject"), MetadataObject.FullName(), "");
			Context.List    = ListDetails.Table;
			If TypeOf(ListDetails) = Type("ValueTreeRow") Then
				Context.AccessValuesTypes = ListDetails.Rows;
			EndIf;
		EndIf;
		If Not ValueIsFilled(Context.FullName) Then
			Continue;
		EndIf;
		PlanForUsers = ForUsers
			AND UsersAccessKeysUpdateRequired(Context, False);
		
		PlanForExternalUsers = ForExternalUsers
			AND UsersAccessKeysUpdateRequired(Context, True);
		
		If PlanForUsers AND PlanForExternalUsers Then
			Lists.Add(Context.FullName);
			
		ElsIf PlanForUsers Then
			ListsForUsers.Add(Context.FullName);
			
		ElsIf PlanForExternalUsers Then
			ListsForExternalUsers.Add(Context.FullName);
		EndIf;
	EndDo;
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.DataAccessKeys = False;
	PlanningParameters.LeadingObject = LeadingObject;
	PlanningParameters.Details = Details;
	ScheduleAccessUpdate(Lists, PlanningParameters);
	
	PlanningParameters.ForExternalUsers = False;
	ScheduleAccessUpdate(ListsForUsers, PlanningParameters);
	
	PlanningParameters.ForUsers = False;
	PlanningParameters.ForExternalUsers = True;
	ScheduleAccessUpdate(ListsForExternalUsers, PlanningParameters);
	
EndProcedure

// For the ScheduleAccessKeysUsersUpdate procedure.
Function UsersAccessKeysUpdateRequired(Context, ForExternalUsers)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Context.TransactionID, Undefined, False);
	If ForExternalUsers Then
		AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
	Else
		AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
	EndIf;
	RestrictionProperties = AdditionalContext.ListRestrictionsProperties.Get(Context.FullName);
	
	If AdditionalContext.ListsWithDisabledRestriction.Get(Context.FullName) <> Undefined
	 Or RestrictionProperties = Undefined
	 Or RestrictionProperties.AccessDenied
	 Or RestrictionProperties.OwnerField <> Undefined
	 Or Context.OnChangeAccessGroupMembers
	   AND Not RestrictionProperties.CalculateUserRights Then
		
		Return False;
	EndIf;
	
	If RestrictionProperties <> Undefined
	   AND Context.AccessValuesTypes <> Undefined
	   AND Not Context.OnChangeAccessGroupMembers Then
		
		NoUsedTypesAmongChangedAccessValuesTypes = True;
		UsedAccessValuesTypes = RestrictionProperties.UsedAccessValuesTypes.Get();
		For Each String In Context.AccessValuesTypes Do
			If UsedAccessValuesTypes.Find(String.AccessValuesType) <> Undefined Then
				NoUsedTypesAmongChangedAccessValuesTypes = False;
				Break;
			EndIf;
		EndDo;
		If NoUsedTypesAmongChangedAccessValuesTypes Then
			Return False;
		EndIf;
	EndIf;
	
	Return True;
	
EndFunction

// For the ScheduleAccessUpdateOnIndirectChangeOfAccessGroupMembers procedure, and the AccessGroups 
// catalog object and manager modules.
//
Procedure ScheduleAccessGroupsSetsUpdate(Details, ForUsers = True, ForExternalUsers = True) Export
	
	If Not ForUsers AND Not ForExternalUsers Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	
	List = "Catalog.SetsOfAccessGroups";
	UniqueKey = New UUID;
	ListID = Common.MetadataObjectID(List);
	CurrentDate = CurrentSessionDate();
	MaxDate = MaxDate();
	
	// Update only by changes (not a full update).
	JobParameters = New Structure;
	SetDataKeyKind(JobParameters, "NewSingleUserSets");
	JobParametersStorage = New ValueStorage(JobParameters);
	
	If ForUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = ListID;
		NewRecord.ForExternalUsers            = False;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.JobParameters                   = JobParametersStorage;
		NewRecord.JobSize                      = 3;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	If ForExternalUsers Then
		NewRecord = RecordSet.Add();
		NewRecord.UniqueKey                   = UniqueKey;
		NewRecord.List                             = ListID;
		NewRecord.ForExternalUsers            = True;
		NewRecord.LatestUpdatedItemDate = MaxDate;
		NewRecord.JobParameters                   = JobParametersStorage;
		NewRecord.JobSize                      = 3;
		NewRecord.RegisterRecordChangeDate        = CurrentDate;
	EndIf;
	
	RecordSet.Write(False);
	
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys = False;
	PlanningParameters.ForUsers        = ForUsers;
	PlanningParameters.ForExternalUsers = ForExternalUsers;
	PlanningParameters.Details = Details;
	
	ListsByIDs = New Map;
	ListsByIDs.Insert(ListID, List);
	
	RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters);
	
EndProcedure

#EndRegion

#Region AccessUpdate

// Starts an access update background job instead of a scheduled job.
//
// Parameters:
//  IsManualStart - Boolean - if False is passed, the description will begin with "Autorun", 
//                              otherwise, it will begin with "Manual run". Access update lock will 
//                              be removed, execution will continue until the full completion.
//                              
//
// Returns:
//  Undefined - access update is not required or it is prohibited.
//  Structure - with the following properties:
//   * Running - Boolean - if the update is already running.
//
//   * BackgroundJobID - Undefined - if the update is not running or running not in a background job.
//                                      
//                                  - UUID - a background job ID.
//
//   * SessionProperties - Undefined - if a background job never started or was just added to the queue.
//                    - Structure - with session properties if the update is already running.
//                        * ComputerName - String - the InfobaseSession object property of the same name.
//                        * SessionNumber   - Number - the InfobaseSession object property of the same name.
//                        * SessionStart  - String - the InfobaseSession object property of the same name.
//
//   * WarningText - Undefined - if a background job never started or a new background job was started.
//                         - String - a description showing that access update is already started.
//
Function StartAccessUpdateAtRecordLevel(IsManualStart = False) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	If Not LimitAccessAtRecordLevelUniversally(True) Then
		ErrorText =
			NStr("ru = 'Невозможно запустить обновление доступа на уровне записей, так как
			           |константа ОграничиватьДоступНаУровнеЗаписейУниверсально выключена.'; 
			           |en = 'Cannot start access update at the record level as
			           |the LimitAccessAtRecordLevelUniversally constant is disabled.'; 
			           |pl = 'Nie można uruchomić aktualizację dostępu na poziomie rekordu, ponieważ
			           |stała ОграничиватьДоступНаУровнеЗаписейуниверсально jest wyłączona.';
			           |de = 'Es ist nicht möglich, die Aktualisierung des Zugriffs auf die Aufzeichnungsebene zu starten, da die Konstante
			           |ZugriffAufDerAufzeichnungsEbeneUniversalEinschränken deaktiviert ist.';
			           |ro = 'Actualizarea accesului la nivel de înregistrări nu poate fi lansată, deoarece este dezactivată
			           |constanta ОграничиватьДоступНаУровнеЗаписейУниверсально.';
			           |tr = 'ErişimiKayıtlarSeviyesindeÜniversalOlarakKısıtla sabiti devre dışı bırakıldığı için 
			           |erişim kayıtlar seviyesinde güncellenemez.'; 
			           |es_ES = 'Imposible lanzar la actualización de acceso en nivel de registros, porque
			           |el constante LimitAccessAtRecordLevelUniversally no está desactivado.'");
		Raise ErrorText;
	EndIf;
	
	If TransactionActive() Then
		ErrorText =
			NStr("ru = 'Невозможно запустить обновление доступа на уровне записей в открытой транзакции.'; en = 'Cannot start access update at the record level in an open transaction.'; pl = 'Nie można uruchomić aktualizację dostępu na poziomie rekordu w otwartej transakcji.';de = 'Es ist nicht möglich, die Aktualisierung des Zugriffs auf die Aufzeichnungsebene in der offenen Transaktion zu starten.';ro = 'Actualizarea accesului la nivel de înregistrări nu poate fi lansată în tranzacție deschisă.';tr = 'Açık bir işlemde kayıt düzeyinde erişim güncelleştirmesi başlatılamıyor.'; es_ES = 'Imposible lanzar la actualización de acceso en nivel de registros en transacción abierta.'");
		Raise ErrorText;
	EndIf;
	
	If Not IsManualStart AND Not AccessUpdateScheduled() Then
		Return Undefined;
	EndIf;
	
	LastAccessUpdate = LastAccessUpdate();
	If Not IsManualStart AND LastAccessUpdate.AccessUpdateProhibited Then
		Return Undefined;
	EndIf;
	
	Result = New Structure("AlreadyRunning, BackgroundJobID, SessionProperties, WarningText", True);
	Performer = AccessUpdateAssignee(LastAccessUpdate);
	
	If Performer = Undefined Then
		Result.AlreadyRunning = False;
		If Common.FileInfobase() Then
			StandardSubsystemsServer.CheckApplicationVersionDynamicUpdate();
		EndIf;
		If IsManualStart Then
			SetAccessUpdateProhibition(False);
			JobParameters = New Array;
			JobParameters.Add(True);
		Else
			JobParameters = Undefined;
		EndIf;
		BackgroundJob = ConfigurationExtensions.ExecuteBackgroundJobWithDatabaseExtensions(
			Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName, JobParameters,,
			?(IsManualStart, NStr("ru = 'Запуск вручную'; en = 'Manual start'; pl = 'Uruchomienie ręczne';de = 'Manueller Start';ro = 'Lansare manuală';tr = 'Manuel başlatma'; es_ES = 'Lanzar manualmente'"), NStr("ru = 'Автозапуск'; en = 'Autostart'; pl = 'Autostart';de = 'Autostart';ro = 'Lansare automată';tr = 'Otomatik başlatma'; es_ES = 'Lanzamiento automático'")) + ": "
				+ Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.Synonym);
			
		Result.BackgroundJobID = BackgroundJob.UUID;
		
	ElsIf TypeOf(Performer) = Type("BackgroundJob")
	        AND Performer.UUID <> LastAccessUpdate.BackgroundJobID Then
		
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'; en = 'Cannot start access update as it has already been started on %3 at %4'; pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona działa już %3 w %4';de = 'Es war nicht möglich, mit der Aktualisierung des Zugriffs zu beginnen, da er bereits gestartet wurde %3 in %4';ro = 'Eșec la startarea actualizării accesului, deoarece ea deja este lansată %3 la %4';tr = 'Erişim güncellemesi %3''de %4 başlatıldığı için güncelleme başlatılamadı'; es_ES = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4'"),
			Format(Performer.Begin, "DLF=D"),
			Format(Performer.Begin, "DLF=T"));
	Else
		SessionProperties = New Structure("ComputerName, SessionNumber, SessionStarted");
		If TypeOf(Performer) = Type("BackgroundJob") Then
			FillPropertyValues(SessionProperties, LastAccessUpdate);
		Else
			FillPropertyValues(SessionProperties, Performer);
		EndIf;
		Result.SessionProperties = SessionProperties;
		Result.WarningText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обновление доступа уже выполняется
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
			           |en = 'Access update is already running
			           |(computer: %1, session: %2, started: %3 at %4)'; 
			           |pl = 'Aktualizacja dostępu jest już uruchomiona
			           |(komputer:%1, sesja: %2, rozpoczęto: %3 w %4)';
			           |de = 'Zugriffsaktualisierung läuft bereits
			           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)';
			           |ro = 'Actualizarea accesului deja se execută
			           |(computer: %1, sesiunea: %2, început: %3 la%4)';
			           |tr = 'Erişim zaten güncelleniyor 
			           | (bilgisayar:%1, oturum:%2, başlatma: %3''de %4)'; 
			           |es_ES = 'La actualización de acceso ya se está procesando
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)'"),
			SessionProperties.ComputerName,
			SessionProperties.SessionNumber,
			Format(SessionProperties.SessionStarted, "DLF=D"),
			Format(SessionProperties.SessionStarted, "DLF=T"));
	EndIf;
	
	If TypeOf(Performer) = Type("BackgroundJob") Then
		Result.BackgroundJobID = Performer.UUID;
	EndIf;
	
	Return Result;
	
EndFunction

// Cancel access update that is running in the background job.
Procedure CancelAccessUpdateAtRecordLevel() Export
	
	Performer = AccessUpdateAssignee(LastAccessUpdate());
	
	If TypeOf(Performer) = Type("InfoBaseSession") Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Невозможно отменить полное обновление доступа
			           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
			           |en = 'Cannot cancel full access update
			           |(computer: %1, session: %2, started: %3 at %4)'; 
			           |pl = 'Nie można cofnąć pełnej aktualizacji dostępu
			           |(komputer: %1, sesja: %2, rozpoczęto: %3 w %4)';
			           |de = 'Aktualisierung mit vollem Zugriff kann nicht abgebrochen werden
			           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)';
			           |ro = 'Nu puteți anula actualizarea completă a accesului
			           |(computer: %1, sesiunea: %2, început: %3 la%4)';
			           |tr = 'Tam erişim güncellemesi iptal edilemez 
			           | (bilgisayar: %1, oturum: %2, başlatma: %3''de %4)'; 
			           |es_ES = 'Es imposible cancelar la actualización completa del acceso
			           |(ordenador: %1, sesión: %2, empezado: %3 a %4)'"),
			Performer.ComputerName,
			Performer.SessionNumber,
			Format(Performer.SessionStarted, "DLF=D"),
			Format(Performer.SessionStarted, "DLF=T"));
		Raise ErrorText;
	EndIf;
	
	CompleteAccessUpdateThreads(True);
	SetAccessUpdateProhibition(True, True);
	
	If TypeOf(Performer) = Type("BackgroundJob") Then
		Try
			Performer.WaitForCompletion(15);
		Except
			Performer.Cancel();
		EndTry;
	EndIf;
	
	Filter = New Structure;
	Filter.Insert("State", BackgroundJobState.Active);
	Filter.Insert("MethodName", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName);
	MainJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	
	For Each MainJob In MainJobs Do
		Try
			MainJob.WaitForCompletion(15);
		Except
			MainJob.Cancel();
		EndTry;
	EndDo;
	
	CancelAccessUpdateThreadsBackgroundJobs();
	
EndProcedure

// It enables or disables access update prohibition upon startup using a scheduled job or upon 
// application startup.
//
// When calling the AccessUpdateAtRecordLevel procedure with the UpdateAll flag, the prohibition is 
// ignored.
// 
// When calling the StartAccessUpdateAtRecordLevel procedure with the IsManualStart flag, the 
// prohibition is removed automatically.
//
Procedure SetAccessUpdateProhibition(Usage, CancelUpdate = False) Export
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		Write = False;
		If LastAccessUpdate.AccessUpdateProhibited <> Usage Then
			LastAccessUpdate.AccessUpdateProhibited = Usage;
			Write = True;
		EndIf;
		
		If CancelUpdate
		   AND ( Not LastAccessUpdate.UpdateCanceled
		      Or LastAccessUpdate.CompletionErrorText <> "") Then
			
			LastAccessUpdate.UpdateCanceled = True;
			LastAccessUpdate.CompletionErrorText = "";
			Write = True;
		EndIf;
		
		If Write Then
			Constants.LastAccessUpdate.Set(
				New ValueStorage(LastAccessUpdate));
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// AccessUpdateAtRecordLevel scheduled job handler.
Procedure AccessUpdateAtRecordLevel(UpdateAll = False, RaiseExceptiopnInsteadErrorRegistration = False) Export
	
	Common.OnStartExecuteScheduledJob(
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	
	ExecuteAccessUpdateAtRecordLevel(UpdateAll, RaiseExceptiopnInsteadErrorRegistration)
	
EndProcedure

// Updates access if it is scheduled.
Procedure ExecuteAccessUpdateAtRecordLevel(UpdateAll, RaiseExceptiopnInsteadErrorRegistration)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	CurrentSession = GetCurrentInfoBaseSession();
	MainSessionDetails = New Structure("BackgroundJobID, BackgroundJob");
	MainSessionDetails.Insert("SessionNumber",  CurrentSession.SessionNumber);
	MainSessionDetails.Insert("SessionStarted", CurrentSession.SessionStarted);
	
	If CurrentSession.ApplicationName <> "BackgroundJob" Then
		If UpdateAll Then
			BackgroundJobID = ArbitrarySessionID();
		Else
			ErrorText = NStr("ru = 'Обновление доступа может выполняться порциями только в фоновом задании.'; en = 'Access can be updated in batches only in a background job.'; pl = 'Aktualizacja dostępu może być wykonywana porcjami tylko w tle zadania.';de = 'Der Zugriff kann nur in Chargen im Hintergrundjob aktualisiert werden.';ro = 'Actualizarea accesului poate fi executată în porțiuni numai în sarcina de fundal.';tr = 'Erişim güncellemesi partiler halinde sadece arkaplan görevinde yapılabilir.'; es_ES = 'La actualización de acceso puede realizarse gradualmente solo en la tarea de fondo.'");
			Raise ErrorText;
		EndIf;
		MainSessionID = String(New UUID);
	Else
		CurrentBackgroundJob = CurrentSession.GetBackgroundJob();
		If CurrentBackgroundJob = Undefined Then
			ErrorText = NStr("ru = 'Не удалось получить фоновое задание текущего сеанса.'; en = 'Cannot get background job of the current session.'; pl = 'Nie można uzyskać zadania w tle dla bieżącej sesji.';de = 'Der Hintergrundjob der aktuellen Sitzung konnte nicht abgerufen werden.';ro = 'Eșec la obținerea sarcinii de fundal a sesiunii curente.';tr = 'Geçerli oturum için arka plan işi alınamadı.'; es_ES = 'No se ha podido recibir una tarea de fondo de la sesión actual.'");
			Raise ErrorText;
		EndIf;
		BackgroundJobID = CurrentBackgroundJob.UUID;
		MainSessionDetails.BackgroundJob = CurrentBackgroundJob;
		MainSessionDetails.BackgroundJobID = BackgroundJobID;
		MainSessionID = String(BackgroundJobID);
	EndIf;
	MainSessionDetails.Insert("ID", MainSessionID
		+ " (" + NStr("ru = 'Идентификатор основного сеанса'; en = 'Main session ID'; pl = 'Identyfikator sesji głównej';de = 'Kennung der Hauptsitzung';ro = 'Identificatorul sesiunii principale';tr = 'Ana oturum kimliği'; es_ES = 'Identificador de la sesión principal'") + ")");
	
	DataLock = New DataLock;
	DataLock.Add("Constant.LastAccessUpdate");
	
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		LastAccessUpdate = LastAccessUpdate(ConstantValue);
		
		If UpdateAll Or Not LastAccessUpdate.AccessUpdateProhibited Then
			Performer = AccessUpdateAssignee(LastAccessUpdate, BackgroundJobID);
			
			If Performer = Undefined Then
				LastAccessUpdate.StartDateAtServer = CurrentDateAtServer();
				LastAccessUpdate.SessionNumber          = CurrentSession.SessionNumber;
				LastAccessUpdate.SessionStarted         = CurrentSession.SessionStarted;
				LastAccessUpdate.ComputerName        = CurrentSession.ComputerName;
				LastAccessUpdate.BackgroundJobID = BackgroundJobID;
				
				Constants.LastAccessUpdate.Set(
					New ValueStorage(LastAccessUpdate));
			EndIf;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Not UpdateAll AND LastAccessUpdate.AccessUpdateProhibited Then
		If CurrentBackgroundJob.ScheduledJob <> Undefined Then
			SetAccessUpdate(False);
		EndIf;
		ErrorText =
			NStr("ru = 'Обновление доступа запрещено.
			           |Чтобы разрешить нужно нажать ""Разрешить"" в форме ""Обновление доступа на уровне записей"".
			           |Форму можно открыть из панели ""Настройки пользователей и прав"" или перейти по навигационной ссылке:
			           |e1cib/app/РегистрСведений.ОбновлениеКлючейДоступаКДанным.Форма.ОбновлениеДоступаНаУровнеЗаписей'; 
			           |en = 'Access update is prohibited.
			           |To allow it, click Allow in the ""Access update at record level"" form.
			           |You can open the form from the ""Users and rights settings"" panel or follow the link:
			           |e1cib/app/InformationRegister.DataAccessKeysUpdate.Form.AccessUpdateAtRecordLevel'; 
			           |pl = 'Aktualizacja dostępu jest zabroniona.
			           |Aby zezwolić, musisz kliknąć ""Zezwól"" w formularzu ""Aktualizuj dostęp na poziomie zapisu"".
			           |Możesz otworzyć formularz z panelu ""Ustawienia użytkownika i praw"" lub kliknąć na link nawigacyjny:
			           |e1cib/app/РегистрСведений.ОбновлениеКлючейДоступаКДанным.Форма.ОбновлениеДоступаНаУровнеЗаписей';
			           |de = 'Das Aktualisieren des Zugriffs ist nicht zulässig. 
			           |Um dies zuzulassen, müssen Sie im Formular ""Zugriff auf Datensatzebene aktualisieren"" auf ""Zulassen"" klicken.
			           |Sie können das Formular über das Bedienfeld ""Einstellungen für Benutzer und Rechte"" öffnen oder den Navigationslink aufrufen:
			           | e1cib/app/InformationRegister.AktualisierenVonDatenzugriffsschlüsseln.Formular.AktualisierenDesZugriffsAufDatensatzebene';
			           |ro = 'Actualizarea accesului este interzisă.
			           |Pentru a permite trebuie să tastați ""Permite"" în forma ""Actualizarea accesului la nivel de înregistrări"".
			           |Forma poate fi deschisă din panoul ""Setările utilizatorilor și drepturilor"" sau urmați linkul de navigare:
			           |e1cib/app/РегистрСведений.ОбновлениеКлючейДоступаКДанным.Форма.ОбновлениеДоступаНаУровнеЗаписей';
			           |tr = 'Erişim güncellemesi yasaktır.
			           |İzin vermek için, kayıt düzeyinde erişim güncelleştirmesi formunda İzin Ver''i tıklamanız gerekir.
			           |Form, kullanıcı ve hak ayarları panelinden açılabilir veya navigasyon bağlantısına gidebilirsiniz:
			           | e1cıb / app / Kayıtlargörünümler.Güncellemeleriçinmevcut.Form.Güncellemelermevcutarayıtlar'; 
			           |es_ES = 'Está prohibido actualizar el acceso.
			           |Para permitir hay que pulsar ""Permitir"" en el formulario ""Actualización del acceso en nivel de registros"".
			           |Se puede abrir el formulario del panel ""Ajustes de usuarios y derechos"" o pasar por enlace de navegación:
			           |e1cib/app/РегистрСведений.ОбновлениеКлючейДоступаКДанным.Форма.ОбновлениеДоступаНаУровнеЗаписей'");
		Raise ErrorText;
	EndIf;
	
	If Performer <> Undefined Then
		If Not UpdateAll Then
			Return;
		EndIf;
		
		If TypeOf(Performer) = Type("BackgroundJob")
		   AND Performer.UUID <> LastAccessUpdate.BackgroundJobID Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось начать обновление доступа, так как оно уже запущено %3 в %4'; en = 'Cannot start access update as it has already been started on %3 at %4'; pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona działa już %3 w %4';de = 'Es war nicht möglich, mit der Aktualisierung des Zugriffs zu beginnen, da er bereits gestartet wurde %3 in %4';ro = 'Eșec la startarea actualizării accesului, deoarece ea deja este lansată %3 la %4';tr = 'Erişim güncellemesi %3''de %4 başlatıldığı için güncelleme başlatılamadı'; es_ES = 'No se ha podido empezar la actualización de acceso porque ya está lanzado %3 en %4'"),
				Format(Performer.Begin, "DLF=D"),
				Format(Performer.Begin, "DLF=T"));
		Else
			SessionProperties = ?(TypeOf(Performer) = Type("BackgroundJob"),
				LastAccessUpdate, Performer);
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Не удалось начать обновление доступа, так как оно уже выполняется
				           |(компьютер: %1, сеанс: %2, начат: %3 в %4)'; 
				           |en = 'Cannot start access update as it is already running
				           |(computer: %1, session: %2, started: %3 at %4)'; 
				           |pl = 'Nie udało się rozpocząć aktualizację dostępu, ponieważ ona już działa
				           |(komputer: %1, sesja: %2, rozpoczęto: %3 w %4)';
				           |de = 'Fehler beim Starten der Zugriffsaktualisierung, da diese bereits ausgeführt wird
				           |(Computer: %1, Sitzung: %2, gestartet: %3 in %4)';
				           |ro = 'Eșec la startarea actualizării accesului, deoarece ea deja se execută
				           |(computer: %1, sesiunea: %2, început: %3 la%4)';
				           |tr = 'Erişim güncellemesi zaten yapıldığı için başlatılamadı 
				           | (bilgisayar: %1, oturum: %2, başlatma: %3''de %4)'; 
				           |es_ES = 'No se ha podido empezar la actualización de acceso porque se está actualizando
				           |(ordenador: %1, sesión: %2, empezado: %3 a %4)'"),
				SessionProperties.ComputerName,
				SessionProperties.SessionNumber,
				Format(SessionProperties.SessionStarted, "DLF=D"),
				Format(SessionProperties.SessionStarted, "DLF=T"));
		EndIf;
		Raise ErrorText;
	EndIf;
	
	LastAccessUpdate.UpdateCanceled = False;
	LastAccessUpdate.CompletionErrorText = "";
	LastAccessUpdate.BackgroundJobID =
		CommonClientServer.BlankUUID();
	
	PlanningErrorText = "";
	If Not ValueIsFilled(LastAccessUpdate.LastObsoleteItemsProcessingPlanning) Then
		LastAccessUpdate.LastObsoleteItemsProcessingPlanning = CurrentSessionDate();
	EndIf;
	Try
		WaitBoundary = CurrentSessionDate() - HoursCountBetweenPlanningToProcessObsoleteItems() * 60 * 60;
		If LastAccessUpdate.LastObsoleteItemsProcessingPlanning < WaitBoundary Then
			PlanningParameters = AccessUpdatePlanningParameters(False);
			PlanningParameters.IsObsoleteItemsDataProcessor = True;
			PlanningParameters.Details = "AccessUpdateAtRecordLevel";
			ScheduleAccessUpdate(, PlanningParameters);
			LastAccessUpdate.LastObsoleteItemsProcessingPlanning = CurrentSessionDate();
		EndIf;
	Except
		ErrorInformation = ErrorInfo();
		PlanningErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось запланировать обработку устаревших элементов ограничения доступа по причине:
			           |%1'; 
			           |en = 'Cannot schedule processing of obsolete access restriction items due to:
			           |%1'; 
			           |pl = 'Nie udało się zaplanować przestarzałego ograniczenia dostępu z powodu:
			           |%1';
			           |de = 'Die Verarbeitung der veralteten Elemente der Zugriffsbeschränkung konnte aus diesem Grund nicht eingeplant werden:
			           |%1';
			           |ro = 'Eșec la planificarea procesării elementelor învechite de restricționare a accesului din motivul:
			           |%1';
			           |tr = 'Nedeniyle eski erişim kısıtlama öğeleri işlemek için zamanlayamadı:
			           |%1'; 
			           |es_ES = 'No se ha podido planificar el procesamiento de elementos antiguos de restricción de acceso a causa de:
			           |%1'"),
			DetailErrorDescription(ErrorInformation));
	EndTry;
	
	AllErrorsText = "";
	CompletionErrorText = "";
	Try
		If DataBaseConfigurationChangedDynamically() Then
			StandardSubsystemsServer.RequireRestartDueToApplicationVersionDynamicUpdate();
		EndIf;
		If LimitAccessAtRecordLevelUniversally() Then
			CheckUpdateActiveAccessRestrictionParameters();
			ExecuteAccessUpdate(UpdateAll, MainSessionDetails,
				LastAccessUpdate.UpdateCanceled, CompletionErrorText);
		Else
			SetAccessUpdate(False);
		EndIf;
	Except
		AllErrorsText = DetailErrorDescription(ErrorInfo());
	EndTry;
	
	Try
		CompleteAccessUpdateThreads();
	Except
		ErrorInformation = ErrorInfo();
		AddCompletionErrorText(AllErrorsText, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось завершить потоки обновления доступа по причине:
			           |%1'; 
			           |en = 'Cannot complete access update threads due to:
			           |%1'; 
			           |pl = 'Nie można ukończyć strumieni aktualizacji dostępu z powodu:
			           |%1';
			           |de = 'Fehler beim Abschließen der Zugriffsaktualisierungsdatenströme aufgrund von:
			           |%1';
			           |ro = 'Eșec la finalizarea fluxurilor de actualizare a accesului din motivul:
			           |%1';
			           |tr = 'Aşağıdakilerden dolayı erişim güncelleme akışlarını tamamlayamadı:
			           |%1'; 
			           |es_ES = 'No se ha podido terminar los flujos de actualización de acceso a causa de:
			           |%1'"),
			DetailErrorDescription(ErrorInformation)));
	EndTry;
	
	Try
		CancelAccessUpdateThreadsBackgroundJobs(2);
	Except
		ErrorInformation = ErrorInfo();
		AddCompletionErrorText(AllErrorsText, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось отменить фоновые задания потоков обновления доступа по причине:
			           |%1'; 
			           |en = 'Cannot cancel background jobs of access update threads due to:
			           |%1'; 
			           |pl = 'Nie można cofnąć strumieni aktualizacji dostępu do zadań w tle z powodu:
			           |%1';
			           |de = 'Die Hintergrundjobs der Zugriffsaktualisierungsströme konnten aus diesem Grund nicht abgebrochen werden:
			           |%1';
			           |ro = 'Eșec la revocarea sarcinilor de fundal ale fluxurilor de actualizare a accesului din motivul:
			           |%1';
			           |tr = 'Erişim güncelleştirme iş parçacıklarının arka plan işlerini neden geri alınamadı:
			           |%1'; 
			           |es_ES = 'No se ha podido cancelar tareas de fondo de flujos de actualización de acceso a causa de:
			           |%1'"),
			DetailErrorDescription(ErrorInformation)));
	EndTry;
	
	AddCompletionErrorText(AllErrorsText, PlanningErrorText);
	AddCompletionErrorText(AllErrorsText, CompletionErrorText);
	
	LastAccessUpdate.CompletionErrorText = AllErrorsText;
	LastAccessUpdate.EndDateAtServer = CurrentDateAtServer();
	LastAccessUpdate.LastRunSeconds =
		LastAccessUpdate.EndDateAtServer - LastAccessUpdate.StartDateAtServer;
	
	BeginTransaction();
	Try
		DataLock.Lock();
		ConstantValue = Constants.LastAccessUpdate.Get();
		CurrentLastAccessUpdate = LastAccessUpdate(ConstantValue);

		LastAccessUpdate.AccessUpdateProhibited =
			CurrentLastAccessUpdate.AccessUpdateProhibited;
		
		Constants.LastAccessUpdate.Set(New ValueStorage(LastAccessUpdate));
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Not ValueIsFilled(AllErrorsText) Then
		Return;
	EndIf;
	
	AllErrorsText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Не удалось выполнить обновление доступа по причине:
		           |%1'; 
		           |en = 'Cannot update access due to:
		           |%1'; 
		           |pl = 'Nie można zaktualizować dostępu z powodu:
		           |%1';
		           |de = 'Konnte den Zugriff aus dem Grund nicht aktualisieren:
		           |%1';
		           |ro = 'Eșec la executarea actualizării accesului din motivul:
		           |%1';
		           |tr = 'Erişim güncellemesi 
		           |%1 nedeniyle yürütülemedi.'; 
		           |es_ES = 'No se ha podido actualizar el acceso a causa de:
		           |%1'"), AllErrorsText);
	
	If RaiseExceptiopnInsteadErrorRegistration Then
		Raise AllErrorsText;
	Else
		RegisterAccessUpdateError(AllErrorsText,
			New Structure("MainSessionDetails", MainSessionDetails));
	EndIf;
	
EndProcedure

// For the StartAccessUpdateAtRecordLevel function.
Function AccessUpdateScheduled()
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|
	|UNION ALL
	|
	|SELECT TOP 1
	|	TRUE
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate";
	
	Return Not Query.Execute().IsEmpty();
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function, the AccessUpdateAtRecordLevel and 
// CancelAccessUpdateAtRecordLevel procedures, and the AccessUpdateAtRecordLevel form.
// 
//
Function LastAccessUpdate(CurrentValue = Undefined) Export
	
	If CurrentValue = Undefined Then
		Query = New Query;
		Query.Text =
		"SELECT
		|	LastAccessUpdate.Value AS Value
		|FROM
		|	Constant.LastAccessUpdate AS LastAccessUpdate";
		
		Selection = Query.Execute().Select();
		CurrentValue = ?(Selection.Next(), Selection.Value, Undefined);
	EndIf;
	
	Properties = New Structure;
	Properties.Insert("StartDateAtServer",      '00010101');
	Properties.Insert("EndDateAtServer",   '00010101');
	Properties.Insert("UpdateCanceled",        False);
	Properties.Insert("LastRunSeconds", 0);
	Properties.Insert("CompletionErrorText",     "");
	Properties.Insert("SessionNumber",               0);
	Properties.Insert("SessionStarted",              '00010101');
	Properties.Insert("ComputerName",             "");
	Properties.Insert("AccessUpdateProhibited", False);
	Properties.Insert("BackgroundJobID",
		CommonClientServer.BlankUUID());
	Properties.Insert("LastObsoleteItemsProcessingPlanning", '00010101');
	
	If TypeOf(CurrentValue) <> Type("ValueStorage") Then
		Return Properties;
	EndIf;
	
	CurrentProperties = CurrentValue.Get();
	
	If TypeOf(CurrentProperties) <> Type("Structure") Then
		Return Properties;
	EndIf;
	
	FillPropertyValues(Properties, CurrentProperties);
	
	Return Properties;
	
EndFunction

// For the StartAccessUpdateAtRecordLevel function, the AccessUpdateAtRecordLevel and 
// CancelAccessUpdateAtRecordLevel procedures, and the AccessUpdateAtRecordLevel form.
// 
//
Function AccessUpdateAssignee(LastAccessUpdate, IDOfJobToExclude = Undefined) Export
	
	If ValueIsFilled(LastAccessUpdate.BackgroundJobID) Then
		If LastAccessUpdate.BackgroundJobID = ArbitrarySessionID() Then
			Sessions = GetInfoBaseSessions();
			For Each Session In Sessions Do
				If Session.SessionNumber  = LastAccessUpdate.SessionNumber
				   AND Session.SessionStarted = LastAccessUpdate.SessionStarted Then
					Return Session;
				EndIf;
			EndDo;
		Else
			ActiveBackgroundJob = BackgroundJobs.FindByUUID(
				LastAccessUpdate.BackgroundJobID);
		
			If ActiveBackgroundJob <> Undefined
			   AND ActiveBackgroundJob.State = BackgroundJobState.Active Then
				
				Return ActiveBackgroundJob;
			EndIf;
		EndIf;
	EndIf;
	
	Filter = New Structure("State, MethodName", BackgroundJobState.Active,
		Metadata.ScheduledJobs.AccessUpdateAtRecordLevel.MethodName);
	
	FoundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	For Each FoundJob In FoundJobs Do
		If FoundJob.UUID <> IDOfJobToExclude Then
			Return FoundJob;
		EndIf;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the AccessUpdateAtRecordLevel and AccessUpdateAssignee procedures.
Function ArbitrarySessionID()
	
	Return New UUID("ba4730f7-0493-402d-b5d3-8052c80fb125");
	
EndFunction

// For the AccessUpdateAtRecordLevel procedure.
Procedure CheckUpdateActiveAccessRestrictionParameters()
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ExtensionsVersionUpdateDate = Catalogs.ExtensionsVersions.LastExtensionsVersion().UpdateDate;
	
	AllApplicationParametersUpdateDate =
		InformationRegisters.ApplicationParameters.AllApplicationParametersUpdateDate();
	
	LastFillingDateOfAllExtensionsParameters =
		InformationRegisters.ExtensionVersionParameters.LastFillingDateOfAllExtensionsParameters();
	
	ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	AccessRestrictionParametersCreationDate = SessionParameters.AccessRestrictionParameters.CreationDate;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
	AccessRestrictionParametersCheckDate = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	If TypeOf(AccessRestrictionParametersCheckDate) <> Type("Date") Then
		AccessRestrictionParametersCheckDate = '00010101';
	EndIf;
	
	SetPrivilegedMode(False);
	SetSafeModeDisabled(False);
	
	If AccessRestrictionParametersCheckDate > AccessRestrictionParametersCreationDate Then
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCheckDate;
	Else
		AccessRestrictionParametersRelevanceDate = AccessRestrictionParametersCreationDate;
	EndIf;
	
	If ExtensionsVersionUpdateDate                         > AccessRestrictionParametersRelevanceDate
	 Or AllApplicationParametersUpdateDate            > AccessRestrictionParametersRelevanceDate
	 Or LastFillingDateOfAllExtensionsParameters > AccessRestrictionParametersRelevanceDate Then
		
		ActiveAccessRestrictionParameters(Undefined, Undefined, True);
	EndIf;
	
EndProcedure

// For procedures AccessUpdateAtRecordLevel, ExecuteAccessUpdate,
// CancelAccessUpdateAtRecordLevel, CompleteAccessUpdate.
//
Procedure CompleteAccessUpdateThreads(CancelUpdate = False)
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	
	If CancelUpdate Then
		RecordSet.Add().ThreadID = CancelUpdateAtRecordLevelID();
	Else
		Query = New Query;
		Query.Text =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.UsersAccessKeysCurrentJobs AS UsersAccessKeysCurrentJobs";
		
		If Query.Execute().IsEmpty() Then
			Return;
		EndIf;
	EndIf;
	
	RecordSet.Write();
	
EndProcedure

// For the ProcessExecutedJobs and CompleteAccessUpdateThreads procedures.
Function CancelUpdateAtRecordLevelID()
	
	Return New UUID("06cc4b5f-a2f9-4622-bef0-df4870ab5dd5");
	
EndFunction

// For procedures AccessUpdateAtRecordLevel, ExecuteAccessUpdate,
// CancelAccessUpdateAtRecordLevel, CompleteAccessUpdate.
//
Procedure CancelAccessUpdateThreadsBackgroundJobs(WaitSeconds = 5)
	
	Filter = New Structure;
	Filter.Insert("State", BackgroundJobState.Active);
	Filter.Insert("MethodName", AccessUpdateThreadMethodName());
	
	ThreadsBackgroundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
	Try
		BackgroundJobs.WaitForCompletion(ThreadsBackgroundJobs, WaitSeconds);
	Except
		ThreadsBackgroundJobs = BackgroundJobs.GetBackgroundJobs(Filter);
		For Each ThreadBackgroundJob In ThreadsBackgroundJobs Do
			ThreadBackgroundJob.Cancel();
		EndDo;
	EndTry;
	
EndProcedure

// Updates access keys to data based on information register records
// DataAccessKeysUpdate and user access keys based on records of the UsersAccessKeysUpdate 
// information register.
//
// Data batch for each table is updated starting from the most recent data.
// The procedure must be called again until the data processor is completed, while the scheduled job 
// is stopped.
//
// The procedure is designed to function in a single copy without parallel operation (call from the 
// AccessUpdateAtRecordLevel scheduled job procedure).
// Parallel operation is ensured by the procedure itself by running up to two background jobs for 
// each list, but not more than the AccessUpdateThreadsCount constant value.
//
Procedure ExecuteAccessUpdate(UpdateAll, MainSessionDetails, UpdateCanceled, CompletionErrorText)
	
	Context = New Structure;
	Context.Insert("MainSessionDetails",  MainSessionDetails);
	Context.Insert("CurrentBackgroundJob",    MainSessionDetails.BackgroundJob);
	Context.Insert("Jobs",                  UpdateJobsTable());
	Context.Insert("JobsForStartup",        New Array);
	Context.Insert("LockedThreads",            New Map);
	Context.Insert("FreeThreads",          New Array);
	Context.Insert("JobsUpdateBoundary", '00010101');
	Context.Insert("CommonUpdateParameters", CommonUpdateParametersDetails());
	Context.Insert("UpdateInThisSession",    False);
	Context.Insert("ThreadsCount",        0);
	Context.Insert("CompletionErrorText",    "");
	Context.Insert("HasDeferredJobs",    False);
	Context.Insert("HasStartedJob",    True);
	Context.Insert("ProcessingCompleted",       False);
	Context.Insert("UpdateCanceled",       False);
	Context.Insert("MaxBatchesFromOriginalItem", 0);
	Context.Insert("AdditionalBatchesCount", 0);
	Context.Insert("AccessGroupsSetsCatalogID",
		Common.MetadataObjectID("Catalog.SetsOfAccessGroups"));
	MainSessionDetails.Delete("BackgroundJob");
	
	Query = New Query;
	Query.Text = JobsQueryText();
	Query.SetParameter("MaxDate", MaxDate());
	Query.SetParameter("BlankID",
		CommonClientServer.BlankUUID());
	
	CompleteAccessUpdateThreads();
	CancelAccessUpdateThreadsBackgroundJobs(1);
	
	Jobs = Context.Jobs;
	LockedThreads = Context.LockedThreads;
	ExecutionEnd = CurrentSessionDate()
		+ MaxCountOfMinutesToPerformBackgroundAccessUpdateJob() * 60;
	
	FillThreadsCount(Context);
	Context.Insert("Indicators", LeadingThreadUpdateIndicators(Context));
	
	While True Do
		If Not UpdateAll AND CurrentSessionDate() > ExecutionEnd
		 Or ValueIsFilled(Context.CompletionErrorText) Then
			Break;
		EndIf;
		Context.ProcessingCompleted = True;
		
		FillThreadsCount(Context);
		ProcessExecutedJobs(Context);
		
		If Context.UpdateCanceled Then
			Context.ProcessingCompleted = False;
			Break;
		EndIf;
		
		QueryResults = Query.ExecuteBatch();
		AddAccessUpdateJobs(QueryResults, Context);
		
		If Context.ProcessingCompleted Then
			Break;
		EndIf;
		
		CurrentStartupCompletion = CurrentSessionDate() + 5;
		Context.Insert("FirstPass", True);
		
		While True Do
			
			If Not UpdateAll AND CurrentSessionDate() > ExecutionEnd
			 Or CurrentSessionDate() > CurrentStartupCompletion
			 Or ValueIsFilled(Context.CompletionErrorText)
			 Or Jobs.Count() = 0
			 Or Context.UpdateCanceled Then
				Break;
			EndIf;
			
			AbortPass = False;
			PassAbortionMoment = CurrentUniversalDateInMilliseconds() + 1000;
			FillCommonUpdateParameters(Context);
			Context.HasStartedJob = False;
			JobsForStartup = Context.JobsForStartup;
			
			For Each Job In JobsForStartup Do
				
				While LockedThreads.Count() >= Context.ThreadsCount Do
					ProcessExecutedJobs(Context);
					
					If Context.UpdateCanceled Then
						AbortPass = True;
						Break;
					EndIf;
					
					If LockedThreads.Count() >= Context.ThreadsCount Then
						If Not UpdateAll AND CurrentSessionDate() > ExecutionEnd
						 Or CurrentSessionDate() > CurrentStartupCompletion Then
							AbortPass = True;
							Break;
						EndIf;
						WaitForThreadToUnlock(Context, True);
						If Not Context.FirstPass
						   AND CurrentUniversalDateInMilliseconds() > PassAbortionMoment Then
							AbortPass = True;
							Break;
						EndIf;
					EndIf;
				EndDo;
				If AbortPass Then
					Break;
				EndIf;
				If LockedThreads.Count() < Context.ThreadsCount Then
					StartListAccessUpdate(Job, Context);
					If ValueIsFilled(Context.CompletionErrorText) Then
						Break;
					EndIf;
				EndIf;
			EndDo;
			If Not Context.HasStartedJob
			   AND (LockedThreads.Count() >= Context.ThreadsCount
			      Or Not Context.HasDeferredJobs) Then
				
				WaitForThreadToUnlock(Context, True);
			EndIf;
			ProcessExecutedJobs(Context);
			Context.FirstPass = False;
		EndDo;
	EndDo;
	
	CompleteAccessUpdate(Context);
	
	CompletionErrorText = Context.CompletionErrorText;
	UpdateCanceled    = Context.UpdateCanceled;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Function UpdateJobsTable()
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	Jobs = New ValueTable;
	Jobs.Columns.Add("HasSpotJob",                    New TypeDescription("Boolean"));
	Jobs.Columns.Add("HasInitialUpdateOfSpotJob",New TypeDescription("Date"));
	Jobs.Columns.Add("SpotJobLastRunDate",  New TypeDescription("Date"));
	Jobs.Columns.Add("SpotJobAddedOn",         New TypeDescription("Date"));
	Jobs.Columns.Add("DependencyLevel",                     New TypeDescription("Number"));
	Jobs.Columns.Add("DependentLists",                        New TypeDescription("Array,String"));
	Jobs.Columns.Add("HasInitialUpdate",                New TypeDescription("Boolean"));
	Jobs.Columns.Add("HasRestart",                         New TypeDescription("Boolean"));
	Jobs.Columns.Add("CommonJobLastRunDate",     New TypeDescription("Date"));
	Jobs.Columns.Add("HasLastUpdatedItemDate", New TypeDescription("Boolean"));
	Jobs.Columns.Add("LatestUpdatedItemDate",     New TypeDescription("Date"));
	Jobs.Columns.Add("CommonJobAddedOn",            New TypeDescription("Date"));
	Jobs.Columns.Add("ListID",                    New TypeDescription(IDsTypes));
	Jobs.Columns.Add("ForExternalUsers",                New TypeDescription("Boolean"));
	Jobs.Columns.Add("IsRightsUpdate",                      New TypeDescription("Boolean"));
	Jobs.Columns.Add("Run",                              New TypeDescription("Boolean"));
	Jobs.Columns.Add("AdditionalStartup",                   New TypeDescription("Boolean"));
	Jobs.Columns.Add("LockedThreads",                          New TypeDescription("Map"));
	Jobs.Columns.Add("BatchesSet",                            New TypeDescription("Array"));
	Jobs.Columns.Add("BatchesToProcessCount",           New TypeDescription("Number"));
	Jobs.Columns.Add("IndexOfLastBatchToProcess",      New TypeDescription("Number"));
	Jobs.Columns.Add("Ignore",                             New TypeDescription("Boolean"));
	Jobs.Columns.Add("Delete",                                New TypeDescription("Boolean"));
	Jobs.Columns.Add("DataKeyKindOrder",                 New TypeDescription("Number"));
	Jobs.Columns.Add("IsObsoleteItemsDataProcessor",        New TypeDescription("Boolean"));
	Jobs.Columns.Add("UpdateDependencyLevel",             New TypeDescription("Boolean"));
	
	Jobs.Indexes.Add(
		"HasSpotJob,
		|HasInitialUpdateOfSpotJob,
		|SpotJobLastRunDate,
		|SpotJobAddedOn,
		|HasInitialUpdate,
		|CommonJobLastRunDate,
		|HasLastUpdatedItemDate,
		|LatestUpdatedItemDate,
		|CommonJobAddedOn");
	
	Jobs.Indexes.Add("ListID, ForExternalUsers, IsRightsUpdate");
	Jobs.Indexes.Add("Delete, IsObsoleteItemsDataProcessor");
	Jobs.Indexes.Add("DependencyLevel");
	
	Return Jobs;
	
EndFunction

// For the AddAccessUpdateJobs procedure.
Function JobsKeysTable()
	
	IDsTypes = New Array;
	IDsTypes.Add(Type("CatalogRef.MetadataObjectIDs"));
	IDsTypes.Add(Type("CatalogRef.ExtensionObjectIDs"));
	
	Jobs = New ValueTable;
	Jobs.Columns.Add("ListID",     New TypeDescription(IDsTypes));
	Jobs.Columns.Add("ForExternalUsers", New TypeDescription("Boolean"));
	Jobs.Columns.Add("IsRightsUpdate",       New TypeDescription("Boolean"));
	
	Jobs.Indexes.Add("ListID, ForExternalUsers, IsRightsUpdate");
	
	Return Jobs;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Function NewThread()
	
	Thread = New Structure;
	Thread.Insert("ThreadID");
	Thread.Insert("BackgroundJob");
	Thread.Insert("Job");
	Thread.Insert("CancelJob", False);
	Thread.Insert("BatchFromSet");
	Thread.Insert("ReleaseDate", '00010101');
	
	Return Thread;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Function CommonUpdateParametersDetails(Context = Undefined)
	
	CommonUpdateParameters = New Structure;
	CommonUpdateParameters.Insert("IsRightsUpdate",            False);
	CommonUpdateParameters.Insert("ListID",          Undefined);
	CommonUpdateParameters.Insert("ForExternalUsers",      False);
	CommonUpdateParameters.Insert("StartDate",                   '00010101');
	CommonUpdateParameters.Insert("EndDate",                '00010101');
	CommonUpdateParameters.Insert("InitialUpdate",          False);
	CommonUpdateParameters.Insert("ProcessingCompleted",           True);
	CommonUpdateParameters.Insert("MaxProcessingMilliseconds", 1000);
	
	If Context = Undefined Then
		CommonUpdateParameters.Insert("AccessGroupsSetsCatalogID",
			Common.MetadataObjectID("Catalog.SetsOfAccessGroups"));
	Else
		CommonUpdateParameters.Insert("AccessGroupsSetsCatalogID",
			Context.AccessGroupsSetsCatalogID);
		
		If Context.UpdateInThisSession Then
			CommonUpdateParameters.Insert("Cache", Context.Cache);
		EndIf;
		CommonUpdateParameters.Insert("MaxBatchesFromOriginalItem", Context.MaxBatchesFromOriginalItem);
	EndIf;
	
	Return CommonUpdateParameters;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Function JobsQueryText()
	
	Return
	"SELECT
	|	FALSE AS IsRightsUpdate,
	|	Lists.List AS ListID,
	|	Lists.ForExternalUsers AS ForExternalUsers,
	|	MAX(Lists.SpotJob) AS HasSpotJob,
	|	MAX(Lists.SpotJob
	|			AND Lists.LatestUpdatedItemDate = &MaxDate) AS HasInitialUpdateOfSpotJob,
	|	MAX(CASE
	|			WHEN Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS SpotJobAddedOn,
	|	MAX((NOT Lists.SpotJob
	|			OR Lists.UniqueKey = &BlankID)
	|			AND Lists.LatestUpdatedItemDate = &MaxDate) AS HasInitialUpdate,
	|	MAX(NOT Lists.SpotJob
	|			AND Lists.UniqueKey <> &BlankID) AS HasRestart,
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					OR Lists.UniqueKey = &BlankID
	|				THEN Lists.LatestUpdatedItemDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS LatestUpdatedItemDate,
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END) AS CommonJobAddedOn
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers
	|
	|UNION ALL
	|
	|SELECT
	|	TRUE,
	|	Lists.List,
	|	Lists.ForExternalUsers,
	|	MAX(Lists.SpotJob),
	|	FALSE,
	|	MAX(CASE
	|			WHEN Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END),
	|	FALSE,
	|	MAX(NOT Lists.SpotJob
	|			AND Lists.UniqueKey <> &BlankID),
	|	DATETIME(1, 1, 1),
	|	MAX(CASE
	|			WHEN NOT Lists.SpotJob
	|					AND Lists.UniqueKey <> &BlankID
	|				THEN Lists.RegisterRecordChangeDate
	|			ELSE DATETIME(1, 1, 1)
	|		END)
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS Lists
	|
	|GROUP BY
	|	Lists.List,
	|	Lists.ForExternalUsers";
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Procedure FillThreadsCount(Context)
	
	If Context.UpdateInThisSession Then
		Return;
	EndIf;
	
	If Common.FileInfobase() Then
		ThreadsCount = 1;
		Context.MaxBatchesFromOriginalItem = 5;
	Else
		ThreadsCount = Constants.AccessUpdateThreadsCount.Get();
		Context.MaxBatchesFromOriginalItem = 5 + (ThreadsCount - 1) * 2;
	EndIf;
	
	If ThreadsCount < 1 Then
		ThreadsCount = 1;
	EndIf;
	
	If Context.ThreadsCount = 0 Then
		Context.UpdateInThisSession = ThreadsCount = 1;
	EndIf;
	
	Context.ThreadsCount = ThreadsCount;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure AddAccessUpdateJobs(QueryResults, Context)
	
	If Context.Property("Cache") Then
		Cache = Context.Cache;
	Else
		Cache = New Structure;
		Context.Insert("Cache", Cache);
		Context.Insert("IDsByFullNames", New Map);
		Context.Insert("RestrictionParametersVersion");
		Context.Insert("REstrictionParametersHashsum");
	EndIf;
	If Not Cache.Property("MetadataObjectsByIDs") Then
		Cache.Insert("MetadataObjectsByIDs", New Map);
	EndIf;
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	Jobs = Context.Jobs;
	ListsIDs = New Array;
	
	If Context.RestrictionParametersVersion   <> SessionParameters.AccessRestrictionParameters.Version
	 Or Context.REstrictionParametersHashsum <> SessionParameters.AccessRestrictionParameters.HashSum Then
		
		Jobs.FillValues(-1, "DependencyLevel");
		Jobs.FillValues(Undefined, "DependentLists");
		Context.Insert("IDsByFullNames", New Map);
		Context.Insert("LeadingListsByDependentOnes", JobsKeysTable());
		Context.LeadingListsByDependentOnes.Columns.Add("LeadingLists");
		
		CurrentListIDs = Jobs.Copy(, "ListID");
		CurrentListIDs.GroupBy("ListID");
		ListsIDs = CurrentListIDs.UnloadColumn("ListID");
		
		Context.RestrictionParametersVersion   = SessionParameters.AccessRestrictionParameters.Version;
		Context.REstrictionParametersHashsum = SessionParameters.AccessRestrictionParameters.HashSum;
	EndIf;
	
	Jobs.FillValues(True, "Delete");
	Filter = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	
	DataExported = QueryResults[0].Unload();
	If DataExported.Count() > 0 Then
		Context.ProcessingCompleted = False;
	EndIf;
	
	For Each String In DataExported Do
		FillPropertyValues(Filter, String);
		Rows = Jobs.FindRows(Filter);
		If Rows.Count() = 0 Then
			Job = Jobs.Add();
			Job.DependencyLevel = -1; // Blank.
			If String.ListID <> Undefined
			   AND Cache.MetadataObjectsByIDs.Get(String.ListID) = Undefined Then
				ListsIDs.Add(String.ListID);
			EndIf;
		Else
			Job = Rows[0];
		EndIf;
		FillPropertyValues(Job, String);
		Job.Delete = False;
		UpdateIsObsoleteItemsDataProcessorProperty(Job, False);
		Job.HasLastUpdatedItemDate
			= ValueIsFilled(Job.LatestUpdatedItemDate);
		
		If Job.HasRestart Then
			CancelJob(Job);
		EndIf;
	EndDo;
	
	If ListsIDs.Count() > 0 Then
		MetadataObjectsByIDs =
			Common.MetadataObjectsByIDs(ListsIDs, False);
		For Each KeyAndValue In MetadataObjectsByIDs Do
			Cache.MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
			If TypeOf(KeyAndValue.Value) = Type("MetadataObject") Then
				Context.IDsByFullNames.Insert(KeyAndValue.Value.FullName(), KeyAndValue.Key);
			EndIf;
		EndDo;
	EndIf;
	
	FillJobsDependencyLevels(Context, ActiveParameters.LeadingLists);
	
EndProcedure

// For the AddAccessUpdateJobs and UpdateJobProperties procedures and the StartListAccessUpdate 
// function.
//
Procedure UpdateIsObsoleteItemsDataProcessorProperty(Job, DependencyLevelOnChangeUpdateRequired = True)
	
	IsObsoleteItemsDataProcessor = Not Job.HasSpotJob
		AND Job.DataKeyKindOrder >= DataKeyKindOrder("ObsoleteItems")
		AND Job.DataKeyKindOrder < DataKeyKindOrder("NoData");
	
	If Job.IsObsoleteItemsDataProcessor <> IsObsoleteItemsDataProcessor Then
		Job.IsObsoleteItemsDataProcessor = IsObsoleteItemsDataProcessor;
		Job.UpdateDependencyLevel = DependencyLevelOnChangeUpdateRequired;
	EndIf;
	
EndProcedure

// For the AddAccessUpdateJobs procedure.
Procedure FillJobsDependencyLevels(Context, LeadingListsProperties)
	
	Jobs = Context.Jobs;
	MetadataObjectsByIDs = Context.Cache.MetadataObjectsByIDs;
	IDsByFullNames       = Context.IDsByFullNames;
	
	JobsForFilling = Jobs.FindRows(New Structure("DependencyLevel", -1));
	LeadingListsByDependentOnes = Context.LeadingListsByDependentOnes;
	JobFilter = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	
	For Each Job In JobsForFilling Do
		SetDependencyLevelByLeadingLists(Job, Jobs, LeadingListsByDependentOnes);
		
		MetadataObject = MetadataObjectsByIDs.Get(Job.ListID);
		If TypeOf(MetadataObject) <> Type("MetadataObject") Then
			Continue;
		EndIf;
		FullName = MetadataObject.FullName();
		LeadingListProperties = LeadingListsProperties.Get(FullName);
		If LeadingListProperties = Undefined
		 Or LeadingListProperties.ByAccessKeys = Undefined Then
			Continue;
		EndIf;
		DependentLists = LeadingListProperties.ByAccessKeys[?(Job.ForExternalUsers,
			"ForExternalUsers", "ForUsers")];
		If DependentLists = Undefined Then
			Continue;
		EndIf;
		FillPropertyValues(JobFilter, Job);
		For Each DependentList In DependentLists Do
			DependentListID = IDsByFullNames.Get(DependentList);
			If Job.DependentLists = Undefined Then
				Job.DependentLists = New Array;
			EndIf;
			Job.DependentLists.Add(DependentListID);
			JobFilter.ListID = DependentListID;
			FoundItems = LeadingListsByDependentOnes.FindRows(JobFilter);
			If FoundItems.Count() = 0 Then
				LeadingLists = New Map;
				NewString = LeadingListsByDependentOnes.Add();
				FillPropertyValues(NewString, JobFilter);
				NewString.LeadingLists = LeadingLists;
			Else
				LeadingLists = FoundItems[0].LeadingLists;
			EndIf;
			LeadingLists.Insert(Job.ListID, True);
			DependentJobs = Jobs.FindRows(JobFilter);
			If DependentJobs.Count() > 0 Then
				SetDependencyLevelByLeadingLists(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the FillJobsDependencyLevels and UpdateDependencyLevel procedures.
Procedure SetDependencyLevelByLeadingLists(Job, Jobs, LeadingListsByDependentOnes)
	
	Job.DependencyLevel = 0;
	If Job.IsObsoleteItemsDataProcessor Then
		Return;
	EndIf;
	
	JobFilter = New Structure("ListID, ForExternalUsers, IsRightsUpdate",
		Job.ListID, Job.ForExternalUsers, Job.IsRightsUpdate);
	
	FoundItems = LeadingListsByDependentOnes.FindRows(JobFilter);
	If FoundItems.Count() = 0 Then
		Return;
	EndIf;
	
	JobFilter.Insert("IsObsoleteItemsDataProcessor", False);
	
	For Each LeadingListDetails In FoundItems[0].LeadingLists Do
		JobFilter.ListID = LeadingListDetails.Key;
		LeadingJobs = Jobs.FindRows(JobFilter);
		If LeadingJobs.Count() = 0 Then
			Continue;
		EndIf;
		If Job.DependencyLevel < LeadingJobs[0].DependencyLevel + 1 Then
			Job.DependencyLevel = LeadingJobs[0].DependencyLevel + 1;
		EndIf;
	EndDo;
	
EndProcedure

// For the FillCommonUpdateParameters procedure.
Procedure UpdateDependencyLevel(JobProperties, Jobs, LeadingListsByDependentOnes)
	
	If Not ValueIsFilled(JobProperties.DependentLists) Then
		Return;
	EndIf;
	JobFilter = New Structure("ListID, ForExternalUsers, IsRightsUpdate");
	FillPropertyValues(JobFilter, JobProperties);
	
	For Each DependentList In JobProperties.DependentLists Do
		JobFilter.ListID = DependentList;
		DependentJobs = Jobs.FindRows(JobFilter);
		If DependentJobs.Count() = 0 Then
			Continue;
		EndIf;
		SetDependencyLevelByLeadingLists(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
		UpdateDependencyLevel(DependentJobs[0], Jobs, LeadingListsByDependentOnes);
	EndDo;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure FillCommonUpdateParameters(Context)
	
	Jobs = Context.Jobs;
	Jobs.Sort(
		"HasSpotJob Desc,
		|HasInitialUpdateOfSpotJob Desc,
		|SpotJobLastRunDate Asc,
		|SpotJobAddedOn Desc,
		|HasInitialUpdate Desc,
		|CommonJobLastRunDate Asc,
		|HasLastUpdatedItemDate Asc,
		|LatestUpdatedItemDate Desc,
		|CommonJobAddedOn Desc");
	
	JobsToDelete = Jobs.FindRows(New Structure("Delete", True));
	For Each Job In JobsToDelete Do
		If Not Job.Delete Or Job.LockedThreads.Count() > 0 Then
			Continue;
		EndIf;
		JobProperties = New Structure("ListID,
		|ForExternalUsers, IsRightsUpdate, DependentLists");
		FillPropertyValues(JobProperties, Job);
		Jobs.Delete(Job);
		UpdateDependencyLevel(JobProperties, Jobs, Context.LeadingListsByDependentOnes);
	EndDo;
	JobsToUpdateLevel = Jobs.FindRows(New Structure("UpdateDependencyLevel", True));
	For Each Job In JobsToUpdateLevel Do
		SetDependencyLevelByLeadingLists(Job, Jobs, Context.LeadingListsByDependentOnes);
		UpdateDependencyLevel(Job, Jobs, Context.LeadingListsByDependentOnes);
		Job.UpdateDependencyLevel = False;
	EndDo;
	
	LevelsFilter = New Structure("Delete, IsObsoleteItemsDataProcessor", False, False);
	Levels = Jobs.Copy(LevelsFilter, "DependencyLevel");
	Levels.GroupBy("DependencyLevel");
	Levels.Sort("DependencyLevel");
	LowestDependencyLevel = ?(Levels.Count() > 0, Levels[0].DependencyLevel, 0);
	IsObsoleteItemsDataProcessor = Levels.Count() = 0;
	LastDependentCommonJobStartupDate = '00010101';
	LastStartupDateOfCommonObsoleteOnesProcessingJob = '00010101';
	If Levels.Count() > 1 Or Not IsObsoleteItemsDataProcessor Then
		For Each Job In Jobs Do
			If Job.Delete
			 Or Job.HasSpotJob Then
				Continue;
			EndIf;
			If Job.DependencyLevel > LowestDependencyLevel
			   AND LastDependentCommonJobStartupDate < Job.CommonJobLastRunDate Then
				LastDependentCommonJobStartupDate = Job.CommonJobLastRunDate;
			EndIf;
			If Job.IsObsoleteItemsDataProcessor
			   AND LastStartupDateOfCommonObsoleteOnesProcessingJob < Job.CommonJobLastRunDate Then
				LastStartupDateOfCommonObsoleteOnesProcessingJob = Job.CommonJobLastRunDate;
			EndIf;
		EndDo;
	EndIf;
	CommonDependentJobToStart =
		?(LastDependentCommonJobStartupDate > CurrentSessionDate() - 10, Null, Undefined);
	
	CommonObsoleteOnesProcessingJobToStart =
		?(LastStartupDateOfCommonObsoleteOnesProcessingJob > CurrentSessionDate() - 15, Null, Undefined);
	
	CommonUpdateParameters = Context.CommonUpdateParameters;
	CommonUpdateParameters.InitialUpdate = False;
	LastDate = '00010101';
	AccessGroupsSetsCatalogJob = Undefined;
	WaitBoundaryForDependentJobs = CurrentSessionDate() - 3;
	
	For Each Job In Jobs Do
		If Job.Delete Then
			Continue;
		EndIf;
		If Job.ListID = Context.AccessGroupsSetsCatalogID Then
			AccessGroupsSetsCatalogJob = Job;
		EndIf;
		Job.AdditionalStartup = False;
		Job.Ignore = False;
		If Job.HasInitialUpdate Then
			CommonUpdateParameters.InitialUpdate = True;
		Else
			If Job.DependencyLevel > LowestDependencyLevel Then
				If Job.HasSpotJob Then
					If Job.SpotJobLastRunDate > WaitBoundaryForDependentJobs Then
						Job.Ignore = True;
						Continue;
					EndIf;
				ElsIf CommonDependentJobToStart <> Undefined Then
					Job.Ignore = True;
					Continue;
				Else
					CommonDependentJobToStart = Job;
				EndIf;
			EndIf;
			If Not IsObsoleteItemsDataProcessor AND Job.IsObsoleteItemsDataProcessor Then
				If CommonObsoleteOnesProcessingJobToStart <> Undefined Then
					Job.Ignore = True;
					Continue;
				Else
					CommonObsoleteOnesProcessingJobToStart = Job;
				EndIf;
			EndIf;
		EndIf;
		If Job.HasRestart Then
			CommonUpdateParameters.InitialUpdate = True;
		EndIf;
		If Job.LatestUpdatedItemDate > LastDate Then
			LastDate = Job.LatestUpdatedItemDate;
		EndIf;
	EndDo;
	
	If CommonUpdateParameters.InitialUpdate Then
		// Update start.
		CommonUpdateParameters.StartDate = BegOfDay(CurrentSessionDate()) - 7 * (60 * 60 * 24); // 7 Days.
	Else
		// Continue update.
		MaxPeriod = MaxGettingBatchesByQueryPeriod();
		
		If MaxPeriod = "Week" Then
			StartDate = BegOfWeek(LastDate);
			
		ElsIf MaxPeriod = "Month" Then
			StartDate = BegOfMonth(LastDate);
		Else
			ThisYear = Year(CurrentSessionDate()) - Year(LastDate) = 0;
			MonthOffset = Month(CurrentSessionDate()) - Month(LastDate);
			
			If ThisYear AND MonthOffset = 0 Then
				StartDate = BegOfMonth(LastDate);
				
			ElsIf ThisYear AND MonthOffset < 3 Or MaxPeriod = "Quarter" Then
				StartDate = BegOfQuarter(LastDate);
			Else
				StartDate = BegOfYear(LastDate);
			EndIf;
		EndIf;
		
		CommonUpdateParameters.StartDate = StartDate;
	EndIf;
	CommonUpdateParameters.EndDate = LastDate;
	
	JobsForStartup = New Array;
	Context.JobsForStartup = JobsForStartup;
	Context.HasDeferredJobs = False;
	
	If AccessGroupsSetsCatalogJob <> Undefined Then
		AccessGroupsSetsCatalogJob.Run = True;
		JobsForStartup.Add(AccessGroupsSetsCatalogJob);
		Context.HasDeferredJobs = Jobs.Count() > 1;
	Else
		For Each Job In Jobs Do
			If Job.Delete Or Job.Ignore Then
				Job.Run = False;
				If Job.Ignore Then
					Context.HasDeferredJobs = True;
				EndIf;
				Continue;
			EndIf;
			
			If Job.HasSpotJob Or Job.IsRightsUpdate Then
				Job.Run = True;
				
			ElsIf CommonUpdateParameters.InitialUpdate Then
				Job.Run = Job.HasInitialUpdate Or Job.HasRestart;
			Else
				Job.Run = Not UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
					Job.LatestUpdatedItemDate);
			EndIf;
			
			If Job.Run Then
				JobsForStartup.Add(Job);
			Else
				Context.HasDeferredJobs = True;
			EndIf;
		EndDo;
	EndIf;
	
	If Not LoadFreeThreadsWithNextJobsAtLongQueries() Then
		Context.HasDeferredJobs = False;
	EndIf;
	
	If Not Context.HasStartedJob
	   AND Context.HasDeferredJobs
	   AND Context.LockedThreads.Count() < Context.ThreadsCount Then
		
		Context.HasDeferredJobs = False;
		FreeThreadsCount = Context.ThreadsCount - Context.LockedThreads.Count();
		AdditionalJobsCount = 0;
		
		For Each Job In Jobs Do
			If Job.Delete Or Job.Run Then
				Continue;
			EndIf;
			If AdditionalJobsCount >= FreeThreadsCount Then
				Context.HasDeferredJobs = True;
				Break;
			EndIf;
			Job.Run = True;
			Job.AdditionalStartup = True;
			JobsForStartup.Add(Job);
			AdditionalJobsCount = AdditionalJobsCount + 1;
		EndDo;
	EndIf;
	
	MainJobsCount = JobsForStartup.Count();
	If MainJobsCount > 0 Then
		Context.AdditionalBatchesCount = Int(Context.ThreadsCount / MainJobsCount);
	Else
		Context.AdditionalBatchesCount = 0;
	EndIf;
	
	JobsCount = Jobs.Count();
	If JobsCount = 0 Then
		ThreadsSufficiency = 0;
	ElsIf Context.ThreadsCount > JobsCount Then
		ThreadsSufficiency = 1;
	Else
		ThreadsSufficiency = Context.ThreadsCount / JobsCount;
	EndIf;
	LoadFromThreads = Context.ThreadsCount * 0.025;
	If LoadFromThreads > 1 Then
		LoadFromThreads = 1;
	EndIf;
	CommonUpdateParameters.MaxProcessingMilliseconds =
		Int(MinSecondsCountOfBatchProcessingInSingleThread() * 1000
		* (1 + LoadFromThreads) * (1 + ThreadsSufficiency));
	
EndProcedure

// For procedures AddAccessUpdateJobs, StartListAccessUpdate,
// ExecuteUpdateListAccess.
//
Function UpdatePeriodToDataPeriod(StartDate, LatestUpdatedItemDate)
	
	// StartDate - for example, it is 01.01.2012 and end date is 31.12.2012, in this case, 
	// LatestUpdatedItemDate is, for example, 03.01.2013.
	// In this case, data for update is older than update period.
	Return ValueIsFilled(LatestUpdatedItemDate)
		  AND StartDate > LatestUpdatedItemDate;
	
EndFunction

// For the ExecuteAccessUpdate procedure.
Procedure CompleteAccessUpdate(Context)
	
	If Not Context.UpdateCanceled Then
		If ValueIsFilled(Context.CompletionErrorText) Then
			WaitBoundary = CurrentSessionDate() + 3;
		Else
			WaitBoundary = CurrentSessionDate() + 15;
		EndIf;
		While Context.LockedThreads.Count() > 0 Do
			WaitForThreadToUnlock(Context);
			ProcessExecutedJobs(Context);
			If CurrentSessionDate() > WaitBoundary Then
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	CompleteAccessUpdateThreads();
	CancelAccessUpdateThreadsBackgroundJobs();
	
	Try
		If Context.ProcessingCompleted Then
			UpdateRightsToAllowedAccessKey();
			
			Context.Insert("DataLockWaitingError", False);
			Try
				DisableScheduledJobIfNoNewJobs(Context);
			Except
				If Not Context.DataLockWaitingError Then
					Raise;
				EndIf;
			EndTry;
			If Not Constants.FirstAccessUpdateCompleted.Get() Then
				Constants.FirstAccessUpdateCompleted.Set(True);
			EndIf;
		EndIf;
	Except
		RegisterMainThreadUpdateIndicators(Context);
		Raise;
	EndTry;
	
	RegisterMainThreadUpdateIndicators(Context);
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Procedure DisableScheduledJobIfNoNewJobs(Context)
	
	Query = New Query;
	Query.SetParameter("UnavailableListsForDataAccessKeyUpdate",       New Array);
	Query.SetParameter("UnavailableListsForUserAccessKeyUpdate", New Array);
	Query.Text =
	"SELECT DISTINCT
	|	DataAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|WHERE
	|	NOT DataAccessKeysUpdate.List IN (&UnavailableListsForDataAccessKeyUpdate)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UsersAccessKeysUpdate.List AS List
	|FROM
	|	InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate
	|WHERE
	|	NOT UsersAccessKeysUpdate.List IN (&UnavailableListsForUserAccessKeyUpdate)";
	QueryResults = Query.ExecuteBatch();
	
	If Not QueryResults[0].IsEmpty() Then
		SetUnavailableLists(QueryResults[0],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Not QueryResults[1].IsEmpty() Then
		SetUnavailableLists(QueryResults[1],
			Query.Parameters.UnavailableListsForDataAccessKeyUpdate);
	EndIf;
	
	If Query.Parameters.UnavailableListsForDataAccessKeyUpdate.Count() > 0
	 Or Query.Parameters.UnavailableListsForUserAccessKeyUpdate.Count() > 0 Then
		
		QueryResults = Query.ExecuteBatch();
	EndIf;
	
	If QueryResults[0].IsEmpty()
	   AND QueryResults[1].IsEmpty() Then
		
		Lock = New DataLock;
		Lock.Add("InformationRegister.DataAccessKeysUpdate");
		Lock.Add("InformationRegister.UsersAccessKeysUpdate");
		BeginTransaction();
		Try
			Context.DataLockWaitingError = True;
			Lock.Lock();
			Context.DataLockWaitingError = False;
			
			QueryResults = Query.ExecuteBatch();
			
			If QueryResults[0].IsEmpty()
			   AND QueryResults[1].IsEmpty() Then
				
				SetAccessUpdate(False);
			Else
				Context.ProcessingCompleted = False;
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Context.ProcessingCompleted = False;
			Raise;
		EndTry;
	Else
		Context.ProcessingCompleted = False;
	EndIf;
	
EndProcedure

// For the DisableScheduledJobIfNoNewJobs procedure.
Procedure SetUnavailableLists(QueryResult, UnavailableLists)
	
	MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
		QueryResult.Unload().UnloadColumn("List"), False);
	
	For Each KeyAndValue In MetadataObjectsByIDs Do
		If KeyAndValue.Value = Undefined Then
			UnavailableLists.Add(KeyAndValue.Key);
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteAccessUpdate procedure.
Function StartListAccessUpdate(Job, Context)
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		Indicators.JobIssueStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ProcessExecutedJobs(Context, Job.LockedThreads);
	
	If ValueIsFilled(Context.CompletionErrorText) Then
		Return False;
	EndIf;
	
	If Job.LockedThreads.Count() > 0 AND Context.FirstPass Then
		Return True; // Already started.
	EndIf;
	
	If CommonJobBeingExecuted(Job)
	   AND Not StartGotBatchesUpdateOnGetNewBatches() Then
		Return True;
	EndIf;
	
	CommonUpdateParameters = CommonUpdateParametersDetails(Context);
	FillPropertyValues(CommonUpdateParameters, Context.CommonUpdateParameters);
	CommonUpdateParameters.IsRightsUpdate       = Job.IsRightsUpdate;
	CommonUpdateParameters.ListID     = Job.ListID;
	CommonUpdateParameters.ForExternalUsers = Job.ForExternalUsers;
	
	BatchesSet = Job.BatchesSet;
	LastIndex = BatchesSet.Count() - 1;
	
	IndexOfLastBatchToProcess = Job.IndexOfLastBatchToProcess;
	BatchToProcess = Undefined;
	For Index = IndexOfLastBatchToProcess To LastIndex Do
		ItemsBatch = BatchesSet.Get(Index);
		If Not ItemsBatch.Processed AND Not ItemsBatch.Processing Then
			BatchToProcess = ItemsBatch;
			Job.IndexOfLastBatchToProcess = Index;
			IndexOfLastBatchToProcess = Index + 1;
			Break;
		EndIf;
	EndDo;
	
	If BatchToProcess = Undefined Then
		Job.IndexOfLastBatchToProcess = LastIndex + 1;
		PreviousBatch = Undefined;
		
	ElsIf Index > 0 Then
		PreviousBatch = BatchesSet.Get(Index - 1);
	Else
		PreviousBatch = Undefined;
	EndIf;
	
	If Not Job.HasSpotJob AND BatchToProcess <> Undefined Then
		If UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
		         ?(PreviousBatch = Undefined, Job.LatestUpdatedItemDate,
		             PreviousBatch.LatestBatchItemDate)) Then
			Return True;
		EndIf;
		CommonUpdateParameters.Insert("BatchFromSet", BatchToProcess);
		BatchToProcess.Processing = True;
		Job.IndexOfLastBatchToProcess = IndexOfLastBatchToProcess;
	Else
		LastBatch = ?(LastIndex > -1, BatchesSet[LastIndex], Undefined);
		
		If LastBatch <> Undefined
		   AND (LastBatch.LastBatchItem.DataKeyKind
		       <> LastBatch.NewLastBatchItem.DataKeyKind
		      Or LastBatch.NewLastBatchItem.DataKey = Null
		      Or Not CommonUpdateParameters.IsRightsUpdate
		        AND UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
		              LastBatch.LatestBatchItemDate)) Then
			
			GetBatches = 0;
		Else
			BatchesToProcessCount = Job.BatchesToProcessCount;
			GetBatches = (Context.AdditionalBatchesCount + 2) * 2;
			If Job.HasSpotJob Then
				GetBatches = GetBatches - BatchesToProcessCount;
				If GetBatches - BatchesToProcessCount < Int(GetBatches / 3) Then
					GetBatches = Int(GetBatches / 3);
				Else
					GetBatches = GetBatches - BatchesToProcessCount;
				EndIf;
			EndIf;
		EndIf;
		
		If Not Job.HasSpotJob AND GetBatches = 0 Then
			Return True;
		EndIf;
		
		CommonUpdateParameters.Insert("GetBatches", GetBatches);
		If LastBatch <> Undefined Then
			CommonUpdateParameters.Insert("NewLastBatchItem",
				LastBatch.NewLastBatchItem);
		EndIf;
	EndIf;
	
	If Not CommonUpdateParameters.Property("BatchFromSet") AND CommonJobBeingExecuted(Job) Then
		Return True;
	EndIf;
	
	If Job.HasSpotJob Then
		Job.HasSpotJob = False;
		UpdateIsObsoleteItemsDataProcessorProperty(Job);
		Job.SpotJobLastRunDate = CurrentSessionDate();
	Else
		Job.CommonJobLastRunDate = CurrentSessionDate();
	EndIf;
	
	If Context.UpdateInThisSession Then
		UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context);
		ProcessJobResult(Context, CommonUpdateParameters, Job);
	Else
		For Each FreeThread In Context.FreeThreads Do
			Break;
		EndDo;
		If FreeThread = Undefined Then
			If Context.LockedThreads.Count() >= Context.ThreadsCount Then
				Return True;
			EndIf;
			FreeThread = NewThread();
			Parameters = New Array;
			Parameters.Add(Context.MainSessionDetails);
			FreeThread.BackgroundJob = BackgroundJobs.Execute(AccessUpdateThreadMethodName(), Parameters);
			FreeThread.ThreadID = FreeThread.BackgroundJob.UUID;
			Context.FreeThreads.Add(FreeThread);
		EndIf;
		
		ThreadID = FreeThread.ThreadID;
		RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
		RecordSet.Filter.ThreadID.Set(ThreadID);
		SetRecord = RecordSet.Add();
		SetRecord.ThreadID = ThreadID;
		SetRecord.IsStart = True;
		SetRecord.Parameters = New ValueStorage(CommonUpdateParameters);
		SetRecord.RegisterRecordChangeDate = CurrentSessionDate();
		
		RecordSet.Write();
		
		FreeThread.Job = Job;
		If CommonUpdateParameters.Property("BatchFromSet") Then
			FreeThread.BatchFromSet = CommonUpdateParameters.BatchFromSet;
		EndIf;
		Job.LockedThreads.Insert(ThreadID, FreeThread);
		Context.LockedThreads.Insert(ThreadID, FreeThread);
		Context.FreeThreads.Delete(0);
		If Indicators <> Undefined Then
			RemoveJobsIssueIndicators(Indicators);
		EndIf;
		Context.HasStartedJob = True;
	EndIf;
	
	Return True;
	
EndFunction

// For the StartListAccessUpdate function and the ProcessJobResult procedure.
Function CommonJobBeingExecuted(Job)
	
	For Each LockedThreadDetails In Job.LockedThreads Do
		If LockedThreadDetails.Value.BatchFromSet = Undefined Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the StartListAccessUpdate function and the CancelAccessUpdateThreadsBackgroundJobs procedure.
Function AccessUpdateThreadMethodName()
	
	Return "AccessManagementInternal.UpdateListAccessInBackground";
	
EndFunction

// For the ExecuteAccessUpdate and CompleteAccessUpdate procedures.
Procedure WaitForThreadToUnlock(Context, WaitForJobToComplete = False)
	
	If Context.UpdateInThisSession Then
		Return;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		WaitStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ExecuteJob = True;
	
	If WaitForJobToComplete Then
		Query = New Query;
		Query.SetParameter("ThreadsIDs", ThreadsIDs(Context.LockedThreads));
		Query.Text =
		"SELECT TOP 1
		|	TRUE AS TrueValue
		|FROM
		|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
		|WHERE
		|	NOT CurrentJobs.IsStart
		|	AND CurrentJobs.ThreadID IN(&ThreadsIDs)";
		If Not Query.Execute().IsEmpty() Then
			ExecuteJob = False;
		EndIf;
		WaitBoundary = CurrentSessionDate() + 5;
	EndIf;
	
	While ExecuteJob Do
		If Context.CurrentBackgroundJob <> Undefined Then
			BackgroundJob = Context.CurrentBackgroundJob;
		Else
			BackgroundJob = Undefined;
			For Each ThreadDetails In Context.LockedThreads Do
				Thread = ThreadDetails.Value;
				UpdateBackgroundJobProperties(Thread, Context);
				If Thread.BackgroundJob <> Undefined
				   AND Thread.BackgroundJob.State = BackgroundJobState.Active Then
					
					BackgroundJob = Thread.BackgroundJob;
					Break;
				EndIf;
			EndDo;
		EndIf;
		If BackgroundJob = Undefined Then
			Break;
		EndIf;
		Try
			BackgroundJob.WaitForCompletion(0.025);
		Except
			// No special processing is required. Perhaps the exception was raised because a timeout occurred.
		EndTry;
		If Not WaitForJobToComplete
		 Or CurrentSessionDate() > WaitBoundary
		 Or Context.LockedThreads.Count() = 0 Then
			Break;
		EndIf;
		If Not Query.Execute().IsEmpty() Then
			Break;
		EndIf;
	EndDo;
	
	If Indicators <> Undefined Then
		Indicators.FreeThreadWaitsTime = Indicators.FreeThreadWaitsTime
			+ (CurrentUniversalDateInMilliseconds() - WaitStart);
	EndIf;
	
EndProcedure

// For the WaitForThreadToUnlock and ProcessExecutedJobs procedures.
Function ThreadsIDs(LockedThreads)
	
	ThreadsIDs = New Array;
	
	For Each ThreadDetails In LockedThreads Do
		ThreadsIDs.Add(ThreadDetails.Key);
	EndDo;
	
	Return ThreadsIDs;
	
EndFunction

// For the WaitForThreadToUnlock and DeleteStoppedThreads procedures.
Procedure UpdateBackgroundJobProperties(Thread, Context)
	
	BackgroundJob = BackgroundJobs.FindByUUID(Thread.ThreadID);
	
	If BackgroundJob = Undefined Then
		If RegisterAccessUpdateIndicators() Then
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				NStr("ru = 'Не удалось найти запущенное фоновое задание.'; en = 'Cannot find the started background job.'; pl = 'Nie udało się znaleźć rozpoczętego zadania wykonywanego w tle.';de = 'Es konnte kein laufender Hintergrundjob gefunden werden.';ro = 'Sarcina de fundal lansată nu a putut fi găsită.';tr = 'Başlatılan arkaplan görevi bulunamadı.'; es_ES = 'No se ha podido encontrar una tarea de fondo lanzada.'"), Thread.Job, True), Context);
		EndIf;
		Context.ProcessingCompleted = False;
		Return;
	EndIf;
	Thread.BackgroundJob = BackgroundJob;
	
EndProcedure

// For the CompleteAccessUpdate procedure.
Procedure CancelThreadBackgroundJob(Thread, Context)
	
	UpdateBackgroundJobProperties(Thread, Context);
	BackgroundJob = Thread.BackgroundJob;
	
	If BackgroundJob = Undefined
	 Or BackgroundJob.State <> BackgroundJobState.Active Then
		
		Return;
	EndIf;
	
	Try
		BackgroundJob.Cancel();
	Except
		ErrorPresentation = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось отменить фоновое задание потока по причине:
			           |%1'; 
			           |en = 'Cannot cancel the thread background job due to:
			           |%1'; 
			           |pl = 'Nie można cofnąć strumień aktualizacji dostępu do zadania w tle z powodu:
			           |%1';
			           |de = 'Es war aus diesem Grund nicht möglich, die Hintergrundaufgabe des Streams abzubrechen:
			           |%1';
			           |ro = 'Eșec la revocarea sarcinii de fundal a fluxului din motivul:
			           |%1';
			           |tr = 'Arka plan iş parçacığı işi şu sebeplerden dolayı iptal edilemedi:
			           |%1'; 
			           |es_ES = 'No se ha podido cancelar tarea de fondo de flujo de actualización de acceso a causa de:
			           |%1'"), BriefErrorDescription(ErrorInfo()));
		RegisterAccessUpdateError(UpdateErrorTextWithContext(
			ErrorPresentation, Thread.Job, True), Context);
	EndTry;
	
	Context.ProcessingCompleted = False;
	
EndProcedure

// For the ExecuteAccessUpdate and ProcessJobResult procedure.
Procedure ProcessExecutedJobs(Context, LockedThreads = Undefined)
	
	If Context.UpdateInThisSession Then
		If AccessUpdateCanceled() Then
			Context.UpdateCanceled = True;
		EndIf;
		Return;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		ProcessingStart = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	If LockedThreads = Undefined Then
		LockedThreads = Context.LockedThreads;
	EndIf;
	ThreadsDetails = New Map(New FixedMap(LockedThreads));
	
	Query = New Query;
	Query.SetParameter("CancelID", CancelUpdateAtRecordLevelID());
	Query.SetParameter("ThreadsIDs", ThreadsIDs(ThreadsDetails));
	Query.SetParameter("ExecutionExpectationLimit", CurrentSessionDate()
		- MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed());
	
	Query.Text =
	"SELECT
	|	CurrentJobs.ThreadID AS ThreadID,
	|	CurrentJobs.Result AS Result,
	|	CurrentJobs.IsStart
	|			AND &ExecutionExpectationLimit > CurrentJobs.RegisterRecordChangeDate
	|		OR CurrentJobs.ThreadID = &CancelID AS RunTimeExceeded,
	|	CurrentJobs.RegisterRecordChangeDate AS RegisterRecordChangeDate
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	(NOT CurrentJobs.IsStart
	|				AND CurrentJobs.ThreadID IN (&ThreadsIDs)
	|			OR CurrentJobs.IsStart
	|				AND &ExecutionExpectationLimit > CurrentJobs.RegisterRecordChangeDate
	|			OR CurrentJobs.ThreadID = &CancelID)";
	
	ResultsDetails = New Map;
	Selection = Query.Execute().Select();
	
	While Selection.Next() Do
		If Selection.RunTimeExceeded = True Then
			If Selection.ThreadID = CancelUpdateAtRecordLevelID() Then
				Context.UpdateCanceled = True;
				Return;
			EndIf;
			Thread = Context.LockedThreads.Get(Selection.ThreadID);
			If Thread = Undefined Then
				For Each FreeThread In Context.FreeThreads Do
					If FreeThread.ThreadID = Selection.ThreadID Then
						Thread = FreeThread;
						Break;
					EndIf;
				EndDo;
			EndIf;
			If Thread = Undefined Then
				Continue;
			EndIf;
			
			ErrorPresentation = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Превышено время выполнения задания в потоке (%1 сек).
				           |Фоновое задание потока отменено и перезапущено.'; 
				           |en = 'Job execution time in thread is exceeded (%1 sec).
				           |Background job of the thread is canceled and restarted.'; 
				           |pl = 'Czas wykonania zadania w strumieniu (%1 sek.) został przekroczony.
				           |Zadanie w tle strumienia zostało anulowane i zrestartowane.';
				           |de = 'Die Auftragsausführungszeit im Stream wird überschritten (%1 sec).
				           |Der Hintergrund-Job wird abgebrochen und neu gestartet.';
				           |ro = 'Este depășit timpul de executare a sarcinii în flux (%1 sec).
				           |Sarcina de fundal a fluxului a fost revocată sau relansată.';
				           |tr = 'İş parçacığında (%1sn) 
				           |görev yürütme süresi aşıldı İş parçacığı için arka plan görevi iptal edildi ve yeniden başlatıldı.'; 
				           |es_ES = 'Se ha superado el tiempo de ejecución de tarea en el flujo (%1 s).
				           |La tarea de fondo del flujo se ha cancelado y se ha reiniciado.'"),
				MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed());
			
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				ErrorPresentation, Thread.Job, True), Context);
			
			CancelThreadBackgroundJob(Thread, Context);
			DeleteThread(Thread, Context);
			ThreadsDetails.Delete(Thread.ThreadID);
			
			If Indicators <> Undefined Then
				Indicators.ThreadsExceedingExecutionTimeCount =
					Indicators.ThreadsExceedingExecutionTimeCount + 1;
			EndIf;
			
		ElsIf TypeOf(Selection.Result) = Type("ValueStorage") Then
			ResultDetails = New Structure;
			ResultDetails.Insert("CompletedOn", Selection.RegisterRecordChangeDate);
			ResultDetails.Insert("Result",      Selection.Result.Get());
			ResultsDetails.Insert(Selection.ThreadID, ResultDetails);
		EndIf;
	EndDo;
	
	For Each ThreadDetails In ThreadsDetails Do
		Thread = ThreadDetails.Value;
		ResultDetails = ResultsDetails.Get(Thread.ThreadID);
		ProcessCompletedJobResult(Thread, ResultDetails, Context);
	EndDo;
	
	ThreadsCount = Context.LockedThreads.Count() + Context.FreeThreads.Count();
	If ThreadsCount > Context.ThreadsCount Then
		Index = Context.FreeThreads.Count() - 1;
		While Index >= 0 Do
			FreeThread = Context.FreeThreads.Get(Index);
			DeleteThread(FreeThread, Context);
			Index = Index - 1;
			ThreadsCount = ThreadsCount - 1;
			If ThreadsCount <= Context.ThreadsCount Then
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	If CurrentSessionDate() > Context.JobsUpdateBoundary Then
		Context.JobsUpdateBoundary = CurrentSessionDate() + 2;
		DeleteStoppedThreads(Context, Context.LockedThreads);
		DeleteStoppedThreads(Context, Context.FreeThreads);
		DeleteNotUsedFreeThreads(Context);
	EndIf;
	
	If Indicators <> Undefined Then
		Indicators.JobsResultsProcessingTime = Indicators.JobsResultsProcessingTime
			+ (CurrentUniversalDateInMilliseconds() - ProcessingStart);
	EndIf;
	
EndProcedure

// For the ProcessExecutedJobs and UpdateListAccessWithRetryAttempts procedures.
Function AccessUpdateCanceled()
	
	Query = New Query;
	Query.SetParameter("ThreadID", CancelUpdateAtRecordLevelID());
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	CurrentJobs.ThreadID = &ThreadID";
	
	Return Not Query.Execute().IsEmpty();
	
EndFunction

// For the ProcessCompletedJobs procedure.
Procedure ProcessCompletedJobResult(Thread, ResultDetails, Context)
	
	If Not Thread.CancelJob
	   AND Not Thread.Job.Delete Then
		
		If ResultDetails = Undefined Then
			Return;
		ElsIf TypeOf(ResultDetails.Result) <> Type("Structure") Then
			Context.ProcessingCompleted = False;
		Else
			Result = ResultDetails.Result;
			If Result.Property("BatchFromSet") Then
				Result.BatchFromSet = Thread.BatchFromSet;
			EndIf;
			Indicators = Context.Indicators;
			If Indicators <> Undefined Then
				Indicators.JobProcessingStart = CurrentUniversalDateInMilliseconds();
			EndIf;
			ProcessJobResult(Context, Result, Thread.Job);
			If Indicators <> Undefined Then
				RemoveJobResultProcessingIndicators(Indicators);
			EndIf;
		EndIf;
	EndIf;
	
	If ResultDetails = Undefined Then
		CompletedOn = Undefined;
	Else
		CompletedOn = ResultDetails.CompletedOn;
	EndIf;
	
	UnlockThread(Thread, Context, CompletedOn);
	
EndProcedure

// For the ProcessCompletedJobResult and DeleteThread procedures.
Procedure UnlockThread(Thread, Context, CompletedOn = Undefined)
	
	InsertPosition = 0;
	If CompletedOn = Undefined Then
		Thread.ReleaseDate = CurrentSessionDate();
	Else
		Thread.ReleaseDate = CompletedOn;
		Count = Context.FreeThreads.Count();
		While InsertPosition < Count Do
			CurrentThread = Context.FreeThreads.Get(InsertPosition);
			If CurrentThread.ReleaseDate <= CompletedOn Then
				Break;
			EndIf;
			InsertPosition = InsertPosition + 1;
		EndDo;
	EndIf;
	
	Context.FreeThreads.Insert(InsertPosition, Thread);
	Context.LockedThreads.Delete(Thread.ThreadID);
	Thread.Job.LockedThreads.Delete(Thread.ThreadID);
	If Thread.BatchFromSet <> Undefined Then
		RemoveBeingProcessedFlagForBatch(Thread, Thread.Job);
		Thread.BatchFromSet = Undefined;
	EndIf;
	Thread.Job = Undefined;
	Thread.CancelJob = False;
	
EndProcedure

// For the StartListAccessUpdate, ProcessCompletedJobResult, and UnlockThread procedures.
Procedure RemoveBeingProcessedFlagForBatch(ThreadOrResult, Job)
	
	BatchFromSet = Undefined;
	
	If Not ThreadOrResult.Property("BatchFromSet", BatchFromSet)
	 Or BatchFromSet = Undefined
	 Or Not BatchFromSet.Processing Then
		Return;
	EndIf;
	
	If Not BatchFromSet.Processed Then
		BatchIndex = Job.BatchesSet.Find(BatchFromSet);
		
		If BatchIndex = Undefined Then
			Job.IndexOfLastBatchToProcess = 0;
			
		ElsIf Job.IndexOfLastBatchToProcess > BatchIndex Then
			Job.IndexOfLastBatchToProcess = BatchIndex;
		EndIf;
	EndIf;
	
	BatchFromSet.Processing = False;
	
EndProcedure

// For the ProcessCompletedJobResult and CompleteAccessUpdate procedures.
Procedure DeleteThread(Thread, Context)
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	RecordSet.Filter.ThreadID.Set(Thread.ThreadID);
	RecordSet.Write();
	
	If Context.LockedThreads.Get(Thread.ThreadID) <> Undefined Then
		UnlockThread(Thread, Context);
	EndIf;
	
	Index = Context.FreeThreads.Find(Thread);
	If Index <> Undefined Then
		Context.FreeThreads.Delete(Index);
	EndIf;
	
EndProcedure

// For the ProcessCompletedJobResult and CompleteAccessUpdate procedures.
Procedure DeleteStoppedThreads(Context, ThreadsDetails)
	
	If TypeOf(ThreadsDetails) = Type("Map") Then
		InitialThreadsDetails = New FixedMap(ThreadsDetails);
	Else
		InitialThreadsDetails = New FixedArray(ThreadsDetails);
	EndIf;
	
	For Each ThreadDetails In InitialThreadsDetails Do
		If TypeOf(ThreadDetails) = Type("KeyAndValue") Then
			Thread = ThreadDetails.Value;
		Else
			Thread = ThreadDetails;
		EndIf;
		UpdateBackgroundJobProperties(Thread, Context);
		BackgroundJob = Thread.BackgroundJob;
		
		If BackgroundJob <> Undefined
		   AND BackgroundJob.State = BackgroundJobState.Active Then
			Continue;
		EndIf;
		Context.ProcessingCompleted = False;
		
		DeleteThread(Thread, Context);
		
		If BackgroundJob <> Undefined
		   AND BackgroundJob.State = BackgroundJobState.Failed Then
			
			RegisterAccessUpdateError(UpdateErrorTextWithContext(
				BackgroundJob.ErrorInfo, Thread.Job, True), Context);
			
			If Context.Indicators <> Undefined Then
				Context.Indicators.ThreadsWithNonStandardCompletionCount =
					Context.Indicators.ThreadsWithNonStandardCompletionCount + 1;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the ProcessCompletedJobs procedure.
Procedure DeleteNotUsedFreeThreads(Context)
	
	Count = Context.FreeThreads.Count();
	If Count = 0 Then
		Return;
	EndIf;
	
	FreeThreads = Context.FreeThreads;
	Index = Count - 1;
	CurrentSessionDate = CurrentSessionDate();
	
	While Index >= 0 Do
		Thread = FreeThreads.Get(Index);
		If CurrentSessionDate > Thread.ReleaseDate + 15 Then
			DeleteThread(Thread, Context);
		EndIf;
		Index = Index - 1;
	EndDo;
	
EndProcedure

// For the AddAccessUpdateJobs and ProcessJobResult procedures.
Procedure CancelJob(Job)
	
	Job.BatchesSet = New Array;
	Job.BatchesToProcessCount = 0;
	Job.IndexOfLastBatchToProcess = 0;
	
	For Each ThreadDetails In Job.LockedThreads Do
		ThreadDetails.Value.CancelJob = True;
	EndDo;
	
EndProcedure

// For the StartListAccessUpdate and ProcessCompletedJobResult procedures.
Procedure ProcessJobResult(Context, Result, Job)
	
	If Result.Property("NoJobs") Or Result.Property("UpdateRestart") Then
		If Result.Property("UpdateRestart") Then
			Job.HasRestart = True;
			If Result.Property("RestartUpdateFromBeginning") Then
				Job.HasInitialUpdate = True;
			EndIf;
		EndIf;
		CancelJob(Job);
		If Result.Property("NoJobs") Then
			RemoveBeingProcessedFlagForBatch(Result, Job);
			UpdateJobProperties(Job, New Structure("DataKey", Null));
		EndIf;
	EndIf;
	
	If Result.Property("CompletionErrorText") Then
		If Not Result.ProcessingCompleted Then
			Context.ProcessingCompleted = False;
		EndIf;
		If ValueIsFilled(Result.CompletionErrorText) Then
			RemoveBeingProcessedFlagForBatch(Result, Job);
			AddCompletionErrorText(Context.CompletionErrorText, Result.CompletionErrorText);
			Return;
		EndIf;
	EndIf;
	
	If Result.Property("NoJobs") Then
		Return;
	EndIf;
	
	If Result.Property("InitialUpdateCompleted") Then
		Job.HasInitialUpdate = False;
		Job.HasRestart = False;
	EndIf;
	
	If Result.Property("BatchFromSet") Then
		InitialBatchFromSet = Result.BatchFromSet;
		If Result.Property("BatchesSet") Then
			Index = Job.BatchesSet.Find(InitialBatchFromSet);
			If Job.IndexOfLastBatchToProcess > Index Then
				Job.IndexOfLastBatchToProcess = Index + 1;
			EndIf;
			For Each NewBatchFromSourceOne In Result.BatchesSet Do
				Index = Index + 1;
				Job.BatchesSet.Insert(Index, NewBatchFromSourceOne);
			EndDo;
			Job.BatchesToProcessCount = Job.BatchesToProcessCount
				+ Result.BatchesSet.Count();
			InitialBatchFromSet.LastBatchItem      = Result.NewLastUpdatedItem;
			InitialBatchFromSet.NewLastBatchItem = Result.NewLastUpdatedItem;
		EndIf;
		InitialBatchFromSet.Processed = True;
		RemoveBeingProcessedFlagForBatch(Result, Job);
		
	ElsIf Result.Property("BatchesSet") Then
		For Each NewBatch In Result.BatchesSet Do
			Job.BatchesSet.Add(NewBatch);
		EndDo;
		Job.BatchesToProcessCount = Job.BatchesToProcessCount
			+ Result.BatchesSet.Count();
		
	ElsIf Result.Property("NewLastUpdatedItem") Then
		UpdateJobProperties(Job, Result.NewLastUpdatedItem);
	EndIf;
	
	If Result.Property("BatchFromSet") AND CommonJobBeingExecuted(Job) Then
		Return;
	EndIf;
	
	Commit = False;
	While Job.BatchesSet.Count() > 0 Do
		BatchFromSet = Job.BatchesSet[0];
		If Not BatchFromSet.Processed Then
			Break;
		EndIf;
		Commit = True;
		NewLastUpdatedItem = BatchFromSet.NewLastBatchItem;
		Job.BatchesSet.Delete(0);
		If Job.IndexOfLastBatchToProcess > 0 Then
			Job.IndexOfLastBatchToProcess = Job.IndexOfLastBatchToProcess - 1;
		EndIf;
	EndDo;
	
	If Commit Then
		WriteLastUpdatedItem(Result, NewLastUpdatedItem);
		UpdateJobProperties(Job, NewLastUpdatedItem);
		If Not Result.ProcessingCompleted Then
			Context.ProcessingCompleted = False;
		EndIf;
	EndIf;
	
EndProcedure

// For the ProcessJobResult procedure.
Procedure UpdateJobProperties(Job, NewLastUpdatedItem)
	
	If NewLastUpdatedItem.DataKey = Null Then
		Job.Delete = True;
	Else
		If NewLastUpdatedItem.Property("Date") Then
			Job.LatestUpdatedItemDate = NewLastUpdatedItem.Date;
		Else
			Job.LatestUpdatedItemDate = '00010101';
		EndIf;
		Job.HasLastUpdatedItemDate
			= ValueIsFilled(Job.LatestUpdatedItemDate);
		
		Job.DataKeyKindOrder = NewLastUpdatedItem.DataKeyKindOrder;
		UpdateIsObsoleteItemsDataProcessorProperty(Job);
	EndIf;
	
EndProcedure

// For the StartListAccessUpdate  function.
Procedure UpdateListAccessInBackground(ParentSessionDetails) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	Context = New Structure;
	Context.Insert("Indicators", ActiveThreadUpdateIndicators());
	Context.Insert("ParentSessionDetails", ParentSessionDetails);
	
	If Not PerformingThreadStarted(Context) Then
		Return;
	EndIf;
	Cache = New Structure;
	
	While True Do
		Selection = Context.Query.Execute().Select();
		If Not Selection.Next() Then
			Break;
		EndIf;
		If TypeOf(Selection.Parameters) <> Type("ValueStorage") Then
			If ContinueWaitForNewJob(Context) Then
				Continue;
			Else
				Break;
			EndIf;
		EndIf;
		Result = CommonUpdateParametersDetails();
		Result.Insert("ProcessingCompleted", False);
		Result.Insert("CompletionErrorText", "");
		Try
			CommonUpdateParameters = Selection.Parameters.Get();
			FillPropertyValues(Result, CommonUpdateParameters);
			CommonUpdateParameters.Insert("Cache", Cache);
			Context.WaitSecondsCountTillNewJobSearch =
				Int(0.025 * Result.MaxProcessingMilliseconds) / 1000;
			
			UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context);
			Result.ProcessingCompleted = CommonUpdateParameters.ProcessingCompleted;
			
			PropertiesToReturn = "NoJobs, UpdateRestart, RestartUpdateFromBeginning, BatchesSet,
				|NewLastUpdatedItem, InitialUpdateCompleted, CompletionErrorText";
			For Each KeyAndValue In New Structure(PropertiesToReturn) Do
				If CommonUpdateParameters.Property(KeyAndValue.Key) Then
					Result.Insert(KeyAndValue.Key, CommonUpdateParameters[KeyAndValue.Key]);
				EndIf;
			EndDo;
			If CommonUpdateParameters.Property("BatchFromSet") Then
				Result.Insert("BatchFromSet");
			EndIf;
		Except
			AddCompletionErrorText(Result.CompletionErrorText, UpdateErrorTextWithContext(
				DetailErrorDescription(ErrorInfo()), Result));
		EndTry;
		WriteResultOfListAccessUpdateInBackground(Result, Selection.Parameters, Context);
	EndDo;
	
	If RegisterAccessUpdateIndicators() Then
		RegisterActiveThreadUpdateIndicators(Context);
	EndIf;
	
EndProcedure

// For the UpdateListAccessInBackground procedure.
Function PerformingThreadStarted(Context)
	
	CurrentSession = GetCurrentInfoBaseSession();
	Context.Insert("CurrentSession", CurrentSession);
	
	If CurrentSession.ApplicationName <> "BackgroundJob" Then
		ErrorText = NStr("ru = 'Порция обновления доступа может обрабатываться только в фоновом задании.'; en = 'Access update batch can be processed in the background job only.'; pl = 'Część aktualizacji dostępu może być przetwarzana tylko, jako zadanie w tle.';de = 'Der Teil der Zugriffsaktualisierung kann nur im Hintergrundjob verarbeitet werden.';ro = 'Porțiunea de actualizare a accesului poate fi procesată numai în sarcina de fundal.';tr = 'Erişim güncelleme bölümü sadece arka plan işinde işlenebilir.'; es_ES = 'Una parte de actualización de acceso puede ser procesada solo en la tarea de fondo.'");
		Raise ErrorText;
	EndIf;
	
	Context.Insert("CurrentBackgroundJob", CurrentSession.GetBackgroundJob());
	ThreadID = Context.CurrentBackgroundJob.UUID;
	
	Query = New Query;
	Query.SetParameter("ThreadID", ThreadID);
	Query.Text =
	"SELECT
	|	CASE
	|		WHEN CurrentJobs.IsStart
	|			THEN CurrentJobs.Parameters
	|		ELSE UNDEFINED
	|	END AS Parameters
	|FROM
	|	InformationRegister.UsersAccessKeysCurrentJobs AS CurrentJobs
	|WHERE
	|	CurrentJobs.ThreadID = &ThreadID";
	Context.Insert("Query", Query);
	
	Lock = New("DataLock");
	LockItem = Lock.Add("InformationRegister.UsersAccessKeysCurrentJobs");
	LockItem.SetValue("ThreadID", ThreadID);
	Context.Insert("Lock", Lock);
	
	RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeysCurrentJobs);
	RecordSet.Filter.ThreadID.Set(ThreadID);
	Context.Insert("RecordSet", RecordSet);
	
	SetRecord = RecordSet.Add();
	SetRecord.ThreadID = ThreadID;
	SetRecord.IsStart = False;
	Context.Insert("SetRecord", SetRecord);
	
	// Waiting for startup flag.
	WaitBoundary = CurrentUniversalDateInMilliseconds() + 1000;
	While True Do
		If Not Query.Execute().IsEmpty() Then
			Break;
		EndIf;
		If CurrentUniversalDateInMilliseconds() > WaitBoundary Then
			Return False;
		EndIf;
		Try
			Context.CurrentBackgroundJob.WaitForCompletion(0.025);
		Except
			Continue;
		EndTry;
	EndDo;
	
	Context.Insert("ParentSessionCheckBoundary", CurrentUniversalDateInMilliseconds() + 1000);
	Context.Insert("WaitSecondsCountTillNewJobSearch", 0.025);
	
	Return True;
	
EndFunction

// For the UpdateListAccessInBackground procedure.
Function ContinueWaitForNewJob(Context)
	
	If CurrentUniversalDateInMilliseconds() > Context.ParentSessionCheckBoundary Then
		If AccessUpdateCanceled() Then
			Return False;
		EndIf;
		Context.ParentSessionCheckBoundary = CurrentUniversalDateInMilliseconds() + 1000;
		If Not SessionExists(Context.ParentSessionDetails) Then
			Return False;
		EndIf;
	EndIf;
	
	Indicators = Context.Indicators;
	If Indicators <> Undefined Then
		Indicators.WaitsForNewJobsCount = Indicators.WaitsForNewJobsCount + 1;
	EndIf;
	
	WaitStart = CurrentUniversalDateInMilliseconds();
	Try
		Context.CurrentBackgroundJob.WaitForCompletion(
			Context.WaitSecondsCountTillNewJobSearch);
	Except
		If Indicators <> Undefined Then
			Indicators.NewJobsWaitTime = Indicators.NewJobsWaitTime
				+ (CurrentUniversalDateInMilliseconds() - WaitStart);
		EndIf;
		If Context.WaitSecondsCountTillNewJobSearch < 1 Then
			Context.WaitSecondsCountTillNewJobSearch =
				Context.WaitSecondsCountTillNewJobSearch + 0.010;
		EndIf;
	EndTry;
	
	Return True;
	
EndFunction

// For the ContinueWaitForNewJob function.
Function SessionExists(SessionDetails)
	
	If ValueIsFilled(SessionDetails.BackgroundJobID) Then
		BackgroundJob = BackgroundJobs.FindByUUID(
			SessionDetails.BackgroundJobID);
		
		Return BackgroundJob <> Undefined
		      AND BackgroundJob.State = BackgroundJobState.Active;
	EndIf;
	
	MainSessionFound = False;
	Sessions = GetInfoBaseSessions();
	
	For Each Session In Sessions Do
		
		If Session.SessionStarted = SessionDetails.SessionStarted
		   AND Session.SessionNumber  = SessionDetails.SessionNumber Then
			
			MainSessionFound = True;
			Break;
		EndIf;
	EndDo;
	
	Return MainSessionFound;
	
EndFunction

// For the UpdateListAccessInBackground procedure.
Procedure WriteResultOfListAccessUpdateInBackground(Result, InitialParameters, Context)
	
	BeginTransaction();
	Try
		Context.Lock.Lock();
		Selection = Context.Query.Execute().Select();
		
		If Selection.Next()
		   AND XMLString(Selection.Parameters) = XMLString(InitialParameters) Then
			
			Context.SetRecord.Parameters = InitialParameters;
			Context.SetRecord.Result = New ValueStorage(Result);
			Context.SetRecord.RegisterRecordChangeDate = CurrentSessionDate();
			Context.RecordSet.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateListAccessInBackground procedure.
Function LeadingThreadUpdateIndicators(Context)
	
	If Not RegisterAccessUpdateIndicators() Then
		Return Undefined;
	EndIf;
	
	Indicators = New Structure;
	
	// Variables.
	Indicators.Insert("WorkStartInMilliseconds", CurrentUniversalDateInMilliseconds());
	Indicators.Insert("JobIssueStart");
	
	If Context.UpdateInThisSession Then
		AddJobsExecutionIndicators(Indicators);
	Else
		Indicators.Insert("FreeThreadWaitsTime", 0);
		
		Indicators.Insert("IssuedJobsCount", 0);
		Indicators.Insert("JobsIssueTime", 0);
		Indicators.Insert("MinJobIssueTime", 0);
		Indicators.Insert("MaxJobIssueTime", 0);
		
		Indicators.Insert("JobsResultsProcessingTime", 0);
		Indicators.Insert("MinJobResultProcessingTime", 0);
		Indicators.Insert("MaxJobResultProcessingTime", 0);
		
		Indicators.Insert("ThreadsExceedingExecutionTimeCount", 0);
		Indicators.Insert("ThreadsWithNonStandardCompletionCount", 0);
		
		// Variables.
		Indicators.Insert("JobProcessingStart", 0);
	EndIf;
	
	Return Indicators;
	
EndFunction

// For the UpdateListAccessInBackground procedure.
Function ActiveThreadUpdateIndicators()
	
	If Not RegisterAccessUpdateIndicators() Then
		Return Undefined;
	EndIf;
	
	Indicators = New Structure;
	
	Indicators.Insert("WorkStartInMilliseconds", CurrentUniversalDateInMilliseconds());
	Indicators.Insert("WaitsForNewJobsCount", 0);
	Indicators.Insert("NewJobsWaitTime", 0);
	
	AddJobsExecutionIndicators(Indicators);
	
	Return Indicators;
	
EndFunction

// For the LeadingThreadUpdateIndicators and ActiveThreadUpdateIndicators functions.
Procedure AddJobsExecutionIndicators(Indicators)
	
	// Variables.
	Indicators.Insert("JobWithGettingBatches", True);
	Indicators.Insert("StartFirstAttemptToExecuteJob", 0);
	Indicators.Insert("JobExecutionStart", 0);
	
	// Common indicators.
	Indicators.Insert("JobsWithRetriesBecauseOfErrorsCount", 0);
	Indicators.Insert("ExecutionTimeOfJobsWithRetriesBecauseOfErrors", 0);
	Indicators.Insert("JobsRetriesBecauseOfErrorsCount", 0);
	Indicators.Insert("MaxJobRetriesOnErrorCount", 0);
	Indicators.Insert("ErrorsTextOnRetryAttempts", "");
	
	// Getting batches or processing a small batch.
	Indicators.Insert("ExecutedJobsWithGettingBatchesCount", 0);
	Indicators.Insert("JobsWithGettingBatchesExecutionTime", 0);
	Indicators.Insert("JobsWithGettingBatchesMinExecutionTime", 0);
	Indicators.Insert("JobsWithGettingBatchesMaxExecutionTime", 0);
	
	// Batch data processors only.
	Indicators.Insert("JobsWithoutGettingBatchesCount", 0);
	Indicators.Insert("JobsWithoutGettingBatchesExecutionTime", 0);
	Indicators.Insert("JobsWithoutGettingBatchesMinExecutionTime", 0);
	Indicators.Insert("JobsWithoutGettingBatchesMaxExecutionTime", 0);
	
EndProcedure

// For the StartListAccessUpdate  function.
Procedure RemoveJobsIssueIndicators(Indicators)
	
	JobIssueTime = CurrentUniversalDateInMilliseconds() - Indicators.JobIssueStart;
	
	Indicators.IssuedJobsCount = Indicators.IssuedJobsCount + 1;
	Indicators.JobsIssueTime = Indicators.JobsIssueTime + JobIssueTime;
	
	If Indicators.MinJobIssueTime = 0 Then
		Indicators.MinJobIssueTime = JobIssueTime;
	EndIf;
	If JobIssueTime < Indicators.MinJobIssueTime Then
		Indicators.MinJobIssueTime = JobIssueTime;
	EndIf;
	
	If JobIssueTime > Indicators.MaxJobIssueTime Then
		Indicators.MaxJobIssueTime = JobIssueTime;
	EndIf;
	
EndProcedure

// For the StartListAccessUpdate  function.
Procedure RemoveJobResultProcessingIndicators(Indicators)
	
	JobProcessingTime = CurrentUniversalDateInMilliseconds() - Indicators.JobProcessingStart;
	
	Indicators.JobsResultsProcessingTime =
		Indicators.JobsResultsProcessingTime + JobProcessingTime;
	
	If Indicators.MinJobResultProcessingTime = 0 Then
		Indicators.MinJobResultProcessingTime = JobProcessingTime;
	EndIf;
	If JobProcessingTime < Indicators.MinJobResultProcessingTime Then
		Indicators.MinJobResultProcessingTime = JobProcessingTime;
	EndIf;
	
	If JobProcessingTime > Indicators.MaxJobResultProcessingTime Then
		Indicators.MaxJobResultProcessingTime = JobProcessingTime;
	EndIf;
	
EndProcedure

// For the UpdateListAccessInBackground procedure.
Procedure RemoveJobExecutionIndicators(Indicators)
	
	JobExecutionTime = CurrentUniversalDateInMilliseconds() - Indicators.JobExecutionStart;
	
	If Indicators.JobWithGettingBatches Then
		Indicators.ExecutedJobsWithGettingBatchesCount =
			Indicators.ExecutedJobsWithGettingBatchesCount + 1;
		
		Indicators.JobsWithGettingBatchesExecutionTime =
			Indicators.JobsWithGettingBatchesExecutionTime + JobExecutionTime;
		
		If Indicators.JobsWithGettingBatchesMinExecutionTime = 0 Then
			Indicators.JobsWithGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		If JobExecutionTime < Indicators.JobsWithGettingBatchesMinExecutionTime Then
			Indicators.JobsWithGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		
		If JobExecutionTime > Indicators.JobsWithGettingBatchesMaxExecutionTime Then
			Indicators.JobsWithGettingBatchesMaxExecutionTime = JobExecutionTime;
		EndIf;
	Else
		Indicators.JobsWithoutGettingBatchesCount =
			Indicators.JobsWithoutGettingBatchesCount + 1;
		
		Indicators.JobsWithoutGettingBatchesExecutionTime =
			Indicators.JobsWithoutGettingBatchesExecutionTime + JobExecutionTime;
		
		If Indicators.JobsWithoutGettingBatchesMinExecutionTime = 0 Then
			Indicators.JobsWithoutGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		If JobExecutionTime < Indicators.JobsWithoutGettingBatchesMinExecutionTime Then
			Indicators.JobsWithoutGettingBatchesMinExecutionTime = JobExecutionTime;
		EndIf;
		
		If JobExecutionTime > Indicators.JobsWithoutGettingBatchesMaxExecutionTime Then
			Indicators.JobsWithoutGettingBatchesMaxExecutionTime = JobExecutionTime;
		EndIf;
	EndIf;
	
EndProcedure

// For the UpdateListAccessInBackground procedure.
Procedure RemoveJobExecutionErrorsIndicators(Indicators, ErrorsText, ErrorsCount);
	
	If ErrorsCount = 0 Then
		Return;
	EndIf;
	
	Indicators.JobsWithRetriesBecauseOfErrorsCount = Indicators.JobsWithRetriesBecauseOfErrorsCount + 1;
	
	Indicators.ExecutionTimeOfJobsWithRetriesBecauseOfErrors = Indicators.ExecutionTimeOfJobsWithRetriesBecauseOfErrors
		+ (CurrentUniversalDateInMilliseconds() - Indicators.StartFirstAttemptToExecuteJob);
	
	Indicators.JobsRetriesBecauseOfErrorsCount =
		Indicators.JobsRetriesBecauseOfErrorsCount + ErrorsCount;
	
	If ErrorsCount > Indicators.MaxJobRetriesOnErrorCount Then
		Indicators.MaxJobRetriesOnErrorCount = ErrorsCount;
	EndIf;
	
	AddCompletionErrorText(Indicators.ErrorsTextOnRetryAttempts, ErrorsText);
	
EndProcedure

// For procedures RegisterMainThreadUpdateIndicators,
// RegisterActiveThreadUpdateIndicators,
// AddSessionOperationIndicatorsValues,
// AddJobsExecutionIndicatorsValues
//
Function SecondsFormat(SecondsCount)
	
	If SecondsCount = 0 Then
		Return StrReplace(Format(1.111), "1", "0");
	EndIf;
	
	Return Format(SecondsCount, "NFD=3; NG=");
	
EndFunction

// For procedures RegisterMainThreadUpdateIndicators,
// RegisterActiveThreadUpdateIndicators,
// AddJobsExecutionIndicatorsValues
//
Function CountFormat(CountNumber)
	
	Return Format(CountNumber, "NZ=0; NG=");
	
EndFunction

// For the CompleteAccessUpdate procedure.
Procedure RegisterMainThreadUpdateIndicators(Context)
	
	Indicators = Context.Indicators;
	
	If Context.UpdateInThisSession Then
		Comment = NStr("ru = 'Завершен сеанс обновления доступа.'; en = 'Access update session is completed.'; pl = 'Zakończono sesję aktualizacji dostępu.';de = 'Zugriff auf die Aktualisierungssitzung abgeschlossen.';ro = 'Sesiunea de actualizare a accesului este finalizată.';tr = 'Erişim güncelleme oturumu sona erdi.'; es_ES = 'Se ha terminado la sesión de actualización de acceso.'");
		AddSessionOperationIndicatorsValues(Comment, Indicators, Context.MainSessionDetails);
		AddJobsExecutionIndicatorsValues(Comment, Indicators);
	Else
		FreeThreadWaitsTime = Indicators.FreeThreadWaitsTime / 1000;
		
		JobsIssueTime             = Indicators.JobsIssueTime / 1000;
		MinJobIssueTime  = Indicators.MinJobIssueTime / 1000;
		MaxJobIssueTime = Indicators.MaxJobIssueTime / 1000;
		
		JobsResultsProcessingTime            = Indicators.JobsResultsProcessingTime / 1000;
		MinJobResultProcessingTime  = Indicators.MinJobResultProcessingTime / 1000;
		MaxJobResultProcessingTime = Indicators.MaxJobResultProcessingTime / 1000;
		
		Comment = NStr("ru = 'Завершен сеанс управляющего потока обновления доступа.'; en = 'Session of control access update thread is completed.'; pl = 'Sesja sterującego strumienia kontroli aktualizacji dostępu została zakończona.';de = 'Die Sitzung zur Zugriffsaktualisierung des Streams ist abgeschlossen.';ro = 'Sesiunea fluxului principal de actualizare a accesului este finalizată.';tr = 'Erişim kontrolü akış kontrolü oturumu sona erdi.'; es_ES = 'Se ha terminado la sesión del flujo de gestión de actualización de acceso.'");
		AddSessionOperationIndicatorsValues(Comment, Indicators, Context.MainSessionDetails);
		
		Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Время ожиданий свободного потока: %1 сек
			           |
			           |Количество выданных заданий: %2
			           |Время выдачи заданий: %3 сек
			           |Минимальное время выдачи заданий: %4 сек
			           |Максимальное время выдачи заданий: %5 сек'; 
			           |en = 'Waiting time for a free thread: %1 sec
			           |
			           |Number of issued jobs: %2
			           |Job issue time: %3 sec
			           |Min job issue time: %4 sec
			           |Max job issue time: %5 sec'; 
			           |pl = 'Czas oczekiwania wolnego strumienia: %1 sek.
			           |
			           |Liczba wydanych zadań: %2
			           |Czas wydania zadań: %3 sek.
			           |Minimalny czas wydawania zadań: %4 sek.
			           |Maksymalny czas wydawania zadań: %5sek.';
			           |de = 'Wartezeit für freien Ablauf: %1s
			           |
			           | Anzahl der ausgegebenen Aufgaben: %2
			           |Zeit für die Ausgabe der Aufgabe: %3 s 
			           |Minimale Zeit für die Ausgabe der Aufgabe: %4s
			           | Maximale Zeit für die Ausgabe der Aufgabe: %5s';
			           |ro = 'Timpul de așteptare a fluxului liber: %1 sec
			           |
			           |Cantitatea sarcinilor atribuite: %2
			           |Timpul de atribuire a sarcinilor: %3 sec
			           |Timpul minim de atribuire a sarcinilor: %4 sec
			           |Timpul maxim de atribuire a sarcinilor: %5 sec';
			           |tr = 'Serbest akış için bekleme süresi:%1 s 
			           |
			           |Verilen görev sayısı:%2
			           | Görev süresi:%3 saniye
			           | Minimum görev süresi: %4saniye 
			           |Maksimum görev süresi:%5 saniye'; 
			           |es_ES = 'Tiempo de espera del flujo libre: %1 s 
			           |
			           |Cantidad de tareas emitidas: %2
			           |Tiempo de emisión de tareas: %3 s
			           |Tiempo mínimo de tareas de emisión de tareas: %4 s
			           |Tiempo máximo de tareas de emisión de tareas: %5 s'"),
			SecondsFormat(FreeThreadWaitsTime),
			CountFormat(Indicators.IssuedJobsCount),
			SecondsFormat(JobsIssueTime),
			SecondsFormat(MinJobIssueTime),
			SecondsFormat(MaxJobIssueTime));
		
		Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Время обработки результатов заданий: %1 сек
			           |Минимальное время обработки результатов заданий: %2 сек
			           |Максимальное время обработки результатов заданий: %3 сек
			           |
			           |Количество потоков с превышением времени выполнения: %4
			           |Количество потоков с нештатным завершением: %5'; 
			           |en = 'Time of processing job results: %1 sec
			           |Min time of processing job results: %2sec
			           |Max time of processing job results: %3 sec
			           |
			           |Number of threads exceeding execution time: %4
			           |Number of threads with non-standard completion: %5'; 
			           |pl = 'Czas przetwarzania wyników zadań: %1 sek.
			           |Minimalny czas przetwarzania wyników zadań: %2 sek.
			           |Maksymalny czas przetwarzania wyników zadań: %3 sek.
			           |
			           |Liczba strumieni z przekroczeniem czasu realizacji: %4
			           |Liczba strumieni z niezależnym zakończeniem: %5';
			           |de = 'Verarbeitungszeit der Auftragsergebnisse: %1s
			           |Minimale Verarbeitungszeit der Auftragsergebnisse: %2 s
			           | Maximale Verarbeitungszeit der Auftragsergebnisse: %3 s
			           |
			           |Anzahl der Threads, die die Laufzeit überschreiten: %4
			           |Anzahl der Threads mit abnormalem Abschluss: %5';
			           |ro = 'Timpul de procesare a rezultatelor sarcinilor: %1 sec
			           |Timpul minim de procesare a rezultatelor sarcinilor: %2 sec
			           |Timpul maxim de procesare a rezultatelor sarcinilor: %3 sec
			           |
			           |Cantitatea fluxurilor cu depășirea timpului de executare: %4
			           |Cantitatea fluxurilor cu finalizare forțată: %5';
			           |tr = 'Görevlerin sonuçlarının işlenme zamanı: %1sek
			           | Görevlerin sonuçlarının işlendiği zaman süresi:%2 sek
			           | Görevlerin sonuçlarının işlenme süresi:%3 sek
			           |
			           |%4
			           |%5'; 
			           |es_ES = 'Tiempo de procesamiento de resultados de tareas: %1 s 
			           |Tiempo mínimo de procesamiento de resultados de tareas: %2 s
			           |Tiempo máximo de procesamiento de resultados de tareas: %3 s
			           |
			           |Cantidad de flujos con superación de tiempo de ejecución: %4
			           |Cantidad de flujos con finalización imprevista: %5'"),
			SecondsFormat(JobsResultsProcessingTime),
			SecondsFormat(MinJobResultProcessingTime),
			SecondsFormat(MaxJobResultProcessingTime),
			CountFormat(Indicators.ThreadsExceedingExecutionTimeCount),
			CountFormat(Indicators.ThreadsWithNonStandardCompletionCount));
	EndIf;
	Data = Context.MainSessionDetails.ID;
	
	WriteLogEvent(
		NStr("ru = 'Управление доступом.Показатели.Обновление доступа'; en = 'Access management.Indicators.Access update'; pl = 'Kontrola dostępu.Wskaźniki.Aktualizacja dostępu';de = 'Zugangskontrolle.Indikatoren.Zugriff auf Update';ro = 'Administrarea accesului.Indicatori.Actualizarea accesului';tr = 'Erişim kontrolü Göstergeler Erişim güncellemesi.'; es_ES = 'Gestión de acceso.Indicadores.Actualización de acceso'",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, , Data, Comment);
		
EndProcedure

// For the UpdateListAccessInBackground procedure.
Procedure RegisterActiveThreadUpdateIndicators(Context)
	
	Indicators = Context.Indicators;
	
	NewJobsWaitTime = Indicators.NewJobsWaitTime / 1000;
	
	NumberFormat = "NZ=0; NG=";
	Comment = NStr("ru = 'Завершен сеанс исполняющего потока обновления доступа.'; en = 'Session of active access update thread is completed.'; pl = 'Sesja wykonującego strumienia kontroli aktualizacji dostępu została zakończona. ';de = 'Die Sitzung des Aktualisierungs-Streams für den ausführbaren Zugriff wird beendet.';ro = 'Sesiunea fluxului principal de actualizare a accesului este finalizată.';tr = 'Erişim güncelleme iş parçacığını çalıştıran oturum sona erdi.'; es_ES = 'Se ha terminado la sesión del flujo ejecutivo de actualización de acceso.'");
	AddSessionOperationIndicatorsValues(Comment, Indicators, Context.CurrentSession);
	
	Comment = Comment + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Номер сеанса управляющего потока: %1
		           |Начало сеанса управляющего потока: %2
		           |
		           |Количество ожиданий новых заданий: %3
		           |Время ожидания новых заданий: %4 сек'; 
		           |en = 'Number of control thread session: %1
		           |Control thread session start: %2
		           |
		           |Number of waitings for new jobs: %3
		           |New job waiting time: %4 sec'; 
		           |pl = 'Numer sesji sterującego strumienia: %1
		           |Początek sesji sterującego strumienia: %2
		           |
		           |Liczba oczekujących nowych zadań: %3
		           |Czas oczekiwania na nowe zadania: %4 sek.';
		           |de = 'Kontrollstream-Sitzungsnummer: %1
		           |Start der Kontrollstream-Sitzung: %2
		           |
		           |Anzahl der erwarteten neuen Jobs: %3
		           |Wartezeit für neue Jobs: %4 s';
		           |ro = 'Numărul sesiunii fluxului principal: %1
		           |Începutul sesiunii fluxului principal: %2
		           |
		           |Numărul de așteptări ale sarcinilor noi: %3
		           |Timpul de așteptare a sarcinilor noi: %4 sec';
		           |tr = 'Kontrol akışı oturumunun sayısı:%1
		           | Kontrol akışı oturumunun başlangıcı:%2
		           |
		           | Yeni bekleyen işlerin sayısı:%3
		           |Yeni işler için bekleme süresi:%4 s'; 
		           |es_ES = 'Número de sesión del flujo de gestión: %1
		           |Inicio de sesión del flujo de gestión: %2
		           |
		           |Cantidad de espera de tareas nuevas: %3
		           |Tiempo de espera de tareas nuevas: %4 s'"),
		Context.ParentSessionDetails.SessionNumber,
		Context.ParentSessionDetails.SessionStarted,
		CountFormat(Indicators.WaitsForNewJobsCount),
		SecondsFormat(NewJobsWaitTime));
	
	AddJobsExecutionIndicatorsValues(Comment, Indicators);
	Data = Context.ParentSessionDetails.ID;
	
	WriteLogEvent(
		NStr("ru = 'Управление доступом.Показатели.Обновление доступа'; en = 'Access management.Indicators.Access update'; pl = 'Kontrola dostępu.Wskaźniki.Aktualizacja dostępu';de = 'Zugangskontrolle.Indikatoren.Zugriff auf Update';ro = 'Administrarea accesului.Indicatori.Actualizarea accesului';tr = 'Erişim kontrolü Göstergeler Erişim güncellemesi.'; es_ES = 'Gestión de acceso.Indicadores.Actualización de acceso'",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, , Data, Comment);
		
EndProcedure

// For the RegisterLeadingThreadUpdateIndicators and
// RegisterActiveThreadUpdateIndicators procedures.
//
Procedure AddSessionOperationIndicatorsValues(Comment, Indicators, SessionDetails)
	
	OperationTime = (CurrentUniversalDateInMilliseconds()
		- Indicators.WorkStartInMilliseconds) / 1000;
	
	NumberFormat = "NZ=0; NG=";
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Номер сеанса: %1
		           |Начало сеанса: %2
		           |Время работы: %3 сек'; 
		           |en = 'Session number: %1
		           |Session start: %2
		           |Run time: %3 sec'; 
		           |pl = 'Numer sesji: %1
		           |Początek sesji: %2
		           |Czas pracy: %3 sek.';
		           |de = 'Sitzungsnummer: %1
		           |Sitzungsbeginn: %2
		           |Arbeitszeit: %3 s';
		           |ro = 'Numărul sesiunii: %1
		           |Începutul sesiunii: %2
		           |Timpul de lucru: %3 sec';
		           |tr = 'Seans Numarası:%1
		           | Seansı Başlat:%2
		           | Çalışma Süresi:%3 sn'; 
		           |es_ES = 'Número de sesión: %1
		           |Inicio de sesión: %2
		           |Tiempo de funcionamiento: %3 s'"),
		SessionDetails.SessionNumber,
		SessionDetails.SessionStarted,
		SecondsFormat(OperationTime));
	
EndProcedure

// For the RegisterLeadingThreadUpdateIndicators and
// RegisterActiveThreadUpdateIndicators procedures.
//
Procedure AddJobsExecutionIndicatorsValues(Comment, Indicators)
	
	JobsWithGettingBatchesExecutionTime              = Indicators.JobsWithGettingBatchesExecutionTime / 1000;
	JobsWithGettingBatchesMaxExecutionTime  = Indicators.JobsWithGettingBatchesMaxExecutionTime / 1000;
	JobsWithGettingBatchesMinExecutionTime   = Indicators.JobsWithGettingBatchesMinExecutionTime / 1000;
	
	JobsWithoutGettingBatchesExecutionTime             = Indicators.JobsWithoutGettingBatchesExecutionTime / 1000;
	JobsWithoutGettingBatchesMaxExecutionTime = Indicators.JobsWithoutGettingBatchesMaxExecutionTime / 1000;
	JobsWithoutGettingBatchesMinExecutionTime  = Indicators.JobsWithoutGettingBatchesMinExecutionTime / 1000;
	
	ExecutedJobsCount = Indicators.ExecutedJobsWithGettingBatchesCount
		+ Indicators.JobsWithoutGettingBatchesCount;
	
	JobsExecutionTime = JobsWithGettingBatchesExecutionTime + JobsWithoutGettingBatchesExecutionTime;
	ExecutionTimeOfJobsWithRetriesBecauseOfErrors = Indicators.ExecutionTimeOfJobsWithRetriesBecauseOfErrors / 1000;
	
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Количество выполненных заданий: %1
		           |Время выполнения заданий: %2 сек
		           |
		           |Количество заданий с повторами из-за ошибок: %3
		           |Время выполнения заданий с повторами из-за ошибок: %4 сек
		           |Количество повторов заданий из-за ошибок: %5
		           |Максимум повторов отдельного задания из-за ошибок: %6'; 
		           |en = 'Jobs completed: %1
		           |Total time for completed jobs: %2 sec
		           |
		           |Jobs retried due to errors: %3
		           |Total time for retried jobs: %4 sec
		           |Retry attempts due to errors: %5
		           |Maximum rertry attempts for a single job: %6'; 
		           |pl = 'Liczba wykonanych zadań: %1
		           |Czas realizacji zadania: %2 sek.
		           |
		           |Liczba zadań z powtórzeniami z powodu błędów: %3
		           |Czas wykonywania zadań z powtórzeniami z powodu błędów: %4 sek.
		           |Liczba powtórzeń zadań z powodu błędów: %5
		           |Maksymalna liczba powtórzeń danego zadania z powodu błędów: %6';
		           |de = 'Anzahl der erledigten Aufgaben: %1
		           |Zeitpunkt der Aufgabenausführung: %2 s 
		           |
		           |Anzahl der Aufgaben mit Wiederholungen aufgrund von Fehlern: %3
		           |Fehlerwiederholte Aufträge: %4 s 
		           |Fehlerwiederholte Aufträge: %5
		           |Maximale Anzahl der Aufträge, die aufgrund von Fehlern wiederholt werden: %6';
		           |ro = 'Numărul de sarcini executate: %1
		           |Timpul de executare a sarcinilor: %2 sec
		           |
		           |Numărul de sarcini cu repetări din cauza erorilor: %3
		           |Timpul de executare a sarcinilor cu repetări din cauza erorilor: %4 sec
		           |Numărul de repetări ale sarcinilor din cauza erorilor: %5
		           |Maximul de repetări ale sarcinii separate din cauza erorilor: %6';
		           |tr = 'Tamamlanan görevlerin sayısı:%1
		           | Görev yürütme süresi:%2
		           |
		           | saniye Hatalar nedeniyle tekrarlanan görevlerin sayısı:%3
		           | Hatalardan dolayı tekrarlar ile görev yürütme süresi: %4saniye 
		           |Hatalar nedeniyle tekrarlanan görevlerin sayısı:%5
		           |Hatalar nedeniyle tek bir görevin maksimum tekrarı:%6'; 
		           |es_ES = 'Cantidad de tareas ejecutadas: %1
		           |Tiempo de ejecución de tareas: %2 s
		           |
		           |Cantidad de tareas con repetición a causa de errores: %3
		           |Tiempo de ejecución de tareas con repetición a causa de errores: %4 s
		           |Cantidad de repetición de tareas a causa de errores: %5
		           |Máximo de repeticiones de tarea separada a causa de errores: %6'"),
		CountFormat(ExecutedJobsCount),
		SecondsFormat(JobsExecutionTime),
		CountFormat(Indicators.JobsWithRetriesBecauseOfErrorsCount),
		SecondsFormat(ExecutionTimeOfJobsWithRetriesBecauseOfErrors),
		CountFormat(Indicators.JobsRetriesBecauseOfErrorsCount),
		CountFormat(Indicators.MaxJobRetriesOnErrorCount));
	
	Comment = Comment + Chars.LF + Chars.LF + StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Задания получения порций и/или обработки маленькой порции:
		           |- количество выполненных заданий: %1
		           |- время выполнения заданий: %2 сек
		           |- минимальное время выполнения задания: %3 сек
		           |- максимальное время выполнения задания: %4 сек
		           |
		           |Задания обработки порций:
		           |- количество выполненных заданий: %5
		           |- время выполнения заданий: %6 сек
		           |- минимальное время выполнения задания: %7 сек
		           |- максимальное время выполнения задания: %8 сек'; 
		           |en = 'Jobs for getting batches or processing a small batch:
		           |- jobs completed: %1
		           |- total time: %2 sec
		           |- minimum job completion time: %3 sec
		           |- maximum job completion time: %4 sec
		           |
		           |Batch processing jobs:
		           |- jobs completed jobs:%5
		           |- total time: %6 sec
		           |- minimum job completion time: %7 sec
		           |- maximum job completion time: %8 sec'; 
		           |pl = 'Zadania otrzymaniu porcji i/lub przetwarzania małej części:
		           |- ilość wykonanych zadań: %1
		           |- czas realizacji zadań: %2 sek.
		           |- minimalny czas realizacji zadania: %3 sek.
		           |- maksymalny czas realizacji zadania: %4 sek.
		           |
		           |Zadania przetwarzania części:
		           |- ilość wykonanych zadań:%5
		           |- czas realizacji zadania: %6 sek.
		           |- minimalny czas realizacji zadania: %7 sek.
		           |- maksymalny czas realizacji zadania: %8 sek.';
		           |de = 'Aufgaben zum Empfangen von Portionen und / oder zum Verarbeiten einer kleinen Portion:
		           |- Anzahl der erledigten Aufgaben: %1
		           |- Ausführungszeit der Aufgabe: %2 s
		           |- Minimale Ausführungszeit der Aufgabe: %3 s
		           |- Maximale Ausführungszeit der Aufgabe: %4s
		           |
		           | Aufgabenverarbeitungsaufgaben:
		           |- Anzahl der erledigten Aufgaben: %5
		           |- Ausführungszeit der Aufgabe: %6 s
		           |- Minimale Task-Ausführungszeit: %7 s
		           |- Maximale Task-Ausführungszeit: %8 s';
		           |ro = 'Sarcinile de obținere a porțiunilor și/sau a procesării unei porțiuni mici:
		           |- numărul de sarcini executate: %1
		           |- timpul de executare a sarcinilor: %2 sec
		           |- timpul minim de executare a sarcinii: %3 sec
		           |- timpul maxim de executare a sarcinii: %4 sec
		           |
		           |Sarcinile de procesare a porțiunilor:
		           |- numărul de sarcini executate: %5
		           |- timpul de executare a sarcinilor: %6 sec
		           |- timpul minim de executare a sarcinii: %7 sec
		           |- timpul maxim de executare a sarcinii: %8 sec';
		           |tr = 'Bölüm alma ve / veya küçük bölümleri işleme görevleri:
		           | - tamamlanan görev sayısı:%1
		           | - görev yürütme süresi:%2 saniye
		           |- minimum görev yürütme süresi: %3saniye
		           |- maksimum görev yürütme süresi:%4 sn 
		           |
		           |Görev işleme bölümleri:
		           | - tamamlanan görev sayısı:%5
		           | - görev yürütme süresi: %6sn
		           |- asgari görev yürütme süresi:%7 sec
		           |- asgari görev yürütme süresi:%8 sn'; 
		           |es_ES = 'La tarea de recibir partes y/o procesamientos de parte pequeña:
		           |- cantidad de tareas ejecutadas: %1
		           |- tiempo de ejecutar las tareas: %2 s
		           |- tiempo mínimo de ejecutar las tareas: %3 s
		           |- tiempo máximo de ejecutar las tareas: %4 s
		           |
		           |Tareas de procesar partes:
		           |- cantidad de tareas ejecutadas: %5
		           |- tiempo de ejecutar las tareas: %6 s
		           |- tiempo mínimo de ejecutar las tareas: %7 s
		           |-tiempo máximo de ejecutar las tareas: %8 s'"),
		CountFormat(Indicators.ExecutedJobsWithGettingBatchesCount),
		SecondsFormat(JobsWithGettingBatchesExecutionTime),
		SecondsFormat(JobsWithGettingBatchesMinExecutionTime),
		SecondsFormat(JobsWithGettingBatchesMaxExecutionTime),
		CountFormat(Indicators.JobsWithoutGettingBatchesCount),
		SecondsFormat(JobsWithoutGettingBatchesExecutionTime),
		SecondsFormat(JobsWithoutGettingBatchesMinExecutionTime),
		SecondsFormat(JobsWithoutGettingBatchesMaxExecutionTime));
	
	If ValueIsFilled(Indicators.ErrorsTextOnRetryAttempts) Then
		Comment = Comment + Chars.LF + Chars.LF
			+ NStr("ru = 'Тексты ошибок при попытках повторного выполнения:'; en = 'Error texts upon retry attempts:'; pl = 'Teksty błędów podczas próby ponownego wykonania:';de = 'Fehlertexte beim erneuten Ausführen:';ro = 'Textele erorilor la tentativele de executare repetată:';tr = 'Yeniden yürütmeye çalışırken hata metinleri:'; es_ES = 'Textos de errores al probar de ejecutar de nuevo:'")
			+ Chars.LF + Chars.LF + Indicators.ErrorsTextOnRetryAttempts;
	EndIf;
	
EndProcedure

// For the AccessUpdateAtRecordLevel, ProcessJobResult, and RegisterAccessUpdateError procedures.
Procedure AddCompletionErrorText(CompletionErrorText, ErrorText)
	
	If Not ValueIsFilled(ErrorText) Then
		Return;
	EndIf;
	
	If ValueIsFilled(CompletionErrorText) Then
		If StrFind(CompletionErrorText, ErrorText) > 0 Then
			Return;
		EndIf;
		CompletionErrorText = CompletionErrorText + Chars.LF + Chars.LF;
	EndIf;
	
	CompletionErrorText = CompletionErrorText + ErrorText;
	
EndProcedure

// For procedures UpdateBackgroundJobProperties, CancelThreadBackgroundJob, ProcessJobExecution,
// DeleteStoppedThreads, and UpdateListAccessInBackground.
//
Function UpdateErrorTextWithContext(ErrorInformation, CommonUpdateParameters, ErrorToFix = False)
	
	If TypeOf(ErrorInformation) = Type("ErrorInfo") Then
		ErrorPresentation = DetailErrorDescription(ErrorInformation);
	Else
		ErrorPresentation = String(ErrorInformation);
	EndIf;
	
	If Not ValueIsFilled(ErrorPresentation) Then
		Return "";
	EndIf;
	
	If CommonUpdateParameters = Undefined Then
		ErrorText = ErrorPresentation;
		
	ElsIf Not CommonUpdateParameters.IsRightsUpdate Then
		
		If CommonUpdateParameters.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'При обновлении ключей доступа к элементам данных списка
				           |""%1"" (для внешних пользователей)
				           |возникла ошибка:
				           |%2'; 
				           |en = 'An error occurred when updating access keys
				           |to the ""%1"" list data items
				           |(for external users):
				           |%2'; 
				           |pl = 'Podczas aktualizowania kluczy dostępu do elementów danych listy
				           |""%1"" (dla użytkowników zewnętrznych)
				           |wystąpił błąd:
				           |%2';
				           |de = 'Beim Aktualisieren der Zugriffsschlüssel auf die Listendatenelemente
				           |""%1"" ist ein Fehler aufgetreten (für externe Benutzer)
				           |:
				           |%2';
				           |ro = 'La actualizarea cheilor de acces la elementele datelor listei
				           |""%1"" (pentru utilizatorii externi)
				           |s-a produs eroarea:
				           |%2';
				           |tr = 'Erişim tuşlarını liste veri öğelerine güncellerken
				           | ""%1(harici kullanıcılar için)
				           |, bir hata oluştu:
				           |%2'; 
				           |es_ES = 'Al actualizar las claves de acceso a los elementos de datos de la lista
				           |""%1"" (para usuarios externos)
				           |se ha producido un error:
				           |%2'"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'При обновлении ключей доступа к элементам данных списка
				           |""%1"" (для пользователей)
				           |возникла ошибка:
				           |%2'; 
				           |en = 'An error occurred when updating access keys
				           |to the ""%1"" list data items
				           |(for users):
				           |%2'; 
				           |pl = 'Podczas aktualizowania kluczy dostępu do elementów danych listy
				           |""%1"" (dla użytkowników)
				           |wystąpił błąd:
				           |%2';
				           |de = 'Beim Aktualisieren der Zugriffsschlüssel auf die Listendatenelemente 
				           |""%1"" (für Benutzer)
				           |ist ein Fehler aufgetreten:
				           |%2';
				           |ro = 'La actualizarea cheilor de acces la elementele datelor listei
				           |""%1"" (pentru utilizatori)
				           |s-a produs eroarea:
				           |%2';
				           |tr = 'Erişim anahtarlarını liste veri öğelerine güncellerken 
				           |""%1(kullanıcılar için)
				           |, bir hata oluştu:
				           |%2'; 
				           |es_ES = 'Al actualizar las claves de acceso a los elementos de datos de la lista
				           |""%1"" (para usuarios)
				           |se ha producido un error:
				           |%2'"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		EndIf;
		
	Else // UsersAccessKeysUpdate.
		
		If CommonUpdateParameters.ForExternalUsers Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'При обновлении ключей доступа внешних пользователей списка
				           |""%1""
				           |возникла ошибка:
				           |%2'; 
				           |en = 'An error occurred when updating access keys for external users of the
				           |""%1""
				           |list:
				           |%2'; 
				           |pl = 'Podczas aktualizowania kluczy dostępu do użytkowników zewnętrznych listy
				           |""%1""
				           |wystąpił błąd:
				           |%2';
				           |de = 'Beim Aktualisieren der Zugriffsschlüssel externer Benutzer der Liste
				           |""%1""
				           |ist ein Fehler aufgetreten:
				           |%2';
				           |ro = 'La actualizarea cheilor de acces ale utilizatorilor externi ai listei
				           |""%1""
				           |s-a produs eroarea:
				           |%2';
				           |tr = '
				           |""%1"" 
				           |Listesinin harici kullanıcılarının erişim anahtarlarını güncellerken bir hata oluştu:
				           |%2'; 
				           |es_ES = 'Al actualizar las claves de acceso de usuarios externos de la lista
				           |""%1""
				           |se ha producido un error:
				           |%2'"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'При обновлении ключей доступа пользователей списка
				           |""%1""
				           |возникла ошибка:
				           |%2'; 
				           |en = 'An error occurred when updating access keys for users of the
				           |""%1""
				           |list:
				           |%2'; 
				           |pl = 'Podczas aktualizowania kluczy dostępu do użytkowników listy
				           |""%1""
				           |wystąpił błąd:
				           |%2';
				           |de = 'Beim Aktualisieren der Zugriffsschlüssel externer Benutzer der Liste
				           |""%1""
				           |ist ein Fehler aufgetreten:
				           |%2';
				           |ro = 'La actualizarea cheilor de acces ale utilizatorilor listei
				           |""%1""
				           |s-a produs eroarea:
				           |%2';
				           |tr = '
				           |""%1""
				           | Listesindeki kullanıcıların erişim anahtarlarını güncellerken bir hata oluştu:
				           |%2'; 
				           |es_ES = 'Al actualizar las claves de acceso de usuarios de la lista
				           |""%1""
				           |se ha producido un error:
				           |%2'"),
				String(CommonUpdateParameters.ListID),
				ErrorPresentation);
		EndIf;
	EndIf;
	
	If ErrorToFix Then
		ErrorText = NStr("ru = 'Возникла устранимая ошибка (обновление продолжается автоматически).'; en = 'A recoverable error occurred (update continues automatically).'; pl = 'Wystąpił błąd nie krytyczny (aktualizacja rozpocznie się automatycznie).';de = 'Ein behebbarer Fehler ist aufgetreten (Aktualisierung wird automatisch fortgesetzt).';ro = 'S-a produs eroare reparabilă (actualizarea continuă în mod automat).';tr = 'Kurtarılabilir bir hata oluştu (güncelleme otomatik olarak devam ediyor).'; es_ES = 'Se ha producido un error evitable (la actualización continúa automáticamente).'")
			+ Chars.LF + ErrorText;
	EndIf;
	
	Return ErrorText;
	
EndFunction

// For procedures AccessUpdateAtRecordLevel, CompleteBackgroundJobs,
// ProcessCompletedJobResult, UpdateBackgroundJobProperties,
// UpdateListAccessInBackground.
//
Procedure RegisterAccessUpdateError(ErrorText, Context)
	
	If Context.Property("ParentSessionDetails") Then
		Data = Context.ParentSessionDetails.ID;
	Else
		Data = Context.MainSessionDetails.ID;
	EndIf;
	
	WriteLogEvent(
		NStr("ru = 'Управление доступом.Обновление доступа на уровне записей'; en = 'Access management.Access update at record level'; pl = 'Kontrola dostępu.Aktualizacja dostępu na poziomie zapisów';de = 'Zugangskontrolle. Aktualisieren des Zugriffs auf Aufzeichnungsebene';ro = 'Administrarea accesului.Actualizarea accesului la nivelul înregistrărilor';tr = 'Erişim kontrolü. Kayıt seviyesinde erişim güncelleme'; es_ES = 'Gestión de acceso.Actualización de acceso en nivel de registros'",
			Common.DefaultLanguageCode()),
		EventLogLevel.Error, , Data, ErrorText);
	
EndProcedure

// For the StartListAccessUpdate function and the UpdateListAccessInBackground procedure.
Procedure UpdateListAccessWithRetryAttempts(CommonUpdateParameters, Context)
	
	Indicators = Context.Indicators;
	
	If Indicators <> Undefined Then
		Indicators.StartFirstAttemptToExecuteJob = CurrentUniversalDateInMilliseconds();
	EndIf;
	
	ExecutionAttempt = 1;
	ExecutionAttemptsErrors = New Array;
	While True Do
		CurrentAttemptErrorText = "";
		If Indicators <> Undefined Then
			Indicators.JobWithGettingBatches = Not CommonUpdateParameters.Property("BatchFromSet");
			Indicators.JobExecutionStart = CurrentUniversalDateInMilliseconds();
		EndIf;
		Try
			ExecuteUpdateListAccess(CommonUpdateParameters);
		Except
			CurrentAttemptErrorText = DetailErrorDescription(ErrorInfo());
		EndTry;
		If Indicators <> Undefined AND Not ValueIsFilled(CurrentAttemptErrorText) Then
			RemoveJobExecutionIndicators(Indicators);
		EndIf;
		If ValueIsFilled(CurrentAttemptErrorText) Then
			CurrentAttemptErrorTime = Format(CurrentSessionDate(), "DLF=DT");
			ExecutionAttemptsErrors.Add(CurrentAttemptErrorTime + " " + CurrentAttemptErrorText);
			ExecutionAttempt = ExecutionAttempt + 1;
			If ExecutionAttempt < 9 Then
				For Counter = 1 To ExecutionAttempt Do
					If AccessUpdateCanceled() Then
						Break;
					EndIf;
					If Context.CurrentBackgroundJob <> Undefined Then
						Try
							Context.CurrentBackgroundJob.WaitForCompletion(1);
						Except
							Continue;
						EndTry;
					Else
						WaitBoundary = CurrentUniversalDateInMilliseconds() + 1000;
						While WaitBoundary > CurrentUniversalDateInMilliseconds() Do
							Continue;
						EndDo;
					EndIf;
				EndDo;
				If Not AccessUpdateCanceled() Then
					Continue;
				EndIf;
			EndIf;
		EndIf;
		ErrorText = StrConcat(ExecutionAttemptsErrors, Chars.LF + "---" + Chars.LF);
		ErrorText = UpdateErrorTextWithContext(ErrorText, CommonUpdateParameters);
		
		If ValueIsFilled(CurrentAttemptErrorText) Then
			CommonUpdateParameters.Insert("CompletionErrorText", "");
			AddCompletionErrorText(CommonUpdateParameters.CompletionErrorText, ErrorText);
		EndIf;
		If Indicators <> Undefined Then
			RemoveJobExecutionErrorsIndicators(Indicators, ErrorText, ExecutionAttemptsErrors.Count());
		EndIf;
		Break;
	EndDo;
	
EndProcedure

// For the UpdateListAccessWithRetryAttempts procedure.
Procedure ExecuteUpdateListAccess(CommonUpdateParameters)
	
	If Not CommonUpdateParameters.Property("Cache") Then
		CommonUpdateParameters.Insert("Cache", New Structure);
	EndIf;
	
	If CommonUpdateParameters.ListID = Undefined Then
		MetadataObject = Null;
	ElsIf CommonUpdateParameters.Property("Cache")
	        AND CommonUpdateParameters.Cache.Property("MetadataObjectsByIDs") Then
		
		MetadataObject = CommonUpdateParameters.Cache.MetadataObjectsByIDs.Get(
			CommonUpdateParameters.ListID);
	Else
		MetadataObject = Common.MetadataObjectByID(
			CommonUpdateParameters.ListID, False);
	EndIf;
	
	If MetadataObject = Undefined Then
		// If a configuration extension is disabled, the update is unavailable, but you cannot clear a 
		// registration to update.
		Return;
	EndIf;
	
	IsRightsUpdate = CommonUpdateParameters.IsRightsUpdate;
	
	If Not CommonUpdateParameters.ForExternalUsers
	   AND CommonUpdateParameters.ListID
	       = Catalogs.MetadataObjectIDs.EmptyRef() Then
		DeleteObjectsOfInvalidTypesInAccessKeysToObjectsRegister();
	EndIf;
	
	UpdateParameters = UpdateParameters(CommonUpdateParameters, MetadataObject);
	
	// Processing a batch prepared earlier.
	If CommonUpdateParameters.Property("BatchFromSet") Then
		BatchFromSet = CommonUpdateParameters.BatchFromSet;
		BatchItems = BatchFromSet.Items.Get();
		UpdateParameters.Insert("LastUpdatedItem",
			BatchFromSet.LastBatchItem);
		
		UpdateItemsBatch(BatchItems, UpdateParameters);
		
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			UpdateParameters.NewLastUpdatedItem);
		
		If BatchItems <> Undefined Then
			CommonUpdateParameters.ProcessingCompleted = False;
			SelectedAllItems = BatchFromSet.LastBatchItem.DataKey = Null;
			CommonUpdateParameters.Insert("BatchesSet", ItemsBatchesSet(
				UpdateParameters, BatchItems, SelectedAllItems));
		EndIf;
		Return;
	EndIf;
	
	// Preparing a processing plan for data items.
	PreparationCompleted = False;
	UpdateParameters.Insert("UpdateRestart", False);
	
	While Not PreparationCompleted Do
		PreparationCompleted = True;
		UpdateParameters.Insert("HasJobs", True);
		UpdateParameters.Insert("SpotJob", Undefined);
		UpdateParameters.Insert("LastUpdatedItem", InitialItem(UpdateParameters));
		PrepareUpdatePlan(UpdateParameters, PreparationCompleted);
	EndDo;
	
	If Not UpdateParameters.HasJobs Then
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	If UpdateParameters.SpotJob <> Undefined Then
		SelectedAllItems = False;
		Items = SpotJobItemsForUpdate(UpdateParameters,
			ItemsInQueryCount(IsRightsUpdate), SelectedAllItems);
		
		If Items <> Undefined Then
			MaxMilliseconds = SpotJobExecutionMinSecondsCount() * 1000;
			If UpdateParameters.ProcessingTimeBoundary - CurrentUniversalDateInMilliseconds() < MaxMilliseconds Then
				UpdateParameters.ProcessingTimeBoundary = CurrentUniversalDateInMilliseconds() + MaxMilliseconds;
			EndIf;
			UpdateItemsBatch(Items, UpdateParameters, True);
		EndIf;
		If Items <> Undefined Or Not SelectedAllItems Then
			RestartUpdateAtNotCompletedSpotUpdate(UpdateParameters);
		EndIf;
	EndIf;
	
	ClarifyLastUpdatedItem(UpdateParameters);
	
	If UpdateParameters.LastUpdatedItem.DataKeyKind = "NoData" Then
		UpdateParameters.LastUpdatedItem.DataKey = Null;
		WriteLastUpdatedItem(CommonUpdateParameters,
			UpdateParameters.LastUpdatedItem);
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	If UpdateParameters.SpotJob <> Undefined Then
		UpdateParameters.LastUpdatedItem.Insert("ClearSpotJob");
		WriteLastUpdatedItem(CommonUpdateParameters,
			UpdateParameters.LastUpdatedItem);
		UpdateParameters.LastUpdatedItem.Delete("ClearSpotJob");
	EndIf;
	
	If UpdateParameters.UpdateRestart Then
		CommonUpdateParameters.Insert("UpdateRestart");
		If CommonUpdateParameters.Property("NewLastBatchItem") Then
			CommonUpdateParameters.Delete("NewLastBatchItem");
		EndIf;
	EndIf;
	
	If CommonUpdateParameters.GetBatches > 0
	   AND CommonUpdateParameters.Property("NewLastBatchItem") Then
		
		UpdateParameters.LastUpdatedItem = InitialItem(UpdateParameters);
		FillPropertyValues(UpdateParameters.LastUpdatedItem,
			CommonUpdateParameters.NewLastBatchItem);
	EndIf;
	
	If Not IsRightsUpdate
	   AND UpdatePeriodToDataPeriod(CommonUpdateParameters.StartDate,
	         UpdateParameters.LastUpdatedItem.Date) Then
		
		CommonUpdateParameters.Insert("NewLastUpdatedItem",
			UpdateParameters.LastUpdatedItem);
		
		CommonUpdateParameters.ProcessingCompleted = False;
		Return;
	EndIf;
	
	// Single thread update of some access group sets.
	If Not IsRightsUpdate
	   AND IsCatalogAccessGroupsSets(UpdateParameters)
	   AND UpdateParameters.LastUpdatedItem.DataKey = Undefined Then
		
		If UpdateParameters.LastUpdatedItem.DataKeyKind = "NewSingleUserSets" Then
			EliminateSetsDuplicatesFromOneUserInCatalog(UpdateParameters);
			
		ElsIf UpdateParameters.LastUpdatedItem.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			FillBlankGroupsSetsHashes(UpdateParameters);
			
		ElsIf UpdateParameters.LastUpdatedItem.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			ClearBlankAccessGroupsSetRights(UpdateParameters);
			
		ElsIf IsObsoleteItemsDataProcessor(UpdateParameters) Then
			ClearNonExistentAccessGroupsSetsRights(UpdateParameters);
		EndIf;
	EndIf;
	
	// Requesting items for processing.
	SelectedAllItems = False;
	
	If CommonUpdateParameters.GetBatches > 0 Then
		CountInBatch = ItemsInBatchCount(UpdateParameters);
		CountInQuery = CountInBatch * CommonUpdateParameters.GetBatches;
		Items = ItemsForUpdate(UpdateParameters, CountInQuery, SelectedAllItems);
		
		If CommonUpdateParameters.Property("NewLastBatchItem")
		 Or Items <> Undefined
		   AND Items.Count() > CountInBatch * 2 Then
			
			CommonUpdateParameters.ProcessingCompleted = False;
			CommonUpdateParameters.Insert("BatchesSet", ItemsBatchesSet(
				UpdateParameters, Items, SelectedAllItems, CountInBatch));
			Return;
		EndIf;
	Else
		Return;
	EndIf;
	
	// Processing data items.
	UpdateParameters.Insert("NewLastUpdatedItem",
		InitialItem(UpdateParameters, , True));
	
	CommonUpdateParameters.Insert("InitialUpdateCompleted");
	
	If Items <> Undefined Then
		UpdateItemsBatch(Items, UpdateParameters);
	EndIf;
	
	// Clarifying new last item.
	If Items = Undefined AND SelectedAllItems Then
		SetLastBlankItem(UpdateParameters.NewLastUpdatedItem,
			UpdateParameters);
	EndIf;
	
	// Writing new last item.
	WriteLastUpdatedItem(CommonUpdateParameters,
		UpdateParameters.NewLastUpdatedItem);
	
	If UpdateParameters.NewLastUpdatedItem.DataKey = Null Then
		CommonUpdateParameters.Insert("NoJobs");
		Return;
	EndIf;
	
	CommonUpdateParameters.Insert("NewLastUpdatedItem",
		UpdateParameters.NewLastUpdatedItem);
	
	// Preparing the rest of items to continue update.
	If Items <> Undefined Then
		CommonUpdateParameters.Insert("BatchesSet",
			ItemsBatchesSet(UpdateParameters, Items, SelectedAllItems));
	EndIf;
	
EndProcedure

Function IsCatalogAccessGroupsSets(UpdateParameters)
	
	If UpdateParameters.Property("List") Then
		Return UpdateParameters.List = "Catalog.SetsOfAccessGroups";
	EndIf;
	
	Return UpdateParameters.ListID
		= UpdateParameters.AccessGroupsSetsCatalogID;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Function UpdateParameters(CommonUpdateParameters, MetadataObject)
	
	UpdateParameters = New Structure("IsRightsUpdate,
		|ListID, ForExternalUsers, Cache,
		|StartDate, EndDate, MaxBatchesFromOriginalItem,
		|IsBackgroundAccessUpdate, AccessGroupsSetsCatalogID");
	
	FillPropertyValues(UpdateParameters, CommonUpdateParameters);
	
	If TypeOf(MetadataObject) = Type("MetadataObject") Then
		UpdateParameters.Insert("List", MetadataObject.FullName());
	EndIf;

	UpdateParameters.Insert("ProcessingTimeBoundary",
		CurrentUniversalDateInMilliseconds()
		+ CommonUpdateParameters.MaxProcessingMilliseconds);
	
	AddRestrictionParameters(UpdateParameters);
	
	Return UpdateParameters;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Procedure AddRestrictionParameters(UpdateParameters)
	
	If IsCatalogAccessGroupsSets(UpdateParameters) Then
		UpdateParameters.Insert("ListWithDate", False);
		UpdateParameters.Insert("ListWithPeriod", False);
		UpdateParameters.Insert("IsReferenceType", True);
		UpdateParameters.Insert("BlankAccessGroupsSet", Catalogs.SetsOfAccessGroups.EmptyRef());
		Return;
	EndIf;
	
	TransactionID = New UUID;
	List = ?(UpdateParameters.Property("List"), UpdateParameters.List, "");
	ListPropertiesAsLeadingOne = ListPropertiesAsLeadingOne(List, TransactionID);
	RestrictionParameters = RestrictionParameters(List,
		TransactionID, UpdateParameters.ForExternalUsers);
	
	RestrictionParameters = New Structure(RestrictionParameters);
	For Each KeyAndValue In UpdateParameters Do
		RestrictionParameters.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	UpdateParameters = RestrictionParameters;
	UpdateParameters.Insert("TransactionID", TransactionID);
	
	UsersKindPropertyName = ?(UpdateParameters.ForExternalUsers,
		"ForExternalUsers", "ForUsers");
	
	If ListPropertiesAsLeadingOne = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys = Undefined
	 Or ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName] = Undefined Then
		
		UpdateParameters.Insert("DependentListsByAccessKeys", New Array);
	Else
		UpdateParameters.Insert("DependentListsByAccessKeys",
			ListPropertiesAsLeadingOne.ByAccessKeys[UsersKindPropertyName]);
	EndIf;
	
EndProcedure

// For the ExecuteListAccessUpdate and PrepareUpdatePlan procedures.
Function InitialItem(UpdateParameters, DataKeyKind = Undefined,
			SaveDataKeyKind = False, RestartUpdateFromBeginning = False)
	
	InitialItem = New Structure;
	InitialItem.Insert("DataKey");
	InitialItem.Insert("ProcessObsoleteItems", False);
	
	If DataKeyKind = Undefined Then
		If SaveDataKeyKind Then
			DataKeyKind = UpdateParameters.LastUpdatedItem.DataKeyKind;
			If UpdateParameters.LastUpdatedItem.ProcessObsoleteItems Then
				InitialItem.ProcessObsoleteItems = True;
			EndIf;
		ElsIf UpdateParameters.IsRightsUpdate
		      Or IsCatalogAccessGroupsSets(UpdateParameters) Then
			
			DataKeyKind = "ItemsWithObsoleteRights";
		Else
			DataKeyKind = "ItemsWithObsoleteKeys";
		EndIf;
		
	ElsIf DataKeyKind <> "NoData"
		    AND UpdateParameters.Property("LastUpdatedItem")
		    AND UpdateParameters.LastUpdatedItem.ProcessObsoleteItems Then
		
		InitialItem.ProcessObsoleteItems = True;
	EndIf;
	SetDataKeyKind(InitialItem, DataKeyKind);
	
	If Not UpdateParameters.IsRightsUpdate Then
		InitialItem.Insert("Date", ?(RestartUpdateFromBeginning,
			MaxDate(), MaxDateOnContinue()));
	EndIf;
	
	Return InitialItem;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Procedure PrepareUpdatePlan(UpdateParameters, PreparationCompleted)
	
	ListID     = UpdateParameters.ListID;
	ForExternalUsers = UpdateParameters.ForExternalUsers;
	IsRightsUpdate       = UpdateParameters.IsRightsUpdate;
	
	Query = New Query;
	Query.SetParameter("List", ListID);
	Query.SetParameter("ForExternalUsers", ForExternalUsers);
	
	Query.Text =
	"SELECT TOP 1000
	|	UniqueKeys.UniqueKey AS UniqueKey,
	|	UniqueKeys.JobParameters AS JobParameters,
	|	UniqueKeys.LatestUpdatedItemDate AS LatestUpdatedItemDate
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS UniqueKeys
	|WHERE
	|	UniqueKeys.List = &List
	|	AND UniqueKeys.ForExternalUsers = &ForExternalUsers
	|
	|ORDER BY
	|	UniqueKeys.List,
	|	UniqueKeys.ForExternalUsers,
	|	UniqueKeys.UniqueKey";
	
	If IsRightsUpdate Then
		Query.Text = StrReplace(Query.Text,
			"InformationRegister.DataAccessKeysUpdate",
			"InformationRegister.UsersAccessKeysUpdate");
		Query.Text = StrReplace(Query.Text, ",
			|	UniqueKeys.LatestUpdatedItemDate AS LatestUpdatedItemDate",
			"");
	EndIf;
	
	QueryResult = Query.Execute();
	
	If QueryResult.IsEmpty() Then
		UpdateParameters.HasJobs = False;
		Return;
	EndIf;
	
	DataExported = QueryResult.Unload();
	
	UpdateRestart = False;
	RestartUpdateFromBeginning = False;
	JobParametersToSave = JobParametersToSave(IsRightsUpdate, UpdateParameters);
	
	If Not ValueIsFilled(DataExported[0].UniqueKey) Then
		CurrentTotal = DataExported[0];
		JobParameters = CurrentTotal.JobParameters.Get();
		If TypeOf(JobParameters) = Type("Structure") Then
			JobParametersToSave = JobParametersToSave(IsRightsUpdate,
				UpdateParameters, JobParameters, UpdateRestart);
		Else
			UpdateRestart = True;
		EndIf;
		If Not UpdateRestart AND Not IsRightsUpdate Then
			SavedDate = CurrentTotal.LatestUpdatedItemDate;
			If TypeOf(SavedDate) = Type("Date") Then
				JobParametersToSave.LastUpdatedItem.Date = SavedDate;
			Else
				UpdateRestart = True;
			EndIf;
		EndIf;
		DataExported.Delete(0);
		If Not UpdateRestart Then
			UpdateParameters.LastUpdatedItem =
				JobParametersToSave.LastUpdatedItem;
		EndIf;
	EndIf;
	
	If Not UpdateRestart
	   AND CurrentTotal <> Undefined
	   AND DataExported.Count() = 0 Then
		
		UpdateParameters.SpotJob = PreparedSpotJob(
			IsRightsUpdate, JobParametersToSave.SpotJob, UpdateRestart);
		If Not UpdateRestart Then
			Return;
		EndIf;
	EndIf;
	
	BlankID = CommonClientServer.BlankUUID();
	FullRegisterName = ?(IsRightsUpdate, "InformationRegister.UsersAccessKeysUpdate",
		"InformationRegister.DataAccessKeysUpdate");
	
	Lock = New DataLock;
	LockItem = Lock.Add(FullRegisterName);
	LockItem.SetValue("List",                  ListID);
	LockItem.SetValue("ForExternalUsers", ForExternalUsers);
	LockItem.SetValue("UniqueKey",        BlankID);
	
	For Each String In DataExported Do
		LockItem = Lock.Add(FullRegisterName);
		LockItem.SetValue("List",                  ListID);
		LockItem.SetValue("ForExternalUsers", ForExternalUsers);
		LockItem.SetValue("UniqueKey",        String.UniqueKey);
		Break;
	EndDo;
	
	MaxDate = MaxDate();
	DataKeyProperties = InitialItem(UpdateParameters, "NoData");
	For Each String In DataExported Do
		JobParameters = String.JobParameters.Get();
		If TypeOf(JobParameters) = Type("Structure") AND JobParameters.Property("SpotJob") Then
			AddLeadingObjectToSpotJob(JobParameters.SpotJob,
				JobParametersToSave.SpotJob, UpdateRestart);
		Else
			UpdateRestart = True;
			If Not IsRightsUpdate AND String.LatestUpdatedItemDate = MaxDate Then
				RestartUpdateFromBeginning = True;
			EndIf;
			If DataKeyProperties <> Undefined AND HasDataKeyProperties(JobParameters) Then
				If DataKeyProperties.DataKeyKindOrder > JobParameters.DataKeyKindOrder Then
					DataKeyProperties.DataKeyKindOrder = JobParameters.DataKeyKindOrder;
					DataKeyProperties.DataKeyKind         = JobParameters.DataKeyKind;
				EndIf;
				If IsObsoleteItemsDataProcessor(New Structure("LastUpdatedItem", JobParameters)) Then
					DataKeyProperties.ProcessObsoleteItems = True;
				EndIf;
			Else
				DataKeyProperties = Undefined;
				If IsRightsUpdate Or RestartUpdateFromBeginning Then
					Break;
				EndIf;
			EndIf;
		EndIf;
	EndDo;
	
	UpdateParameters.SpotJob = PreparedSpotJob(
		IsRightsUpdate, JobParametersToSave.SpotJob, UpdateRestart);
	
	If UpdateRestart Then
		UpdateParameters.UpdateRestart = True;
		If RestartUpdateFromBeginning Then
			UpdateParameters.Insert("RestartUpdateFromBeginning");
		EndIf;
		UpdateParameters.LastUpdatedItem =
			InitialItem(UpdateParameters, , , RestartUpdateFromBeginning);
	EndIf;
	
	LastUpdatedItem = UpdateParameters.LastUpdatedItem;
	If DataKeyProperties <> Undefined Then
		If CurrentTotal = Undefined Then
			SetDataKeyKind(LastUpdatedItem, DataKeyProperties.DataKeyKind);
			
		ElsIf LastUpdatedItem.DataKeyKindOrder > DataKeyProperties.DataKeyKindOrder  Then
			LastUpdatedItem.DataKeyKindOrder = DataKeyProperties.DataKeyKindOrder;
			LastUpdatedItem.DataKeyKind         = DataKeyProperties.DataKeyKind;
		EndIf;
		If DataKeyProperties.ProcessObsoleteItems Then
			LastUpdatedItem.ProcessObsoleteItems = True;
		EndIf;
	EndIf;
	JobParametersToSave.LastUpdatedItem = LastUpdatedItem;
	
	If UpdateParameters.LastUpdatedItem.DataKeyKind = "NoData" Then
		JobSize = 1;
	ElsIf IsObsoleteItemsDataProcessor(New Structure("LastUpdatedItem",
					LastUpdatedItem)) Then
		JobSize = 2;
	Else
		JobSize = 3;
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "SELECT TOP 1000", "SELECT TOP 1");
	JobsDeleted = False;
	
	If IsRightsUpdate Then
		UpdatePlan = ServiceRecordSet(InformationRegisters.UsersAccessKeysUpdate);
	Else
		UpdatePlan = ServiceRecordSet(InformationRegisters.DataAccessKeysUpdate);
	EndIf;
	
	UpdatePlan.Filter.List.Set(ListID);
	UpdatePlan.Filter.ForExternalUsers.Set(ForExternalUsers);
	UpdatePlan.Filter.UniqueKey.Set(BlankID);
	
	BeginTransaction();
	Try
		Lock.Lock();
		QueryResult = Query.Execute();
		If QueryResult.IsEmpty() Then
			JobsDeleted = True;
		Else
			Record = UpdatePlan.Add();
			Record.List                  = ListID;
			Record.ForExternalUsers = ForExternalUsers;
			Record.SpotJob         = UpdateParameters.SpotJob <> Undefined;
			Record.JobParameters        = New ValueStorage(JobParametersToSave);
			Record.JobSize           = JobSize;
			If Not IsRightsUpdate Then
				Record.LatestUpdatedItemDate =
					UpdateParameters.LastUpdatedItem.Date;
			EndIf;
			Record.RegisterRecordChangeDate = CurrentSessionDate();
			UpdatePlan.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If JobsDeleted Then
		UpdateParameters.HasJobs = False;
		UpdateParameters.SpotJob = Undefined;
		UpdateParameters.LastUpdatedItem = InitialItem(UpdateParameters);
		Return;
	EndIf;
	
	UpdatePlan.Clear();
	For Each String In DataExported Do
		UpdatePlan.Filter.UniqueKey.Set(String.UniqueKey);
		UpdatePlan.Write();
	EndDo;
	
	If DataExported.Count() = 1000 Then
		PreparationCompleted = False;
	EndIf;
	
EndProcedure

// For the PreparedUpdatePlan and WriteLastUpdatedItem procedures.
Function JobParametersToSave(IsRightsUpdate, UpdateParameters, JobParameters = Undefined,
			UpdateRestart = False, ClearSpotJob = False)
	
	SpotJob = New Structure;
	SpotJob.Insert("ByAccessKeys", New Map);
	If Not IsRightsUpdate Then
		SpotJob.Insert("ByFieldsValues",     New Map);
		SpotJob.Insert("ByValuesWithGroups", New Map);
	EndIf;
	
	ParametersToSave = New Structure;
	ParametersToSave.Insert("SpotJob", SpotJob);
	ParametersToSave.Insert("LastUpdatedItem", InitialItem(UpdateParameters));
	
	If TypeOf(JobParameters) <> Type("Structure") Then
		Return ParametersToSave;
	EndIf;
	
	If JobParameters.Property("LastUpdatedItem") Then
		Order = DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind);
		If Order <> Undefined Then
			FillPropertyValues(ParametersToSave.LastUpdatedItem,
				JobParameters.LastUpdatedItem);
		EndIf;
	EndIf;
	
	If ClearSpotJob Or Not JobParameters.Property("SpotJob") Then
		Return ParametersToSave;
	EndIf;
	
	CurrentSpotJob = JobParameters.SpotJob;
	If TypeOf(CurrentSpotJob) <> Type("Structure") Then
		UpdateRestart = True;
		Return ParametersToSave;
	EndIf;
	
	For Each JobOption In SpotJob Do
		If Not CurrentSpotJob.Property(JobOption.Key)
		 Or TypeOf(CurrentSpotJob[JobOption.Key]) <> Type("Map") Then
			UpdateRestart = True;
			Continue;
		EndIf;
		SpotJob[JobOption.Key] = CurrentSpotJob[JobOption.Key];
	EndDo;
	
	Return ParametersToSave;
	
EndFunction

// For the PrepareUpdatePlan procedure.
Procedure AddLeadingObjectToSpotJob(SpotJob, SpotJobToSave,
			UpdateRestart)
	
	If TypeOf(SpotJob) <> Type("Structure") Then
		UpdateRestart = True;
		Return;
	EndIf;
	MaximumCount = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	
	For Each JobOption In SpotJob Do
		If Not SpotJobToSave.Property(JobOption.Key) Then
			UpdateRestart = True;
			Continue;
		EndIf;
		If JobOption.Key <> "ByFieldsValues" Then
			References = ?(TypeOf(JobOption.Value) = Type("Array"), JobOption.Value,
				CommonClientServer.ValueInArray(JobOption.Value));
			RefsToSave = SpotJobToSave[JobOption.Key];
			For Each Ref In References Do
				RefsToSave.Insert(Ref, True);
				If RefsToSave.Count() >= MaximumCount Then
					UpdateRestart = True;
					Continue;
				EndIf;
			EndDo;
		Else
			Properties = JobOption.Value;
			TablesToSave = SpotJobToSave[JobOption.Key];
			
			If Not Properties.Property("ChangedTable")
			 Or Not Properties.Property("ChangesContent")
			 Or TypeOf(Properties.ChangesContent) <> Type("ValueTable")
			 Or TypeOf(TablesToSave) <> Type("Map") Then
				
				UpdateRestart = True;
				Continue;
			EndIf;
			TableToSave = TablesToSave.Get(Properties.ChangedTable);
			ChangesContent = Properties.ChangesContent;
			If TableToSave = Undefined Then
				TablesToSave.Insert(Properties.ChangedTable, ChangesContent);
				
			ElsIf TypeOf(TableToSave) <> Type("ValueTable")
			      Or ChangesContent.Columns.Count() <> TableToSave.Columns.Count() Then
				
				UpdateRestart = True;
				Continue;
			Else
				ColumnsNames = New Array;
				For Each Column In TableToSave.Columns Do
					If ChangesContent.Columns.Find(Column.Name) = Undefined Then
						ColumnsNames = Undefined;
						Break;
					EndIf;
					ColumnsNames.Add(Column.Name);
				EndDo;
				If ColumnsNames = Undefined Then
					UpdateRestart = True;
					Continue;
				EndIf;
				Filter = New Structure(StrConcat(ColumnsNames, ", "));
				For Each String In ChangesContent Do
					FillPropertyValues(Filter, String);
					If TableToSave.FindRows(Filter).Count() = 0 Then
						FillPropertyValues(TableToSave.Add(), String);
						If TableToSave.Count() >= MaximumCount Then
							UpdateRestart = True;
							Break;
						EndIf;
					EndIf;
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Function HasDataKeyProperties(JobParameters)
	
	If TypeOf(JobParameters) <> Type("Structure")
	 Or Not JobParameters.Property("DataKeyKind")
	 Or Not JobParameters.Property("DataKeyKindOrder") Then
		Return False;
	EndIf;
	
	Order = DataKeyKindOrder(JobParameters.DataKeyKind);
	
	Return Order <> Undefined AND Order = JobParameters.DataKeyKindOrder;
	
EndFunction

// For procedures ExecuteListAccessUpdate, UpdateItemsBatch,
// SetQueryTextAndLastUpdatedDataItemParameters, UpdateAccessGroupsSets procedure and functions 
// ItemsForUpdate, LastItem, DataKey, and AccessGroupsSetsForUpdate.
//
Function IsObsoleteItemsDataProcessor(UpdateParameters)
	
	Order = DataKeyKindOrder(UpdateParameters.LastUpdatedItem.DataKeyKind);
	
	Return Order >= DataKeyKindOrder("ObsoleteItems")
	      AND Order < DataKeyKindOrder("NoData");
	
EndFunction

// For the JobParametersToSave and HasDataKeyProperties functions and the 
// UpdateIsObsoleteItemsDataProcessorProperty and SetDataKeyKind procedures.
//
Function DataKeyKindOrder(DataKeyKind)
	
	DataKeysKinds = New Map;
	DataKeysKinds.Insert("ItemsWithObsoleteKeys", 0);
	DataKeysKinds.Insert("ItemsWithoutKeysByFieldValues", 1);
	DataKeysKinds.Insert("ItemsWithoutKeysByPeriod", 1);
	
	DataKeysKinds.Insert("ItemsWithObsoleteRights", 0);
	
	DataKeysKinds.Insert("NewSingleUserSets", 1);
	DataKeysKinds.Insert("AccessGroupsSetsAssignedToUsers", 2);
	DataKeysKinds.Insert("UserGroupSetsAssignedToUsers", 3);
	DataKeysKinds.Insert("NewGroupsSetsWithObsoleteRights", 4);
	DataKeysKinds.Insert("GroupSetsAllowedForUsers", 5);
	
	DataKeysKinds.Insert("ObsoleteItems", 10);
	DataKeysKinds.Insert("ObsoleteCommonRegisterItems", 11);
	
	DataKeysKinds.Insert("NoData", 99);
	
	Return DataKeysKinds.Get(DataKeyKind);
	
EndFunction

// For procedures ScheduleAccessUpdate, ScheduleAccessGroupsSetsUpdate,
// ClarifyBlankLastItem, and function InintialItem.
//
Procedure SetDataKeyKind(Item, DataKeyKind)
	
	Order = DataKeyKindOrder(DataKeyKind);
	If Order = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректный имя вида порядка ключа данных ""%1""'; en = 'Name of the ""%1"" data key order kind is incorrect'; pl = 'Błędna nazwa rodzaju zamówienia klucza danych ""%1""';de = 'Falscher Name der Art der Reihenfolge der Datenschlüssel ""%1""';ro = 'Nume incorect al tipului de ordine a cheii de date ""%1""';tr = 'Hatalı veri anahtarı türü sipariş adı ""%1""'; es_ES = 'Nombre incorrecto del tipo de orden de la clave de datos ""%1""'"), DataKeyKind);
		Raise ErrorText;
	EndIf;
	Item.Insert("DataKeyKind", DataKeyKind);
	Item.Insert("DataKeyKindOrder", Order);
	
EndProcedure

// For the PrepareUpdatePlan procedure.
Function PreparedSpotJob(IsRightsUpdate, SpotJobToSave, UpdateRestart)
	
	SpotJob = New Structure;
	If IsRightsUpdate Then
		SpotJob.Insert("ByAccessKeys", New Array);
	Else
		SpotJob.Insert("ByFieldsValues",     New Map);
		SpotJob.Insert("ByAccessKeys",      New ValueTable);
		SpotJob.Insert("ByValuesWithGroups", New ValueTable);
	EndIf;
	
	IsBlankJob = True;
	MaximumCount = MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes();
	LeadingObjectsTypes = AccessManagementInternalCached.LeadingObjectsRefTypes();
	
	For Each JobOption In SpotJobToSave Do
		If JobOption.Key = "ByFieldsValues" Then
			If ValueIsFilled(JobOption.Value) Then
				IsBlankJob = False;
				SpotJob.ByFieldsValues = JobOption.Value;
			EndIf;
			Continue;
		EndIf;
		
		ReferencesToDelete = New Array;
		ReferencesDetails = JobOption.Value;
		If IsRightsUpdate Then
			References = SpotJob[JobOption.Key];
		Else
			References = New Array;
			Types = New Map;
			Table = SpotJob[JobOption.Key];
		EndIf;
		For Each ReferenceDetails In ReferencesDetails Do
			Ref = ReferenceDetails.Key;
			Type = TypeOf(Ref);
			If LeadingObjectsTypes.Get(Type) = Undefined Then
				UpdateRestart = True;
				ReferencesToDelete.Add(Ref);
				Continue;
			EndIf;
			References.Add(Ref);
			If Not IsRightsUpdate Then
				Types.Insert(Type, True);
				Table.Add();
			EndIf;
			If References.Count() >= MaximumCount Then
				UpdateRestart = True;
				Break;
			EndIf;
		EndDo;
		For Each Ref In ReferencesToDelete Do
			ReferencesDetails.Delete(Ref);
		EndDo;
		If References.Count() > 0 Then
			IsBlankJob = False;
		Else
			Continue;
		EndIf;
		If Not IsRightsUpdate Then
			ColumnTypes = New Array;
			For Each KeyAndValue In Types Do
				ColumnTypes.Add(KeyAndValue.Key);
			EndDo;
			Table.Columns.Add("Ref", New TypeDescription(ColumnTypes));
			Table.LoadColumn(References, "Ref");
		EndIf;
	EndDo;
	
	If IsBlankJob Then
		Return Undefined;
	EndIf;
	
	Return SpotJob;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Function ItemsInBatchCount(UpdateParameters)
	
	If IsCatalogAccessGroupsSets(UpdateParameters) Then
		Return 25;
	ElsIf UpdateParameters.IsRightsUpdate Then
		Return AccessKeysInBatchCount();
	Else
		Return DataItemsInBatchCount();
	EndIf;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Function ItemsInQueryCount(IsRightsUpdate)
	
	If IsRightsUpdate Then
		Return AccessKeysInQueryCount();
	Else
		Return DataItemsInQueryCount();
	EndIf;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Procedure UpdateItemsBatch(Items, UpdateParameters, IsSpotJob = False)
	
	UpdateParameters.Insert("ProcessedItemsCount", 0);
	UpdateParameters.Insert("DeletedItemsComposition", New Array);
	
	If IsSpotJob Then
		If UpdateParameters.IsRightsUpdate Then
			UpdateRightsOfListAccessKeysBatch(Items, UpdateParameters);
		Else
			UpdateListDataItemsWithObsoleteKeys(Items, UpdateParameters);
		EndIf;
		
	ElsIf UpdateParameters.IsRightsUpdate Then
		If IsObsoleteItemsDataProcessor(UpdateParameters) Then
			ProcessObsoleteListAccessKeys(Items, UpdateParameters);
		Else
			UpdateRightsOfListAccessKeysBatch(Items, UpdateParameters);
		EndIf;
		
	ElsIf IsCatalogAccessGroupsSets(UpdateParameters) Then
		UpdateAccessGroupsSets(Items, UpdateParameters);
		
	ElsIf IsObsoleteItemsDataProcessor(UpdateParameters) Then
		DeleteObsoleteListDataItems(Items, UpdateParameters);
		
	ElsIf UpdateParameters.WriteAlwaysAllowedAccessKey Then
		UpdateListDataItemsWithObsoleteAllowedKey(Items, UpdateParameters);
		UpdateParameters.ProcessedItemsCount = Items.Count();
	Else
		UpdateListDataItemsWithObsoleteKeys(Items, UpdateParameters);
	EndIf;
	
	If Not IsSpotJob AND Items.Count() = UpdateParameters.DeletedItemsComposition.Count() Then
		UpdateParameters.Insert("NewLastUpdatedItem",
			LastItem(Items, UpdateParameters));
	EndIf;
	
	For Each Item In UpdateParameters.DeletedItemsComposition Do
		Items.Delete(Item);
	EndDo;
	
	If Not IsSpotJob AND Items.Count() > 0 Then
		UpdateParameters.Insert("NewLastUpdatedItem",
			LastItem(Items, UpdateParameters, True));
	EndIf;
	
	If Items.Count() = UpdateParameters.ProcessedItemsCount Then
		Items = Undefined;
	Else
		For Counter = 1 To UpdateParameters.ProcessedItemsCount Do
			Items.Delete(0);
		EndDo;
	EndIf;
	
	UpdateParameters.ProcessedItemsCount =
		UpdateParameters.ProcessedItemsCount
			+ UpdateParameters.DeletedItemsComposition.Count();
	
EndProcedure

// For procedures UpdateAccessGroupsSets, DeleteObsoleteListDataItems,
// WriteObjectsAccessKeys, WriteRegistersAccessKeys,
// UpdateRightsOfListAccessKeysBatch, DeleteListAccessKeysBatch, and
// DeleteCurrentListAccessKeysBatch.
//
Function ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsOnStepCount = 1)
	
	If Not UpdateParameters.Property("ProcessedItemsCount")
	 Or Not UpdateParameters.Property("ProcessingTimeBoundary") Then
		Return False;
	EndIf;
	
	UpdateParameters.ProcessedItemsCount =
		UpdateParameters.ProcessedItemsCount + ProcessedItemsOnStepCount;
	
	If CurrentUniversalDateInMilliseconds() > UpdateParameters.ProcessingTimeBoundary Then
		Return True;
	EndIf;
	
	Return False;
	
EndFunction

// For the ExecuteListAccessUpdate and CheckCompleteUpdateByBatches procedures.
Procedure WriteLastUpdatedItem(CommonUpdateParameters, LastUpdatedItem)
	
	IsRightsUpdate       = CommonUpdateParameters.IsRightsUpdate;
	ForExternalUsers = CommonUpdateParameters.ForExternalUsers;
	ListID     = CommonUpdateParameters.ListID;
	
	RegisterManager = ?(IsRightsUpdate, InformationRegisters.UsersAccessKeysUpdate,
		InformationRegisters.DataAccessKeysUpdate);
	
	UpdatePlan = ServiceRecordSet(RegisterManager);
	UpdatePlan.Filter.List.Set(ListID);
	UpdatePlan.Filter.ForExternalUsers.Set(ForExternalUsers);
	UpdatePlan.Filter.UniqueKey.Set(
		CommonClientServer.BlankUUID());
	
	FullRegisterName = ?(IsRightsUpdate, "InformationRegister.UsersAccessKeysUpdate",
		"InformationRegister.DataAccessKeysUpdate");
	
	Lock = New DataLock;
	LockItem = Lock.Add(FullRegisterName);
	LockItem.SetValue("List", ListID);
	LockItem.SetValue("ForExternalUsers", ForExternalUsers);
	LockItem.SetValue("UniqueKey",
		CommonClientServer.BlankUUID());
	
	BeginTransaction();
	Try
		Lock.Lock();
		UpdatePlan.Read();
		If UpdatePlan.Count() > 0 Then
			If LastUpdatedItem.DataKey = Null Then
				UpdatePlan.Clear();
			Else
				Record = UpdatePlan[0];
				If LastUpdatedItem.Property("ClearSpotJob") Then
					Record.SpotJob = False;
				EndIf;
				
				CurrentJobParameters = Record.JobParameters.Get();
				JobParameters = JobParametersToSave(IsRightsUpdate, CommonUpdateParameters,
					CurrentJobParameters, , LastUpdatedItem.Property("ClearSpotJob"));
				
				FillPropertyValues(JobParameters.LastUpdatedItem, LastUpdatedItem);
				
				If Not IsRightsUpdate AND LastUpdatedItem.Property("Date") Then
					Record.LatestUpdatedItemDate = LastUpdatedItem.Date;
				EndIf;
				
				Record.JobParameters = New ValueStorage(JobParameters);
				Record.JobSize = ?(IsObsoleteItemsDataProcessor(
					New Structure("LastUpdatedItem", LastUpdatedItem)), 2, 3);
				
				Record.RegisterRecordChangeDate = CurrentSessionDate();
				CommonUpdateParameters.ProcessingCompleted = False;
			EndIf;
			UpdatePlan.Write();
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Function ItemsForUpdate(UpdateParameters, CountInQuery, SelectedAllItems)
	
	If IsCatalogAccessGroupsSets(UpdateParameters) Then
		If UpdateParameters.IsRightsUpdate Then
			SelectedAllItems = True;
			Return Undefined;
		EndIf;
		Items = AccessGroupsSetsForUpdate(UpdateParameters, CountInQuery);
	Else
		Query = New Query;
		If UpdateParameters.IsRightsUpdate Then
			Query.SetParameter("List", UpdateParameters.ListID);
			Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
			
			LastAccessKey = UpdateParameters.LastUpdatedItem.DataKey;
			If TypeOf(LastAccessKey) <> Type("CatalogRef.AccessKeys") Then
				LastAccessKey = Undefined;
			EndIf;
			Query.SetParameter("LastAccessKey", LastAccessKey);
			
			If UpdateParameters.DoNotWriteAccessKeys
			 Or UpdateParameters.WriteAlwaysAllowedAccessKey Then
				
				Query.Text =
				"SELECT TOP " + BatchSizeMarker() + "
				|	AccessKeys.Ref AS Ref
				|FROM
				|	Catalog.AccessKeys AS AccessKeys
				|WHERE
				|	AccessKeys.List = &List
				|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
				|	AND AccessKeys.Ref > &LastAccessKey
				|
				|ORDER BY
				|	AccessKeys.Ref";
				
			ElsIf IsObsoleteItemsDataProcessor(UpdateParameters) Then
				Query.SetParameter("DateOfBecomingObsolete", DateOfBecomingObsolete());
				Query.Text = UpdateParameters.ObsoleteAccessKeysQueryText;
			Else
				Query.Text = UpdateParameters.AccessKeysQueryTextToUpdateRights;
			EndIf;
			
		ElsIf UpdateParameters.IsReferenceType
		        AND UpdateParameters.ForExternalUsers
		        AND IsObsoleteItemsDataProcessor(UpdateParameters)
		        AND (Not UpdateParameters.DoNotWriteAccessKeys
		           Or UpdateParameters.DoNotWriteAccessKeysForUsersAndExternalUsers) Then
			
			SelectedAllItems = True;
			Return Undefined;
		Else
			SetQueryTextAndLastUpdatedDataItemParameters(Query, UpdateParameters);
		EndIf;
		
		CountInQuery = ?(CountInQuery < 1000, 1000, ?(CountInQuery > 10000, 10000, CountInQuery));
		Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(CountInQuery, "NG="));
		Items = Query.Execute().Unload();
	EndIf;
	
	If Items.Count() = 0 Then
		SelectedAllItems = True;
		Return Undefined;
	EndIf;
	
	SelectedAllItems = Items.Count() < CountInQuery;
	
	Return Items;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Function SpotJobItemsForUpdate(UpdateParameters, CountInQuery, SelectedAllItems)
	
	If IsCatalogAccessGroupsSets(UpdateParameters)
	 Or UpdateParameters.DoNotWriteAccessKeys
	 Or UpdateParameters.WriteAlwaysAllowedAccessKey Then
		
		Return Undefined;
	EndIf;
	
	Query = New Query;
	If UpdateParameters.IsRightsUpdate Then
		Query.Text = UpdateParameters.KeysQueryTextByLeadingKeysToUpdateRights;
		If Not ValueIsFilled(Query.Text) Then
			Return Undefined;
		EndIf;
		Query.SetParameter("List", UpdateParameters.ListID);
		Query.SetParameter("LeadingAccessKeys", UpdateParameters.SpotJob.ByAccessKeys);
	Else
		If Not UpdateParameters.IsReferenceType Then
			Query.SetParameter("RegisterID", UpdateParameters.ListID);
		EndIf;
		QueriesDetails = UpdateParameters.DetailsOfObsoleteAccessKeysForLeadingObjects;
		PackageQueries = New Array;
		DataQueries = New Array;
		If ValueIsFilled(UpdateParameters.SpotJob.ByFieldsValues) Then
			QueriesDetailsByFieldsValues = QueriesDetails.Get("ByFieldsValues");
			If QueriesDetailsByFieldsValues = Undefined Then
				Return Undefined;
			EndIf;
			For Each ChangesDetails In UpdateParameters.SpotJob.ByFieldsValues Do
				RequestDetails = QueriesDetailsByFieldsValues.Get(ChangesDetails.Key);
				If RequestDetails = Undefined Then
					Return Undefined;
				EndIf;
				ChangesContent = ChangesDetails.Value;
				If RequestDetails.FieldsTypes.Count() <> ChangesContent.Columns.Count() Then
					Return Undefined;
				EndIf;
				For Each Column In ChangesContent.Columns Do
					FieldTypes = RequestDetails.FieldsTypes.Get(Column.Name);
					If TypeOf(FieldTypes) <> Type("ValueStorage") Then
						Return Undefined;
					EndIf;
					ColumnType = New TypeDescription(Column.ValueType,, "Null");
					If FieldTypes.Get() <> ColumnType Then
						Return Undefined;
					EndIf;
				EndDo;
				TemporaryTableAndParameterName = StrReplace(ChangesDetails.Key, ".", "_");
				Query.SetParameter(TemporaryTableAndParameterName, ChangesContent);
				PackageQueries.Add(RequestDetails.ParametersQueryText);
				For Each DataQueryText In RequestDetails.DataQueryTexts Do
					DataQueries.Add(DataQueryText);
				EndDo;
			EndDo;
		EndIf;
		If Not AddSpotJobQueries("ByAccessKeys",
		            Query, PackageQueries, DataQueries, UpdateParameters)
		 Or Not AddSpotJobQueries("ByValuesWithGroups",
		            Query, PackageQueries, DataQueries, UpdateParameters)
		 Or DataQueries.Count() = 0 Then
			Return Undefined;
		EndIf;
		If DataQueries.Count() = 1 Then
			PackageQueries.Add(StrReplace(DataQueries[0],
			"
			|FROM
			|	",
			"
			|INTO CurrentListByLeadingObjects
			|FROM
			|	"));
		Else
			QueriesTexts = StrConcat(DataQueries,
			"
			|
			|UNION ALL
			|
			|");
			PackageQueries.Add(StrReplace(QueriesDetails.Get("DataSelectionWrapQueryText"),
				"#DataSelectionRequests", TextWithIndent(QueriesTexts, "	")));
		EndIf;
		PackageQueries.Add(QueriesDetails.Get("SpotCheckQueryText"));
		Query.Text = StrConcat(PackageQueries, Common.QueryBatchSeparator());
	EndIf;
	
	CountInQuery = ?(CountInQuery < 1000, 1000, ?(CountInQuery > 4000, 4000, CountInQuery));
	Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(CountInQuery, "NG="));
	
	If UpdateParameters.IsRightsUpdate Then
		Items = Query.Execute().Unload();
		SelectedItemsCount = Items.Count();
	Else
		QueryResults = Query.ExecuteBatch();
		SelectedItemsCount = QueryResults[PackageQueries.Count() - 2].Unload()[0].Count;
		Items = QueryResults[PackageQueries.Count() - 1].Unload();
	EndIf;
	
	SelectedAllItems = SelectedItemsCount < CountInQuery;
	
	If Items.Count() = 0 Then
		Return Undefined;
	EndIf;
	
	Return Items;
	
EndFunction

// For the SpotJobItemsForUpdate function.
Function AddSpotJobQueries(JobKind, Query, PackageQueries, DataQueries, UpdateParameters)
	
	Data = UpdateParameters.SpotJob[JobKind];
	If Not ValueIsFilled(Data) Then
		Return True;
	EndIf;
	
	QueriesDetails =
		UpdateParameters.DetailsOfObsoleteAccessKeysForLeadingObjects.Get(JobKind);
	
	If QueriesDetails = Undefined Then
		Return False;
	EndIf;
	
	ColumnType = Data.Columns.Ref.ValueType;
	MissingTypes = New TypeDescription(ColumnType, , QueriesDetails.RefType.Get().Types());
	If MissingTypes.Types().Count() > 0 Then
		Return False;
	EndIf;
	
	Query.SetParameter(JobKind, Data);
	PackageQueries.Add(QueriesDetails.ParametersQueryText);
	
	QueriesKeys = New Map;
	For Each Type In ColumnType.Types() Do
		CurrentKeys = QueriesDetails.QueryKeysByTypes.Get(Type);
		If CurrentKeys = Undefined Then
			Return False;
		EndIf;
		For Each varKey In CurrentKeys Do
			QueriesKeys.Insert(varKey, True);
		EndDo;
	EndDo;
	
	For Each KeyAndValue In QueriesKeys Do
		QueryText = QueriesDetails.QueriesTextsByKeys.Get(KeyAndValue.Key);
		If QueryText = Undefined Then
			Return False;
		EndIf;
		DataQueries.Add(QueryText);
	EndDo;
	
	Return True;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Procedure RestartUpdateAtNotCompletedSpotUpdate(UpdateParameters)
	
	UpdateParameters.UpdateRestart = True;
	UpdateParameters.LastUpdatedItem = InitialItem(UpdateParameters);
	
	// Register indirect planning of access update.
	PlanningParameters = AccessUpdatePlanningParameters(False);
	PlanningParameters.AllowedAccessKeys  =    UpdateParameters.IsRightsUpdate;
	PlanningParameters.ForUsers         = Not UpdateParameters.ForExternalUsers;
	PlanningParameters.ForExternalUsers  =    UpdateParameters.ForExternalUsers;
	PlanningParameters.IsUpdateContinuation = True;
	PlanningParameters.Details = "RestartUpdateAtNotCompletedSpotUpdate";
	
	ListsByIDs = New Map;
	ListsByIDs.Insert(UpdateParameters.ListID, UpdateParameters.List);
	
	RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters);
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Function ItemsBatchesSet(UpdateParameters, Items, SelectedAllItems, BatchSize = Undefined)
	
	BatchesSet = New Array;
	
	If Items = Undefined Then
		BatchFromSet = New Structure;
		BatchFromSet.Insert("Processed", True);
		BatchFromSet.Insert("Processing", False);
		BatchFromSet.Insert("Items", New ValueStorage(New ValueTable));
		BatchFromSet.Insert("LatestBatchItemDate", '00010101');
		BatchFromSet.Insert("LastBatchItem", InitialItem(UpdateParameters,, True));
		BatchFromSet.Insert("NewLastBatchItem");
		BatchesSet.Add(BatchFromSet);
		BatchFromSet.LastBatchItem.DataKey = Null;
		If BatchFromSet.LastBatchItem.Property("Date") Then
			BatchFromSet.LastBatchItem.Date = '00010101';
		EndIf;
		SetLastBlankItem(BatchFromSet.NewLastBatchItem,
			UpdateParameters, '00010101');
		Return BatchesSet;
	EndIf;
	
	If BatchSize = Undefined Then
		BatchSize = UpdateParameters.ProcessedItemsCount;
		MaxNewBatches = UpdateParameters.MaxBatchesFromOriginalItem;
		If Items.Count() / BatchSize > MaxNewBatches Then
			BatchSize = Items.Count() / MaxNewBatches;
			If BatchSize <> Int(BatchSize) Then
				BatchSize = Int(BatchSize) + 1;
			EndIf;
		EndIf;
	EndIf;
	
	UpdateParameters.Insert("BatchesSet", BatchesSet);
	Index = 0;
	For Each Item In Items Do
		If Index / BatchSize = Int(Index / BatchSize) Then
			BatchFromSet = New Array;
			BatchesSet.Add(BatchFromSet);
		EndIf;
		BatchFromSet.Add(Item);
		Index = Index + 1;
	EndDo;
	
	For Index = 0 To BatchesSet.Count() - 1 Do
		BatchItems = Items.Copy(BatchesSet[Index]);
		BatchFromSet = New Structure;
		BatchFromSet.Insert("Processed", False);
		BatchFromSet.Insert("Processing", False);
		BatchesSet[Index] = BatchFromSet;
		BatchFromSet.Insert("Items", New ValueStorage(BatchItems));
		BatchFromSet.Insert("LastBatchItem",
			LastItem(BatchItems, UpdateParameters));
		BatchFromSet.Insert("LatestBatchItemDate",
			?(BatchFromSet.LastBatchItem.Property("Date"),
				BatchFromSet.LastBatchItem.Date, '00010101'));
		BatchFromSet.Insert("NewLastBatchItem",
			LastItem(BatchItems, UpdateParameters));
	EndDo;
	
	If SelectedAllItems Then
		BatchFromSet.LastBatchItem.DataKey = Null;
		SetLastBlankItem(BatchFromSet.NewLastBatchItem,
			UpdateParameters, '00010101');
	EndIf;
	
	Return BatchesSet;
	
EndFunction

// For the ExecuteListAccessUpdate, UpdateItemsBatch, and ItemsBatchesSet procedures.
Function LastItem(Items, UpdateParameters, LastProcessedItem = False)
	
	LastItemNumber = ?(LastProcessedItem,
		UpdateParameters.ProcessedItemsCount, Items.Count());
	
	LastItem = Items[LastItemNumber - 1];
	
	DataItem = InitialItem(UpdateParameters, , True);
	
	If UpdateParameters.IsRightsUpdate Then
		DataItem.DataKey = LastItem.Ref;
		Return DataItem;
	EndIf;
	
	If UpdateParameters.ListWithDate Then
		DataItem.Date = LastItem.Date;
		
	ElsIf UpdateParameters.IsReferenceType Then
		DataItem.DataKey = LastItem.CurrentRef;
	Else
		DataItem.DataKey = DataKey(UpdateParameters);
		FillPropertyValues(DataItem.DataKey, LastItem);
		
		If UpdateParameters.ListWithPeriod
		   AND Not IsObsoleteItemsDataProcessor(UpdateParameters) Then
			
			DataItem.Date = LastItem.Period;
		EndIf;
	EndIf;
	
	Return DataItem;
	
EndFunction

// For the ExecuteListAccessUpdate procedure.
Procedure ClarifyLastUpdatedItem(UpdateParameters)
	
	If UpdateParameters.List = "Catalog.SetsOfAccessGroups"
	 Or UpdateParameters.LastUpdatedItem.DataKeyKind = "NoData" Then
		Return;
	EndIf;
	
	If UpdateParameters.DoNotWriteAccessKeys
	 Or UpdateParameters.IsRightsUpdate
	   AND UpdateParameters.WriteAlwaysAllowedAccessKey Then
		
		If Not UpdateParameters.LastUpdatedItem.ProcessObsoleteItems Then
			UpdateParameters.LastUpdatedItem =
				InitialItem(UpdateParameters, "NoData");
			
		ElsIf Not IsObsoleteItemsDataProcessor(UpdateParameters) Then
			UpdateParameters.LastUpdatedItem =
				InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
	EndIf;
	
EndProcedure

// For the ExecuteListAccessUpdate and ItemsBatchesSet procedures.
Procedure SetLastBlankItem(Item, UpdateParameters, ItemDate = '00010101')
	
	ItemDate = '00010101';
	Item = InitialItem(UpdateParameters, , True);
	Item.DataKey = Null;
	
	// Clarifying new last item.
	If IsCatalogAccessGroupsSets(UpdateParameters) Then
		If UpdateParameters.IsRightsUpdate Then
			Return;
		EndIf;
		NewDataKeyKind = "";
		If Item.DataKeyKind = "ItemsWithObsoleteRights" Then
			NewDataKeyKind = "NewSingleUserSets";
			
		ElsIf Item.DataKeyKind = "NewSingleUserSets" Then
			NewDataKeyKind = "AccessGroupsSetsAssignedToUsers";
			
		ElsIf Item.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			NewDataKeyKind = "UserGroupSetsAssignedToUsers";
			
		ElsIf Item.DataKeyKind = "UserGroupSetsAssignedToUsers" Then
			NewDataKeyKind = "NewGroupsSetsWithObsoleteRights";
			
		ElsIf Item.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			NewDataKeyKind = "GroupSetsAllowedForUsers";
			
		ElsIf Item.DataKeyKind = "GroupSetsAllowedForUsers"
		        AND Item.ProcessObsoleteItems Then
			
			NewDataKeyKind = "ObsoleteItems";
		EndIf;
		If ValueIsFilled(NewDataKeyKind) Then
			Item = InitialItem(UpdateParameters, NewDataKeyKind);
		EndIf;
		Return;
	EndIf;
	
	If UpdateParameters.IsRightsUpdate Then
		If Item.DataKeyKind = "ItemsWithObsoleteRights"
		   AND Item.ProcessObsoleteItems Then
			
			Item = InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ObsoleteCommonRegisterItems" Then
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ObsoleteItems" Then
		If Not UpdateParameters.IsReferenceType
		   AND ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		
			Item = InitialItem(UpdateParameters, "ObsoleteCommonRegisterItems");
		EndIf;
		Return;
	EndIf;
	
	If UpdateParameters.ListWithDate Then
		SetNextPeriodItem(UpdateParameters, Item, ItemDate);
		Return;
	EndIf;
	
	If UpdateParameters.IsReferenceType Then
		If Item.DataKeyKind = "ItemsWithObsoleteKeys"
		   AND Item.ProcessObsoleteItems
		   AND (UpdateParameters.DoNotWriteAccessKeys
		      Or Not UpdateParameters.ForExternalUsers) Then
			
			Item = InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If UpdateParameters.DoNotWriteAccessKeys Then
		If Item.DataKeyKind = "ItemsWithObsoleteKeys"
		   AND Item.ProcessObsoleteItems Then
			
			Item = InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithoutKeysByFieldValues" Then
		If Item.ProcessObsoleteItems Then
			Item = InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		SetNextPeriodItem(UpdateParameters, Item, ItemDate);
		If Item.DataKey = Null AND Item.ProcessObsoleteItems Then
			Item = InitialItem(UpdateParameters, "ObsoleteItems");
		EndIf;
		Return;
	EndIf;
	
	If Not UpdateParameters.ListWithPeriod Then
		Item = InitialItem(UpdateParameters, "ItemsWithoutKeysByFieldValues");
		Return;
	EndIf;
	
	Item = InitialItem(UpdateParameters, "ItemsWithoutKeysByPeriod");
	LastUpdatedItem = UpdateParameters.LastUpdatedItem;
	UpdateParameters.LastUpdatedItem = Item;
	SetNextPeriodItem(UpdateParameters, Item, ItemDate, MaxDate());
	UpdateParameters.LastUpdatedItem = LastUpdatedItem;
	
	If Item.DataKey = Null AND Item.ProcessObsoleteItems Then
		Item = InitialItem(UpdateParameters, "ObsoleteItems");
	EndIf;
	
EndProcedure

// For the ClarifyBlankLastItem procedure.
Procedure SetNextPeriodItem(UpdateParameters, Item, ItemDate,
			CurrentPeriodStartDate = Undefined)
	
	If CurrentPeriodStartDate = Undefined Then
		CurrentPeriodStartDate = UpdateParameters.StartDate;
	EndIf;
	
	Query = New Query;
	Query.SetParameter("StartDate", CurrentPeriodStartDate);
	
	Query.Text = UpdateParameters.NextDataItemDateQueryText;
	
	QueryResult = Query.Execute();
	
	If QueryResult.IsEmpty() Then
		Item.DataKey = Null;
		Return;
	EndIf;
	
	Item = LastItem(QueryResult.Unload(), UpdateParameters);
	ItemDate = ?(Item.Property("Date"), Item.Date, '00010101');
	
EndProcedure

// For the ItemsForUpdate function.
Procedure SetQueryTextAndLastUpdatedDataItemParameters(Query, UpdateParameters)
	
	If IsObsoleteItemsDataProcessor(UpdateParameters) Then
		If UpdateParameters.LastUpdatedItem.DataKeyKind = "ObsoleteItems" Then
			Query.Text = UpdateParameters.ObsoleteDataItemsQueryText;
		Else
			Query.Text = UpdateParameters.ObsoleteDataItemsFromCommonRegisterQueryText;
		EndIf;
	Else
		If UpdateParameters.WriteAlwaysAllowedAccessKey Then
			Query.SetParameter("AllowedAccessKey", AccessManagementInternalCached.AllowedAccessKey());
			Query.Text = UpdateParameters.DataItemWithObsoleteAllowedKeyQueryText;
		Else
			Query.Text = UpdateParameters.DataItemWithObsoleteKeysQueryText;
		EndIf;
		If UpdateParameters.ListWithDate Then
			Query.SetParameter("StartDate",    UpdateParameters.StartDate);
			Query.SetParameter("EndDate", UpdateParameters.LastUpdatedItem.Date);
			Return;
		EndIf;
	EndIf;
	
	DataKey = UpdateParameters.LastUpdatedItem.DataKey;
	
	If UpdateParameters.IsReferenceType Then
		SetDataKey = ?(Common.IsReference(TypeOf(DataKey)), DataKey, Undefined);
		Query.SetParameter("LastProcessedRef", SetDataKey);
		Return;
	EndIf;
	
	Query.SetParameter("RegisterID", UpdateParameters.ListID);
	SetDataKey = DataKey(UpdateParameters, DataKey);
	DataKeyKind = UpdateParameters.LastUpdatedItem.DataKeyKind;
	
	If UpdateParameters.ListWithPeriod
	   AND StrStartsWith(DataKeyKind, "ItemsWithoutKeys") Then
		
		If DataKeyKind <> "ItemsWithoutKeysByPeriod" Then
			SetDataKeyKind(UpdateParameters.LastUpdatedItem,
				"ItemsWithoutKeysByPeriod");
		EndIf;
		Query.Text = UpdateParameters.DataItemsWithoutAccessKeysQueryText;
		Query.SetParameter("StartDate",    UpdateParameters.StartDate);
		Query.SetParameter("EndDate", UpdateParameters.LastUpdatedItem.Date);
		
	ElsIf StrStartsWith(DataKeyKind, "ItemsWithoutKeys") Then
		If DataKeyKind <> "ItemsWithoutKeysByFieldValues" Then
			SetDataKeyKind(UpdateParameters.LastUpdatedItem,
				"ItemsWithoutKeysByFieldValues");
		EndIf;
		Query.Text = UpdateParameters.DataItemsWithoutAccessKeysQueryText;
	EndIf;
	
	For Each KeyAndValue In SetDataKey Do
		If KeyAndValue.Value = Undefined Then
			FieldName = KeyAndValue.Key;
			Query.Text = StrReplace(Query.Text, " > &" + FieldName, " >= &" + FieldName);
		EndIf;
		Query.SetParameter(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the LastItem and SetLastUpdatedItemParameters procedures, and the 
// RemainingRegisterItemsCountQueryText function.
//
Function DataKey(UpdateParameters, InitialDataKey = Undefined)
	
	FieldsCount = UpdateParameters.BasicFields.Used.Count();
	
	If FieldsCount = 0
	 Or UpdateParameters.UsesRestrictionByOwner
	 Or IsObsoleteItemsDataProcessor(UpdateParameters) Then
		
		FieldsCount = UpdateParameters.BasicFields.MaxCount;
	EndIf;
	
	If TypeOf(InitialDataKey) = Type("Structure")
	   AND InitialDataKey.Count() = FieldsCount Then
		
		FieldsValues = InitialDataKey;
	Else
		FieldsValues = New Structure;
	EndIf;
	
	NewFieldsValues = New Structure;
	
	For Number = 1 To FieldsCount Do
		FieldName = "Field" + Number;
		If FieldsValues.Property(FieldName) Then
			NewFieldsValues.Insert(FieldName, FieldsValues[FieldName]);
		Else
			NewFieldsValues.Insert(FieldName, Undefined);
		EndIf;
	EndDo;
	
	Return NewFieldsValues;
	
EndFunction

// For the ItemsForUpdate procedure.
Function AccessGroupsSetsForUpdate(UpdateParameters, CountInQuery)
	
	LastUpdatedItem = UpdateParameters.LastUpdatedItem;
	DataKeyKind = LastUpdatedItem.DataKeyKind;
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("LastProcessedRef", LastUpdatedItem.DataKey);
	
	If DataKeyKind = "ItemsWithObsoleteRights" Then
		Query.Text =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND CurrentList.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
		|	AND CurrentList.Ref > &LastProcessedRef
		|
		|ORDER BY
		|	CurrentList.Ref";
		
		If UpdateParameters.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
		EndIf;
		
	ElsIf DataKeyKind = "NewSingleUserSets" Then
		Query.SetParameter("BlankUUID",
			CommonClientServer.BlankUUID());
		Query.Text =
		"SELECT TOP " + BatchSizeMarker() + "
		|	UserGroupCompositions.User AS CurrentRef,
		|	UserGroupCompositions.User.Description AS Description,
		|	UserGroupCompositions.Used AS Used,
		|	SetsOfAccessGroups.NotUsedSince AS NotUsedSince
		|FROM
		|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
		|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|		ON (SetsOfAccessGroups.User = UserGroupCompositions.User)
		|			AND (SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers)
		|			AND (SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef))
		|			AND (NOT FALSE IN
		|					(SELECT TOP 1
		|						FALSE
		|					FROM
		|						Catalog.SetsOfAccessGroups.Folders AS SetGroups
		|					WHERE
		|						SetGroups.Ref = SetsOfAccessGroups.Ref))
		|WHERE
		|	VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.Users)
		|	AND CASE
		|			WHEN UserGroupCompositions.Used
		|					AND CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID
		|				THEN SetsOfAccessGroups.User IS NULL
		|						OR SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
		|			ELSE SetsOfAccessGroups.NotUsedSince = DATETIME(1, 1, 1)
		|		END
		|	AND UserGroupCompositions.User > &LastProcessedRef
		|
		|ORDER BY
		|	UserGroupCompositions.User";
		
		If UpdateParameters.ForExternalUsers Then
			Query.Text = StrReplace(Query.Text,
				"Catalog.Users", "Catalog.ExternalUsers");
		EndIf;
		
	ElsIf DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
		Return OneUserSetsToUpdateAssignedAccessGroupsSets(
			UpdateParameters, CountInQuery);
		
	ElsIf DataKeyKind = "UserGroupSetsAssignedToUsers" Then
		Return OneUserSetsToUpdateAssignedUsersGroupsSets(
			UpdateParameters, CountInQuery);
		
	ElsIf DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
		Query.Text =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND CurrentList.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
		|	AND (TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|				WHERE
		|					SetsOfAccessGroups.NewAccessGroupsSet = CurrentList.Ref)
		|			OR TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|				WHERE
		|					SetsOfAccessGroups.NewUserGroupsSet = CurrentList.Ref))
		|	AND CurrentList.Ref > &LastProcessedRef
		|
		|ORDER BY
		|	CurrentList.Ref";
		
	ElsIf DataKeyKind = "GroupSetsAllowedForUsers" Then
		Query.Text =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	Catalog.SetsOfAccessGroups AS CurrentList
		|WHERE
		|	CurrentList.ForExternalUsers = &ForExternalUsers
		|	AND (CurrentList.NewAccessGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
		|			OR CurrentList.NewUserGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef))
		|	AND CurrentList.Ref > &LastProcessedRef
		|
		|ORDER BY
		|	CurrentList.Ref";
		
	ElsIf IsObsoleteItemsDataProcessor(UpdateParameters) Then
		Return ObsoleteAccessGroupsSetsInCatalog(UpdateParameters, CountInQuery);
	EndIf;
	
	CountInQuery = ?(CountInQuery < 25, 25, ?(CountInQuery > 10000, 10000, CountInQuery));
	Query.Text = StrReplace(Query.Text, BatchSizeMarker(), Format(CountInQuery, "NG="));
	
	DataItems = Query.Execute().Unload();
	
	Return DataItems;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure UpdateAccessGroupsSets(DataItems, UpdateParameters)
	
	DataKeyKind = UpdateParameters.LastUpdatedItem.DataKeyKind;
	
	If DataKeyKind = "ItemsWithObsoleteRights" Then
		UpdateGroupsSetsWithObsoleteParameters(DataItems, UpdateParameters);
		
	ElsIf DataKeyKind = "NewSingleUserSets" Then
		UpdateSetsOfOneUserInCatalog(DataItems, UpdateParameters);
		
	ElsIf DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
		UpdateGroupsSetsAssingedToUsersInCatalog(DataItems, UpdateParameters, True);
		
	ElsIf DataKeyKind = "UserGroupSetsAssignedToUsers" Then
		UpdateGroupsSetsAssingedToUsersInCatalog(DataItems, UpdateParameters, False);
		
	ElsIf DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
		UpdateGroupsSetsWithObsoleteParameters(DataItems, UpdateParameters);
		
	ElsIf DataKeyKind = "GroupSetsAllowedForUsers" Then
		UpdateGroupsSetsAllowedForUsersInCatalog(DataItems, UpdateParameters);
		
	ElsIf IsObsoleteItemsDataProcessor(UpdateParameters) Then
		ProcessObsoleteSetsInCatalog(DataItems, UpdateParameters);
	EndIf;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Procedure ClearBlankAccessGroupsSetRights(UpdateParameters)
	
	If UpdateParameters.ForExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
	|WHERE
	|	AccessGroupSetsAccessKeys.AccessGroupsSet = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.User = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.ExternalUser = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)";
	
	QueryResults = Query.ExecuteBatch();
	
	If Not QueryResults[0].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
		RecordSet.Filter.AccessGroupsSet.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
	If Not QueryResults[1].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
		RecordSet.Filter.User.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
	If Not QueryResults[2].IsEmpty() Then
		RecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
		RecordSet.Filter.ExternalUser.Set(Catalogs.SetsOfAccessGroups.EmptyRef());
		RecordSet.Write();
	EndIf;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsWithObsoleteParameters(DataItems, UpdateParameters)
	
	GroupsSetsBatches = New Array;
	GroupsSets = New Array;
	
	For Each DataItem In DataItems Do
		If GroupsSets.Count() > 4 Then
			GroupsSetsBatches.Add(GroupsSets);
			GroupsSets = New Array;
		EndIf;
		GroupsSets.Add(DataItem.CurrentRef);
	EndDo;
	GroupsSetsBatches.Add(GroupsSets);
	
	For Each GroupsSets In GroupsSetsBatches Do
		UpdateGroupsSetsAccessKeys(UpdateParameters,
			GroupsSets, "AccessGroupSetsAccessKeys", "AccessGroups", "AccessGroupsSet");
		
		If Not UpdateParameters.ForExternalUsers Then
			UpdateGroupsSetsAccessKeys(UpdateParameters,
				GroupsSets, "UsersAccessKeys", "UserGroups", "User");
		Else
			UpdateGroupsSetsAccessKeys(UpdateParameters,
				GroupsSets, "ExternalUsersAccessKeys", "ExternalUsersGroups", "ExternalUser");
		EndIf;
		
		If ItemsProcessingAbortRequired(UpdateParameters, GroupsSets.Count()) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsWithObsoleteParameters procedure.
Procedure UpdateGroupsSetsAccessKeys(UpdateParameters, GroupsSets, RightsRegisterName,
				GroupsCatalogName, GroupsSetFieldName)
	
	BatchForLockSelectionQueryText =
	"SELECT TOP 1000
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind,
	|	AllRows.AccessKey AS AccessKey
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Folders AS GroupsInSets
	|			ON (GroupsInSets.Folder = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups))
	|				AND (&AccessGroupSetFilterCriterion1)
	|	
	|	GROUP BY
	|		AccessGroupsAccessKeys.AccessKey,
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.AccessKey,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND &AccessGroupSetFilterCriterion2
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.AccessKey,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		&GroupRightsFilterCriterion
	|		AND &AccessGroupSetFilterCriterion3) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.AccessKey,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	AccessGroupsSet,
	|	RowChangeKind,
	|	AccessKey";
	
	BatchForUpdateSelectionQueryText =
	"SELECT TOP 1000
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	AllRows.AccessKey AS AccessKey,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		AccessGroupsAccessKeys.AccessKey AS AccessKey,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Folders AS GroupsInSets
	|			ON (GroupsInSets.Folder = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups))
	|				AND (&AccessGroupSetFilterCriterion1)
	|				AND (&AccessKeyFilterCriterion1)
	|	
	|	GROUP BY
	|		AccessGroupsAccessKeys.AccessKey,
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.AccessKey,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND &AccessGroupSetFilterCriterion2
	|		AND &AccessKeyFilterCriterion2
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.AccessKey,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		&GroupRightsFilterCriterion
	|		AND &AccessGroupSetFilterCriterion3
	|		AND &AccessKeyFilterCriterion3) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.AccessKey,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"TYPE(Catalog.AccessGroups)", "TYPE(Catalog." + GroupsCatalogName + ")");
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"AccessGroupsSet", GroupsSetFieldName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"AccessGroupsSet", GroupsSetFieldName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"TYPE(Catalog.AccessGroups)", "TYPE(Catalog." + GroupsCatalogName + ")");
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"InformationRegister.AccessGroupSetsAccessKeys", "InformationRegister." + RightsRegisterName);
	
	BatchForLockSelectionQueryText = StrReplace(BatchForLockSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(GroupsCatalogName = "AccessGroups", "TRUE", "OldData.AreGroupSetRights"));
	
	BatchForUpdateSelectionQueryText = StrReplace(BatchForUpdateSelectionQueryText,
		"&GroupRightsFilterCriterion", ?(GroupsCatalogName = "AccessGroups", "TRUE", "OldData.AreGroupSetRights"));
	
	While True Do
		Query = New Query;
		Query.Text = BatchForLockSelectionQueryText;
		
		Query.SetParameter("AllowedEmptySet",
			AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
		
		SetFilterCriterionInQuery(Query, GroupsSets, "GroupsSets",
			"&AccessGroupSetFilterCriterion1:GroupsInSets.Ref
			|&AccessGroupSetFilterCriterion2:&AllowedEmptySet
			|&AccessGroupSetFilterCriterion3:OldData." + GroupsSetFieldName);
		
		DataExported = Query.Execute().Unload();
		If DataExported.Count() = 0 Then
			Break;
		EndIf;
		
		Lock = New DataLock;
		For Each Row In DataExported Do
			LockItem = Lock.Add("InformationRegister." + RightsRegisterName);
			LockItem.SetValue(GroupsSetFieldName, Row[GroupsSetFieldName]);
			LockItem.SetValue("AccessKey",      Row.AccessKey);
		EndDo;
		
		If Common.FileInfobase() Then
			LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
			LockItem.Mode = DataLockMode.Shared;
		EndIf;
		
		DataExported.GroupBy("AccessKey");
		AccessKeys = DataExported.UnloadColumn("AccessKey");
		
		Query = New Query;
		Query.Text = BatchForUpdateSelectionQueryText;
		
		Query.SetParameter("AllowedEmptySet",
			AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
		
		SetFilterCriterionInQuery(Query, GroupsSets, "GroupsSets",
			"&AccessGroupSetFilterCriterion1:GroupsInSets.Ref
			|&AccessGroupSetFilterCriterion2:&AllowedEmptySet
			|&AccessGroupSetFilterCriterion3:OldData." + GroupsSetFieldName);
		
		SetFilterCriterionInQuery(Query, AccessKeys, "AccessKeys",
			"&AccessKeyFilterCriterion1:AccessGroupsAccessKeys.AccessKey
			|&AccessKeyFilterCriterion2:AccessGroupsAccessKeys.AccessKey
			|&AccessKeyFilterCriterion3:OldData.AccessKey");
		
		RecordSet = ServiceRecordSet(InformationRegisters[RightsRegisterName]);
		
		BeginTransaction();
		Try
			Lock.Lock();
			Selection = Query.Execute().Select();
			
			DeletionCompleted = False;
			While Selection.Next() Do
				RecordSet.Filter[GroupsSetFieldName].Set(Selection[GroupsSetFieldName]);
				RecordSet.Filter.AccessKey.Set(Selection.AccessKey);
				If Not DeletionCompleted AND Selection.RowChangeKind = 1 Then
					DeletionCompleted = True;
					OneRecord = RecordSet.Add();
				EndIf;
				If DeletionCompleted Then
					FillPropertyValues(OneRecord, Selection);
				EndIf;
				RecordSet.Write();
			EndDo;
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Procedure EliminateSetsDuplicatesFromOneUserInCatalog(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.User AS User,
	|	SetsOfAccessGroups.Ref AS Ref
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND SetsOfAccessGroups.User IN
	|			(SELECT DISTINCT
	|				SetsOfAccessGroups.User AS User
	|			FROM
	|				Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|			WHERE
	|				SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|			GROUP BY
	|				SetsOfAccessGroups.User
	|			HAVING
	|				COUNT(SetsOfAccessGroups.User) > 1)";
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		If Selection.Ref.UUID() = Selection.User.UUID() Then
			Continue;
		EndIf;
		Lock = New DataLock;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", Selection.Ref);
		BeginTransaction();
		Try
			Lock.Lock();
			Object = ServiceItem(Undefined, Selection.Ref);
			If Object <> Undefined Then
				Object.SetItemsType = Undefined;
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateSetsOfOneUserInCatalog(DataItems, UpdateParameters)
	
	If UpdateParameters.ForExternalUsers Then
		SetItemsType = Catalogs.ExternalUsers.EmptyRef();
		ItemPresentation = NStr("ru = 'Внешний пользователь'; en = 'External user'; pl = 'Użytkownik zewnętrzny';de = 'Externer Benutzer';ro = 'Utilizator extern';tr = 'Harici kullanıcı'; es_ES = 'Usuario externo'", Common.DefaultLanguageCode());
	Else
		SetItemsType = Catalogs.Users.EmptyRef();
		ItemPresentation = NStr("ru = 'Пользователь'; en = 'User'; pl = 'Użytkownik';de = 'Benutzer';ro = 'Utilizator';tr = 'Kullanıcı'; es_ES = 'Usuario'", Common.DefaultLanguageCode());
	EndIf;
	
	For Each String In DataItems Do
		SetRef = Catalogs.SetsOfAccessGroups.GetRef(String.CurrentRef.UUID());
		Lock = New DataLock;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", SetRef);
		
		BeginTransaction();
		Try
			Lock.Lock();
			
			Object = ServiceItem(Undefined, SetRef);
			If Object = Undefined Then
				Object = ServiceItem(Catalogs.SetsOfAccessGroups);
				Object.SetNewObjectRef(SetRef);
			Else
				Object.Folders.Clear();
			EndIf;
			If String.Used Then
				Object.NotUsedSince = '00010101';
			ElsIf Not ValueIsFilled(String.NotUsedSince) Then
				Object.NotUsedSince = CurrentSessionDate();
			EndIf;
			Object.ForExternalUsers = UpdateParameters.ForExternalUsers;
			Object.SetItemsType = SetItemsType;
			Object.User = String.CurrentRef;
			Object.Description = String.Description + " (" + ItemPresentation + ")";
			Object.Write();
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Procedure FillBlankGroupsSetsHashes(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("AllowedEmptySet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.Ref AS Ref
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType IN (VALUE(Catalog.AccessGroups.EmptyRef), VALUE(Catalog.UserGroups.EmptyRef))
	|	AND SetsOfAccessGroups.Hash = 0
	|	AND SetsOfAccessGroups.Ref <> &AllowedEmptySet";
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	Selection = Query.Execute().Select();
	While Selection.Next() Do
		Lock = New DataLock;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", Selection.Ref);
		BeginTransaction();
		Try
			Lock.Lock();
			Object = ServiceItem(Undefined, Selection.Ref);
			If Object <> Undefined Then
				FillGroupsSetHash(Object);
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the AccessGroupsSetsForUpdate function.
Function OneUserSetsToUpdateAssignedAccessGroupsSets(UpdateParameters,
			CountInQuery)
	
	If Not UpdateParameters.ForExternalUsers Then
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator)
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND CASE
		|			WHEN TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						Catalog.AccessGroupProfiles.Purpose AS Purpose
		|					WHERE
		|						Purpose.Ref = AccessGroups.Profile
		|						AND VALUETYPE(Purpose.UsersType) = TYPE(Catalog.Users))
		|				THEN TRUE
		|			WHEN NOT FALSE IN
		|						(SELECT TOP 1
		|							FALSE
		|						FROM
		|							Catalog.AccessGroupProfiles.Purpose AS Purpose
		|						WHERE
		|							Purpose.Ref = AccessGroups.Profile)
		|				THEN TRUE
		|			ELSE FALSE
		|		END
		|
		|ORDER BY
		|	Ref";
	Else
		GroupsQueryText =
		"SELECT
		|	AccessGroups.Ref AS Ref
		|FROM
		|	Catalog.AccessGroups AS AccessGroups
		|WHERE
		|	AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator)
		|	AND NOT AccessGroups.DeletionMark
		|	AND NOT AccessGroups.Profile.DeletionMark
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroups.Users AS AccessGroupsUsers
		|			WHERE
		|				AccessGroupsUsers.Ref = AccessGroups.Ref)
		|	AND TRUE IN
		|			(SELECT TOP 1
		|				TRUE
		|			FROM
		|				Catalog.AccessGroupProfiles.Purpose AS Purpose
		|			WHERE
		|				Purpose.Ref = AccessGroups.Profile
		|				AND Purpose.UsersType <> UNDEFINED
		|				AND VALUETYPE(Purpose.UsersType) <> TYPE(Catalog.Users))
		|
		|ORDER BY
		|	Ref";
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserAccessGroups.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	(SELECT DISTINCT
	|		UserGroupCompositions.User AS User,
	|		AccessGroupsUsers.Ref AS AccessGroup
	|	FROM
	|		Catalog.AccessGroups.Users AS AccessGroupsUsers
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = AccessGroupsUsers.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID)
	|				AND (UserGroupCompositions.Used)) AS UserAccessGroups
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserAccessGroups.AccessGroup = GroupsNumbers.Folder
	|
	|GROUP BY
	|	UserAccessGroups.User
	|
	|INDEX BY
	|	UserAccessGroups.User";
	
	DataItems = OneUserSetsToUpdateAssignedGroupsSets(UpdateParameters,
		GroupsQueryText, NewGroupsSetsQueryText, "AccessGroupsSet", "AccessGroups");
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For the AccessGroupsSetsForUpdate function.
Function OneUserSetsToUpdateAssignedUsersGroupsSets(UpdateParameters,
			CountInQuery)
	
	GroupsQueryText =
	"SELECT DISTINCT
	|	UserGroupCompositions.UsersGroup AS Ref
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|WHERE
	|	UserGroupCompositions.Used
	|	AND VALUETYPE(UserGroupCompositions.UsersGroup) = TYPE(Catalog.UserGroups)
	|
	|ORDER BY
	|	UserGroupCompositions.UsersGroup";
	
	If UpdateParameters.ForExternalUsers Then
		GroupsQueryText = StrReplace(GroupsQueryText,
			"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	NewGroupsSetsQueryText =
	"SELECT
	|	UserGroupCompositions.User AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN GroupsNumbers AS GroupsNumbers
	|		ON UserGroupCompositions.UsersGroup = GroupsNumbers.Folder
	|			AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|			AND (CAST(UserGroupCompositions.User AS Catalog.Users).IBUserID <> &BlankUUID)
	|			AND (UserGroupCompositions.Used)
	|
	|GROUP BY
	|	UserGroupCompositions.User
	|
	|INDEX BY
	|	UserGroupCompositions.User";
	
	If UpdateParameters.ForExternalUsers Then
		GroupsCatalogName = "ExternalUsersGroups";
		ItemPresentation = NStr("ru = 'Группы внешних пользователей'; en = 'External user groups'; pl = 'Zewnętrzna grupa użytkowników';de = 'Gruppen externer Benutzer';ro = 'Grupuri utilizatori externi';tr = 'Dış kullanıcı grupları'; es_ES = 'Grupos de usuario externo'",
			Common.DefaultLanguageCode());
	Else
		GroupsCatalogName = "UserGroups";
		ItemPresentation = NStr("ru = 'Группы пользователей'; en = 'User groups'; pl = 'Grupy użytkowników';de = 'Benutzergruppen';ro = 'Grupurile utilizatorilor';tr = 'Kullanıcı grupları'; es_ES = 'Grupos de usuario'",
			Common.DefaultLanguageCode());
	EndIf;
	
	DataItems = OneUserSetsToUpdateAssignedGroupsSets(UpdateParameters,
		GroupsQueryText, NewGroupsSetsQueryText, "UserGroupsSet", GroupsCatalogName);
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For functions OneUserSetsToUpdateAssignedAccessGroupsSets and
// OneUserSetsToUpdateAssignedUsersGroupsSets.
//
Function OneUserSetsToUpdateAssignedGroupsSets(UpdateParameters,
			GroupsQueryText, NewGroupsSetsQueryText, SetFieldName, GroupsCatalogName)
	
	Query = New Query;
	Query.Text = GroupsQueryText;
	GroupsNumbers = Query.Execute().Unload();
	
	NumberPartsNames = New Array;
	FillGroupsNumbers(GroupsNumbers, NumberPartsNames);
	
	Query = New Query;
	Query.SetParameter("GroupsNumbers", GroupsNumbers);
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	Query.Text =
	"SELECT
	|	GroupsNumbers.Ref AS Folder,
	|	GroupsNumbers.NumberPart1 AS NumberPart1
	|INTO GroupsNumbers
	|FROM
	|	&GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UNDEFINED AS User,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO NewGroupsSets
	|FROM
	|	GroupsNumbers AS GroupsNumbers
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS SingleUserSet,
	|	GroupsSets.User AS User,
	|	ISNULL(SUM(GroupsNumbers.NumberPart1), -1) AS NumberPart1
	|INTO OldGroupSets
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups.Folders AS SetGroups
	|		ON (SetGroups.Ref = GroupsSets.AllowedAccessGroupsSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Folder = GroupsNumbers.Folder)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupsSet = VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User
	|
	|UNION ALL
	|
	|SELECT
	|	GroupsSets.Ref,
	|	GroupsSets.User,
	|	ISNULL(SUM(GroupsNumbers.NumberPart1), -1)
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups.Folders AS SetGroups
	|		ON (SetGroups.Ref = GroupsSets.NewAccessGroupsSet)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Folder = GroupsNumbers.Folder)
	|WHERE
	|	GroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND GroupsSets.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND GroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|	AND GroupsSets.NewAccessGroupsSet <> VALUE(Catalog.SetsOfAccessGroups.EmptyRef)
	|
	|GROUP BY
	|	GroupsSets.Ref,
	|	GroupsSets.User
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	OldSets.SingleUserSet AS SingleUserSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|INTO GroupSetsForUpdate
	|FROM
	|	OldGroupSets AS OldSets
	|		LEFT JOIN NewGroupsSets AS NewSets
	|		ON (NewSets.User = OldSets.User)
	|WHERE
	|	OldSets.NumberPart1 <> NewSets.NumberPart1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	GroupsSets.Ref AS GroupSet,
	|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
	|INTO ExistingGroupSets
	|FROM
	|	Catalog.SetsOfAccessGroups AS GroupsSets
	|		INNER JOIN Catalog.SetsOfAccessGroups.Folders AS SetGroups
	|		ON (GroupsSets.ForExternalUsers = &ForExternalUsers)
	|			AND (GroupsSets.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef))
	|			AND (SetGroups.Ref = GroupsSets.Ref)
	|		LEFT JOIN GroupsNumbers AS GroupsNumbers
	|		ON (SetGroups.Folder = GroupsNumbers.Folder)
	|
	|GROUP BY
	|	GroupsSets.Ref
	|
	|HAVING
	|	NOT SUM(GroupsNumbers.NumberPart1) IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	NewSets.SingleUserSet AS CurrentRef,
	|	ISNULL(ExistingSets.GroupSet, VALUE(Catalog.SetsOfAccessGroups.EmptyRef)) AS GroupSet,
	|	TRUE IN
	|		(SELECT TOP 1
	|			TRUE
	|		FROM
	|			Catalog.SetsOfAccessGroups AS AllSets
	|		WHERE
	|			AllSets.ForExternalUsers = &ForExternalUsers
	|			AND AllSets.NewAccessGroupsSet = ExistingSets.GroupSet) AS NewGroupSet,
	|	NewSets.NumberPart1 AS NumberPart1
	|FROM
	|	GroupSetsForUpdate AS NewSets
	|		LEFT JOIN ExistingGroupSets AS ExistingSets
	|		ON (ExistingSets.NumberPart1 = NewSets.NumberPart1)
	|
	|ORDER BY
	|	CurrentRef,
	|	GroupSet";
	
	Query.Text = StrReplace(Query.Text,
		"SELECT
		|	UNDEFINED AS User,
		|	SUM(GroupsNumbers.NumberPart1) AS NumberPart1
		|INTO NewGroupsSets
		|FROM
		|	GroupsNumbers AS GroupsNumbers",
		NewGroupsSetsQueryText);
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	Query.Text = StrReplace(Query.Text, "VALUE(Catalog.AccessGroups.EmptyRef)",
		"VALUE(Catalog." + GroupsCatalogName + ".EmptyRef)");
	
	Query.Text = StrReplace(Query.Text, "NewAccessGroupsSet",       "New"       + SetFieldName);
	Query.Text = StrReplace(Query.Text, "AllowedAccessGroupsSet", "Allowed" + SetFieldName);
	
	Query.Text = StrReplace(Query.Text,
		"	GroupsNumbers.NumberPart1 AS NumberPart1",
		"	GroupsNumbers." + StrConcat(NumberPartsNames, ",
		|	GroupsNumbers."));
	
	Query.Text = StrReplace(Query.Text,
		"	ISNULL(SUM(GroupsNumbers.NumberPart1), -1)
		|",
		"	ISNULL(SUM(GroupsNumbers." + StrConcat(NumberPartsNames, "), -1),
		|	ISNULL(SUM(GroupsNumbers.") + "), -1)
		|");
	
	Query.Text = StrReplace(Query.Text,
		"	NewSets.NumberPart1 AS NumberPart1",
		"	NewSets." + StrConcat(NumberPartsNames, ",
		|	NewSets."));
	
	Query.Text = StrReplace(Query.Text,
		"	NOT SUM(GroupsNumbers.NumberPart1) IS NULL",
		"	NOT SUM(GroupsNumbers." + StrConcat(NumberPartsNames, ") IS NULL
		|	AND NOT SUM(GroupsNumbers.") + ") IS NULL");
	
	FilterCriterion = "";
	ConnectionCondition = "";
	OldOnesSumFields = "";
	NewOnesSumFields = "";
	For Each NumberPartName In NumberPartsNames Do
		FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "","
		|			OR ") + "OldSets." + NumberPartName + " <> NewSets." + NumberPartName;
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(ExistingSets." + NumberPartName + " = NewSets." + NumberPartName + ")";
		OldOnesSumFields = OldOnesSumFields + ?(OldOnesSumFields = "", "", ",
		|	") + "ISNULL(SUM(GroupsNumbers." + NumberPartName + "), -1) AS " + NumberPartName;
		NewOnesSumFields = NewOnesSumFields + ?(NewOnesSumFields = "", "", ",
		|	") + "SUM(GroupsNumbers." + NumberPartName + ") AS " + NumberPartName;
	EndDo;
	
	Query.Text = StrReplace(Query.Text,
		"OldSets.NumberPart1 <> NewSets.NumberPart1", "(" + FilterCriterion + ")");
	Query.Text = StrReplace(Query.Text,
		"(ExistingSets.NumberPart1 = NewSets.NumberPart1)", ConnectionCondition);
	
	Query.Text = StrReplace(Query.Text,
		"ISNULL(SUM(GroupsNumbers.NumberPart1), -1) AS NumberPart1", OldOnesSumFields);
	Query.Text = StrReplace(Query.Text,
		"SUM(GroupsNumbers.NumberPart1) AS NumberPart1", NewOnesSumFields);
	
	Result = Query.Execute().Unload();
	
	SetPartsNamesList = StrConcat(NumberPartsNames, ", ");
	NewGroupsSets = Result.Copy(New Array, SetPartsNamesList);
	NewGroupsSets.Columns.Add("SetGroups");
	NewGroupsSets.Columns.Add("GroupsID");
	Filter = New Structure(SetPartsNamesList);
	
	DataItems = Result.Copy(New Array, "CurrentRef, GroupSet, NewGroupSet");
	DataItems.Columns.Add("SetGroups");
	DataItems.Columns.Add("GroupsID");
	
	For Each String In Result Do
		NewString = DataItems.Add();
		FillPropertyValues(NewString, String);
		If ValueIsFilled(String.GroupSet) Then
			Continue;
		EndIf;
		FillPropertyValues(Filter, String);
		FoundRows = NewGroupsSets.FindRows(Filter);
		If FoundRows.Count() = 0 Then
			NewSetProperties = NewGroupsSets.Add();
			FillPropertyValues(NewSetProperties, String);
			NewSetProperties.GroupsID = New UUID;
			NewSetProperties.SetGroups =
				SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NewSetProperties);
		Else
			NewSetProperties = FoundRows[0];
		EndIf;
		NewString.SetGroups       = NewSetProperties.SetGroups;
		NewString.GroupsID = NewSetProperties.GroupsID;
	EndDo;
	
	Return DataItems;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure UpdateGroupsSetsAssingedToUsersInCatalog(DataItems,
			UpdateParameters, IsAssignedAccessGroupsSetsUpdate)
	
	ForExternalUsers = UpdateParameters.ForExternalUsers;
	
	If IsAssignedAccessGroupsSetsUpdate Then
		SetFieldName = "AccessGroupsSet";
		SetItemsType = Catalogs.AccessGroups.EmptyRef();
		GroupsItemsPresentation = NStr("ru = 'Группы доступа'; en = 'Access groups'; pl = 'Grupy dostępu';de = 'Zugriffsgruppen';ro = 'Grupuri de acces';tr = 'Erişim grupları'; es_ES = 'Grupos de acceso'",
			Common.DefaultLanguageCode());
		
	Else
		SetFieldName = "UserGroupsSet";
		If Not ForExternalUsers Then
			SetItemsType = Catalogs.UserGroups.EmptyRef();
			GroupsItemsPresentation = NStr("ru = 'Группы пользователей'; en = 'User groups'; pl = 'Grupy użytkowników';de = 'Benutzergruppen';ro = 'Grupurile utilizatorilor';tr = 'Kullanıcı grupları'; es_ES = 'Grupos de usuario'",
				Common.DefaultLanguageCode());
		Else
			SetItemsType = Catalogs.ExternalUsersGroups.EmptyRef();
			GroupsItemsPresentation = NStr("ru = 'Группы внешних пользователей'; en = 'External user groups'; pl = 'Grupa użytkowników zewnętrznych';de = 'Gruppen externer Benutzer';ro = 'Grupurile utilizatorilor externi';tr = 'Dış kullanıcı grupları'; es_ES = 'Grupos de usuario externo'",
				Common.DefaultLanguageCode());
		EndIf;
	EndIf;
	
	NewGroupsSets = New Map;
	
	For Each String In DataItems Do
		If Not ValueIsFilled(String.GroupSet) Then
			GroupsSet = NewGroupsSets.Get(String.GroupsID);
			If GroupsSet = Undefined Then
				String.GroupSet = NewGroupsSet(String.SetGroups,
					UpdateParameters.ForExternalUsers,
					SetItemsType,
					GroupsItemsPresentation,
					String.NewGroupSet);
				NewGroupsSets.Insert(String.GroupsID, String.GroupSet);
			Else
				String.GroupSet = GroupsSet;
			EndIf;
		EndIf;
		
		Lock = New DataLock;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Lock.Lock();
			
			Object = ServiceItem(Undefined, String.CurrentRef);
			If String.NewGroupSet Then
				Object["New" + SetFieldName] = String.GroupSet;
			Else
				Object["Allowed" + SetFieldName] = String.GroupSet;
				Object["New" + SetFieldName] = UpdateParameters.BlankAccessGroupsSet;
			EndIf;
			Object.Write();
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Procedure FillGroupsNumbers(GroupsNumbers, NumberPartsNames)
	
	GroupsCount = GroupsNumbers.Count();
	NumberPartsCount = Int(GroupsCount / 64) + 1;
	NumberTypesDetails = New TypeDescription("Number",,,
		New NumberQualifiers(31, 0, AllowedSign.Nonnegative));
	
	For Counter = 1 To NumberPartsCount Do
		NumberPartName = "NumberPart" + Format(Counter, "NGS=");
		NumberPartsNames.Add(NumberPartName);
		GroupsNumbers.Columns.Add(NumberPartName, NumberTypesDetails);
	EndDo;
	
	CurrentNumberPart = 1;
	CurrentNumberPartName = NumberPartsNames[0];
	CurrentGroupNumber = 1;
	MaxGroupNumberInNumberPart = 9223372036854775808; // 2^63.
	For Each Row In GroupsNumbers Do
		Row[CurrentNumberPartName] = CurrentGroupNumber;
		CurrentGroupNumber = CurrentGroupNumber * 2;
		If CurrentGroupNumber > MaxGroupNumberInNumberPart Then
			CurrentGroupNumber = 1;
			CurrentNumberPartName = NumberPartsNames[CurrentNumberPart];
			CurrentNumberPart = CurrentNumberPart + 1;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateGroupsSetsInCatalog procedure.
Function NewGroupsSet(SetGroups, ForExternalUsers, SetItemsType,
			GroupsItemsPresentation, GroupsSetAdded)
	
	NewRef = Catalogs.SetsOfAccessGroups.GetRef();
	Object = ServiceItem(Catalogs.SetsOfAccessGroups);
	Object.SetNewObjectRef(NewRef);
	Object.ForExternalUsers = ForExternalUsers;
	Object.SetItemsType = SetItemsType;
	Object.Description = String(NewRef.UUID()) + " (" + GroupsItemsPresentation + ")";
	
	For Each SetGroup In SetGroups Do
		Object.Folders.Add().Folder = SetGroup;
	EndDo;
	
	FillGroupsSetHash(Object);
	
	Lock = New DataLock;
	LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
	LockItem.SetValue("SetItemsType", Object.SetItemsType);
	LockItem.SetValue("Hash", Object.Hash);
	
	BeginTransaction();
	Try
		Lock.Lock();
		If Not GroupsSetExists(Object) Then
			Object.Write();
			GroupsSetAdded = True;
		EndIf;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	Return Object.Ref;
	
EndFunction

// For the NewGroupsSet function and the FillBlankGroupsSetsHashes procedure.
Procedure FillGroupsSetHash(Object)
	
	Object.Folders.Sort("Folder", New CompareValues);
	
	DataForHash = Object.Folders.UnloadColumn("Folder");
	StringForHash = DataStringForHashing(DataForHash);
	Hashing = New DataHashing(HashFunction.CRC32);
	Hashing.Append(StringForHash);
	Object.Hash = Hashing.HashSum;
	
EndProcedure

// For the NewGroupsSet function.
Function SetGroupsByNumbers(GroupsNumbers, NumberPartsNames, NumberParts)
	
	SetGroups = New Array;
	GroupIndex = 0;
	Divisor = 4294967296; // 2^32.
	
	For Each NumberPartName In NumberPartsNames Do
		NumberPart = NumberParts[NumberPartName];
		For NumberPartBlockNumber = 1 To 2 Do
			Integer = Int(NumberPart / Divisor);
			NumberPartBlock = NumberPart - Integer * Divisor;
			NumberPart = Integer;
			If NumberPartBlock > 0 Then
				For BitNumber = 0 To 31 Do
					If CheckBit(NumberPartBlock, BitNumber) Then
						SetGroups.Add(GroupsNumbers[GroupIndex + BitNumber].Ref);
					EndIf;
				EndDo;
			EndIf;
			GroupIndex = GroupIndex + 32;
		EndDo;
	EndDo;
	
	Return SetGroups;
	
EndFunction

// For the NewGroupsSet function.
Function GroupsSetExists(Object)
	
	Query = New Query;
	Query.SetParameter("SetItemsType", Object.SetItemsType);
	Query.SetParameter("Hash", Object.Hash);
	Query.Text =
	"SELECT
	|	ExistingSets.Ref AS Ref,
	|	ExistingSets.Folders.(
	|		Folder AS Folder
	|	) AS Folders
	|FROM
	|	Catalog.SetsOfAccessGroups AS ExistingSets
	|WHERE
	|	ExistingSets.SetItemsType = &SetItemsType
	|	AND ExistingSets.Hash = &Hash
	|
	|ORDER BY
	|	Ref";
	
	ObjectGroups = Object.Folders.Unload(, "Folder");
	ObjectGroups.Indexes.Add("Folder");
	
	DataExported = Query.Execute().Unload();
	For Each String In DataExported Do
		If ObjectGroups.Count() <> String.Folders.Count() Then
			Continue;
		EndIf;
		GroupsMap = True;
		For Each Substring In String.Folders Do
			If ObjectGroups.Find(Substring.Folder, "Folder") = Undefined Then
				GroupsMap = False;
				Break;
			EndIf;
		EndDo;
		If GroupsMap Then
			Object = New Structure("Ref", String.Ref);
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateAccessGroupsSets procedure.
Procedure UpdateGroupsSetsAllowedForUsersInCatalog(DataItems, UpdateParameters)
	
	Lock = New DataLock;
	LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
	
	For Each String In DataItems Do
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Lock.Lock();
			
			Object = ServiceItem(Undefined, String.CurrentRef);
			If Object <> Undefined Then
				If ValueIsFilled(Object.NewAccessGroupsSet) Then
					Object.AllowedAccessGroupsSet = Object.NewAccessGroupsSet;
					Object.NewAccessGroupsSet = UpdateParameters.BlankAccessGroupsSet;
				EndIf;
				If ValueIsFilled(Object.NewUserGroupsSet) Then
					Object.AllowedUserGroupsSet = Object.NewUserGroupsSet;
					Object.NewUserGroupsSet = UpdateParameters.BlankAccessGroupsSet;
				EndIf;
				If Object.Modified() Then
					Object.Write();
				EndIf;
			EndIf;
			
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Procedure ClearNonExistentAccessGroupsSetsRights(UpdateParameters)
	
	If UpdateParameters.ForExternalUsers Then
		Return;
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	SetsAccessKeys.AccessGroupsSet AS Set
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.AccessGroupsSet.Ref IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SetsAccessKeys.User AS Set
	|FROM
	|	InformationRegister.UsersAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.User.Ref IS NULL
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SetsAccessKeys.ExternalUser AS Set
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.ExternalUser.Ref IS NULL";
	
	QueryResults = Query.ExecuteBatch();
	
	Selection = QueryResults[0].Select();
	While Selection.Next() Do
		DeleteRegisterRecordsForSet(Selection.Set,
			"AccessGroupSetsAccessKeys", "AccessGroupsSet");
	EndDo;
	
	Selection = QueryResults[1].Select();
	While Selection.Next() Do
		DeleteRegisterRecordsForSet(Selection.Set,
			"UsersAccessKeys", "User");
	EndDo;
	
	Selection = QueryResults[2].Select();
	While Selection.Next() Do
		DeleteRegisterRecordsForSet(Selection.Set,
			"ExternalUsersAccessKeys", "ExternalUser");
	EndDo;
	
EndProcedure

// For the AccessGroupsSetsForUpdate function.
Function ObsoleteAccessGroupsSetsInCatalog(UpdateParameters, CountInQuery)
	
	Query = New Query;
	Query.SetParameter("ForExternalUsers", UpdateParameters.ForExternalUsers);
	Query.SetParameter("DateOfBecomingObsolete", DateOfBecomingObsolete());
	Query.SetParameter("AllowedEmptySet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	Query.Text =
	"SELECT
	|	SetsOfAccessGroups.Ref AS CurrentRef,
	|	SetsOfAccessGroups.SetItemsType AS SetItemsType,
	|	FALSE AS Used,
	|	TRUE AS Delete
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.SetItemsType = UNDEFINED
	|
	|UNION ALL
	|
	|SELECT
	|	SetsOfAccessGroups.Ref,
	|	SetsOfAccessGroups.SetItemsType,
	|	FALSE,
	|	TRUE
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.Users.EmptyRef)
	|	AND (CAST(SetsOfAccessGroups.User AS Catalog.Users).Ref IS NULL
	|			OR SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
	|				AND SetsOfAccessGroups.NotUsedSince < &DateOfBecomingObsolete)
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	SetsOfAccessGroups.Ref,
	|	SetsOfAccessGroups.SetItemsType,
	|	NOT SetsWithSingleUser.Ref IS NULL,
	|	SetsOfAccessGroups.NotUsedSince <> DATETIME(1, 1, 1)
	|		AND SetsOfAccessGroups.NotUsedSince < &DateOfBecomingObsolete
	|FROM
	|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
	|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedAccessGroupsSet = SetsOfAccessGroups.Ref
	|				OR SetsWithSingleUser.NewAccessGroupsSet = SetsOfAccessGroups.Ref)
	|WHERE
	|	SetsOfAccessGroups.ForExternalUsers = &ForExternalUsers
	|	AND SetsOfAccessGroups.SetItemsType = VALUE(Catalog.AccessGroups.EmptyRef)
	|	AND SetsOfAccessGroups.Ref <> &AllowedEmptySet
	|	AND CASE
	|			WHEN SetsOfAccessGroups.NotUsedSince = DATETIME(1, 1, 1)
	|				THEN SetsWithSingleUser.Ref IS NULL
	|			ELSE NOT SetsWithSingleUser.Ref IS NULL
	|					OR SetsOfAccessGroups.NotUsedSince < &DateOfBecomingObsolete
	|		END
	|
	|UNION ALL
	|
	|SELECT DISTINCT
	|	UsersGroupsSets.Ref,
	|	UsersGroupsSets.SetItemsType,
	|	NOT SetsWithSingleUser.Ref IS NULL,
	|	UsersGroupsSets.NotUsedSince <> DATETIME(1, 1, 1)
	|		AND SetsWithSingleUser.NotUsedSince < &DateOfBecomingObsolete
	|FROM
	|	Catalog.SetsOfAccessGroups AS UsersGroupsSets
	|		LEFT JOIN Catalog.SetsOfAccessGroups AS SetsWithSingleUser
	|		ON (SetsWithSingleUser.ForExternalUsers = &ForExternalUsers)
	|			AND (SetsWithSingleUser.AllowedUserGroupsSet = UsersGroupsSets.Ref
	|				OR SetsWithSingleUser.NewUserGroupsSet = UsersGroupsSets.Ref)
	|WHERE
	|	UsersGroupsSets.ForExternalUsers = &ForExternalUsers
	|	AND UsersGroupsSets.SetItemsType = VALUE(Catalog.UserGroups.EmptyRef)
	|	AND CASE
	|			WHEN UsersGroupsSets.NotUsedSince = DATETIME(1, 1, 1)
	|				THEN SetsWithSingleUser.Ref IS NULL
	|			ELSE NOT SetsWithSingleUser.Ref IS NULL
	|					OR UsersGroupsSets.NotUsedSince < &DateOfBecomingObsolete
	|		END";
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text, "Catalog.Users", "Catalog.ExternalUsers");
		Query.Text = StrReplace(Query.Text, "Catalog.UserGroups", "Catalog.ExternalUsersGroups");
	EndIf;
	
	DataItems = Query.Execute().Unload();
	
	CountInQuery = DataItems.Count();
	Return DataItems;
	
EndFunction

// For the ObsoleteAccessGroupsSetsInCatalog and  ItemsForUpdate functions.
Function DateOfBecomingObsolete()
	
	Return CurrentSessionDate() - HoursOfNotUsedItemsBecomingObsoleteCount() * 60 * 60;
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure ProcessObsoleteSetsInCatalog(DataItems, UpdateParameters)
	
	Lock = New DataLock;
	LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
	
	For Each String In DataItems Do
		LockItem.SetValue("Ref", String.CurrentRef);
		
		BeginTransaction();
		Try
			Lock.Lock();
			Object = ServiceItem(Undefined, String.CurrentRef);
			If Object <> Undefined Then
				If String.Used Then
					Object.NotUsedSince = '00010101';
				ElsIf Not String.Delete Then
					Object.NotUsedSince = CurrentSessionDate();
				Else
					Object.SetItemsType = Undefined;
					Object.Hash = 0;
					Object.Folders.Clear();
				EndIf;
				Object.Write();
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If Not String.Used AND String.Delete Then
			DeleteRegisterRecordsForSet(String.CurrentRef, "AccessGroupSetsAccessKeys",  "AccessGroupsSet");
			DeleteRegisterRecordsForSet(String.CurrentRef, "UsersAccessKeys",        "User");
			DeleteRegisterRecordsForSet(String.CurrentRef, "ExternalUsersAccessKeys", "ExternalUser");
			
			BeginTransaction();
			Try
				Lock.Lock();
				Object = ServiceItem(Undefined, String.CurrentRef);
				If Object <> Undefined Then
					Object.Delete();
				EndIf;
				CommitTransaction();
			Except
				RollbackTransaction();
				Raise;
			EndTry;
		EndIf;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the DeleteObsoleteSetsInCatalog procedure.
Procedure DeleteRegisterRecordsForSet(Set, InformationRegisterName, SetFieldName)
	
	Query = New Query;
	Query.SetParameter("Set", Set);
	Query.Text =
	"SELECT TOP 1000
	|	SetsAccessKeys.AccessKey AS AccessKey
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS SetsAccessKeys
	|WHERE
	|	SetsAccessKeys.AccessGroupsSet = &Set";
	
	Query.Text = StrReplace(Query.Text, "AccessGroupSetsAccessKeys", InformationRegisterName);
	Query.Text = StrReplace(Query.Text, "AccessGroupsSet", SetFieldName);
	
	RecordSet = ServiceRecordSet(InformationRegisters[InformationRegisterName]);
	FullInformationRegisterName = "InformationRegister." + InformationRegisterName;
	
	While True Do
		DataExported = Query.Execute().Unload();
		If DataExported.Count() = 0 Then
			Break;
		EndIf;
		
		Lock = New DataLock;
		For Each String In DataExported Do
			LockItem = Lock.Add(FullInformationRegisterName);
			LockItem.SetValue(SetFieldName, Set);
			LockItem.SetValue("AccessKey", String.AccessKey);
		EndDo;
		
		BeginTransaction();
		Try
			Lock.Lock();
			For Each String In DataExported Do
				RecordSet.Filter[SetFieldName].Set(Set);
				RecordSet.Filter.AccessKey.Set(String.AccessKey);
				RecordSet.Write();
			EndDo;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
	EndDo;
	
EndProcedure

// For the UpdateItemsBatch and the UpdateAccessKeysOfDataItemsOnWrite procedures.
Procedure UpdateListDataItemsWithObsoleteAllowedKey(DataItems, UpdateParameters)
	
	If Not UpdateParameters.IsReferenceType Then
		Return;
	EndIf;
	
	Context = New Structure;
	Context.Insert("ObjectsRefs", DataItems.UnloadColumn("CurrentRef"));
	Context.Insert("ObjectsAccessKeysDetails", DataItems);
	
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	
	DataItems.Columns.Add("KeyProperties", New TypeDescription("Structure"));
	DataItems.FillValues(New Structure("AccessKey", AllowedAccessKey), "KeyProperties");
	
	WriteObjectsAccessKeys(UpdateParameters, Context);
	
	If UpdateParameters.Property("UpdateRightsToKeys")
	   AND UpdateParameters.UpdateRightsToKeys Then
		
		UpdateRightsToAllowedAccessKey(UpdateParameters.HasRightsChanges);
	EndIf;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteAllowedKey and CompleteAccessUpdate procedures.
Procedure UpdateRightsToAllowedAccessKey(HasChanges = False)
	
	UpdateAccessGroupsOfAllowedAccessKey( , HasChanges);
	
EndProcedure

// For the UpdateRightsToAllowedAccessKey procedure.
Procedure UpdateAccessGroupsOfAllowedAccessKey(AccessGroups = Undefined, HasChanges = False) Export
	
	SetPrivilegedMode(True);
	AllowedAccessKey = AccessManagementInternalCached.AllowedAccessKey();
	AllowedBlankSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet();
	
	Lock = New DataLock;
	
	// Access group update in the AccessGroupsAccessKeys register.
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AllowedAccessKey);
	GroupsQuery.Text = SelectionQueryTextOfAllowedKeyAccessGroupsDifferences();
	SetFilterCriterionInQuery(GroupsQuery, AccessGroups, "AccessGroups",
		"&AccessGroupFilterCriterion1:AccessGroups.Ref
		|&AccessGroupFilterCriterion2:OldData.AccessGroup");
	
	GroupsLockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AllowedAccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AllowedAccessKey);
	
	// Updating access group sets in the AccessGroupsSetsAccessKeys register.
	RightsRequestForAccessGroups = New Query;
	RightsRequestForAccessGroups.SetParameter("AccessKey", AllowedAccessKey);
	RightsRequestForAccessGroups.SetParameter("AllowedEmptySet", AllowedBlankSet);
	RightsRequestForAccessGroups.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
	
	LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
	LockItem.SetValue("AccessKey", AllowedAccessKey);
	RightsForAccessGroups = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	RightsForAccessGroups.Filter.AccessKey.Set(AllowedAccessKey);
	
	If Common.FileInfobase() Then
		LockItem = Lock.Add("Catalog.AccessGroupProfiles");
		LockItem.Mode = DataLockMode.Shared;
		LockItem = Lock.Add("Catalog.AccessGroups");
		LockItem.Mode = DataLockMode.Shared;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.Mode = DataLockMode.Shared;
	EndIf;
	
	BeginTransaction();
	Try
		Lock.Lock();
		
		GroupsRequestResult = GroupsQuery.Execute();
		UpdateDerivedRightsToAccessKey(GroupsRequestResult,
			GroupsRecordSet, "AccessGroup", AllowedAccessKey, HasChanges);
		
		RightsRequestForAccessGroupsResult = RightsRequestForAccessGroups.Execute();
		UpdateDerivedRightsToAccessKey(RightsRequestForAccessGroupsResult,
			RightsForAccessGroups, "AccessGroupsSet", AllowedAccessKey, HasChanges);
		
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAllowedAccessKeyGroups procedure.
Function SelectionQueryTextOfAllowedKeyAccessGroupsDifferences()
	
	Return
	"SELECT
	|	AllRows.AccessGroup AS AccessGroup,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		AccessGroups.Ref AS AccessGroup,
	|		TRUE AS Update,
	|		TRUE AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		Catalog.AccessGroups AS AccessGroups
	|			INNER JOIN Catalog.AccessGroupProfiles AS AccessGroupProfiles
	|			ON AccessGroups.Profile = AccessGroupProfiles.Ref
	|				AND (AccessGroups.Profile <> VALUE(Catalog.AccessGroupProfiles.Administrator))
	|				AND (NOT AccessGroups.DeletionMark)
	|				AND (NOT AccessGroupProfiles.DeletionMark)
	|				AND (&AccessGroupFilterCriterion1)
	|				AND (TRUE IN
	|					(SELECT TOP 1
	|						TRUE AS TrueValue
	|					FROM
	|						Catalog.AccessGroups.Users AS AccessGroupsMembers
	|					WHERE
	|						AccessGroupsMembers.Ref = AccessGroups.Ref))
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroup,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey
	|		AND &AccessGroupFilterCriterion2) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroup,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateItemsBatch procedure.
Procedure DeleteObsoleteListDataItems(DataItems, UpdateParameters)
	
	BatchSize = 100; // Delete N data items, 100 at a time.
	DataItemsBatch = Undefined;
	ItemsCount = DataItems.Count();
	
	If UpdateParameters.IsReferenceType Then
		SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
		Index = 0;
		While Index < ItemsCount Do
			If DataItemsBatch = Undefined Then
				DataItemsBatch = DataItems.Copy(New Array);
				Lock = New DataLock;
			EndIf;
			DataItem = DataItems[Index];
			FillPropertyValues(DataItemsBatch.Add(), DataItem);
			
			LockItem = Lock.Add("InformationRegister.AccessKeysForObjects");
			LockItem.SetValue("Object", DataItem.CurrentRef);
			
			Index = Index + 1;
			If DataItemsBatch.Count() < BatchSize AND Index < ItemsCount Then
				Continue;
			EndIf;
			
			ProcessedItemsCount = DataItemsBatch.Count();
			LockSet = False;
			BeginTransaction();
			Try
				Lock.Lock();
				LockSet = True;
				For Each String In DataItemsBatch Do
					SetOfOneRecord.Filter.Object.Set(String.CurrentRef);
					If Not UpdateParameters.ForExternalUsers
					   AND (UpdateParameters.DoNotWriteAccessKeysForUsersAndExternalUsers
					      Or String.Delete) Then
						SetOfOneRecord.Clear();
						SetOfOneRecord.Write();
					Else
						SetOfOneRecord.Read();
						If SetOfOneRecord.Count() > 0 Then
							If UpdateParameters.ForExternalUsers Then
								SetOfOneRecord[0].ExternalUsersAccessKey = Undefined;
							Else
								SetOfOneRecord[0].UsersAccessKey = Undefined;
							EndIf;
							If Not ValueIsFilled(SetOfOneRecord[0].ExternalUsersAccessKey)
							   AND Not ValueIsFilled(SetOfOneRecord[0].UsersAccessKey) Then
								SetOfOneRecord.Clear();
							EndIf;
							SetOfOneRecord.Write();
						EndIf;
					EndIf;
				EndDo;
				CommitTransaction();
			Except
				RollbackTransaction();
				If LockSet Then
					Raise;
				EndIf;
			EndTry;
			ProcessedItemsCount = 0;
			
			If ItemsProcessingAbortRequired(UpdateParameters) Then
				Break;
			EndIf;
		EndDo;
		
		Return;
	EndIf;
	
	If ValueIsFilled(UpdateParameters.SeparateKeysRegisterName)
	   AND UpdateParameters.LastUpdatedItem.DataKeyKind <> "ObsoleteCommonRegisterItems" Then
		
		RegisterName = UpdateParameters.SeparateKeysRegisterName;
	Else
		RegisterName = "AccessKeysForRegisters";
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[RegisterName]);
	
	If RegisterName = "AccessKeysForRegisters" Then
		SetOfOneRecord.Filter.Register.Set(UpdateParameters.ListID);
	EndIf;
	
	DimensionsNames = New Array;
	For Each Column In DataItems.Columns Do
		If StrStartsWith(Column.Name, "Field") Then
			DimensionsNames.Add(Column.Name);
		EndIf;
	EndDo;
	DimensionsFilter = Undefined;
	
	Index = 0;
	While Index < ItemsCount Do
		If DataItemsBatch = Undefined Then
			CheckRequired = Not UpdateParameters.DoNotWriteAccessKeys;
			DataItemsBatch = DataItems.Copy(New Array);
			Lock = New DataLock;
		EndIf;
		DataItem = DataItems[Index];
		FillPropertyValues(DataItemsBatch.Add(), DataItem);
		If CheckRequired AND Not DataItem.Delete Then
			CheckRequired = True;
		EndIf;
		
		LockItem = Lock.Add("InformationRegister." + RegisterName);
		If RegisterName = "AccessKeysForRegisters" Then
			LockItem.SetValue("Register", UpdateParameters.ListID);
		EndIf;
		For Each DimensionName In DimensionsNames Do
			LockItem.SetValue(DimensionName, DataItem[DimensionName]);
		EndDo;
		
		Index = Index + 1;
		If DataItemsBatch.Count() < BatchSize AND Index < ItemsCount Then
			Continue;
		EndIf;
		
		If CheckRequired Then
			LockItem = Lock.Add(UpdateParameters.List);
			LockItem.Mode = DataLockMode.Shared;
			Query = New Query;
			Query.Text = UpdateParameters.ObsoleteDataItemsCheckQueryText;
			Query.SetParameter("AccessKeysForRegisters", DataItemsBatch);
		EndIf;
		
		ProcessedItemsCount = DataItemsBatch.Count();
		LockSet = False;
		BeginTransaction();
		Try
			Lock.Lock();
			LockSet = True;
			If CheckRequired Then
				DataExported = Query.Execute().Unload();
				If DimensionsFilter = Undefined Then
					DimensionsToCheckNames = New Array;
					For Each Column In DataExported.Columns Do
						DimensionsToCheckNames.Add(Column.Name);
					EndDo;
					DimensionsFilter = New Structure(StrConcat(DimensionsToCheckNames, ","));
				EndIf;
			EndIf;
			For Each String In DataItemsBatch Do
				If CheckRequired AND Not String.Delete Then
					FillPropertyValues(DimensionsFilter, String);
					If DataExported.FindRows(DimensionsFilter).Count() = 0 Then
						Continue;
					EndIf;
				EndIf;
				For Each DimensionName In DimensionsNames Do
					SetOfOneRecord.Filter[DimensionName].Set(String[DimensionName]);
				EndDo;
				SetOfOneRecord.Write();
			EndDo;
			CommitTransaction();
		Except
			RollbackTransaction();
			If LockSet Then
				Raise;
			EndIf;
			ProcessedItemsCount = 0;
		EndTry;
		DataItemsBatch = Undefined;
		
		If ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsCount) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the ExecuteListAccessUpdate procedure.
Procedure DeleteObjectsOfInvalidTypesInAccessKeysToObjectsRegister()
	
	Query = New Query;
	Query.Text =
	"SELECT DISTINCT
	|	VALUETYPE(DataAccessKeys.Object) AS RefType
	|FROM
	|	InformationRegister.AccessKeysForObjects AS DataAccessKeys";
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
	AllowedTypes = AccessManagementInternalCached.AllowedObjectsRefsTypesDetails();
	Selection = Query.Execute().Select();
	
	Query.Text =
	"SELECT
	|	DataAccessKeys.Object AS Object
	|FROM
	|	InformationRegister.AccessKeysForObjects AS DataAccessKeys
	|WHERE
	|	VALUETYPE(DataAccessKeys.Object) = &Type";
	
	While Selection.Next() Do
		If Selection.RefType = Type("Undefined") Then
			RecordSet.Filter.Object.Set(Undefined);
			RecordSet.Write();
			Continue;
		ElsIf AllowedTypes.ContainsType(Selection.RefType) Then
			Continue;
		EndIf;
		Query.SetParameter("Type", Selection.RefType);
		Objects = Query.Execute().Unload().UnloadColumn("Object");
		For Each Object In Objects Do
			RecordSet.Filter.Object.Set(Object);
			RecordSet.Write();
		EndDo;
	EndDo;
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
	|WHERE
	|	AccessKeysForRegisters.Register = UNDEFINED";
	
	If Query.Execute().IsEmpty() Then
		Return;
	EndIf;
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessKeysForRegisters);
	RecordSet.Filter.Register.Set(Undefined);
	RecordSet.Write();
	
EndProcedure

// For the UpdateItemsBatch procedure.
Procedure UpdateListDataItemsWithObsoleteKeys(DataItems, UpdateParameters)
	
	BatchSize = 100; // Import N data items, 100 at a time.
	
	IsExistingCombinationsProcessing = Not UpdateParameters.IsReferenceType
		AND UpdateParameters.LastUpdatedItem.DataKeyKind = "ItemsWithObsoleteKeys";
	
	Index = 0;
	While Index < DataItems.Count() Do
		
		DataItemsBatch = DataItems.Copy(New Array);
		If Not UpdateParameters.IsReferenceType Then
			DataItemsBatch.Columns.Add("CurrentRef", New TypeDescription("Number"));
			DeletedDataItemsBatch = New Array;
		EndIf;
		
		While Index < DataItems.Count()
		   AND DataItemsBatch.Count() < BatchSize
		   AND (UpdateParameters.IsReferenceType
		      Or DeletedDataItemsBatch.Count() < BatchSize) Do
			
			DataItem = DataItems[Index];
			Index = Index + 1;
			
			If IsExistingCombinationsProcessing
			   AND IncorrectCombinationOfBasicFieldsValues(DataItem, UpdateParameters) Then
				
				DeletedDataItemsBatch.Add(DataItem);
				UpdateParameters.DeletedItemsComposition.Add(DataItem);
				Continue;
			EndIf;
			
			NewRow = DataItemsBatch.Add();
			FillPropertyValues(NewRow, DataItem);
			If Not UpdateParameters.IsReferenceType Then
				NewRow.CurrentRef = DataItemsBatch.IndexOf(NewRow) + 1;
			EndIf;
		EndDo;
		
		If IsExistingCombinationsProcessing
		   AND DeletedDataItemsBatch.Count() > 0 Then
			
			DeleteIncorrectBasicFieldsValuesCombinations(DeletedDataItemsBatch, UpdateParameters);
		EndIf;
		
		If DataItemsBatch.Count() > 0 Then
			UpdateAccessKeysOfListDataItemsBatch(DataItemsBatch, UpdateParameters);
		EndIf;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 0) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Function IncorrectCombinationOfBasicFieldsValues(DataItem, UpdateParameters)
	
	Number = 1;
	For Each FieldTypesStorage In UpdateParameters.BasicFields.UsedItemsTypes Do
		FieldTypes = FieldTypesStorage.Get();
		
		If Not FieldTypes.ContainsType(TypeOf(DataItem["Field" + Number]))
		   AND DataItem["Field" + Number] <> Undefined Then
			
			Return True;
		EndIf;
		
		Number = Number + 1;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateListDataItemsWithObsoleteKeys and UpdateAccessKeysOfDataItemsOnWrite function.
Procedure UpdateAccessKeysOfListDataItemsBatch(DataItemsBatch, UpdateParameters)
	
	IsReferenceType     = UpdateParameters.IsReferenceType;
	ListID = UpdateParameters.ListID;
	
	Context = New Structure;
	Context.Insert("DataItemsBatch", DataItemsBatch);
	
	DataItemsValuesQuery = New Query;
	DataItemsValuesQuery.Text = UpdateParameters.DataItemValueForAccessKeysQueryText;
	If IsReferenceType Then
		Context.Insert("ObjectsRefs", DataItemsBatch.UnloadColumn("CurrentRef"));
		DataItemsValuesQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
	Else
		DataItemsValuesQuery.SetParameter("RegisterID", ListID);
		DataItemsValuesQuery.SetParameter("BasicFieldsValues",  DataItemsBatch);
	EndIf;
	ItemsValuesQueryResults = DataItemsValuesQuery.ExecuteBatch();
	
	StringAccessKeysData = New Map;
	KeyTables = UpdateParameters.KeyTables;
	
	TablesRowsValues = New Map;
	ObjectsRowsValuesKeys = ObjectsRowsValuesKeys(ItemsValuesQueryResults,
		?(IsReferenceType, 0, 1), KeyTables, TablesRowsValues);
	
	RequiredAccessKeys         = New Array;
	RequiredAccessKeysHash    = New Array;
	ObjectsAccessKeysDetails = New Array;
	For Each DataItem In DataItemsBatch Do
		ValuesKeysDetails = ObjectsRowsValuesKeys.Get(DataItem.CurrentRef);
		StringForHash = StringForAccessKeyHash(ValuesKeysDetails, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties = Undefined Then
			Properties = New Structure("TablesValues, StringForHash, Hash, AccessKey, TablesColumnsValues");
			StringAccessKeysData.Insert(StringForHash, Properties);
			TablesValues = New Array;
			For Each TableName In KeyTables Do
				ValuesKey = ValuesKeysDetails.ValuesKeys[KeyTables.Find(TableName)];
				RowsValues = TablesRowsValues.Get(TableName).Get(ValuesKey);
				If RowsValues = Undefined Then
					RowsValues = New Array;
				EndIf;
				TablesValues.Add(New Structure("TableName, Table", TableName, RowsValues));
			EndDo;
			Properties.TablesValues = TablesValues;
			Properties.StringForHash = StringForHash;
			Properties.TablesColumnsValues = ValuesKeysDetails.TablesColumnsValues;
			Hashing = New DataHashing(HashFunction.CRC32);
			Hashing.Append(StringForHash);
			Properties.Hash = Hashing.HashSum;
			RequiredAccessKeys.Add(Properties);
			RequiredAccessKeysHash.Add(Properties.Hash);
		EndIf;
		ObjectsAccessKeysDetails.Add(
			New Structure("CurrentRef, KeyProperties", DataItem.CurrentRef, Properties));
	EndDo;
	Context.Insert("ObjectsAccessKeysDetails", ObjectsAccessKeysDetails);
	
	// Receiving data of existing access keys by hash of required access keys.
	KeysValuesQuery = New Query;
	KeysValuesQuery.Text = UpdateParameters.ValueFromAccessKeysInUseForComparisonQueryText;
	KeysValuesQuery.SetParameter("Hashes",   RequiredAccessKeysHash);
	KeysValuesQuery.SetParameter("List", ListID);
	KeysValuesQueryResults = KeysValuesQuery.ExecuteBatch();
	
	KeysRowsValuesKeys = ObjectsRowsValuesKeys(KeysValuesQueryResults,
		?(StrStartsWith(KeyTables[0], "Header"), 0, 1), KeyTables);
	
	For Each AccessKeyDetails In KeysRowsValuesKeys Do
		StringForHash = StringForAccessKeyHash(AccessKeyDetails.Value, KeyTables);
		Properties = StringAccessKeysData.Get(StringForHash);
		If Properties <> Undefined AND Properties.AccessKey = Undefined Then
			Properties.AccessKey = AccessKeyDetails.Key;
		EndIf;
	EndDo;
	
	// Creating missing access keys.
	NewKeysDetails = New Array;
	For Each KeyDetails In RequiredAccessKeys Do
		If KeyDetails.AccessKey <> Undefined Then
			Continue;
		EndIf;
		NewKeysDetails.Add(KeyDetails);
	EndDo;
	If NewKeysDetails.Count() > 0 Then
		UpdateAccessKeysRights(NewKeysDetails, UpdateParameters, True, Context);
		For Each KeyDetails In NewKeysDetails Do
			If ValueIsFilled(KeyDetails.AccessKeyObject.Ref) Then
				KeyDetails.AccessKey = KeyDetails.AccessKeyObject.Ref;
			EndIf;
		EndDo;
	EndIf;
	
	// Updating access keys of data items.
	If IsReferenceType Then
		WriteObjectsAccessKeys(UpdateParameters, Context);
	Else
		WriteRegistersAccessKeys(UpdateParameters, Context);
	EndIf;
	
	// Forced manual update of rights.
	If UpdateParameters.Property("UpdateRightsToKeys")
	   AND UpdateParameters.UpdateRightsToKeys Then
		
		ExistingAccessKeys = New Array;
		For Each KeyDetails In RequiredAccessKeys Do
			If NewKeysDetails.Find(KeyDetails) <> Undefined Then
				Continue;
			EndIf;
			ExistingAccessKeys.Add(KeyDetails.AccessKey);
		EndDo;
		If ExistingAccessKeys.Count() > 0 Then
			UpdateAccessKeysRights(ExistingAccessKeys, UpdateParameters);
		EndIf;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Procedure UpdateAccessKeysRights(KeysDetails, UpdateParameters, IsNewKeys = False, Context = Undefined)
	
	If UpdateParameters.Property("ProcessedItemsCount") Then
		ProcessedItemsCount = UpdateParameters.ProcessedItemsCount;
		UpdateParameters.ProcessedItemsCount = 0;
	EndIf;
	
	If IsNewKeys Then
		AccessKeys = New ValueTable;
		AccessKeys.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
		
		KeysValuesQuery = New Query;
		KeysValuesQuery.Text = UpdateParameters.ValueFromAllAccessKeysForComparisonQueryText;
		KeysValuesQuery.SetParameter("List", UpdateParameters.ListID);
		
		KeysExistenceQuery = New Query;
		KeysExistenceQuery.Text = UpdateParameters.KeysForComparisonExistenceQueryText;
		KeysExistenceQuery.SetParameter("List", UpdateParameters.ListID);
		
		NewKeysDetails = New Structure;
		NewKeysDetails.Insert("KeysDetails",            KeysDetails);
		NewKeysDetails.Insert("AccessKeys",              AccessKeys);
		NewKeysDetails.Insert("TablesValues",            New Structure);
		NewKeysDetails.Insert("KeysDetailsByRef",    New Map);
		NewKeysDetails.Insert("KeysValuesQuery",      KeysValuesQuery);
		NewKeysDetails.Insert("KeysExistenceQuery", KeysExistenceQuery);
		
		AllowedValuesTypes = AccessManagementInternalCached.AllowedAccessKeysValuesTypes();
		TablesValues = NewKeysDetails.TablesValues;
		
		For Each KeyTable In UpdateParameters.KeyTables Do
			ValueTable = New ValueTable;
			ValueTable.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
			TableFields = UpdateParameters.KeyTablesAttributes.Get(KeyTable);
			If StrStartsWith(KeyTable, "Header") AND KeyTable <> "Header0" Then
				ValueTable.Columns.Add("LineNumber", New TypeDescription("Number"));
			EndIf;
			For Each Field In TableFields Do
				ValueTable.Columns.Add(Field, AllowedValuesTypes);
			EndDo;
			TablesValues.Insert(KeyTable, ValueTable);
		EndDo;
		
		For Each KeyDetails In KeysDetails Do
			CheckAccessKeyValueType(KeyDetails, AllowedValuesTypes, UpdateParameters);
			PrepareNewAccessKey(KeyDetails, NewKeysDetails, UpdateParameters);
		EndDo;
		AccessKeysDetails = NewKeysDetails;
	Else
		AccessKeysDetails = New ValueTable;
		AccessKeysDetails.Columns.Add("Ref", New TypeDescription("CatalogRef.AccessKeys"));
		For Each AccessKeyRef In KeysDetails Do
			AccessKeysDetails.Add().Ref = AccessKeyRef;
		EndDo;
	EndIf;
	
	UpdateRightsOfListAccessKeysBatch(AccessKeysDetails, UpdateParameters, IsNewKeys);
	
	If UpdateParameters.Property("ProcessedItemsCount") Then
		UpdateParameters.ProcessedItemsCount = ProcessedItemsCount;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfListDataItemsBatch procedure.
Function StringForAccessKeyHash(ValuesKeysDetails, KeyTables)
	
	If ValuesKeysDetails = Undefined Then
		ValuesKeysDetails = New Structure(
			"ValuesKeys, TablesNames, TablesColumnsValues",
			New Array, New Array, New Array);
	EndIf;
	
	ValuesKeys = ValuesKeysDetails.ValuesKeys;
	TablesNames   = ValuesKeysDetails.TablesNames;
	
	If TablesNames.Count() <> KeyTables.Count() Then
		// The access key uses tabular sections and some blank ones.
		For Index = 0 To KeyTables.Count() - 1 Do
			
			If Index >= TablesNames.Count()
			 Or TablesNames[Index] <> KeyTables[Index] Then
				
				TablesNames.Insert(Index, KeyTables[Index]);
				ValuesKeys.Insert(Index, "6ab8db6a-4878-483a-b9d5-ef905ff1537e");
			EndIf;
		EndDo;
	EndIf;
	
	Return StrConcat(ValuesKeys);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteObjectsAccessKeys(UpdateParameters, Context)
	
	WriteOnlyChangedOnes = WriteOnlyChangedDataItemsAccessKeys();
	
	If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers
	 Or WriteOnlyChangedOnes Then
		
		CurrentKeysQuery = New Query;
		CurrentKeysQuery.Text =
		"SELECT
		|	AccessKeysForObjects.Object AS Object,
		|	AccessKeysForObjects.UsersAccessKey AS UsersAccessKey,
		|	AccessKeysForObjects.ExternalUsersAccessKey AS ExternalUsersAccessKey
		|FROM
		|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|WHERE
		|	AccessKeysForObjects.Object IN (&ObjectsRefs)";
		CurrentKeysQuery.SetParameter("ObjectsRefs", Context.ObjectsRefs);
	EndIf;
	
	If UpdateParameters.ForExternalUsers Then
		KeyToSaveAttributeName = "UsersAccessKey";
		KeyToUpdateAttributeName = "ExternalUsersAccessKey";
	Else
		KeyToSaveAttributeName = "ExternalUsersAccessKey";
		KeyToUpdateAttributeName = "UsersAccessKey";
	EndIf;
	
	SetOfOneRecord = ServiceRecordSet(InformationRegisters.AccessKeysForObjects);
	Record = SetOfOneRecord.Add();
	ObjectType = Metadata.InformationRegisters.AccessKeysForObjects.Dimensions.Object.Type;
	If Not ObjectType.ContainsType(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)) Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Невозможно обновить ключ доступа объекта ""%1"" типа ""%2"",
			           |так как этот тип не указан в определяемом типе ВладелецЗначенийКлючейДоступа.'; 
			           |en = 'Cannot update access key of the ""%1"" object of the ""%2"" type
			           |as this type is not specified in the AccessKeysValuesOwner defined type.'; 
			           |pl = 'Nie można zaktualizować klucza dostępu ""%1"" obiektu typu ""%2"", ponieważ ten typ
			           |nie jest określony w AccessKeysValuesOwner defined type.';
			           |de = 'Es ist nicht möglich, den Zugriffsschlüssel des Objekts ""%1"" des Typs ""%2"" zu aktualisieren,
			           |da dieser Typ im definierten Typ EigentümerDesZugriffsWerteSchlüssels nicht angegeben ist.';
			           |ro = 'Nu puteți actualiza cheia de acces a obiectului ""%1"" de tipul ""%2"",
			           |deoarece acest tip nu este indicat în tipul determinat ВладелецЗначенийКлючейДоступа.';
			           |tr = '""%1"" tür ""%2"" nesnenin erişim anahtarı güncellenemiyor, çünkü bu tür ErişimAnahtarıDeğerlerininSahibi 
			           |belirlenmiş türünde belirtilmedi.'; 
			           |es_ES = 'Es imposible actualizar una clave de acceso del objeto ""%1"" del tipo ""%2"",
			           |porque este tipo no se ha indicado en el tipo determinado AccessKeysValuesOwner.'"),
			String(Context.ObjectsAccessKeysDetails[0].CurrentRef),
			String(TypeOf(Context.ObjectsAccessKeysDetails[0].CurrentRef)),
			UpdateParameters.List);
		Raise ErrorText;
	EndIf;
	
	If WriteOnlyChangedOnes Then
		BeforeCurrentAccessKeysQuery(UpdateParameters);
		CurrentKeysBeforeLock = CurrentKeysQuery.Execute().Unload();
		AfterCurrentAccessKeysQuery(UpdateParameters);
	EndIf;
	
	ProcessedItemsCount = 0;
	ObjectsAccessKeysDetails = New Array;
	
	Lock = New DataLock;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		AccessKey = ObjectAccessKeyDetails.KeyProperties.AccessKey;
		If AccessKey = Undefined Then
			Break;
		EndIf;
		If WriteOnlyChangedOnes Then
			Row = CurrentKeysBeforeLock.Find(ObjectAccessKeyDetails.CurrentRef, "Object");
			If Row <> Undefined AND Row[KeyToUpdateAttributeName] = AccessKey Then
				ProcessedItemsCount = ProcessedItemsCount + 1;
				Continue;
			EndIf;
		EndIf;
		ObjectsAccessKeysDetails.Add(ObjectAccessKeyDetails);
		LockItem = Lock.Add("InformationRegister.AccessKeysForObjects");
		LockItem.SetValue("Object", ObjectAccessKeyDetails.CurrentRef);
	EndDo;
	
	If ObjectsAccessKeysDetails.Count() = 0 Then
		ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsCount);
		Return;
	EndIf;
	
	If Common.FileInfobase() Then
		Lock.Add("InformationRegister.DataAccessKeysUpdate");
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(UpdateParameters);
		Lock.Lock();
		AfterDataLock(UpdateParameters);
		
		If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers Then
			BeforeCurrentAccessKeysQuery(UpdateParameters);
			CurrentKeys = CurrentKeysQuery.Execute().Unload();
			AfterCurrentAccessKeysQuery(UpdateParameters);
		EndIf;
		
		BeforeWriteRows(UpdateParameters);
		ObjectsRefs = New Array;
		For Each ObjectAccessKeyDetails In ObjectsAccessKeysDetails Do
			ObjectsRefs.Add(ObjectAccessKeyDetails.CurrentRef);
			SetOfOneRecord.Filter.Object.Set(ObjectAccessKeyDetails.CurrentRef);
			Record.Object = ObjectAccessKeyDetails.CurrentRef;
			Record[KeyToUpdateAttributeName] = ObjectAccessKeyDetails.KeyProperties.AccessKey;
			
			If UpdateParameters.WriteAccessKeysForUsersAndExternalUsers Then
				Row = CurrentKeys.Find(ObjectAccessKeyDetails.CurrentRef, "Object");
				If Row <> Undefined Then
					Record[KeyToSaveAttributeName] = Row[KeyToSaveAttributeName];
				EndIf;
			EndIf;
			SetOfOneRecord.Write();
		EndDo;
		AfterWriteRows(UpdateParameters, ObjectsAccessKeysDetails.Count());
		
		ListsToUpdate = New Structure("ListsNames, ForExternalUsers",
			UpdateParameters.DependentListsByAccessKeys,
			UpdateParameters.ForExternalUsers);
		
		BeforePlanUpdate(UpdateParameters);
		ScheduleUpdateOfObsoleteAccessKeys(ListsToUpdate,
			UpdateParameters.TransactionID,
			"WriteObjectsAccessKeys",
			?(ObjectsRefs.Count() > 25, Undefined,
				New Structure("ByAccessKeys", ObjectsRefs)),
			UpdateParameters.Property("IsBackgroundAccessUpdate"));
		AfterPlanUpdate(UpdateParameters);
		
		BeforeCommitTransaction(UpdateParameters);
		CommitTransaction();
		AfterCommitTransaction(UpdateParameters); // APK:330 is for performance analysis only.
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	ProcessedItemsCount = ProcessedItemsCount + ObjectsAccessKeysDetails.Count();
	If ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsCount) Then
		Return;
	EndIf;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure WriteRegistersAccessKeys(UpdateParameters, Context)
	
	If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = UpdateParameters.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	Record = SetOfOneRecord.Add();
	
	DataItemsBatch = Context.DataItemsBatch;
	BlankBasicFieldsValues = AccessManagementInternalCached.BlankBasicFieldsValues(
		UpdateParameters.BasicFields.MaxCount);
	
	WriteOnlyChangedOnes = WriteOnlyChangedDataItemsAccessKeys();
	If WriteOnlyChangedOnes Then
		Query = New Query;
		Query.SetParameter("RegisterID", UpdateParameters.ListID);
		QueryText = UpdateParameters.CurrentRegisterAccessKeysQueryText;
		PackageTexts = New Array;
		RowNumber = 1;
		For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
			CurrentNumber = "_" + Format(RowNumber, "NG=");
			PackageTexts.Add(StrReplace(QueryText, "_%1", CurrentNumber));
			For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
				FieldName = "Field" + FieldNumber;
				DataItem = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
				Query.SetParameter(FieldName + CurrentNumber, DataItem[FieldName]);
			EndDo;
			RowNumber = RowNumber + 1;
		EndDo;
		Query.Text = StrConcat(PackageTexts, Common.QueryBatchSeparator());
		BeforeCurrentAccessKeysQuery(UpdateParameters);
		If PackageTexts.Count() > 1 Then
			QueryResults = Query.ExecuteBatch();
		Else
			QueryResults = New Array;
			QueryResults.Add(Query.Execute());
		EndIf;
		AfterCurrentAccessKeysQuery(UpdateParameters);
	EndIf;
	
	ProcessedItemsCount = 0;
	ObjectsAccessKeysDetails = New Array;
	
	ResultIndex = -1;
	Lock = New DataLock;
	For Each ObjectAccessKeyDetails In Context.ObjectsAccessKeysDetails Do
		ResultIndex = ResultIndex + 1;
		AccessKey = ObjectAccessKeyDetails.KeyProperties.AccessKey;
		If AccessKey = Undefined Then
			Break;
		EndIf;
		If WriteOnlyChangedOnes Then
			QueryResult = QueryResults[ResultIndex];
			If Not QueryResult.IsEmpty() Then
				DataExported = QueryResult.Unload();
				If DataExported.Count() = 1 AND DataExported[0].AccessKey = AccessKey Then
					ProcessedItemsCount = ProcessedItemsCount + 1;
					Continue;
				EndIf;
			EndIf;
		EndIf;
		ObjectsAccessKeysDetails.Add(ObjectAccessKeyDetails);
		LockItem = Lock.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", UpdateParameters.ListID);
		EndIf;
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		DataItem = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
		For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, DataItem[FieldName]);
		EndDo;
	EndDo;
	
	If ObjectsAccessKeysDetails.Count() = 0 Then
		ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsCount);
		Return;
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(UpdateParameters);
		Lock.Lock();
		AfterDataLock(UpdateParameters);
		
		BeforeWriteRows(UpdateParameters);
		For Each ObjectAccessKeyDetails In ObjectsAccessKeysDetails Do
			If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(UpdateParameters.ListID);
				Record.Register = UpdateParameters.ListID;
			EndIf;
			SetOfOneRecord.Filter.ForExternalUsers.Set(UpdateParameters.ForExternalUsers);
			Record.ForExternalUsers = UpdateParameters.ForExternalUsers;
			
			DataItem = DataItemsBatch.Find(ObjectAccessKeyDetails.CurrentRef, "CurrentRef");
			FillPropertyValues(Record, BlankBasicFieldsValues);
			For FieldNumber = 1 To UpdateParameters.BasicFields.Used.Count() Do
				FieldName = "Field" + FieldNumber;
				If DataItem[FieldName] = Undefined Then
					SetOfOneRecord.Filter[FieldName].Value = Undefined;
					SetOfOneRecord.Filter[FieldName].Use = True;
				Else
					SetOfOneRecord.Filter[FieldName].Set(DataItem[FieldName]);
				EndIf;
				Record[FieldName] = DataItem[FieldName];
			EndDo;
			
			Record.AccessKey = ObjectAccessKeyDetails.KeyProperties.AccessKey;
			SetOfOneRecord.Write();
		EndDo;
		AfterWriteRows(UpdateParameters, ObjectsAccessKeysDetails.Count());
		
		BeforeCommitTransaction(UpdateParameters);
		CommitTransaction();
		AfterCommitTransaction(UpdateParameters); // APK:330 is for performance analysis only.
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	ProcessedItemsCount = ProcessedItemsCount + ObjectsAccessKeysDetails.Count();
	If ItemsProcessingAbortRequired(UpdateParameters, ProcessedItemsCount) Then
		Return;
	EndIf;
	
EndProcedure

// For the UpdateListDataItemsWithObsoleteKeys function.
Procedure DeleteIncorrectBasicFieldsValuesCombinations(DataItemsBatch, UpdateParameters)
	
	If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
		KeysRegisterName = "AccessKeysForRegisters";
	Else
		KeysRegisterName = UpdateParameters.SeparateKeysRegisterName;
	EndIf;
	SetOfOneRecord = ServiceRecordSet(InformationRegisters[KeysRegisterName]);
	FieldsToUseCount = UpdateParameters.BasicFields.Used.Count();
	MaxFieldsCount = UpdateParameters.BasicFields.MaxCount;
	
	Lock = New DataLock;
	For Each DataItem In DataItemsBatch Do
		LockItem = Lock.Add("InformationRegister." + KeysRegisterName);
		If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
			LockItem.SetValue("Register", UpdateParameters.ListID);
		EndIf;
		LockItem.SetValue("ForExternalUsers", UpdateParameters.ForExternalUsers);
		For FieldNumber = 1 To MaxFieldsCount Do
			FieldName = "Field" + FieldNumber;
			LockItem.SetValue(FieldName, ?(FieldNumber > FieldsToUseCount,
				Enums.AdditionalAccessValues.Null, DataItem[FieldName]));
		EndDo;
	EndDo;
	
	BeginTransaction();
	Try
		Lock.Lock();
		For Each DataItem In DataItemsBatch Do
			If Not ValueIsFilled(UpdateParameters.SeparateKeysRegisterName) Then
				SetOfOneRecord.Filter.Register.Set(UpdateParameters.ListID);
			EndIf;
			For FieldNumber = 1 To MaxFieldsCount Do
				FieldName = "Field" + FieldNumber;
				SetOfOneRecord.Filter[FieldName].Set(?(FieldNumber > FieldsToUseCount,
					Enums.AdditionalAccessValues.Null, DataItem[FieldName]));
			EndDo;
			SetOfOneRecord.Write();
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Function ObjectsRowsValuesKeys(QueryResults, Index, KeyTables, TablesRowsValues = Undefined)
	
	ObjectsRowsValuesKeys = New Map;
	
	If TablesRowsValues = Undefined Then
		TablesRowsValues = New Map;
	EndIf;
	
	For Each AccessKeyTableName In KeyTables Do
		TableRowsValues = TablesRowsValues.Get(AccessKeyTableName);
		If TableRowsValues = Undefined Then
			TableRowsValues = New Map;
			TablesRowsValues.Insert(AccessKeyTableName, TableRowsValues);
		EndIf;
		Tree = QueryResults[Index].Unload(QueryResultIteration.ByGroups);
		Index = Index + 1;
		For Each Row In Tree.Rows Do
			TableColumnsValues = New Array;
			For Each Column In Tree.Columns Do
				If StrStartsWith(Column.Name, "Value") Then
					TableColumnsValues.Add(Row.Rows.UnloadColumn(Column.Name));
				EndIf;
			EndDo;
			RowsValuesKey = DataStringForHashing(TableColumnsValues);
			If TableRowsValues.Get(RowsValuesKey) = Undefined Then
				TableRowsValues.Insert(RowsValuesKey, Row.Rows);
			EndIf;
			ValuesKeysDetails = ObjectsRowsValuesKeys.Get(Row.CurrentRef);
			If ValuesKeysDetails = Undefined Then
				ValuesKeysDetails = New Structure(
					"ValuesKeys, TablesNames, TablesColumnsValues",
					New Array, New Array, New Array);
				ObjectsRowsValuesKeys.Insert(Row.CurrentRef, ValuesKeysDetails);
			EndIf;
			ValuesKeysDetails.TablesNames.Add(AccessKeyTableName);
			ValuesKeysDetails.ValuesKeys.Add(RowsValuesKey);
			ValuesKeysDetails.TablesColumnsValues.Add(TableColumnsValues);
		EndDo;
	EndDo;
	
	Return ObjectsRowsValuesKeys;
	
EndFunction

// For the ObjectsRowsValuesKeys function and other.
Function DataStringForHashing(Data)
	
	// Returns a data string for further hashing, for example, string description of references stored 
	// in the database, considering types by internal IDs, which ensures that the hash sum remains 
	// unchanged upon changing names of tables and attributes, and ensures that the data hash 
	// corresponds to the data stored in the database.
	// 
	//
	// This allows you to avoid excessive mass recreation of access keys with subsequent recalculation 
	// of users and access groups for the recreated access keys.
	
	Return ValueToStringInternal(Data);
	
EndFunction

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure CheckAccessKeyValueType(KeyDetails, AllowedValuesTypes, UpdateParameters)
	
	TablesColumnsValues = KeyDetails.TablesColumnsValues;
	
	For Each TableColumnsValues In TablesColumnsValues Do
		For Each TableColumnValues In TableColumnsValues Do
			For Each Value In TableColumnValues Do
				If Not AllowedValuesTypes.ContainsType(TypeOf(Value)) Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Невозможно сохранить значение ""%1"" типа ""%2""
						           |при обновлении ключей доступа списка ""%3"",
						           |так как этот тип не указан в определяемом типе ЗначениеДоступа.'; 
						           |en = 'Cannot save the ""%1"" value of the ""%2"" type
						           |while updating access keys of the ""%3"" list
						           |as this type is not specified in the AccessValue defined type.'; 
						           |pl = 'Nie można zapisać wartość ""%1"" jak ""%2""
						           |w przypadku aktualizacji kluczy dostępu listy""%3"",
						           |ponieważ ten typ nie znajduje się w określonym typie ЗначениеДоступа.';
						           |de = 'Es ist nicht möglich, den Wert von ""%1"" des Typs ""%2""
						           |bei der Aktualisierung der Zugriffsschlüssel der Liste ""%3"" zu speichern,
						           |da dieser Typ im definierten Typ ZugriffsWert nicht angegeben ist.';
						           |ro = 'Nu puteți salva valoarea ""%1"" de tipul ""%2"",
						           |la actualizarea cheilor de acces ale listei ""%3"",
						           |deoarece acest tip nu este indicat în tipul determinat ЗначениеДоступа.';
						           |tr = 'Bu tür belirtilen ErişimDeğeri türünde listelenmediğinden "
" liste erişim anahtarlarını güncelleştirdiğinizde %3 ""%1"" türü ""%2"" değeri 
						           |kaydedilemiyor.'; 
						           |es_ES = 'Es imposible guardar un valor ""%1"" del tipo ""%2"",
						           |al actualizar las claves de acceso de la lista ""%3"",
						           |porque este tipo no está indicado en el tipo determinado AccessValue.'"),
						String(Value),
						String(TypeOf(Value)),
						UpdateParameters.List);
					Raise ErrorText;
				EndIf;
			EndDo;
		EndDo;
	EndDo;
	
EndProcedure

// For the UpdateAccessKeysOfDataItemsBatch procedure.
Procedure PrepareNewAccessKey(KeyDetails, NewKeysDetails, UpdateParameters)
	
	NewRef = Catalogs.AccessKeys.GetRef();
	NewKey = ServiceItem(Catalogs.AccessKeys);
	
	NewKey.SetNewObjectRef(NewRef);
	NewKey.Description            = String(NewRef.UUID());
	NewKey.List                  = UpdateParameters.ListID;
	NewKey.FieldsComposition             = UpdateParameters.FieldsComposition;
	NewKey.ForExternalUsers = UpdateParameters.ForExternalUsers;
	NewKey.Hash                     = KeyDetails.Hash;
	
	AllTablesValues = NewKeysDetails.TablesValues;
	
	For Each TableValues In KeyDetails.TablesValues Do
		AllTableValues = AllTablesValues[TableValues.TableName];
		
		If StrStartsWith(TableValues.TableName, "Header") Then
			NewString = AllTableValues.Add();
			FillPropertyValues(NewString, TableValues.Table[0]);
			NewString.Ref = NewRef;
			
			If StrEndsWith(TableValues.TableName, "0") Then
				FillPropertyValues(NewKey, TableValues.Table[0],, "Parent");
			Else
				RowNumber = Number(Right(TableValues.TableName, 1));
				NewKey.Header.Add();
				FillPropertyValues(NewKey.Header[RowNumber - 1], TableValues.Table[0]);
				NewString.LineNumber = RowNumber;
			EndIf;
		Else
			For Each String In TableValues.Table Do
				FillPropertyValues(NewKey[TableValues.TableName].Add(), String);
				NewString = AllTableValues.Add();
				FillPropertyValues(NewString, String);
				NewString.Ref = NewRef;
			EndDo;
		EndIf;
	EndDo;
	
	KeyDetails.Insert("AccessKeyObject", NewKey);
	NewKeysDetails.AccessKeys.Add().Ref = NewRef;
	NewKeysDetails.KeysDetailsByRef.Insert(NewRef, KeyDetails);
	
EndProcedure

// For the UpdateItemsBatch and UpdateRightsToAccessKeys procedures.
Procedure UpdateRightsOfListAccessKeysBatch(AccessKeysDetails, UpdateParameters, IsNewKeys = False)
	
	If Not UpdateParameters.Property("Cache") Then
		UpdateParameters.Insert("Cache", New Structure);
	EndIf;
	
	Query = New Query;
	Query.Text = UpdateParameters.ValueFromAccessKeysForRightsCalculationQueryText;
	TableNumber = 0;
	
	If IsNewKeys Then
		QueryTexts = New Array;
		KeyTablesAttributes = UpdateParameters.KeyTablesAttributes;
		Template =
		"SELECT
		|	&Fields
		|INTO Table
		|FROM
		|	&Table AS Table";
		For Each KeyTable In UpdateParameters.KeyTables Do
			FieldLIneNumber = "";
			If StrStartsWith(KeyTable, "Header") Then
				If StrEndsWith(KeyTable, "0") Then
					TempTableName = "CatalogAccessKeys";
					Query.Text = StrReplace(Query.Text,
						"@Catalog.AccessKeys ", TempTableName + " ");
				Else
					TempTableName = "CatalogAccessKeys" + KeyTable;
					FieldLIneNumber = "LineNumber, ";
					Query.Text = StrReplace(Query.Text,
						"@Catalog.AccessKeys.Header AS " + KeyTable,
						TempTableName + " AS " + KeyTable);
				EndIf;
			Else
				TempTableName = "CatalogAccessKeys" + KeyTable;
				Query.Text = StrReplace(Query.Text,
					"@Catalog.AccessKeys." + KeyTable, TempTableName);
			EndIf;
			QueryText = StrReplace(Template, "Table", TempTableName);
			TableAttributes = KeyTablesAttributes.Get(KeyTable);
			Fields = "Ref, " + FieldLIneNumber + StrConcat(TableAttributes, ", ");
			QueryText = StrReplace(QueryText, "&Fields", Fields);
			QueryTexts.Add(QueryText);
			Query.SetParameter(TempTableName, AccessKeysDetails.TablesValues[KeyTable]);
			TableNumber = TableNumber + 1;
		EndDo;
		QueryTexts.Add(Query.Text);
		Query.Text = StrConcat(QueryTexts, Common.QueryBatchSeparator());
		Query.SetParameter("AccessKeys", AccessKeysDetails.AccessKeys);
	Else
		Query.Text = StrReplace(Query.Text, "@Catalog.AccessKeys", "Catalog.AccessKeys");
		Query.SetParameter("AccessKeys", AccessKeysDetails);
	EndIf;
	
	Query.SetParameter("RightSettingsTableID",
		UpdateParameters.RightSettingsTableID);
	
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	QueryResults = Query.ExecuteBatch();
	
	UpdateParameters.Insert("UserType", ?(UpdateParameters.ForExternalUsers,
		Type("CatalogRef.ExternalUsers"), Type("CatalogRef.Users")));
	
	UpdateParameters.Insert("UserGroupType", ?(UpdateParameters.ForExternalUsers,
		Type("CatalogRef.ExternalUsersGroups"), Type("CatalogRef.UserGroups")));
	
	UpdateParameters.Insert("AccessGroupType",    Type("CatalogRef.AccessGroups"));
	UpdateParameters.Insert("BlankAccessGroup", Catalogs.AccessGroups.EmptyRef());
	
	KeysTablesValues = New Map;
	For Each KeyTable In UpdateParameters.KeyTables Do
		TableNumber = TableNumber + 1;
		KeysTablesValues.Insert(KeyTable,
			QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups));
	EndDo;
	FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, UpdateParameters);
	FillRightsByRightsSettingsOwners(QueryResults, TableNumber, UpdateParameters);
	
	FillListAccessGroupsRightsAndMembers(UpdateParameters);
	FillAccessGroupsValuesToCalculateRights(UpdateParameters);
	
	FirstTableValues = KeysTablesValues.Get(UpdateParameters.KeyTables[0]);
	LastKeyIndex = FirstTableValues.Rows.Count() - 1;
	
	For KeyIndex = 0 To LastKeyIndex Do
		KeyTablesValues = New Structure;
		For Each KeyTable In UpdateParameters.KeyTables Do
			TableValues = KeysTablesValues.Get(KeyTable).Rows[KeyIndex].Rows;
			If StrStartsWith(KeyTable, "Header") Then
				TableValues = TableValues[0];
			EndIf;
			KeyTablesValues.Insert(KeyTable, TableValues);
		EndDo;
		AccessKey = FirstTableValues.Rows[KeyIndex].Ref;
		
		RightsToKey = RightsToListAccessKey(KeyTablesValues, UpdateParameters);
		UpdateRightsToListAccessKey(AccessKey, RightsToKey,
			?(IsNewKeys, AccessKeysDetails, Undefined), UpdateParameters);
		
		If ItemsProcessingAbortRequired(UpdateParameters) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateItemsBatch procedure.
Procedure ProcessObsoleteListAccessKeys(DataItems, UpdateParameters)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|WHERE
	|	AccessGroupsAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
	|WHERE
	|	AccessGroupSetsAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.AccessKey = &AccessKey
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT TOP 1
	|	TRUE AS Field1
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.AccessKey = &AccessKey";
	
	KeyUsageQuery = New Query;
	KeyUsageQuery.Text =
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.Ref = &Ref
	|	AND AccessKeys.NotUsedSince = DATETIME(1, 1, 1)";
	
	KeyAccessGroupsRecordSet         = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	KeyAccessGroupsSetsRecordSet  = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	KeyUsersRecordSet        = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
	KeyExternalUsersRecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
	
	IsClearAllKeys = UpdateParameters.DoNotWriteAccessKeys
		Or UpdateParameters.WriteAlwaysAllowedAccessKey;
	
	For Each String In DataItems Do
		KeyUsageQuery.SetParameter("Ref", String.Ref);
		If Not IsClearAllKeys AND String.Used AND Not KeyUsageQuery.Execute().IsEmpty() Then
			If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
				Break;
			EndIf;
			Continue;
		EndIf;
		
		Lock = New DataLock;
		If Not IsClearAllKeys Then
			LockItem = Lock.Add("Catalog.AccessKeys");
			LockItem.SetValue("List",      String.List);
			LockItem.SetValue("Hash",         String.Hash);
			LockItem.SetValue("FieldsComposition", String.FieldsComposition);
			LockItem.SetValue("ForExternalUsers",
				UpdateParameters.ForExternalUsers);
		EndIf;
		LockItem = Lock.Add("Catalog.AccessKeys");
		LockItem.SetValue("Ref", String.Ref);
		LockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
		LockItem.SetValue("AccessKey", String.Ref);
		LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
		LockItem.SetValue("AccessKey", String.Ref);
		LockItem = Lock.Add("InformationRegister.UsersAccessKeys");
		LockItem.SetValue("AccessKey", String.Ref);
		LockItem = Lock.Add("InformationRegister.ExternalUsersAccessKeys");
		LockItem.SetValue("AccessKey", String.Ref);
		
		BeginTransaction();
		Try
			Lock.Lock();
			Object = ServiceItem(Undefined, String.Ref);
			DeleteKey = False;
			If IsClearAllKeys Or Object = Undefined Then
				DeleteKey = True;
			ElsIf String.Used Then
				Object.NotUsedSince = '00010101';
			ElsIf Not String.Delete Then
				Object.NotUsedSince = CurrentSessionDate();
			ElsIf ValueIsFilled(Object.NotUsedSince) Then
				DeleteKey = True;
			EndIf;
			If DeleteKey Then
				Query.SetParameter("AccessKey", String.Ref);
				QueryResults = Query.ExecuteBatch();
				If Not QueryResults[0].IsEmpty() Then
					KeyAccessGroupsRecordSet.Filter.AccessKey.Set(String.Ref);
					KeyAccessGroupsRecordSet.Write();
				EndIf;
				If Not QueryResults[1].IsEmpty() Then
					KeyAccessGroupsSetsRecordSet.Filter.AccessKey.Set(String.Ref);
					KeyAccessGroupsSetsRecordSet.Write();
				EndIf;
				If Not QueryResults[2].IsEmpty() Then
					KeyUsersRecordSet.Filter.AccessKey.Set(String.Ref);
					KeyUsersRecordSet.Write();
				EndIf;
				If Not QueryResults[3].IsEmpty() Then
					KeyExternalUsersRecordSet.Filter.AccessKey.Set(String.Ref);
					KeyExternalUsersRecordSet.Write();
				EndIf;
			EndIf;
			If Object <> Undefined Then
				If DeleteKey Then
					Object.Delete();
				ElsIf Object.Modified() Then
					Object.Write();
				EndIf;
			EndIf;
			CommitTransaction();
		Except
			RollbackTransaction();
			Raise;
		EndTry;
		
		If ItemsProcessingAbortRequired(UpdateParameters, 1) Then
			Break;
		EndIf;
	EndDo;
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillListAccessGroupsRightsAndMembers(UpdateParameters)
	
	Query = New Query;
	Query.SetParameter("Table", UpdateParameters.ListID);
	Query.Text =
	"SELECT
	|	Profiles.Ref AS Profile,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN TRUE
	|			ELSE VALUETYPE(ProfilesPurpose.UsersType) = TYPE(Catalog.Users)
	|		END) AS ForUsers,
	|	MAX(CASE
	|			WHEN ProfilesPurpose.UsersType IS NULL
	|				THEN FALSE
	|			ELSE ProfilesPurpose.UsersType <> UNDEFINED
	|					AND VALUETYPE(ProfilesPurpose.UsersType) <> TYPE(Catalog.Users)
	|		END) AS ForExternalUsers
	|INTO ProfilesPurpose
	|FROM
	|	Catalog.AccessGroupProfiles AS Profiles
	|		LEFT JOIN Catalog.AccessGroupProfiles.Purpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Ref = Profiles.Ref)
	|
	|GROUP BY
	|	Profiles.Ref
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupsTables.AccessGroup AS AccessGroup,
	|	AccessGroupsTables.Update AS Update,
	|	AccessGroupsTables.Insert AS Insert,
	|	AccessGroupsTables.ReadWithoutRestriction AS ReadWithoutRestriction,
	|	AccessGroupsTables.UpdateWithoutRestriction AS UpdateWithoutRestriction,
	|	AccessGroupsTables.InsertWithoutRestriction AS InsertWithoutRestriction
	|FROM
	|	InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|		INNER JOIN Catalog.AccessGroups AS AccessGroups
	|		ON (AccessGroupsTables.Table = &Table)
	|			AND (AccessGroups.Ref = AccessGroupsTables.AccessGroup)
	|		INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|		ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|			AND (ProfilesPurpose.ForUsers)";
	
	MembersQueryText =
	"SELECT DISTINCT
	|	AccessGroups.Ref AS Ref
	|INTO AccessGroups
	|FROM
	|	(SELECT
	|		AccessGroupsTables.AccessGroup AS Ref
	|	FROM
	|		InformationRegister.AccessGroupsTables AS AccessGroupsTables
	|			INNER JOIN Catalog.AccessGroups AS AccessGroups
	|			ON (AccessGroupsTables.Table = &Table)
	|				AND (AccessGroups.Ref = AccessGroupsTables.AccessGroup)
	|			INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|			ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|				AND (ProfilesPurpose.ForUsers)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		AccessGroups.Ref
	|	FROM
	|		Catalog.AccessGroups AS AccessGroups
	|			INNER JOIN ProfilesPurpose AS ProfilesPurpose
	|			ON (ProfilesPurpose.Profile = AccessGroups.Profile)
	|				AND (ProfilesPurpose.ForUsers)
	|				AND (AccessGroups.Ref IN (&AdditionalAccessGroups))) AS AccessGroups
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	UserGroups.Ref AS Ref
	|INTO UserGroups
	|FROM
	|	(SELECT DISTINCT
	|		AccessGroupUsers.User AS Ref
	|	FROM
	|		Catalog.AccessGroups.Users AS AccessGroupUsers
	|			INNER JOIN AccessGroups AS AccessGroups
	|			ON (AccessGroups.Ref = AccessGroupUsers.Ref)
	|	WHERE
	|		VALUETYPE(AccessGroupUsers.User) = TYPE(Catalog.UserGroups)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		UserGroups.Ref
	|	FROM
	|		Catalog.UserGroups AS UserGroups
	|	WHERE
	|		UserGroups.Ref IN(&AdditionalUserGroups)) AS UserGroups
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	UserGroupCompositions.UsersGroup AS UsersGroup,
	|	UserGroupCompositions.User AS User
	|FROM
	|	InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|		INNER JOIN UserGroups AS UserGroups
	|		ON (UserGroups.Ref = UserGroupCompositions.UsersGroup)
	|			AND (UserGroupCompositions.Used)
	|		INNER JOIN Catalog.Users AS Users
	|		ON (Users.Ref = UserGroupCompositions.User)
	|			AND (Users.IBUserID <> &BlankUUID)
	|TOTALS BY
	|	UsersGroup
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	AccessGroupUsers.Ref AS AccessGroup,
	|	AccessGroupUsers.User AS Member
	|FROM
	|	Catalog.AccessGroups.Users AS AccessGroupUsers
	|		INNER JOIN AccessGroups AS AccessGroups
	|		ON (AccessGroups.Ref = AccessGroupUsers.Ref)
	|			AND (TRUE IN
	|				(SELECT TOP 1
	|					TRUE
	|				FROM
	|					InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						INNER JOIN Catalog.Users AS Users
	|						ON
	|							UserGroupCompositions.UsersGroup = AccessGroupUsers.User
	|								AND UserGroupCompositions.Used
	|								AND Users.Ref = UserGroupCompositions.User
	|								AND Users.IBUserID <> &BlankUUID))
	|TOTALS BY
	|	AccessGroup";
	
	If UpdateParameters.CalculateUserRights Then
		If UpdateParameters.ForExternalUsers Then
			MembersQueryText = StrReplace(MembersQueryText,
				"Catalog.Users", "Catalog.ExternalUsers");
			MembersQueryText = StrReplace(MembersQueryText,
				"Catalog.UserGroups", "Catalog.ExternalUsersGroups");
		EndIf;
		
		Query.Text = Query.Text + Common.QueryBatchSeparator() + MembersQueryText;
		Query.SetParameter("BlankUUID",
			CommonClientServer.BlankUUID());
		
		AdditionalAccessGroups       = New Array;
		AdditionalUserGroups = New Array;
		Query.SetParameter("AdditionalAccessGroups",       AdditionalAccessGroups);
		Query.SetParameter("AdditionalUserGroups", AdditionalUserGroups);
		
		AddedAccessGroups          = New Map;
		AddedUserGroups    = New Map;
		AccessGroupType       = UpdateParameters.AccessGroupType;
		UserGroupType = UpdateParameters.UserGroupType;
		
		For Each KeyAndValue In UpdateParameters.RightsToLeadingAccessKeys Do
			For Each RightsDetails In KeyAndValue.Value Do
				If TypeOf(RightsDetails.Key) = AccessGroupType Then
					If AddedAccessGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedAccessGroups.Insert(RightsDetails.Key, True);
						AdditionalAccessGroups.Add(RightsDetails.Key);
					EndIf;
				ElsIf TypeOf(RightsDetails.Key) = UserGroupType Then
					If AddedUserGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedUserGroups.Insert(RightsDetails.Key, True);
						AdditionalUserGroups.Add(RightsDetails.Key);
					EndIf;
				EndIf;
			EndDo;
		EndDo;
		For Each KeyAndValue In UpdateParameters.RightsByRightsSettingsOwners Do
			For Each RightsDetails In KeyAndValue.Value Do
				If TypeOf(RightsDetails.Key) = UserGroupType Then
					If AddedUserGroups.Get(RightsDetails.Key) <> Undefined Then
						AddedUserGroups.Insert(RightsDetails.Key, True);
						AdditionalUserGroups.Add(RightsDetails.Key);
					EndIf;
				EndIf;
			EndDo;
		EndDo;
	EndIf;
	
	If UpdateParameters.ForExternalUsers Then
		Query.Text = StrReplace(Query.Text,
			"ProfilesPurpose.ForUsers", "ProfilesPurpose.ForExternalUsers");
	EndIf;
	
	QueryResults = Query.ExecuteBatch();
	
	Selection = QueryResults[1].Select();
	ListAccessGroupsRights = New Map;
	
	While Selection.Next() Do
		AccessGroupRights = New Structure;
		AccessGroupRights.Insert("Update",                Selection.Update);
		AccessGroupRights.Insert("Insert",               Selection.Insert);
		AccessGroupRights.Insert("ReadWithoutRestriction",     Selection.ReadWithoutRestriction);
		AccessGroupRights.Insert("UpdateWithoutRestriction",  Selection.UpdateWithoutRestriction);
		AccessGroupRights.Insert("InsertWithoutRestriction", Selection.InsertWithoutRestriction);
		ListAccessGroupsRights.Insert(Selection.AccessGroup, AccessGroupRights);
	EndDo;
	UpdateParameters.Insert("ListAccessGroupsRights", ListAccessGroupsRights);
	
	UserGroupsUsers = New Map;
	
	If UpdateParameters.CalculateUserRights Then
		Tree = QueryResults[4].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			UserGroupUsers = New Map;
			For Each Substring In Row.Rows Do
				UserGroupUsers.Insert(Substring.User, True);
			EndDo;
			UserGroupsUsers.Insert(Row.UsersGroup, UserGroupUsers);
		EndDo;
	EndIf;
	UpdateParameters.Insert("UserGroupsUsers", UserGroupsUsers);
	
	AccessGroupsMembers           = New Map;
	AccessGroupsUserGroups = New Map;
	UserGroupType = UpdateParameters.UserGroupType;
	
	If UpdateParameters.CalculateUserRights Then
		Tree = QueryResults[5].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			AccessGroupMembers = New Map;
			AccessGroupUserGroups = New Map;
			For Each Substring In Row.Rows Do
				AccessGroupMembers.Insert(Substring.Member, True);
				If TypeOf(Substring.Member) = UserGroupType Then
					GroupUsers = UserGroupsUsers.Get(Substring.Member);
					If GroupUsers <> Undefined Then
						AccessGroupUserGroups.Insert(Substring.Member, GroupUsers);
					EndIf;
				EndIf;
			EndDo;
			If AccessGroupMembers.Count() > 0 Then
				AccessGroupsMembers.Insert(Row.AccessGroup, AccessGroupMembers);
			EndIf;
			If AccessGroupUserGroups.Count() > 0 Then
				AccessGroupsUserGroups.Insert(Row.AccessGroup, AccessGroupUserGroups);
			EndIf;
		EndDo;
	EndIf;
	UpdateParameters.Insert("AccessGroupsMembers",           AccessGroupsMembers);
	UpdateParameters.Insert("AccessGroupsUserGroups", AccessGroupsUserGroups);
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillAccessGroupsValuesToCalculateRights(UpdateParameters)
	
	If Not UpdateParameters.Cache.Property("AccessGroupsValuesVersion") Then
		UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", New UUID);
	EndIf;
	
	VersionParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValuesVersion";
	AccessGroupsValuesVersion = StandardSubsystemsServer.ExtensionParameter(VersionParameterName, True);
	
	If UpdateParameters.Cache.AccessGroupsValuesVersion = AccessGroupsValuesVersion Then
		UpdateParameters.Insert("AccessGroupsValues", UpdateParameters.Cache.AccessGroupsValues);
		Return;
	EndIf;
	
	ParameterName = "StandardSubsystems.AccessManagement.AccessGroupsValues";
	AccessGroupsValues = StandardSubsystemsServer.ExtensionParameter(ParameterName, True);
	
	If AccessGroupsValuesVersion <> Undefined AND AccessGroupsValues <> Undefined Then
		UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", AccessGroupsValuesVersion);
		UpdateParameters.Cache.Insert("AccessGroupsValues", AccessGroupsValues);
		UpdateParameters.Insert("AccessGroupsValues", AccessGroupsValues);
		Return;
	EndIf;
	
	AccessGroupsValuesVersion = New UUID;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	DefaultAccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(DefaultAccessGroupsValues.AccessValuesType) AS AccessValuesType,
	|	DefaultAccessGroupsValues.AllAllowed AS AllAllowed
	|FROM
	|	InformationRegister.DefaultAccessGroupsValues AS DefaultAccessGroupsValues
	|WHERE
	|	NOT DefaultAccessGroupsValues.NoSettings
	|TOTALS BY
	|	AccessGroup
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AccessGroupsValues.AccessGroup AS AccessGroup,
	|	VALUETYPE(AccessGroupsValues.AccessValue) AS AccessValuesType,
	|	AccessGroupsValues.AccessValue AS AccessValue
	|FROM
	|	InformationRegister.AccessGroupsValues AS AccessGroupsValues
	|TOTALS BY
	|	AccessGroup,
	|	AccessValuesType";
	QueryResults = Query.ExecuteBatch();
	
	AccessGroupsValues = New Map;
	
	Tree = QueryResults[0].Unload(QueryResultIteration.ByGroups);
	For Each Row In Tree.Rows Do
		AccessGroupValues = New Map;
		For Each Substring In Row.Rows Do
			ValuesOfOneType = New Structure;
			ValuesOfOneType.Insert("AllAllowed", Substring.AllAllowed);
			ValuesOfOneType.Insert("Values",     New Map);
			AccessGroupValues.Insert(Substring.AccessValuesType, ValuesOfOneType);
		EndDo;
		AccessGroupsValues.Insert(Row.AccessGroup, AccessGroupValues);
	EndDo;
	
	Tree = QueryResults[1].Unload(QueryResultIteration.ByGroups);
	For Each Row In Tree.Rows Do
		AccessGroupValues = AccessGroupsValues.Get(Row.AccessGroup);
		If AccessGroupValues = Undefined Then
			Continue;
		EndIf;
		For Each Substring In Row.Rows Do
			ValuesOfOneType = AccessGroupValues.Get(Substring.AccessValuesType);
			If ValuesOfOneType = Undefined Then
				Continue;
			EndIf;
			Values = ValuesOfOneType.Values;
			For Each ValueDetails In Substring.Rows Do
				Values.Insert(ValueDetails.AccessValue, True);
			EndDo;
		EndDo;
	EndDo;
	
	StandardSubsystemsServer.SetExtensionParameter(ParameterName, AccessGroupsValues, True);
	StandardSubsystemsServer.SetExtensionParameter(VersionParameterName, AccessGroupsValuesVersion, True);
	
	UpdateParameters.Cache.Insert("AccessGroupsValuesVersion", AccessGroupsValuesVersion);
	UpdateParameters.Cache.Insert("AccessGroupsValues", AccessGroupsValues);
	UpdateParameters.Insert("AccessGroupsValues", AccessGroupsValues);
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsToLeadingAccessKeysAndLeadingLists(QueryResults, TableNumber, UpdateParameters)
	
	RightsToLeadingAccessKeysLists = New Map;
	RightsToLeadingAccessKeys = New Map;
	If UpdateParameters.HasMasterAccessKeys Then
		ActiveParameters = ActiveAccessRestrictionParameters(UpdateParameters.TransactionID, Undefined, False);
		If UpdateParameters.ForExternalUsers Then
			AdditionalContext = ActiveParameters.AdditionalContext.ForExternalUsers;
		Else
			AdditionalContext = ActiveParameters.AdditionalContext.ForUsers;
		EndIf;
		TableNumber = TableNumber + 1;
		RightsToLists = New Map;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		ListsIDs = Tree.Rows.UnloadColumn("List");
		If UpdateParameters.Cache.Property("MetadataObjectsByIDs") Then
			MetadataObjectsByIDs = UpdateParameters.Cache.MetadataObjectsByIDs;
			NotFoundListsIDs = New Array;
			For Each ListID In ListsIDs Do
				If MetadataObjectsByIDs.Get(ListID) = Undefined Then
					NotFoundListsIDs.Add(ListID);
				EndIf;
			EndDo;
			Result = Common.MetadataObjectsByIDs(
				NotFoundListsIDs, False);
			For Each KeyAndValue In Result Do
				MetadataObjectsByIDs.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndDo;
		Else
			MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
				ListsIDs, False);
		EndIf;
		For Each Row In Tree.Rows Do
			MetadataObject = MetadataObjectsByIDs.Get(Row.List);
			If TypeOf(MetadataObject) <> Type("MetadataObject") Then
				Continue;
			EndIf;
			FullName = MetadataObject.FullName();
			ByAccessGroups = New Map;
			For Each Substring In Row.Rows Do
				ByAccessGroups.Insert(Substring.AccessGroup, Substring.Update);
			EndDo;
			RightsToList = New Structure;
			RightsToList.Insert("RightToWriteRestrictionDisabled",
				AdditionalContext.ListsWithReadRestrictionDisabled.Get(FullName) <> Undefined);
			RightsToList.Insert("RestrictionDisabled",
				AdditionalContext.ListsWithDisabledRestriction.Get(FullName) <> Undefined);
			RightsToList.Insert("ByAccessGroups", New FixedMap(ByAccessGroups));
			RightsToLists.Insert(Row.List, New FixedStructure(RightsToList));
		EndDo;
		TableNumber = TableNumber + 1;
		Table = QueryResults[TableNumber].Unload();
		For Each Row In Table Do
			RightsToLeadingAccessKeysLists.Insert(Row.AccessKey,
				RightsToLists.Get(Row.List));
		EndDo;
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			RightsToLeadingKey = New Map;
			For Each Substring In Row.Rows Do
				RightsToLeadingKey.Insert(Substring.RightsOwner, Substring.Update);
			EndDo;
			RightsToLeadingAccessKeys.Insert(Row.AccessKey,
				New FixedMap(RightsToLeadingKey));
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsToLeadingAccessKeysLists",
		New FixedMap(RightsToLeadingAccessKeysLists));
	UpdateParameters.Insert("RightsToLeadingAccessKeys",
		New FixedMap(RightsToLeadingAccessKeys));
	
	RightsToLeadingLists = New Map;
	If UpdateParameters.HasHeadRightsLists Then
		TableNumber = TableNumber + 1;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		AddRightsByTypes = Tree.Columns.Find("ValueType") <> Undefined;
		For Each Row In Tree.Rows Do
			RightsToLeadingList = New Map;
			For Each Substring In Row.Rows Do
				RightsToLeadingList.Insert(Substring.RightsOwner, Substring.Update);
				If AddRightsByTypes Then
					ListValueType = Substring.ValueType;
				EndIf;
			EndDo;
			RightsToLeadingLists.Insert(Row.List,
				New FixedMap(RightsToLeadingList));
			If AddRightsByTypes Then
				RightsToLeadingLists.Insert(ListValueType,
					New FixedMap(RightsToLeadingList));
			EndIf;
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsToLeadingLists",
		New FixedMap(RightsToLeadingLists));
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure FillRightsByRightsSettingsOwners(QueryResults, TableNumber, UpdateParameters)
	
	RightsByRightsSettingsOwners = New Map;
	If UpdateParameters.HasRightsSettingsOwners Then
		TableNumber = TableNumber + 3;
		Tree = QueryResults[TableNumber].Unload(QueryResultIteration.ByGroups);
		For Each Row In Tree.Rows Do
			RightsByRightsSettingsOwner = New Map;
			For Each Substring In Row.Rows Do
				RightsByRightsSettingsOwner.Insert(Substring.RightsOwner, Substring.Update);
			EndDo;
			RightsByRightsSettingsOwners.Insert(Row.RightsSettingsOwner,
				New FixedMap(RightsByRightsSettingsOwner));
		EndDo;
	EndIf;
	UpdateParameters.Insert("RightsByRightsSettingsOwners",
		New FixedMap(RightsByRightsSettingsOwners));
	
EndProcedure

// For the UpdateRightsToListAccessKeys procedure.
Function RightsToListAccessKey(KeyTablesValues, UpdateParameters)
	
	RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
	
	If UpdateParameters.RestrictionDisabled Then
		If Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords Then
			Return RightsToKey;
		ElsIf UpdateParameters.EditionAllowedForAllUsers Then
			RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
				New Structure("Update, Insert", True, True));
			Return RightsToKey;
		EndIf;
	EndIf;
	
	WithoutWriteReadRight = UpdateParameters.RightToWriteRestrictionDisabled
		AND Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords;
	
	Context = New Structure;
	Context.Insert("KeyTablesValues",               KeyTablesValues);
	Context.Insert("WithoutWriteReadRight",              WithoutWriteReadRight);
	Context.Insert("KeyTablesAttributes",              UpdateParameters.KeyTablesAttributes);
	Context.Insert("AccessGroupsMembers",             UpdateParameters.AccessGroupsMembers);
	Context.Insert("AccessGroupsUserGroups",   UpdateParameters.AccessGroupsUserGroups);
	Context.Insert("UserGroupsUsers",    UpdateParameters.UserGroupsUsers);
	Context.Insert("RightsToLeadingAccessKeysLists", UpdateParameters.RightsToLeadingAccessKeysLists);
	Context.Insert("RightsToLeadingAccessKeys",        UpdateParameters.RightsToLeadingAccessKeys);
	Context.Insert("RightsToLeadingLists",              UpdateParameters.RightsToLeadingLists);
	Context.Insert("RightsByRightsSettingsOwners",     UpdateParameters.RightsByRightsSettingsOwners);
	Context.Insert("CalculateUserRights",    UpdateParameters.CalculateUserRights);
	Context.Insert("AccessGroupType",                  UpdateParameters.AccessGroupType);
	Context.Insert("BlankAccessGroup",               UpdateParameters.BlankAccessGroup);
	Context.Insert("UserType",                   UpdateParameters.UserType);
	Context.Insert("UserGroupType",            UpdateParameters.UserGroupType);
	Context.Insert("RightsSettingsOwnersTypes",        UpdateParameters.RightsSettingsOwnersTypes);
	
	ReadAllowedForAllAccessGroups = True;
	ChangeAllowedForAllAccessGroups = True;
	AddAllowedForAllAccessGroups = True;
	
	For Each RightsDetails In UpdateParameters.ListAccessGroupsRights Do
		AccessGroup      = RightsDetails.Key;
		AccessGroupRights = RightsDetails.Value;
		
		Context.Insert("AccessGroup", AccessGroup);
		Context.Insert("AccessGroupValues",
			UpdateParameters.AccessGroupsValues.Get(AccessGroup));
		
		If UpdateParameters.RightToWriteRestrictionDisabled
		 Or AccessGroupRights.ReadWithoutRestriction Then
			
			ReadRight = "True";
		Else
			ReadRight = CalculatedConditionForRows(Context,
				UpdateParameters.ReadRightCalculationStructure);
		EndIf;
		
		If ReadRight <> "True" Then
			ReadAllowedForAllAccessGroups = False;
			ChangeAllowedForAllAccessGroups = False;
			AddAllowedForAllAccessGroups = False;
		EndIf;
		
		If ReadRight = "False"
		 Or TypeOf(ReadRight) = Type("Map")
		   AND ReadRight.Count() = 0 Then
			
			Continue;
		EndIf;
		
		If UpdateParameters.RestrictionDisabled
		 Or AccessGroupRights.UpdateWithoutRestriction
		   AND AccessGroupRights.InsertWithoutRestriction Then
			
			UpdateRight = "True";
			
		ElsIf Not AccessGroupRights.Update Then
			UpdateRight = "False";
			
		ElsIf UpdateParameters.HasLimitChanges Then
			UpdateRight = CalculatedConditionForRows(Context,
				UpdateParameters.EditRightCalculationStructure);
			
		ElsIf UpdateParameters.RightToWriteRestrictionDisabled
		      Or AccessGroupRights.ReadWithoutRestriction Then
			
			UpdateRight = CalculatedConditionForRows(Context,
				UpdateParameters.ReadRightCalculationStructure);
		Else
			UpdateRight = "True";
		EndIf;
		
		InsertRight = ?(AccessGroupRights.Insert, UpdateRight, "False");
		
		If AccessGroupRights.UpdateWithoutRestriction Then
			UpdateRight = "True";
		EndIf;
		
		If UpdateRight <> "True" Then
			ChangeAllowedForAllAccessGroups = False;
		EndIf;
		If InsertRight <> "True" Then
			AddAllowedForAllAccessGroups = False;
		EndIf;
		
		If Context.CalculateUserRights Then
			AddUsersRightsToAccessKey(RightsToKey,
				ReadRight, UpdateRight, InsertRight, Context);
		
		ElsIf Not WithoutWriteReadRight Or UpdateRight = "True" Or InsertRight = "True" Then
			RightsToKey.ForGroups.Insert(AccessGroup, New Structure("Update, Insert",
				UpdateRight = "True", InsertRight = "True"));
		EndIf;
	EndDo;
	
	If Not ReadAllowedForAllAccessGroups
	 Or UpdateParameters.HasDependantListsWithoutAccessKeysRecords
	   AND Not UpdateParameters.ReadingAllowedForAllUsers Then
		
		Return RightsToKey;
	EndIf;
	
	If AddAllowedForAllAccessGroups
	   AND ( Not UpdateParameters.HasDependantListsWithoutAccessKeysRecords
	      Or UpdateParameters.EditionAllowedForAllUsers) Then
		
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
			New Structure("Update, Insert", True, True));
		
	Else // ReadAllowedForAllAccessGroups.
		CurrentRightsToKey = RightsToKey;
		RightsToKey = New Structure("ForGroups, ForUsers", New Map, New Map);
		If Not WithoutWriteReadRight Or ChangeAllowedForAllAccessGroups Then
			RightsToKey.ForGroups.Insert(UpdateParameters.BlankAccessGroup,
				New Structure("Update, Insert", ChangeAllowedForAllAccessGroups, False));
		EndIf;
		RightName = ?(ChangeAllowedForAllAccessGroups, "Insert", "Update");
		For Each KeyAndValue In CurrentRightsToKey.ForGroups Do
			If KeyAndValue.Value[RightName] Then
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
		For Each KeyAndValue In CurrentRightsToKey.ForUsers Do
			If KeyAndValue.Value[RightName] Then
				RightsToKey.ForUsers.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Return RightsToKey;
	
EndFunction

// For the RightsToListAccessKey procedure.
Procedure AddUsersRightsToAccessKey(RightsToKey, ReadRight, UpdateRight, InsertRight, Context)
	
	If TypeOf(UpdateRight) = Type("Map") AND UpdateRight.Count() = 0 Then
		UpdateRight  = "False";
		InsertRight = "False";
		
	ElsIf TypeOf(InsertRight) = Type("Map") AND InsertRight.Count() = 0 Then
		InsertRight = "False";
	EndIf;
	
	Rights = New Structure("Update, Insert", UpdateRight = "True", InsertRight = "True");
	
	If TypeOf(ReadRight) <> Type("Map") Then
		If Not Context.WithoutWriteReadRight Or Rights.Update Or Rights.Insert Then
			RightsToKey.ForGroups.Insert(Context.AccessGroup,
				New Structure("Update, Insert", Rights.Update, Rights.Insert));
		EndIf;
	Else
		AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
			ReadRight, Rights.Update, Rights.Insert, Context.WithoutWriteReadRight);
	EndIf;
	
	If TypeOf(UpdateRight)  <> Type("Map")
	   AND TypeOf(InsertRight) <> Type("Map") Then
		Return;
	EndIf;
	
	Right = ?(TypeOf(UpdateRight) = Type("Map"), UpdateRight, InsertRight);
	AddRightsToAccessKeyToUsers(RightsToKey.ForUsers,
		Right, True, InsertRight <> "False", Context.WithoutWriteReadRight);
	
EndProcedure

// For the AddUsersRightsToAccessKey procedure.
Procedure AddRightsToAccessKeyToUsers(RightsToAccessKeyForUsers,
				UsersContent, Update, Insert, WithoutWriteReadRight)
	
	If Update AND Insert Then
		For Each KeyAndValue In UsersContent Do
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key,
				New Structure("Update, Insert", True, True));
		EndDo;
		
	ElsIf Not Update AND Not Insert Then
		If Not WithoutWriteReadRight Then
			For Each KeyAndValue In UsersContent Do
				Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key);
				If Rights = Undefined Then
					Rights = New Structure("Update, Insert", False, False);
					RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
				EndIf;
			EndDo;
		EndIf;
	Else
		For Each KeyAndValue In UsersContent Do
			Rights = RightsToAccessKeyForUsers.Get(KeyAndValue.Key);
			If Rights = Undefined Then
				Rights = New Structure("Update, Insert", Update, Insert);
			Else
				Rights.Update  = Rights.Update  Or Update;
				Rights.Insert = Rights.Insert Or Insert;
			EndIf;
			RightsToAccessKeyForUsers.Insert(KeyAndValue.Key, Rights);
		EndDo;
	EndIf;
	
EndProcedure

// For the RightsToListAccessKey and CalculatedCondition functions.
Function CalculatedConditionForRows(Context, Condition, AttributesNode = Undefined, ForAnyRow = True)
	
	If AttributesNode = Undefined Then
		Context.Insert("RequiredKeyTablesDetails", New Array);
		If Condition.Node = "ForAllRows" Or Condition.Node = "ForAtLeastOneRow" Then
			Return CalculatedCondition(Context, Condition);
		EndIf;
		AttributesNode = Condition;
	EndIf;
	
	If Not ValueIsFilled(AttributesNode.RequiredKeyTabularSectionsAttributes) Then
		Context.Insert("CurrentKeyTableRows", Context.KeyTablesValues);
		Return CalculatedCondition(Context, Condition);
	EndIf;
	TablesAttributes    = AttributesNode.RequiredKeyTabularSectionsAttributes;
	TablesValues     = CurrentKeyTablesValues(Context, TablesAttributes);
	TablesRowsIndexes = New Map;
	
	Context.RequiredKeyTablesDetails.Add(
		New Structure("TablesAttributes, TablesValues, TablesRowsIndexes",
			TablesAttributes, TablesValues, TablesRowsIndexes));
	
	CurrentKeyTableRows = ?(Context.Property("CurrentKeyTableRows"),
		Context.CurrentKeyTableRows, Undefined);
	
	Context.Insert("CurrentKeyTableRows", New Structure);
	For Each ValuesDetails In Context.KeyTablesValues Do
		If StrStartsWith(ValuesDetails.Key, "Header") Then
			Context.CurrentKeyTableRows.Insert(ValuesDetails.Key, ValuesDetails.Value);
		EndIf;
	EndDo;
	
	Result = "Undefined";
	
	While True Do
		IndexChanged = False;
		For Each TableDetails In TablesAttributes Do
			KeyTableName = TableDetails.Key;
			RowIndex = TablesRowsIndexes.Get(KeyTableName);
			TableValues = TablesValues[KeyTableName];
			If RowIndex = Undefined Then
				RowIndex = 0;
			Else
				If RowIndex >= TableValues.Count() - 1 Then
					Continue;
				EndIf;
				RowIndex = RowIndex + 1;
			EndIf;
			IndexChanged = True;
			TablesRowsIndexes.Insert(KeyTableName, RowIndex);
			Context.CurrentKeyTableRows.Insert(KeyTableName, TableValues[RowIndex]);
		EndDo;
		If Not IndexChanged Then
			Break;
		EndIf; 
		CurrentResult = CalculatedCondition(Context, Condition);
		If TypeOf(CurrentResult) <> Type("Map") Then
			If ForAnyRow Then
				If CurrentResult = "True" Then
					Result = "True";
					Break;
				ElsIf CurrentResult = "False" Then
					If Result = "Undefined" Then
						Result = "False";
					EndIf;
				EndIf;
			Else
				If CurrentResult = "False" Then
					Result = "False";
					Break;
				ElsIf CurrentResult = "True" Then
					If Result = "Undefined" Then
						Result = "True";
					EndIf;
				EndIf;
			EndIf;
		Else
			If Not ForAnyRow AND CurrentResult.Count() = 0 Then
				Result = "False";
				Break;
			EndIf;
			If TypeOf(Result) = Type("String") Then
				Result = CurrentResult;
			Else
				AddCurrentResult(Result, CurrentResult, ForAnyRow, Context);
			EndIf;
		EndIf;
	EndDo;
	
	If Result = "Undefined" Then
		Result = "False";
	EndIf;
	
	Context.RequiredKeyTablesDetails.Delete(
		Context.RequiredKeyTablesDetails.Count() - 1);
	
	Context.Insert("CurrentKeyTableRows", CurrentKeyTableRows);
	
	Return Result;
	
EndFunction

// For the CalculatedConditionForRows function.
Procedure AddCurrentResult(Result, CurrentResult, ForAnyRow, Context)
	
	If ForAnyRow Then
		For Each KeyAndValue In CurrentResult Do
			Result.Insert(KeyAndValue.Key, KeyAndValue.Value);
		EndDo;
	Else
		If Result.Count() > CurrentResult.Count() Then
			SmallerResult = CurrentResult;
			BiggerResult = Result;
		Else
			SmallerResult = Result;
			BiggerResult = CurrentResult;
		EndIf;
		Result = New Map;
		UserGroupType = Undefined;
		
		For Each KeyAndValue In SmallerResult Do
			Member = KeyAndValue.Key;
			If BiggerResult.Get(Member) <> Undefined Then
				Result.Insert(Member, True);
			Else
				If UserGroupType = Undefined Then
					UserGroupType = Context.UserGroupType;
					UserGroupsUsers = Context.UserGroupsUsers;
					BiggerResultGroupsUsers = GroupsUsers(BiggerResult, Context);
				EndIf;
				If TypeOf(Member) = UserGroupType Then
					GroupUsers = UserGroupsUsers.Get(Member);
					If GroupUsers = Undefined Then
						Continue;
					EndIf;
					For Each UserDetails In GroupUsers Do
						If BiggerResultGroupsUsers.Get(UserDetails.Key) <> Undefined Then
							Result.Insert(UserDetails.Key, True);
						EndIf;
					EndDo;
				ElsIf BiggerResultGroupsUsers.Get(Member) <> Undefined Then
					Result.Insert(Member, True);
				EndIf;
			EndIf;
		EndDo;
	EndIf;
	
EndProcedure

// For the AddCurrentResult and SetReverseResult procedures.
Function GroupsUsers(UsersAndGroups, Context)
	
	GroupsUsers = New Map;
	
	UserGroupType = Context.UserGroupType;
	UserGroupsUsers = Context.UserGroupsUsers;
	
	For Each KeyAndValue In UsersAndGroups Do
		If TypeOf(KeyAndValue.Key) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(KeyAndValue.Key);
			If GroupUsers <> Undefined Then
				For Each UserDetails In GroupUsers Do
					GroupsUsers.Insert(UserDetails.Key, True);
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
	Return GroupsUsers;
	
EndFunction

// For the CalculatedCondition function.
Procedure SetReverseResult(Result, Context)
	
	ExceptionsList = Result;
	Result = New Map;
	
	CurrentAccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If CurrentAccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	UserGroupsUsers = Context.UserGroupsUsers;
	UserGroupType         = Context.UserGroupType;
	UserType                = Context.UserType;
	
	UsersOfGroupsToExclude = GroupsUsers(ExceptionsList, Context);
	
	For Each KeyAndValue In CurrentAccessGroupMembers Do
		Member = KeyAndValue.Key;
		If ExceptionsList.Get(Member) <> Undefined Then
			Continue;
		EndIf;
		If TypeOf(Member) = UserType Then
			If ExceptionsList.Get(Member) = Undefined
			   AND UsersOfGroupsToExclude.Get(Member) = Undefined Then
				
				Result.Insert(Member, True);
			EndIf;
		ElsIf TypeOf(Member) = UserGroupType Then
			GroupUsers = UserGroupsUsers.Get(Member);
			If GroupUsers = Undefined Then
				Continue;
			EndIf;
			AllGroupWithoutExceptions = True;
			For Each UserDetails In GroupUsers Do
				If ExceptionsList.Get(UserDetails.Key) <> Undefined
				 Or UsersOfGroupsToExclude.Get(UserDetails.Key) <> Undefined Then
					
					AllGroupWithoutExceptions = False;
					Break;
				EndIf;
			EndDo;
			If AllGroupWithoutExceptions Then
				Result.Insert(Member, True);
			Else
				For Each UserDetails In GroupUsers Do
					If ExceptionsList.Get(UserDetails.Key) = Undefined
					   AND UsersOfGroupsToExclude.Get(UserDetails.Key) = Undefined Then
						
						Result.Insert(UserDetails.Key, True);
					EndIf;
				EndDo;
			EndIf;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedConditionForRows function.
Function CurrentKeyTablesValues(Context, RequiredKeyTabularSectionsAttributes)
	
	CurrentKeyTablesValues = New Structure;
	For Each TableDetails In RequiredKeyTabularSectionsAttributes Do
		KeyTableName = TableDetails.Key;
		Attributes       = TableDetails.Value;
		KeyTableValues = Context.KeyTablesValues[KeyTableName];
		Filter = New Structure;
		For Each CurrentDetails In Context.RequiredKeyTablesDetails Do
			TableAttributes    = CurrentDetails.TablesAttributes.Get(KeyTableName);
			TableValues     = CurrentDetails.TablesValues[KeyTableName];
			TableRowIndex = CurrentDetails.TablesRowsIndexes.Get(KeyTableName);
			TableRow = TableValues[TableRowIndex];
			For Each AttributeName In TableAttributes Do
				Filter.Insert(AttributeName, TableRow[AttributeName]);
			EndDo;
		EndDo;
		TableAttributesTotal = Context.KeyTablesAttributes.Get(KeyTableName).Count();
		If TableAttributesTotal = Attributes.Count() AND Not ValueIsFilled(Filter) Then
			CurrentKeyTablesValues.Insert(KeyTableName, KeyTableValues);
			Continue;
		EndIf;
		Rows = KeyTableValues;
		If ValueIsFilled(Filter) Then
			Rows = Rows.FindRows(Filter);
		EndIf;
		TableValues = New ValueTable;
		For Each AttributeName In Attributes Do
			TableValues.Columns.Add(AttributeName);
		EndDo;
		For Each Row In Rows Do
			FillPropertyValues(TableValues.Add(), Row);
		EndDo;
		If Attributes.Count() < TableAttributesTotal Then
			AttributesAsString = StrConcat(Attributes, ", ");
			TableValues.GroupBy(AttributesAsString);
		EndIf;
		CurrentKeyTablesValues.Insert(KeyTableName, TableValues);
	EndDo;
	
	Return CurrentKeyTablesValues;
	
EndFunction

// For the CalculatedConditionForRows function.
Function CalculatedCondition(Context, Condition)
	
	// Checked types are already considered.
	
	If Condition.Node = "Field" Then
		Value = Context.CurrentKeyTableRows[Condition.Table][Condition.Attribute];
		Result = ?(Value = Enums.AdditionalAccessValues.True
			Or Value = Null AND Condition.Property("CheckHasNull"), "True", "False");
		
	ElsIf Condition.Node = "Constant" Then
		Result = ?(Condition.Value = True, "True", "False");
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) Then // PATCHED:
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "False" Then
				Result = "False";
				Break;
			EndIf;
			If CurrentResult = "True" Then
				If Result = "Undefined" Then
					Result = "True";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					Result = "False";
					Break;
				EndIf;
				If TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, False, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Or" Then
		
		Result = "Undefined";
		For Each Argument In Condition.Arguments Do
			CurrentResult = CalculatedCondition(Context, Argument);
			If CurrentResult = "True" Then
				Result = "True";
				Break;
			EndIf;
			If CurrentResult = "False" Then
				If Result = "Undefined" Then
					Result = "False";
				EndIf;
			ElsIf TypeOf(CurrentResult) = Type("Map") Then
				If CurrentResult.Count() = 0 Then
					If Result = "Undefined" Then
						Result = "False";
					EndIf;
				ElsIf TypeOf(Result) = Type("String") Then
					Result = CurrentResult;
				Else
					AddCurrentResult(Result, CurrentResult, True, Context);
				EndIf;
			EndIf;
		EndDo;
		If Result = "Undefined" Then
			Result = "False";
		EndIf;
		
	ElsIf Condition.Node = "Not" Then
		Result = CalculatedCondition(Context, Condition.Argument);
		If Result = "True" Then
			Result = "False";
		ElsIf Result = "False" Then
			Result = "True";
		ElsIf TypeOf(Result) = Type("Map") Then
			If Result.Count() = 0 Then
				Result = "True";
			Else
				SetReverseResult(Result, Context);
			EndIf;
		EndIf;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		Result = CalculatedConditionForRows(Context,
			Condition.Argument, Condition, Condition.Node = "ForAtLeastOneRow");
		
	ElsIf Condition.Node = "Case" Then
		Result = Undefined;
		For Each When In Condition.When Do
			If CalculatedCondition(Context, When.Condition) = "True" Then
				Result = CalculatedCondition(Context, When.Value);
				Break;
			EndIf;
		EndDo;
		If Result = Undefined Then
			Result = CalculatedCondition(Context, Condition.Else);
		EndIf;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		Value = Context.CurrentKeyTableRows[Condition.Field.Table][Condition.Field.Attribute];
		If Value = Null Then
			Value = Enums.AdditionalAccessValues.Null;
		EndIf;
		
		If Value = Enums.AdditionalAccessValues.AllowedType Then
			CurrentResult = "True";
			
		ElsIf Value = Enums.AdditionalAccessValues.ProhibitedType Then
			CurrentResult = "False";
		Else
			CurrentResult = Undefined;
			For Each ComparisonClarification In Condition.ComparisonClarifications Do
				If ComparisonClarification.Key = "Null"
				 Or ComparisonClarification.Key = "Undefined" Then
					If Value = Enums.AdditionalAccessValues[ComparisonClarification.Key] Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = "EmptyRef" Then
					If Value = Enums.AdditionalAccessValues.EmptyRefAnyType
					 Or Value.IsEmpty() Then
						CurrentResult = ComparisonClarification.Value;
						Break;
					EndIf;
				ElsIf ComparisonClarification.Key = TypeOf(Value) Then
					CurrentResult = ComparisonClarification.Value;
					Break;
				EndIf;
			EndDo;
		EndIf;
		
		If CurrentResult <> Undefined Then
			Result = CurrentResult;
			
		ElsIf Condition.Node = "ValueAllowed" Then
			If Value = Enums.AdditionalAccessValues.Null
			 Or Value = Enums.AdditionalAccessValues.Undefined
			 Or Context.AccessGroupValues = Undefined Then
				Result = "False";
			Else
				ValueType = TypeOf(Value);
				ValuesOfOneType = Context.AccessGroupValues.Get(ValueType);
				If ValuesOfOneType = Undefined Then
					If Condition.ComparisonClarifications.Get("Disabled") = "False" Then
						Result = "False";
					Else
						Result = "True";
					EndIf;
				Else
					ValueSpecified = ValuesOfOneType.Values.Get(Value) <> Undefined;
					Result = "False";
					If    ValueSpecified AND Not ValuesOfOneType.AllAllowed
					 Or Not ValueSpecified AND    ValuesOfOneType.AllAllowed Then
						Result = "True";
						
					ElsIf ValueType = Context.UserType Then
						FillResultForUser(Result, Value, Context);
						
					ElsIf ValueType = Context.UserGroupType Then
						FillResultForUserGroup(Result, Value, Context);
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Condition.Node = "IsAuthorizedUser" Then
			If TypeOf(Value) = Context.UserType Then
				FillResultForUser(Result, Value, Context);
			Else
				Result = "False";
			EndIf;
			
		ElsIf TypeOf(Value) = Type("CatalogRef.AccessKeys") Then
			RightsToList = Context.RightsToLeadingAccessKeysLists.Get(Value);
			If RightsToList = Undefined Then
				Result = "False";
			Else
				UpdateRight = RightsToList.ByAccessGroups.Get(Context.AccessGroup);
				If Condition.Node =    "ObjectReadingAllowed" AND UpdateRight = Undefined
				 Or Condition.Node = "ObjectUpdateAllowed" AND UpdateRight <> True Then
					Result = "False";
				
				ElsIf Condition.Node =    "ObjectReadingAllowed" AND RightsToList.RightToWriteRestrictionDisabled
					  Or Condition.Node = "ObjectUpdateAllowed" AND RightsToList.RestrictionDisabled Then
					
					Result = "True";
				Else
					RightsToLeadingAccessKey = Context.RightsToLeadingAccessKeys.Get(Value);
					If RightsToLeadingAccessKey = Undefined Then
						Result = "False";
						
					ElsIf Context.CalculateUserRights Then
						If Condition.Node = "ObjectReadingAllowed" Then
							Result = New Map;
							For Each KeyAndValue In RightsToLeadingAccessKey Do
								If TypeOf(KeyAndValue.Key) <> Context.AccessGroupType Then
									Result.Insert(KeyAndValue.Key, True);
									
								ElsIf KeyAndValue.Key = Context.AccessGroup
								      Or KeyAndValue.Key = Context.BlankAccessGroup Then
									
									Result.Insert(Context.AccessGroup, True);
								EndIf;
							EndDo;
							
						ElsIf Condition.Node = "ObjectUpdateAllowed" Then
							Result = New Map;
							For Each KeyAndValue In RightsToLeadingAccessKey Do
								If Not KeyAndValue.Value Then
									Continue;
								EndIf;
								If TypeOf(KeyAndValue.Key) <> Context.AccessGroupType Then
									Result.Insert(KeyAndValue.Key, True);
									
								ElsIf KeyAndValue.Key = Context.AccessGroup
								      Or KeyAndValue.Key = Context.BlankAccessGroup Then
									
									Result.Insert(Context.AccessGroup, True);
								EndIf;
							EndDo;
						Else
							Result = "False";
						EndIf;
					Else
						UpdateRight = RightsToLeadingAccessKey.Get(Context.AccessGroup);
						If Condition.Node =    "ObjectReadingAllowed" AND UpdateRight <> Undefined
						 Or Condition.Node = "ObjectUpdateAllowed" AND UpdateRight = True Then
							Result = "True";
						Else
							Result = "False";
						EndIf;
					EndIf;
				EndIf;
			EndIf;
			
		ElsIf Context.RightsSettingsOwnersTypes.Get(TypeOf(Value)) <> Undefined Then
			RightsByRightsSettingsOwner = Context.RightsByRightsSettingsOwners.Get(Value);
			If RightsByRightsSettingsOwner = Undefined Then
				Result = "False";
				
			ElsIf Condition.Node = "ObjectReadingAllowed" Then
				Result = New Map(RightsByRightsSettingsOwner);
				
			ElsIf Condition.Node = "ObjectUpdateAllowed" Then
				Result = New Map;
				For Each KeyAndValue In RightsByRightsSettingsOwner Do
					If KeyAndValue.Value Then
						Result.Insert(KeyAndValue.Key, True);
					EndIf;
				EndDo;
			Else
				Result = "False";
			EndIf;
			
		Else // Checking rights to the list.
			RightsToLeadingList = Context.RightsToLeadingLists.Get(Value);
			If RightsToLeadingList = Undefined Then
				RightsToLeadingList = Context.RightsToLeadingLists.Get(TypeOf(Value));
			EndIf;
			If RightsToLeadingList = Undefined Then
				Result = "False";
			ElsIf Context.CalculateUserRights Then
				If StrStartsWith(Condition.Node, "Read") Then
					Result = RightsToLeadingList;
					
				ElsIf StrStartsWith(Condition.Node, "Update") Then
					Result = New Map;
					For Each KeyAndValue In RightsToLeadingList Do
						If KeyAndValue.Value Then
							Result.Insert(KeyAndValue.Key, True);
						EndIf;
					EndDo;
				Else
					Result = "False";
				EndIf;
			Else
				UpdateRight = RightsToLeadingList.Get(Context.AccessGroup);
				If StrStartsWith(Condition.Node, "Read")    AND UpdateRight <> Undefined
				 Or StrStartsWith(Condition.Node, "Update") AND UpdateRight = True Then
					Result = "True";
				Else
					Result = "False";
				EndIf;
			EndIf;
		EndIf;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При вычислении прав на ключ доступа узел не поддерживается ""%1"".'; en = '""%1"" node is not supported while calculating rights to the access key.'; pl = 'Przy obliczaniu prawa do klucza dostępu węzeł nie jest obsługiwany ""%1"".';de = 'Bei der Berechnung der Zugriffsrechte auf einen Knoten wird der Knoten nicht unterstützt ""%1"".';ro = 'La calcularea drepturilor pentru cheia de acces nu este susținut nodul ""%1"".';tr = 'Erişim anahtarı hakları hesaplanırken, ünite desteklenmiyor ""%1"".'; es_ES = 'Al calcular los derechos de clave de acceso el nodo no se admite ""%1"".'"),
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	Return Result;
	
EndFunction

// For the CalculatedCondition function.
Procedure FillResultForUser(Result, User, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	If AccessGroupMembers.Get(User) <> Undefined Then
		Result = New Map;
		Result.Insert(User, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		Return;
	EndIf;
	
	For Each GroupUsersDetails In AccessGroupUserGroups Do
		If GroupUsersDetails.Value.Get(User) <> Undefined Then
			Result = New Map;
			Result.Insert(User, True);
			Return;
		EndIf;
	EndDo;
	
EndProcedure

// For the CalculatedCondition function.
Procedure FillResultForUserGroup(Result, UsersGroup, Context)
	
	Result = "False";
	
	AccessGroupMembers = Context.AccessGroupsMembers.Get(Context.AccessGroup);
	If AccessGroupMembers = Undefined Then
		Return;
	EndIf;
	
	If AccessGroupMembers.Get(UsersGroup) = Undefined Then
		Result = New Map;
		Result.Insert(UsersGroup, True);
		Return;
	EndIf;
	
	AccessGroupUserGroups = Context.AccessGroupsUserGroups.Get(Context.AccessGroup);
	If AccessGroupUserGroups = Undefined Then
		Return;
	EndIf;
	
	GroupUsers = Context.UserGroupsUsers.Get(UsersGroup);
	If GroupUsers = Undefined Then
		Return;
	EndIf;
	
	Result = New Map;
	For Each UserDetails In GroupUsers Do
		If AccessGroupMembers.Get(UserDetails.Key) <> Undefined Then
			Result.Insert(UserDetails.Key, True);
			Continue;
		EndIf;
		For Each GroupUsersDetails In AccessGroupUserGroups Do
			If GroupUsersDetails.Value.Get(UserDetails.Key) <> Undefined Then
				Result.Insert(UserDetails.Key, True);
				Break;
			EndIf;
		EndDo;
	EndDo;
	
	If Result.Count() = 0 Then
		Result = "False";
	EndIf;
	
EndProcedure

// For the UpdateRightsOfListAccessKeysBatch procedure.
Procedure UpdateRightsToListAccessKey(AccessKey, RightsToKey, NewKeysDetails, UpdateParameters)
	
	If UpdateParameters.CalculateUserRights Then
		RightsToAccessKeyForUsers = New Map;
		UserType = UpdateParameters.UserType;
		For Each KeyAndValue In RightsToKey.ForUsers Do
			If TypeOf(KeyAndValue.Key) = UserType Then
				Set = Catalogs.SetsOfAccessGroups.GetRef(KeyAndValue.Key.UUID());
				RightsToAccessKeyForUsers.Insert(Set, KeyAndValue.Value);
			Else
				RightsToKey.ForGroups.Insert(KeyAndValue.Key, KeyAndValue.Value);
			EndIf;
		EndDo;
	EndIf;
	
	Lock = New DataLock;
	
	GroupsQuery = New Query;
	GroupsQuery.SetParameter("AccessKey", AccessKey);
	GroupsQuery.Text =
	"SELECT
	|	AccessGroupsAccessKeys.AccessGroup AS AccessGroup,
	|	AccessGroupsAccessKeys.Update AS Update,
	|	AccessGroupsAccessKeys.Insert AS Insert
	|FROM
	|	InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|WHERE
	|	AccessGroupsAccessKeys.AccessKey = &AccessKey";
	
	GroupsLockItem = Lock.Add("InformationRegister.AccessGroupsAccessKeys");
	GroupsLockItem.SetValue("AccessKey", AccessKey);
	GroupsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupsAccessKeys);
	GroupsRecordSet.Filter.AccessKey.Set(AccessKey);
	
	AccessGroupsSetsQuery = New Query;
	AccessGroupsSetsQuery.SetParameter("AccessKey", AccessKey);
	AccessGroupsSetsQuery.SetParameter("AllowedEmptySet",
		AccessManagementInternalCached.AllowedBlankAccessGroupsSet());
	
	AccessGroupsSetsQuery.Text = DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups();
	LockItem = Lock.Add("InformationRegister.AccessGroupSetsAccessKeys");
	LockItem.SetValue("AccessKey", AccessKey);
	AccessGroupsSetsRecordSet = ServiceRecordSet(InformationRegisters.AccessGroupSetsAccessKeys);
	AccessGroupsSetsRecordSet.Filter.AccessKey.Set(AccessKey);
	
	If UpdateParameters.CalculateUserRights Then
		Query = New Query;
		Query.SetParameter("AccessKey", AccessKey);
		
		If Not UpdateParameters.ForExternalUsers Then
			Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForUsers();
			RightsOwnerFieldName = "User";
			LockItem = Lock.Add("InformationRegister.UsersAccessKeys");
			RecordSet = ServiceRecordSet(InformationRegisters.UsersAccessKeys);
		Else
			Query.Text = DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers();
			RightsOwnerFieldName = "ExternalUser";
			LockItem = Lock.Add("InformationRegister.ExternalUsersAccessKeys");
			RecordSet = ServiceRecordSet(InformationRegisters.ExternalUsersAccessKeys);
		EndIf;
		LockItem.SetValue("AccessKey", AccessKey);
		RecordSet.Filter.AccessKey.Set(AccessKey);
	EndIf;
	
	If NewKeysDetails <> Undefined Then
		NewKeyDetails = NewKeysDetails.KeysDetailsByRef.Get(AccessKey);
		AccessKeyObject = NewKeyDetails.AccessKeyObject;
		KeyLockItem = Lock.Add("Catalog.AccessKeys");
		KeyLockItem.SetValue("Hash",                     AccessKeyObject.Hash);
		KeyLockItem.SetValue("List",                  AccessKeyObject.List);
		KeyLockItem.SetValue("ForExternalUsers", AccessKeyObject.ForExternalUsers);
		KeyLockItem.SetValue("FieldsComposition",             AccessKeyObject.FieldsComposition);
	EndIf;
	
	UpdateManually = UpdateParameters.Property("UpdateRightsToKeys")
		AND UpdateParameters.UpdateRightsToKeys;
	
	If Common.FileInfobase() Then
		If NewKeysDetails <> Undefined Then
			LockItem = Lock.Add("Catalog.AccessKeys");
		EndIf;
		LockItem = Lock.Add("Catalog.SetsOfAccessGroups");
		LockItem.Mode = DataLockMode.Shared;
		Lock.Add("InformationRegister.UsersAccessKeysUpdate");
	EndIf;
	
	BeginTransaction();
	Try
		BeforeDataLock(UpdateParameters);
		Lock.Lock();
		AfterDataLock(UpdateParameters);
		
		HasRightsChanges = False;
		
		If NewKeysDetails = Undefined
		 Or Not NewAccessKeyAlreadyExists(NewKeysDetails, NewKeyDetails, UpdateParameters) Then
			
			If NewKeysDetails <> Undefined Then
				BeforeWriteNewKey(UpdateParameters);
				AccessKeyObject.Write();
				AfterWriteNewKey(UpdateParameters);
			EndIf;
			
			BeforeAccessGroupsRightsQuery(UpdateParameters);
			GroupsRequestResult = GroupsQuery.Execute();
			AfterAccessGroupsRightsQuery(UpdateParameters);
			
			HasChanges = New Structure("AccessGroupRights, UserGroupRights", False, False);
			UpdateInitialGroupsRightsToAccessKey(GroupsRequestResult, GroupsRecordSet, "AccessGroup",
				AccessKey, RightsToKey.ForGroups, UpdateParameters, HasChanges);
			
			HasRightsChanges = HasChanges.AccessGroupRights Or HasChanges.UserGroupRights;
			
			If HasChanges.AccessGroupRights Or UpdateManually Then
				BeforeDerivedRightsChangesQuery(UpdateParameters);
				AccessGroupsSetsQueryResult = AccessGroupsSetsQuery.Execute();
				AfterDerivedRightsChangesQuery(UpdateParameters);
				UpdateDerivedRightsToAccessKey(AccessGroupsSetsQueryResult,
					AccessGroupsSetsRecordSet, "AccessGroupsSet", AccessKey, , UpdateParameters);
			EndIf;
			
			If UpdateParameters.CalculateUserRights Then
				PackageQueries = StrSplit(Query.Text, ";", False);
				If HasChanges.UserGroupRights Or UpdateManually Then
					Query.Text = PackageQueries[1];
					BeforeDerivedRightsChangesQuery(UpdateParameters);
					QueryResult = Query.Execute();
					AfterDerivedRightsChangesQuery(UpdateParameters);
					UpdateDerivedRightsToAccessKey(QueryResult,
						RecordSet, RightsOwnerFieldName, AccessKey, , UpdateParameters);
					RecordSet.Clear();
				EndIf;
				Query.Text = PackageQueries[0];
				BeforeUsersRightsQuery(UpdateParameters);
				UsersQueryResult = Query.Execute();
				AfterUsersRightsQuery(UpdateParameters);
				UpdateInitialUsersRightsToAccessKey(UsersQueryResult, RecordSet,
					RightsOwnerFieldName, AccessKey, RightsToAccessKeyForUsers, HasRightsChanges, UpdateParameters);
			EndIf;
			
			If NewKeysDetails = Undefined
			   AND HasRightsChanges
			   AND UpdateParameters.DependentListsByAccessKeys.Count() > 0 Then
				
				BeforePlanUpdate(UpdateParameters);
				ScheduleAccessKeysUsersUpdate(UpdateParameters.DependentListsByAccessKeys,
					"UpdateRightsToListAccessKey",
					Not UpdateParameters.ForExternalUsers,
					UpdateParameters.ForExternalUsers, ,
					New Structure("ByAccessKeys", AccessKey));
				AfterPlanUpdate(UpdateParameters);
			EndIf;
		EndIf;
		
		BeforeCommitTransaction(UpdateParameters);
		CommitTransaction();
		AfterCommitTransaction(UpdateParameters); // APK:330 is for performance analysis only.
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If HasRightsChanges AND UpdateParameters.Property("HasRightsChanges") Then
		UpdateParameters.HasRightsChanges = True;
	EndIf;
	
EndProcedure

// For the UpdateRightsToListAccessKey and UpdateAccessGroupsOfAllowedAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForAccessGroups()
	
	Return
	"SELECT
	|	AllRows.AccessGroupsSet AS AccessGroupsSet,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS AccessGroupsSet,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Folders AS GroupsInSets
	|			ON (GroupsInSets.Folder = AccessGroupsAccessKeys.AccessGroup)
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		&AllowedEmptySet,
	|		AccessGroupsAccessKeys.Update,
	|		AccessGroupsAccessKeys.Insert,
	|		1
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|	WHERE
	|		AccessGroupsAccessKeys.AccessGroup = VALUE(Catalog.AccessGroups.EmptyRef)
	|		AND AccessGroupsAccessKeys.AccessKey = &AccessKey
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.AccessGroupsSet,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.AccessGroupSetsAccessKeys AS OldData
	|	WHERE
	|		OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.AccessGroupsSet,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForUsers()
	
	Return
	"SELECT
	|	UsersAccessKeys.User AS User,
	|	UsersAccessKeys.Update AS Update,
	|	UsersAccessKeys.Insert AS Insert,
	|	UsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.UsersAccessKeys AS UsersAccessKeys
	|WHERE
	|	UsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT UsersAccessKeys.AreGroupSetRights
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.User AS User,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS User,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Folders AS GroupsInSets
	|			ON (GroupsInSets.Folder = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.UserGroups))
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.User,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.UsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.User,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey procedures.
Function DifferencesSelectionOfDerivedRightsQueryTextForExternalUsers()
	
	Return
	"SELECT
	|	ExternalUsersAccessKeys.ExternalUser AS ExternalUser,
	|	ExternalUsersAccessKeys.Update AS Update,
	|	ExternalUsersAccessKeys.Insert AS Insert,
	|	ExternalUsersAccessKeys.AreGroupSetRights AS AreGroupSetRights
	|FROM
	|	InformationRegister.ExternalUsersAccessKeys AS ExternalUsersAccessKeys
	|WHERE
	|	ExternalUsersAccessKeys.AccessKey = &AccessKey
	|	AND NOT ExternalUsersAccessKeys.AreGroupSetRights
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	AllRows.ExternalUser AS ExternalUser,
	|	AllRows.Update AS Update,
	|	AllRows.Insert AS Insert,
	|	TRUE AS AreGroupSetRights,
	|	SUM(AllRows.RowChangeKind) AS RowChangeKind
	|FROM
	|	(SELECT
	|		GroupsInSets.Ref AS ExternalUser,
	|		MAX(AccessGroupsAccessKeys.Update) AS Update,
	|		MAX(AccessGroupsAccessKeys.Insert) AS Insert,
	|		1 AS RowChangeKind
	|	FROM
	|		InformationRegister.AccessGroupsAccessKeys AS AccessGroupsAccessKeys
	|			INNER JOIN Catalog.SetsOfAccessGroups.Folders AS GroupsInSets
	|			ON (GroupsInSets.Folder = AccessGroupsAccessKeys.AccessGroup)
	|				AND (VALUETYPE(AccessGroupsAccessKeys.AccessGroup) = TYPE(Catalog.ExternalUsersGroups))
	|				AND (AccessGroupsAccessKeys.AccessKey = &AccessKey)
	|	
	|	GROUP BY
	|		GroupsInSets.Ref
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		OldData.ExternalUser,
	|		OldData.Update,
	|		OldData.Insert,
	|		-1
	|	FROM
	|		InformationRegister.ExternalUsersAccessKeys AS OldData
	|	WHERE
	|		OldData.AreGroupSetRights
	|		AND OldData.AccessKey = &AccessKey) AS AllRows
	|
	|GROUP BY
	|	AllRows.ExternalUser,
	|	AllRows.Update,
	|	AllRows.Insert
	|
	|HAVING
	|	SUM(AllRows.RowChangeKind) <> 0
	|
	|ORDER BY
	|	RowChangeKind";
	
EndFunction

// For the UpdateRightsToListAccessKey procedure.
Function NewAccessKeyAlreadyExists(NewKeysDetails, NewKeyDetails, UpdateParameters)
	
	KeysExistenceQuery = NewKeysDetails.KeysExistenceQuery;
	KeysExistenceQuery.SetParameter("Hash", NewKeyDetails.AccessKeyObject.Hash);
	
	If KeysExistenceQuery.Execute().IsEmpty() Then
		Return False;
	EndIf;
	
	KeysValuesQuery = NewKeysDetails.KeysValuesQuery;
	KeysValuesQuery.SetParameter("Hashes", NewKeyDetails.AccessKeyObject.Hash);
	
	KeysValuesQueryResults = KeysValuesQuery.ExecuteBatch();
	
	KeyTables = UpdateParameters.KeyTables;
	KeysRowsValuesKeys = ObjectsRowsValuesKeys(KeysValuesQueryResults,
		?(StrStartsWith(KeyTables[0], "Header"), 0, 1), KeyTables);
	
	For Each AccessKeyDetails In KeysRowsValuesKeys Do
		StringForHash = StringForAccessKeyHash(AccessKeyDetails.Value, KeyTables);
		If NewKeyDetails.StringForHash = StringForHash Then
			Ref = AccessKeyDetails.Key;
			NewKeyDetails.AccessKeyObject = New Structure("Ref", Ref);
			NotUsedSince = Common.ObjectAttributeValue(Ref, "NotUsedSince");
			If ValueIsFilled(NotUsedSince) Then
				Object = ServiceItem(Undefined, Ref);
				Object.NotUsedSince = '00010101';
				Object.Write();
			EndIf;
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialGroupsRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName,
			 AccessKey, RightsToKey, UpdateParameters, HasChanges)
	
	Selection = QueryResult.Select();
	AccessGroupType = UpdateParameters.AccessGroupType;
	HasAccessGroupsRightsChanges = False;
	HasUsersGroupsRightsChanges = False;
	
	WrittenItemsCount = 0;
	BeforeWriteRows(UpdateParameters);
	While Selection.Next() Do
		RightsOwner = Selection[RightsOwnerFieldName];
		Rights = RightsToKey.Get(RightsOwner);
		If Rights = Undefined Then
			RecordSet.Filter[RightsOwnerFieldName].Set(RightsOwner);
			RecordSet.Write();
			If TypeOf(RightsOwner) = AccessGroupType Then
				HasAccessGroupsRightsChanges = True;
			Else
				HasUsersGroupsRightsChanges = True;
			EndIf;
		ElsIf Selection.Update  = Rights.Update
		        AND Selection.Insert = Rights.Insert Then
			RightsToKey.Insert(RightsOwner, Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		Rights = RightsDetails.Value;
		If Rights = Null Then
			Continue;
		EndIf;
		RightsOwner = RightsDetails.Key;
		RecordSet.Filter[RightsOwnerFieldName].Set(RightsOwner);
		OneRecord[RightsOwnerFieldName]        = RightsOwner;
		OneRecord.Update                    = Rights.Update;
		OneRecord.Insert                   = Rights.Insert;
		RecordSet.Write();
		If TypeOf(RightsOwner) = AccessGroupType Then
			HasAccessGroupsRightsChanges = True;
		Else
			HasUsersGroupsRightsChanges = True;
		EndIf;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(UpdateParameters, WrittenItemsCount);
	
	HasChanges.AccessGroupRights       = HasAccessGroupsRightsChanges;
	HasChanges.UserGroupRights = HasUsersGroupsRightsChanges;
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateInitialUsersRightsToAccessKey(QueryResult, RecordSet,
			RightsOwnerFieldName, AccessKey, RightsToKey, HasRightsChanges, UpdateParameters)
	
	Selection = QueryResult.Select();
	
	WrittenItemsCount = 0;
	BeforeWriteRows(UpdateParameters);
	While Selection.Next() Do
		RightsOwner = Selection[RightsOwnerFieldName];
		Rights = RightsToKey.Get(RightsOwner);
		If Rights = Undefined Then
			RecordSet.Filter[RightsOwnerFieldName].Set(RightsOwner);
			RecordSet.Write();
			HasRightsChanges = True;
		ElsIf Selection.Update  = Rights.Update
		        AND Selection.Insert = Rights.Insert
		        AND Selection.AreGroupSetRights = False Then
			RightsToKey.Insert(RightsOwner, Null);
		EndIf;
	EndDo;
	
	OneRecord = RecordSet.Add();
	OneRecord.AccessKey = AccessKey;
	For Each RightsDetails In RightsToKey Do
		Rights = RightsDetails.Value;
		If Rights = Null Then
			Continue;
		EndIf;
		RightsOwner = RightsDetails.Key;
		RecordSet.Filter[RightsOwnerFieldName].Set(RightsOwner);
		OneRecord[RightsOwnerFieldName] = RightsOwner;
		OneRecord.Update  = Rights.Update;
		OneRecord.Insert = Rights.Insert;
		OneRecord.AreGroupSetRights = False;
		RecordSet.Write();
		HasRightsChanges = True;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(UpdateParameters, WrittenItemsCount);
	
EndProcedure

// For the UpdateRightsToListAccessKey procedure.
Procedure UpdateDerivedRightsToAccessKey(QueryResult, RecordSet, RightsOwnerFieldName,
			AccessKey, HasChanges = False, UpdateParameters = Undefined)
	
	Selection = QueryResult.Select();
	DeletionCompleted = False;
	
	WrittenItemsCount = 0;
	BeforeWriteRows(UpdateParameters);
	While Selection.Next() Do
		RecordSet.Filter[RightsOwnerFieldName].Set(Selection[RightsOwnerFieldName]);
		If Not DeletionCompleted AND Selection.RowChangeKind = 1 Then
			DeletionCompleted = True;
			OneRecord = RecordSet.Add();
			OneRecord.AccessKey = AccessKey;
		EndIf;
		If DeletionCompleted Then
			FillPropertyValues(OneRecord, Selection);
		EndIf;
		RecordSet.Write();
		HasChanges = True;
		WrittenItemsCount = WrittenItemsCount + 1;
	EndDo;
	AfterWriteRows(UpdateParameters, WrittenItemsCount);
	
EndProcedure

// Creates a catalog service item that does not subscribe to events.
Function ServiceItem(CatalogManager, Ref = Undefined)
	
	If Ref = Undefined Then
		CatalogItem = CatalogManager.CreateItem();
	Else
		CatalogItem = Ref.GetObject();
		If CatalogItem = Undefined Then
			Return Undefined;
		EndIf;
	EndIf;
	
	CatalogItem.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	CatalogItem.DataExchange.Recipients.AutoFill = False;
	CatalogItem.DataExchange.Load = True;
	
	Return CatalogItem;
	
EndFunction

// Creates a record set of a service register that does subscribe to events.
Function ServiceRecordSet(RegisterManager)
	
	RecordSet = RegisterManager.CreateRecordSet();
	RecordSet.AdditionalProperties.Insert("DisableObjectChangeRecordMechanism");
	RecordSet.DataExchange.Recipients.AutoFill = False;
	RecordSet.DataExchange.Load = True;
	
	Return RecordSet;
	
EndFunction

// For the FillTemplatesOfObjectCheckQueryParts procedure.
Function BatchSizeMarker()
	
	Return "995";
	
EndFunction

// For the RegisterAccessUpdatePlanning procedure.
Procedure RegisterAccessUpdatePlanningInLog(Lists, PlanningParameters)
	
	CommentForLog = NStr("ru = 'Источник'; en = 'Source'; pl = 'Źródło';de = 'Quelle';ro = 'Sursa';tr = 'Tedarikçi'; es_ES = 'Fuente'", Common.DefaultLanguageCode())
		+ ": " + PlanningParameters.Details + Chars.LF;
	
	If Lists.Count() > 1 Then
		CommentForLog = CommentForLog
			+ NStr("ru = 'Списки'; en = 'Lists'; pl = 'Listy';de = 'Listen';ro = 'Liste';tr = 'Listeler'; es_ES = 'Listas'", Common.DefaultLanguageCode()) + ":"
			+ Chars.LF + Chars.Tab + StrConcat(Lists, Chars.LF + Chars.Tab);
	Else
		CommentForLog = CommentForLog
			+ NStr("ru = 'Список'; en = 'List'; pl = 'Lista';de = 'Liste';ro = 'Listă';tr = 'Liste'; es_ES = 'Lista'", Common.DefaultLanguageCode());
		
		CommentForLog = CommentForLog + " = " + Lists[0];
	EndIf;
	
	CommentForLog = CommentForLog + Chars.LF + "IsSpotJob"
		+ " = " + ?(PlanningParameters.Property("IsSpotJob"), "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "DataAccessKeys"
		+ " = " + ?(PlanningParameters.DataAccessKeys, "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "AllowedAccessKeys"
		+ " = " + ?(PlanningParameters.AllowedAccessKeys, "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "ForUsers"
		+ " = " + ?(PlanningParameters.ForUsers, "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "ForExternalUsers"
		+ " = " + ?(PlanningParameters.ForExternalUsers, "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "IsUpdateContinuation"
		+ " = " + ?(PlanningParameters.IsUpdateContinuation, "Yes", "No");
	
	CommentForLog = CommentForLog + Chars.LF + "IsObsoleteItemsDataProcessor"
	 + " = " + ?(PlanningParameters.IsObsoleteItemsDataProcessor, "Yes", "No");
	
	LeadingObject = Undefined;
	If TypeOf(PlanningParameters.LeadingObject) = Type("Structure") Then
		If PlanningParameters.LeadingObject.Property("ByFieldsValues") Then
			Pointers = PlanningParameters.LeadingObject.ByFieldsValues.Details;
			LeadingObject = "ByFieldsValues";
		ElsIf PlanningParameters.LeadingObject.Property("ByAccessKeys") Then
			Pointers = PlanningParameters.LeadingObject.ByAccessKeys;
			LeadingObject = "ByAccessKeys";
		ElsIf PlanningParameters.LeadingObject.Property("ByValuesWithGroups") Then
			Pointers = PlanningParameters.LeadingObject.ByValuesWithGroups;
			LeadingObject = "ByValuesWithGroups";
		EndIf;
		If LeadingObject <> Undefined Then
			If TypeOf(Pointers) = Type("Array") AND Pointers.Count() > 1 Then
				LeadingObject = LeadingObject + ":";
				For Each Pointer In Pointers Do
					LeadingObject = LeadingObject + Chars.LF + """" + String(Pointer) + """ "
						+ LeadingObjectPointerDetails(Pointer, PlanningParameters);
				EndDo;
			Else
				Pointer = ?(TypeOf(Pointers) = Type("Array"), Pointers[0], Pointers);
				LeadingObject = LeadingObject + ": """ + String(Pointer) + """ "
					+ LeadingObjectPointerDetails(Pointer, PlanningParameters);
			EndIf;
		EndIf;
	EndIf;
	
	WriteLogEvent(
		NStr("ru = 'Управление доступом.Показатели.Планирование обновления доступа'; en = 'Access management.Indicators.Scheduling access update.'; pl = 'Kontrola dostępu.Wskaźniki.Planowanie aktualizacji dostępu';de = 'Zugangskontrolle.Indikatoren.Aufrufen der Update-Planung';ro = 'Administrarea accesului.Indicatori.Planificarea actualizării accesului';tr = 'Erişim kontrolü, göstergeler, erişim güncellemesi planlama.'; es_ES = 'Gestión de acceso.Indicadores.Planificación de actualización de acceso'",
		     Common.DefaultLanguageCode()),
		EventLogLevel.Information, ,
		LeadingObject,
		CommentForLog,
		?(TransactionActive(), EventLogEntryTransactionMode.Transactional, Undefined));
	
EndProcedure

// For the RegisterAccessUpdatePlanningInLog procedure.
Function LeadingObjectPointerDetails(Pointer, PlanningParameters)
	
	If PlanningParameters.Property("LeadingObjectsRefTypes") Then
		RefsTypes = PlanningParameters.LeadingObjectsRefTypes;
	Else
		RefsTypes = AccessManagementInternalCached.LeadingObjectsRefTypes();
		PlanningParameters.Insert("LeadingObjectsRefTypes", RefsTypes);
	EndIf;
	
	If RefsTypes.Get(TypeOf(Pointer)) <> Undefined Then
		Return GetURL(Pointer);
	EndIf;
	
	Details = "";
	For Each FilterItem In Pointer Do
		If Not FilterItem.Use Then
			Continue;
		EndIf;
		If RefsTypes.Get(TypeOf(FilterItem.Value)) <> Undefined Then
			ValueDetails = GetURL(FilterItem.Value);
		ElsIf TypeOf(FilterItem.Value) = Type("Undefined") Then
			ValueDetails = NStr("ru = 'Неопределено'; en = 'Undefined'; pl = 'Nieokreślone';de = 'Nicht definiert';ro = 'Nedefinit';tr = 'Tanımlanmamış'; es_ES = 'No definido'");
		Else
			ValueDetails = Format(FilterItem.Value, "NZ=0; DE='01.01.0001 00:00:00'");
		EndIf;
		Details = Details + ?(Details = "", "", ", ")
			+ FilterItem.Name + " = " + ValueDetails;
	EndDo;
	
	Return Details;
	
EndFunction

// To call from access update planning locations.
Procedure RegisterAccessUpdatePlanning(ListsByIDs, PlanningParameters, AllLists = False)
	
	If Not RegisterAccessUpdatePlanningIndicators() Then
		Return;
	EndIf;
	
	If PlanningParameters = Undefined Then
		PlanningParameters = AccessUpdatePlanningParameters();
	EndIf;
	
	Lists = New Array;
	
	If Not AllLists Then
		For Each ListDetails In ListsByIDs Do
			If ValueIsFilled(ListDetails.Value) Then
				Lists.Add(ListDetails.Value);
			Else
				Lists.Add(FullListName(ListDetails.Key));
			EndIf;
		EndDo;
	Else
		Lists.Add("All");
	EndIf;
	
	RegisterAccessUpdatePlanningInLog(Lists, PlanningParameters);
	
EndProcedure

// For the RegisterAccessUpdatePlanning procedure.
Function FullListName(ListDetails)
	
	If TypeOf(ListDetails) = Type("CatalogRef.MetadataObjectIDs")
	 Or TypeOf(ListDetails) = Type("CatalogRef.ExtensionObjectIDs") Then
		
		MetadataObject = Common.MetadataObjectByID(ListDetails, False);
		
		If TypeOf(MetadataObject) = Type("MetadataObject") Then
			Return MetadataObject.FullName();
		Else
			Return Common.ObjectAttributeValue(ListDetails, "FullName");
		EndIf;
	Else
		Return String(ListDetails);
	EndIf;
	
EndFunction

// For the AccessManagement. procedure.DisableAccessKeysUpdate.
Procedure AddDependentLists(Lists, AddedLists) Export
	
	InitialLists = New FixedArray(Lists);
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	
	For Each InitialList In InitialLists Do
		Properties = ActiveParameters.LeadingLists.Get(InitialList);
		If Properties = Undefined Then
			Continue;
		EndIf;
		For Each KeyAndValue In Properties.DependentLists Do
			If AddedLists.Get(KeyAndValue.Key) = Undefined Then
				Lists.Add(KeyAndValue.Key);
				AddedLists.Insert(KeyAndValue.Key, True);
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

Function DataRestrictionsDetails() Export
	
	CommonContext = New Structure;
	CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	
	Result = New Map;
	
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		Result.Insert(FullName, RestrictionDetails);
	EndDo;
	
	Return Result;
	
EndFunction

#Region ParametersToOverrideThroughConfigurationUpdate

Function HoursOfNotUsedItemsBecomingObsoleteCount()
	
	Return 47;
	
EndFunction

Function HoursCountBetweenPlanningToProcessObsoleteItems()
	
	Return 48;
	
EndFunction

Function MaxCountOfMinutesToPerformBackgroundAccessUpdateJob()
	
	Return 2;
	
EndFunction

Function MaxWaitSecondsCountOfWaitingForOneJobInThreadToBeProcessed()
	
	Return 900; // 15 minutes (for example, excessively long SQL request).
	
EndFunction

Function MinSecondsCountOfBatchProcessingInSingleThread()
	
	Return 1;
	
EndFunction

Function SpotJobExecutionMinSecondsCount()
	
	Return 15;
	
EndFunction

Function LoadFreeThreadsWithNextJobsAtLongQueries()
	
	Return False;
	
EndFunction

Function MaxGettingBatchesByQueryPeriod()
	
	Return "Year"; // Year, Quarter, Month, Week.
	
EndFunction

Function StartGotBatchesUpdateOnGetNewBatches()
	
	Return False;
	
EndFunction

Function DataItemsInQueryCount()
	
	Return 1000;
	
EndFunction

Function DataItemsInBatchCount()
	
	Return 1000;
	
EndFunction

Function AccessKeysInQueryCount()
	
	Return 1000;
	
EndFunction

Function AccessKeysInBatchCount()
	
	Return 200;
	
EndFunction

Function WriteOnlyChangedDataItemsAccessKeys()
	
	Return False;
	
EndFunction

Function MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes()
	
	Return 100;
	
EndFunction

Function RegisterAccessUpdateIndicators()
	
	Return True;
	
EndFunction

Function RegisterAccessUpdatePlanningIndicators()
	
	Return False;
	
EndFunction

#EndRegion

#Region AttachmentPointsToAnalyseProductivityThroughConfigurationExtension

Procedure BeforeDataLock(UpdateParameters)
	Return;
EndProcedure

Procedure AfterDataLock(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeCurrentAccessKeysQuery(UpdateParameters)
	Return;
EndProcedure

Procedure AfterCurrentAccessKeysQuery(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeWriteRows(UpdateParameters)
	Return;
EndProcedure

Procedure AfterWriteRows(UpdateParameters, WrittenItemsCount)
	Return;
EndProcedure

Procedure BeforeCommitTransaction(UpdateParameters)
	Return;
EndProcedure

Procedure AfterCommitTransaction(UpdateParameters)
	Return;
EndProcedure

Procedure BeforePlanUpdate(UpdateParameters)
	Return;
EndProcedure

Procedure AfterPlanUpdate(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeWriteNewKey(UpdateParameters)
	Return;
EndProcedure

Procedure AfterWriteNewKey(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeAccessGroupsRightsQuery(UpdateParameters)
	Return;
EndProcedure

Procedure AfterAccessGroupsRightsQuery(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeDerivedRightsChangesQuery(UpdateParameters)
	Return;
EndProcedure

Procedure AfterDerivedRightsChangesQuery(UpdateParameters)
	Return;
EndProcedure

Procedure BeforeUsersRightsQuery(UpdateParameters)
	Return;
EndProcedure

Procedure AfterUsersRightsQuery(UpdateParameters)
	Return;
EndProcedure

#EndRegion

#EndRegion

#Region AccessRestrictionParameters

#Region AccessRestrictionParametersMainPart

// The main function that returns the parameters required for registering necessity to update access 
// keys to data items.
Function ListPropertiesAsLeadingOne(FullName, TransactionID = Undefined, RepeatedCall = False)
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, Undefined, RepeatedCall);
	StoredListPropertiesAsLeadingOne = ActiveParameters.LeadingLists.Get(FullName);
	
	If StoredListPropertiesAsLeadingOne = Undefined Then
		Return Undefined;
	EndIf;
	
	Cache = RestrictionParametersCache();
	
	ListPropertiesAsLeadingOne = Cache.LeadingListsChecked.Get(FullName);
	If ListPropertiesAsLeadingOne <> Undefined Then
		Return ListPropertiesAsLeadingOne;
	EndIf;
	
	ListPropertiesAsLeadingOne = New Structure(StoredListPropertiesAsLeadingOne);
	Cancel = False;
	FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName,
		ListPropertiesAsLeadingOne, Cancel);
	
	If Not Cancel Then
		Cache.LeadingListsChecked.Insert(FullName,
			New FixedStructure(ListPropertiesAsLeadingOne));
		
		Return ListPropertiesAsLeadingOne;
	EndIf;
	
	If RepeatedCall Then
		Raise StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось подготовить свойства списка ""%1"" как ведущего,
			           |из-за некорректного состояния параметров ограничения доступа.'; 
			           |en = 'Cannot prepare properties of the ""%1"" list as leading
			           |due to the incorrect state of access restriction parameters.'; 
			           |pl = 'Nie udało się przygotować właściwości listy ""%1"" jako listy głównej,
			           |ze względu na niepoprawny stan parametrów ograniczenia dostępu.';
			           |de = '
			           |Aufgrund des falschen Zustands der Zugriffsbeschränkungsparameter war es nicht möglich, die Eigenschaften der ""%1"" Liste als Master aufzubereiten.';
			           |ro = 'Eșec la pregătirea proprietăților listei ""%1"" ca principală,
			           |din cauza statutului incorect al parametrilor de restricționare a accesului.';
			           |tr = 'Erişim kısıtlama parametrelerinin hatalı durumundan dolayı ""%1"" özellikleri ana 
			           |liste olarak hazırlanamadı.'; 
			           |es_ES = 'No se ha podido preparar las propiedades de la lista ""%1"" como principal
			           |a causa del estado incorrecto de parámetros de restricción de acceso.'"),
			FullName);
	EndIf;
	
	Return ListPropertiesAsLeadingOne(FullName, TransactionID, True);
	
EndFunction

// For the ListPropertiesAsLeadingOne function, the FillRestrictionParameters,
// UpdateTransactionIDs, and SetParameterVersion procedures.
//
Function RestrictionParametersCache()
	
	CachedDataKey = String(SessionParameters.CachedDataKey);
	
	Return AccessManagementInternalCached.RestrictionParametersCache(CachedDataKey);
	
EndFunction

// For the ListPropertiesAsLeadingOne function.
Procedure FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges(FullName, Properties, Cancel)
	
	Properties.Delete("DependentLists");
	If Properties.ByFieldsValues = Undefined Then
		Return;
	EndIf;
	
	ByFieldsValues = New Structure(Properties.ByFieldsValues);
	MetadataObject = Metadata.FindByFullName(FullName);
	
	If ByFieldsValues.IsReferenceType Then
		If ValueIsFilled(ByFieldsValues.HeaderFields.AllFields) Then
			QueryText =
			"SELECT
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	(SELECT
			|		TRUE AS TrueValue) AS TrueValue
			|		LEFT JOIN CurrentDataItemTable AS CurrentTable
			|		ON (CurrentTable.Ref = &ObjectRef)";
			FillCurrentTableSelectionFields(QueryText,
				FullName, ByFieldsValues.HeaderFields.AllFields, MetadataObject, Cancel);
		Else
			QueryText = "";
		EndIf;
		
		For Each TabularSection In ByFieldsValues.TabularSections Do
			Collections = New Structure("StandardTabularSections, TabularSections");
			FillPropertyValues(Collections, MetadataObject);
			TableMetadata = Undefined;
			If TypeOf(Collections.TabularSections) = Type("MetadataObjectCollection") Then
				TableMetadata = MetadataObject.TabularSections.Find(TabularSection.Name);
			EndIf;
			If TableMetadata = Undefined
			   AND TypeOf(Collections.StandardTabularSections) = Type("StandardTabularSectionDescriptions") Then
				For Each StandardTabularSection In Collections.StandardTabularSections Do
					If StandardTabularSection.Name = TabularSection.Name Then
						TableMetadata = StandardTabularSection;
						Break;
					EndIf;
				EndDo;
			EndIf;
			If TableMetadata = Undefined Then
				Cancel = True;
				Break;
			EndIf;
			
			TabularSectionQueryText =
			"SELECT DISTINCT TOP 100
			|	CurrentTable.Field1 AS Field1
			|FROM
			|	CurrentDataItemTable AS CurrentTable
			|WHERE
			|	CurrentTable.Ref = &ObjectRef";
			FillCurrentTableSelectionFields(TabularSectionQueryText,
				FullName + "." + TabularSection.Name, TabularSection.AllFields, TableMetadata, Cancel, True);
			
			QueryText = QueryText + ?(QueryText = "", "",
				Common.QueryBatchSeparator()) + TabularSectionQueryText;
		EndDo;
		
	ElsIf ValueIsFilled(ByFieldsValues.HeaderFields.AllFields) Then
		QueryText =
		"SELECT DISTINCT TOP 100
		|	CurrentTable.Field1 AS Field1
		|FROM
		|	CurrentDataItemTable AS CurrentTable
		|WHERE
		|	&FilterByDimensions";
		FillCurrentTableSelectionFields(QueryText,
			FullName, ByFieldsValues.HeaderFields.AllFields, MetadataObject, Cancel);
	Else
		QueryText = "";
	EndIf;
	
	ByFieldsValues.Insert("QueryText", QueryText);
	Properties.ByFieldsValues = New FixedStructure(ByFieldsValues);
	
EndProcedure

// For the FillPreviousValuesQueryTextToCheckLeadingListFieldsChanges procedure.
Procedure FillCurrentTableSelectionFields(QueryText, FullName, FieldsDetails,
			TableMetadata, Cancel, IsTabularSection = False)
	
	FieldsCollections = New Structure("Attributes, Dimensions, Resources, StandardAttributes");
	FillPropertyValues(FieldsCollections, TableMetadata);
	
	SelectionFields = "";
	For Each FieldDetails In FieldsDetails Do
		FieldName = ?(TypeOf(FieldsDetails) = Type("FixedArray"), FieldDetails, FieldDetails.Key);
		
		If Not FieldExists(FieldsCollections.Attributes, FieldName)
		   AND Not FieldExists(FieldsCollections.Dimensions, FieldName)
		   AND Not FieldExists(FieldsCollections.Resources, FieldName)
		   AND Not FieldExists(FieldsCollections.StandardAttributes, FieldName)
		   AND Not (IsTabularSection
		         AND (Upper(FieldName) = Upper("Ref")
		            Or Upper(FieldName) = Upper("Ref"))) Then
			
			Cancel = True;
			Break;
		EndIf;
		
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + FieldName + " AS " + FieldName;
	EndDo;
	QueryText = StrReplace(QueryText,
		"CurrentTable.Field1 AS Field1", TextWithIndent(TrimL(SelectionFields), "	"));
	
	QueryText = StrReplace(QueryText, "CurrentDataItemTable", FullName);
	
	QueryText = StrReplace(QueryText, "TOP 100", "TOP " + Format(
		MaxCombinationsCountOfLeadingFieldsValuesOnCalculateContentOfChangedOnes() * 10, "NG="));
	
EndProcedure

// For the FillCurrentTableSelectionFields procedure.
Function FieldExists(Collection, FieldName)
	
	If TypeOf(Collection) = Type("MetadataObjectCollection") Then
		Return Collection.Find(FieldName) <> Undefined;
		
	ElsIf TypeOf(Collection) = Type("StandardAttributeDescriptions") Then
		For Each StandardAttribute In Collection Do
			If StandardAttribute.Name = FieldName Then
				Return True;
			EndIf;
		EndDo;
	EndIf;
	
	Return False;
	
EndFunction

// The main function that returns the parameters required for checking rights upon recording data items.
Function RestrictionParameters(FullName, TransactionID = Undefined, ForExternalUsers = Undefined) Export
	
	SetSafeModeDisabled(True);
	SetPrivilegedMode(True);
	
	ActiveAccessRestrictionParameters(TransactionID, Undefined, False);
	Parameters = RestrictionParametersCache().ListsRestrictions.Get(FullName);
	
	If Parameters = Undefined Then
		FillRestrictionParameters(FullName, TransactionID, False);
		
		ActiveAccessRestrictionParameters(TransactionID, Undefined, False);
		Parameters = RestrictionParametersCache().ListsRestrictions.Get(FullName);
	EndIf;
	
	If ForExternalUsers = Undefined Then
		ForExternalUsers = Users.IsExternalUserSession();
	EndIf;
	
	If ForExternalUsers Then
		Return Parameters.ForExternalUsers;
	EndIf;
	
	Return Parameters.ForUsers;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions.
Procedure FillRestrictionParameters(FullName, TransactionID, ActiveParametersUpdated,
			ListsRestrictionsToAdd = Undefined, CommonContext = Undefined, RepeatedCall = False)
	
	If CommonContext = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation();
		CommonContext.Insert("RestrictionsDetails", New Map);
	EndIf;
	
	ListsRestrictionParameters = New Map;
	ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext, False);
	FullNameOnLoop = "";
	
	AddListRestrictionParameters(FullName, ListsRestrictionParameters,
		ActiveParameters, ActiveParametersUpdated, TransactionID, CommonContext);
	
	If ActiveParametersUpdated Then
		If RepeatedCall Then
			FullNameOnLoop = FullName;
		Else
			FillRestrictionParameters(FullName,
				TransactionID, False, ListsRestrictionsToAdd, CommonContext, True);
			Return;
		EndIf;
	EndIf;
	
	If ValueIsFilled(FullNameOnLoop) Then
		Raise StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не удалось обновить параметры ограничения доступа списка ""%1""
			           |из-за нестабильной строки свойств версии параметров для вычисления хеш-суммы.'; 
			           |en = 'Cannot update parameters of the ""%1"" list access restriction
			           |due to not stable string of the parameter version properties for calculating a hash sum.'; 
			           |pl = 'Nie można zaktualizować
			           |parametrów ograniczenia dostępu do listy ""%1"" ze względu na niestabilny ciąg właściwości wersji parametru do obliczenia sumy kontrolnej.';
			           |de = 'Es war nicht möglich, die Parameter der Zugriffsbeschränkung der Liste ""%1""
			           |zu aktualisieren, da die Eigenschaften der Version der Parameter zur Berechnung der Hash-Summe instabil sind.';
			           |ro = 'Eșec la actualizarea parametrilor de restricționare a accesului listei ""%1""
			           |din cauza rândului nestabil al proprietăților versiunii parametrilor pentru calculul sumei hash.';
			           |tr = 'Karma toplamı hesaplamak için parametrelerin sürümünün kararsız özellik  dizesi nedeniyle ""%1"" 
			           |liste erişim kısıtlaması ayarları güncellenemedi.'; 
			           |es_ES = 'No se ha podido actualizar los parámetros de restricción de acceso de la lista ""%1""
			           |a causa de una línea inestable de las propiedades de la versión de parámetros para calcular el importe hash.'"),
			FullNameOnLoop);
	EndIf;
	
	If ListsRestrictionParameters.Count() = 0 Then
		Return;
	EndIf;
	
	If ListsRestrictionsToAdd <> Undefined Then
		ListsRestrictionsToAdd = ListsRestrictionParameters;
		Return;
	EndIf;
	
	Cache = RestrictionParametersCache();
	
	For Each KeyAndValue In ListsRestrictionParameters Do
		Cache.ListsRestrictions.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
EndProcedure

// For the FillRestrictionParameters procedure,
// StoredAccessRestrictionParameters, and AccessRestrictionsErrors functions.
//
Function CommonContextOfRestrictionParametersCalculation(AllAccessKindsUsed = False, FillListsWithRestriction = True)
	
	UserTypes = New Array;
	UserTypes.Add(Type("CatalogRef.Users"));
	UserTypes.Add(Type("CatalogRef.UserGroups"));
	UserTypes.Add(Type("CatalogRef.ExternalUsers"));
	UserTypes.Add(Type("CatalogRef.ExternalUsersGroups"));
	
	ValuesTypesToUse = New Map;
	
	AccessKindsProperties = AccessManagementInternalCached.AccessKindsProperties();
	
	For Each AccessKindProperties In AccessKindsProperties.Array Do
		If Not AllAccessKindsUsed
		   AND Not AccessKindUsed(AccessKindProperties.Ref) Then
			Continue;
		EndIf;
		ValuesTypesToUse.Insert(AccessKindProperties.ValuesType, True);
		For Each AdditionalTypeDetails In AccessKindProperties.AdditionalTypes Do
			ValuesTypesToUse.Insert(AdditionalTypeDetails.ValuesType, True);
		EndDo;
	EndDo;
	
	AvailableRights = AccessManagementInternalCached.RightsForObjectsRightsSettingsAvailable();
	ExternalUsersEnabled = AllAccessKindsUsed
		Or Constants.UseExternalUsers.Get();
	
	CommonContext = New Structure;
	CommonContext.Insert("AccessKindsProperties",         AccessKindsProperties);
	CommonContext.Insert("UserTypes",             UserTypes);
	CommonContext.Insert("ValuesTypesToUse",     ValuesTypesToUse);
	CommonContext.Insert("RightsSettingsOwnersTypes",   AvailableRights.ByRefsTypes);
	CommonContext.Insert("SeparateRightsSettingsTables", AvailableRights.SeparateTables);
	CommonContext.Insert("ExternalUsersEnabled",  ExternalUsersEnabled);
	
	If FillListsWithRestriction Then
		CommonContext.Insert("ListsWithRestriction", AccessManagementInternalCached.ListsWithRestriction());
	EndIf;
	
	Return CommonContext;
	
EndFunction

// For the FillRestrictionParameters procedure.
Procedure AddListRestrictionParameters(FullName, ListsRestrictionParameters, ActiveParameters,
			ActiveParametersUpdated, TransactionID, CommonContext)
	
	If RestrictionParametersCache().ListsRestrictions.Get(FullName) <> Undefined Then
		Return;
	EndIf;
	
	RestrictionsVersion = ActiveParameters.ListsRestrictionsVersions.Get(FullName);
	CalculatedParameters = CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters);
	
	If RestrictionsVersion <> CalculatedParameters.Version Then
		ActiveParameters = ActiveAccessRestrictionParameters(TransactionID, CommonContext, True);
		ActiveParametersUpdated = True;
		Return;
	EndIf;
	
	ListsRestrictionParameters.Insert(FullName,
		Common.FixedData(CalculatedParameters));
	
EndProcedure

// For the AddListRestrictionParameters procedure.
Function CalculatedRestrictionParameters(FullName, CommonContext, ActiveParameters)
	
	RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
	
	ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers, RestrictionDetails.TextInManagerModule, True);
	
	AdditionalContext = NewAdditionalContext();
	FillPropertyValues(AdditionalContext, ActiveParameters.AdditionalContext.ForExternalUsers);
	AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
	
	ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
	
	// Filling in parameters based on parameters of both user kinds.
	Version = CommonVersion(CommonContext, FullName, ResultForUsers.Version, ResultForExternalUsers.Version);
	SetAccessKeysRecordProperties(ResultForUsers);
	SetAccessKeysRecordProperties(ResultForExternalUsers);
	WithTwoKeysRecord = Not ResultForUsers.DoNotWriteAccessKeys AND Not ResultForExternalUsers.DoNotWriteAccessKeys;
	WithoutKeysRecord    =    ResultForUsers.DoNotWriteAccessKeys AND    ResultForExternalUsers.DoNotWriteAccessKeys;
	ResultForUsers.Insert(       "WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForExternalUsers.Insert("WriteAccessKeysForUsersAndExternalUsers", WithTwoKeysRecord);
	ResultForUsers.Insert(       "DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", WithoutKeysRecord);
	
	// Generating query texts.
	AddQueryTextsToRestrictionParameters(ResultForUsers);
	AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
	
	LeadingLists = New Structure;
	LeadingLists.Insert("ForUsers",        ResultForUsers.LeadingLists);
	LeadingLists.Insert("ForExternalUsers", ResultForExternalUsers.LeadingLists);
	
	Parameters = New Structure;
	Parameters.Insert("Version",                  Version);
	Parameters.Insert("LeadingLists",           LeadingLists);
	Parameters.Insert("ForUsers",        ResultForUsers);
	Parameters.Insert("ForExternalUsers", ResultForExternalUsers);
	
	Return Parameters;
	
EndFunction

// For the AccessRestrictionErrors function.
Function AccessRestrictionError(CommonContext, FullName)
	
	ErrorTextForUsers = "";
	ErrorTextForExternalUsers = "";
	
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		ErrorInformation = ErrorInfo();
		Return DetailErrorDescription(ErrorInformation);
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Return RestrictionDetails;
	EndIf;
	
	// For users.
	RestrictionStructureForUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.Text, RestrictionDetails.TextInManagerModule, False, True);
	
	If RestrictionStructureForUsers <> Undefined
	   AND RestrictionStructureForUsers.ErrorsDescription.HasErrors Then
		
		ErrorTextForUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForUsers.ErrorsDescription, False, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, False);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForUsers, False, CommonContext, AdditionalContext);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа для пользователей по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters for users due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu dla użytkowników z powodu:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung für Benutzer konnten aus diesem Grund nicht gebildet werden:
					           |%1';
					           |ro = 'Eșec la generarea parametrilor de restricționare a accesului pentru utilizatori din motivul:
					           |%1';
					           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması ayarları oluşturulamadı: 
					           |%1'; 
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios a causa de:
					           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForUsers) Then
			ResultForUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			SetAccessKeysRecordProperties(ResultForUsers);
			ResultForUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			Try
				AddQueryTextsToRestrictionParameters(ResultForUsers);
			Except
				ErrorInformation = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для пользователей по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters
						           |for users due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu
						           |dla użytkowników z powodu:
						           |%1';
						           |de = 'Die Texte von Anfragen konnten aufgrund der Parameter der Zugriffsbeschränkung
						           |für Benutzer aus diesem Grund nicht gebildet werden:
						           |%1';
						           |ro = 'Eșec la generarea textelor interogărilor în baza parametrilor restricției de acces
						           |pentru utilizatori din motivul:
						           |%1';
						           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması ayarlarına göre 
						           | istek metinleri oluşturulamadı:
						           |%1'; 
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios a causa de:
						           |%1'"), DetailErrorDescription(ErrorInformation));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	// For external users.
	RestrictionStructureForExternalUsers = CalculatedRestrictionStructure(FullName,
		RestrictionDetails.TextForExternalUsers, RestrictionDetails.TextInManagerModule, True, True);
	
	If RestrictionStructureForExternalUsers <> Undefined
	   AND RestrictionStructureForExternalUsers.ErrorsDescription.HasErrors Then
		
		ErrorTextForExternalUsers = ErrorsTextToCallException(FullName,
			RestrictionStructureForExternalUsers.ErrorsDescription, True, RestrictionDetails.TextInManagerModule);
	Else
		AdditionalContext = NewAdditionalContext();
		AddAdditionalContext(FullName, AdditionalContext, RestrictionDetails, True);
		
		ErrorOnCallException = New Structure("Text", Undefined);
		AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
		Try
			ResultForExternalUsers = RestrictionParametersByRestrictionStructure(FullName,
				RestrictionStructureForExternalUsers, True, CommonContext, AdditionalContext);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				ErrorTextForExternalUsers = ErrorOnCallException.Text;
			Else
				ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа для внешних пользователей по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters for external users due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu dla użytkowników zewnętrznych z powodu:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung für externe Benutzer konnten aus diesem Grund nicht gebildet werden:
					           |%1';
					           |ro = 'Eșec la generarea parametrilor de restricționare a accesului pentru utilizatori externi din motivul:
					           |%1';
					           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması parametreleri oluşturulamadı: 
					           |%1'; 
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso para los usuarios externos a causa de:
					           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
		EndTry;
		
		If Not ValueIsFilled(ErrorTextForExternalUsers) Then
			ResultForExternalUsers.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
			SetAccessKeysRecordProperties(ResultForExternalUsers);
			ResultForExternalUsers.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
			Try
				AddQueryTextsToRestrictionParameters(ResultForExternalUsers);
			Except
				ErrorInformation = ErrorInfo();
				If ValueIsFilled(ErrorOnCallException.Text) Then
					ErrorTextForExternalUsers = ErrorOnCallException.Text;
				Else
					ErrorTextForExternalUsers = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа
						           |для внешних пользователей по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters
						           |for external users due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu
						           |dla użytkowników zewnętrznych z powodu:
						           |%1';
						           |de = 'Die Texte von Abfragen konnten aus diesem Grund nicht auf der Grundlage der Parameter der Zugriffsbeschränkung
						           |für externe Benutzer gebildet werden:
						           |%1';
						           |ro = 'Eșec la generarea textelor interogărilor în baza parametrilor restricției de acces
						           |pentru utilizatorii externi din motivul:
						           |%1';
						           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması parametrelerine göre 
						           | istek metinleri oluşturulamadı:
						           |%1'; 
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso
						           |para los usuarios externos a causa de:
						           |%1'"), DetailErrorDescription(ErrorInformation));
				EndIf;
			EndTry;
		EndIf;
	EndIf;
	
	Return TrimAll(ErrorTextForUsers
		+ Chars.LF + Chars.LF + ErrorTextForExternalUsers);
	
EndFunction

// For the AccessRestrictionCheckResult function.
Function ObjectAccessRestrictionCheckResult(FullName, Val AdditionalParameters)
	
	If Not ValueIsFilled(AdditionalParameters) Then
		AdditionalParameters = New Structure;
		AdditionalParameters.Insert("Text", Undefined);
		AdditionalParameters.Insert("TextForExternalUsers", Undefined);
		AdditionalParameters.Insert("ConsiderDependencies", False);
	EndIf;
	
	ForUsers        = RestrictionCheckResultStructureForUsersKind();
	ForExternalUsers = RestrictionCheckResultStructureForUsersKind();
	
	Result = New Structure;
	Result.Insert("RestrictionDetailsError", "");
	Result.Insert("TextInManagerModule",     Undefined);
	Result.Insert("ForUsers",          ForUsers);
	Result.Insert("ForExternalUsers",   ForExternalUsers);
	Result.Insert("ImplementationSettings",        New Structure);
	
	CommonContext = Undefined;
	Try
		CommonContext = CommonContextOfRestrictionParametersCalculation(True, False);
	Except
		ErrorInformation = ErrorInfo();
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
	EndTry;
	
	If CommonContext = Undefined Then
		Return Result;
	EndIf;
	
	DependenciesAccountingAvailable = True;
	ListsWithRestriction = Undefined;
	Try
		ListsWithRestriction = AccessManagementInternalCached.ListsWithRestriction();
	Except
		ErrorInformation = ErrorInfo();
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
		DependenciesAccountingAvailable = False;
	EndTry;
	
	If ListsWithRestriction <> Undefined Then
		ListsWithRestriction = New Map(ListsWithRestriction);
	Else
		ListsWithRestriction = New Map;
		DependenciesAccountingAvailable = False;
	EndIf;
	CommonContext.Insert("ListsWithRestriction", ListsWithRestriction);
	
	RestrictionDetails = Undefined;
	Try
		RestrictionDetails = DataRestrictionDetails(CommonContext, FullName, True);
	Except
		Result.RestrictionDetailsError = DetailErrorDescription(ErrorInformation);
		DependenciesAccountingAvailable = False;
	EndTry;
	If TypeOf(RestrictionDetails) = Type("String") Then
		Result.RestrictionDetailsError = RestrictionDetails;
		RestrictionDetails = Undefined;
	EndIf;
	
	If RestrictionDetails <> Undefined Then
		Result.TextInManagerModule                    = RestrictionDetails.TextInManagerModule;
		ForUsers.RestrictionInModule                = RestrictionDetails.Text;
		ForUsers.ByOwnerWithoutSavingAccessKeys = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
		ForExternalUsers.RestrictionInModule         = RestrictionDetails.TextForExternalUsers;
		ForExternalUsers.ByOwnerWithoutSavingAccessKeys =
			RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
		
		If AdditionalParameters.Text = Undefined Then
			ForUsers.RestrictionToCheck = ForUsers.RestrictionInModule;
		Else
			ForUsers.RestrictionToCheck = AdditionalParameters.Text;
			RestrictionDetails.Text               = AdditionalParameters.Text;
		EndIf;
		
		If AdditionalParameters.TextForExternalUsers = Undefined Then
			ForExternalUsers.RestrictionToCheck = ForExternalUsers.RestrictionInModule;
		Else
			ForExternalUsers.RestrictionToCheck   = AdditionalParameters.TextForExternalUsers;
			RestrictionDetails.TextForExternalUsers = AdditionalParameters.TextForExternalUsers;
		EndIf;
	EndIf;
	
	If ListsWithRestriction.Get(FullName) = Undefined Then
		ListsWithRestriction.Insert(FullName, True);
		Result.TextInManagerModule = Undefined;
	EndIf;
	
	Context = New Structure;
	Context.Insert("FullName",                FullName);
	Context.Insert("CommonResult",           Result);
	Context.Insert("CommonContext",            CommonContext);
	Context.Insert("RestrictionDetails",      RestrictionDetails);
	Context.Insert("ConsiderDependencies",     AdditionalParameters.ConsiderDependencies);
	Context.Insert("DependenciesAccountingAvailable", DependenciesAccountingAvailable);
	Context.Insert("ListsRestrictionsVersions", New Map);
	Context.Insert("LeadingLists",            New Map);
	Context.Insert("AdditionalContext",   New Structure("ForUsers, ForExternalUsers"));
	
	CheckRestrictionForUsersKind(Context, ForUsers, False,
		Context.AdditionalContext.ForUsers);
	
	CheckRestrictionForUsersKind(Context, ForExternalUsers, True,
		Context.AdditionalContext.ForExternalUsers);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return Result;
	EndIf;
	
	If AdditionalParameters.ConsiderDependencies Then
		CommonContext.Insert("SpecialFullName", FullName);
		CommonContext.Insert("SpeacialRestrictionDetails", RestrictionDetails);
		CommonContext.Insert("ListsWithRestriction", New FixedMap(ListsWithRestriction));
		NewStoredParameters = StoredAccessRestrictionParameters(CommonContext);
		ActiveParameters = New Structure(NewStoredParameters.ForWritingObjectsAndCheckingRights.Get());
		If ActiveParameters.ListsRestrictionsVersions.Get(FullName) = Undefined Then
			Context.ListsRestrictionsVersions.Insert(FullName, True);
		Else
			Context.ListsRestrictionsVersions.Insert(FullName,
				ActiveParameters.ListsRestrictionsVersions.Get(FullName));
		EndIf;
	Else
		Context.ListsRestrictionsVersions.Insert(FullName, True);
		ActiveParameters = New Structure;
		ActiveParameters.Insert("AdditionalContext", Context.AdditionalContext);
	EndIf;
	ActiveParameters.Insert("ListsRestrictionsVersions", Context.ListsRestrictionsVersions);
	ActiveParameters.Insert("LeadingLists",            Context.LeadingLists);
	
	Settings = ImplementationSettings(ActiveParameters);
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	SetImplementationSettings(Result.ImplementationSettings, Settings, TablesTypesByNames);
	
	Result.ForUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Result.ForExternalUsers.RestrictionInRoles = Settings.RestrictionsInRoles.ForExternalUsers.Get(
		XMLFullName(FullName, TablesTypesByNames));
	
	Return Result;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Procedure SetImplementationSettings(ImplementationSettings, Data, TablesTypesByNames)
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessValues, "AccessValue");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
		Data.AccessKeysValuesOwners.References, "AccessKeysValuesOwner");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Objects, "AccessKeysValuesOwnerObject");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.Documents, "AccessKeysValuesOwnerDocument");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.RecordSets, "AccessKeysValuesOwnerRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, False,
		Data.AccessKeysValuesOwners.CalculationRegisterRecordSets,
			"AccessKeysValuesOwnerCalculationRegisterRecordSet");
	
	ImplementationSettings.Insert("RegisterAccessKeysRegisterField", "");
	ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister", Undefined);
	For Each KeyAndValue In Data.KeysRegistersDimensionsTypes Do
		If StrFind(KeyAndValue.Key, ".") > 0 Then
			Continue;
		EndIf;
		KeysRegisterName = KeyAndValue.Key;
		
		If KeysRegisterName = "AccessKeysForRegisters" Then
			AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, True,
				KeyAndValue.Value.TypesNames, "RegisterAccessKeysRegisterField");
		Else
			RegisterDimensions = Metadata.InformationRegisters[KeysRegisterName].Dimensions;
			TypesList = "";
			FieldNumber = 1;
			For Each RegisterFieldsDetails In KeyAndValue.Value.RegistersFields Do
				Break;
			EndDo;
			For Each FieldDetails In RegisterFieldsDetails.Value Do
				RegisterField = RegisterDimensions.Find("Field" + FieldNumber);
				TypesDetails = ?(RegisterField = Undefined, New TypeDescription, RegisterField.Type);
				TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
					+ NStr("ru = '- для измерения'; en = '- for dimension'; pl = '- dla pomiaru';de = '- zum messen';ro = '- pentru dimensiune';tr = '- ölçüm için'; es_ES = '- para la dimensión'") + " " + "Field" + FieldNumber + ":" + Chars.LF
					+ "	" + TextWithIndent(TypesListFromArray(FieldDetails.Type.Types(),
						True, TablesTypesByNames, TypesDetails), "	");
				FieldNumber = FieldNumber + 1;
			EndDo;
			ImplementationSettings.Insert("DimensionTypesForSeparateKeyRegister",
				New Structure("InformationRegisterName, DimensionsTypes", KeysRegisterName, TypesList));
		EndIf;
	EndDo;
	
	ImplementationSettings.Insert("PredefinedID", Undefined);
	For Each KeyAndValue In Data.PredefinedIDs Do
		NameParts = StrSplit(KeyAndValue.Key, ".", False);
		AlreadyAdded = Metadata.Catalogs[NameParts[0]].GetPredefinedNames().Find(NameParts[1]) <> Undefined;
		ImplementationSettings.Insert("PredefinedID",
			New Structure("CatalogName, PredefinedItemName", NameParts[0],
				 "- " + NameParts[1] + ?(AlreadyAdded, " (" + NStr("ru = 'уже добавлен'; en = 'already added'; pl = 'już dodany';de = 'wurde bereits hinzugefügt';ro = 'deja este adăugat';tr = 'zaten eklendi'; es_ES = 'añadido ya'") + ")", "")));
		Break;
	EndDo;
	
EndProcedure

// For the SetImplementationSettings procedure.
Procedure AddTypesReguiredInDefinedType(ImplementationSettings, TablesTypesByNames, RefsTypes, TypesNames, DefinedTypeName)
	
	ImplementationSettings.Insert(DefinedTypeName, "");
	If TypesNames.Count() = 0 Then
		Return;
	EndIf;
	
	ImplementationSettings[DefinedTypeName] = TypesListFromArray(TypesNames,
		RefsTypes, TablesTypesByNames, Metadata.DefinedTypes[DefinedTypeName].Type);
	
EndProcedure

// For the SetImplementationSettings and AddTypesRequiredInDefinedType procedures.
Function TypesListFromArray(TypesNames, RefsTypes, TablesTypesByNames, TypesDetails)
	
	TypesList = "";
	For Each TypeName In TypesNames Do
		If TypeOf(TypeName) = Type("Type") Then
			Type = TypeName;
		Else
			Type = Type(TypeName);
		EndIf;
		MetadataObject = Metadata.FindByType(Type);
		FullName = MetadataObject.FullName();
		
		TypesList = TypesList + ?(TypesList = "", "", Chars.LF)
			+ "- " + ?(RefsTypes, RefTypeName(FullName, TablesTypesByNames),
				ObjectTypeOrRecordSetName(FullName, TablesTypesByNames));
		
		If TypesDetails.ContainsType(Type) Then
			TypesList = TypesList + " (" + NStr("ru = 'уже добавлен'; en = 'already added'; pl = 'już dodany';de = 'wurde bereits hinzugefügt';ro = 'deja este adăugat';tr = 'zaten eklendi'; es_ES = 'añadido ya'") + ")";
		EndIf;
	EndDo;
	
	Return TypesList;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Function RestrictionCheckResultStructureForUsersKind()
	
	Properties = New Structure;
	Properties.Insert("RestrictionToCheck");
	Properties.Insert("ErrorsDescription");
	Properties.Insert("RestrictionParametersGenerationError");
	Properties.Insert("QueriesTextsGenerationError");
	Properties.Insert("RestrictionByOwnerPossible");
	Properties.Insert("RestrictionInRoles");
	Properties.Insert("RestrictionInModule");
	Properties.Insert("ByOwnerWithoutSavingAccessKeys");
	
	Return Properties;
	
EndFunction

// For the ObjectAccessRestrictionCheckResult function.
Procedure CheckRestrictionForUsersKind(Context, Result, ForExternalUsers, AdditionalContext)
	
	RestrictionText = ?(ForExternalUsers, Context.CommonResult.ForExternalUsers,
		Context.CommonResult.ForUsers).RestrictionToCheck;
	
	RestrictionStructure = CalculatedRestrictionStructure(Context.FullName,
		RestrictionText, Context.CommonResult.TextInManagerModule, ForExternalUsers, True);
	
	If RestrictionStructure <> Undefined
	   AND RestrictionStructure.ErrorsDescription.HasErrors Then
		
		Result.ErrorsDescription = RestrictionStructure.ErrorsDescription;
		Context.DependenciesAccountingAvailable = False;
		Return;
	EndIf;
	
	AdditionalContext = NewAdditionalContext();
	AddAdditionalContext(Context.FullName,
		AdditionalContext, Context.RestrictionDetails, ForExternalUsers);
	
	ErrorOnCallException = New Structure("Text", Undefined);
	AdditionalContext.Insert("ErrorOnCallException", ErrorOnCallException);
	
	Try
		RestrictionParameters = RestrictionParametersByRestrictionStructure(Context.FullName,
			RestrictionStructure, ForExternalUsers, Context.CommonContext, AdditionalContext);
	Except
		ErrorInformation = ErrorInfo();
		RestrictionParameters = Undefined;
		If ValueIsFilled(ErrorOnCallException.Text) Then
			Result.RestrictionParametersGenerationError = ErrorOnCallException.Text;
		Else
			Result.RestrictionParametersGenerationError =
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Не удалось сформировать параметры ограничения доступа по причине:
					           |%1'; 
					           |en = 'Cannot generate access restriction parameters due to:
					           |%1'; 
					           |pl = 'Nie udało się utworzyć ustawienia ograniczenia dostępu z powodu:
					           |%1';
					           |de = 'Die Parameter der Zugriffsbeschränkung konnten aus diesem Grund nicht gebildet werden:
					           |%1';
					           |ro = 'Eșec la generarea parametrilor de restricționare a accesului din motivul:
					           |%1';
					           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması parametreleri oluşturulamadı: 
					           |%1'; 
					           |es_ES = 'No se ha podido generar los parámetros de restricción de acceso a causa de:
					           |%1'"), DetailErrorDescription(ErrorInformation));
		EndIf;
		Context.DependenciesAccountingAvailable = False;
	EndTry;
	
	If RestrictionParameters <> Undefined Then
		Result.RestrictionByOwnerPossible = RestrictionParameters.OwnerField <> Undefined;
		RestrictionParameters.Context.ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
		SetAccessKeysRecordProperties(RestrictionParameters);
		RestrictionParameters.Insert("DoNotWriteAccessKeysForUsersAndExternalUsers", False);
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByFieldsValues Do
			Context.LeadingLists.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		For Each KeyAndValue In RestrictionParameters.LeadingLists.ByAccessKeys Do
			Context.ListsRestrictionsVersions.Insert(KeyAndValue.Key, Undefined);
		EndDo;
		Try
			AddQueryTextsToRestrictionParameters(RestrictionParameters);
		Except
			ErrorInformation = ErrorInfo();
			If ValueIsFilled(ErrorOnCallException.Text) Then
				Result.QueriesTextsGenerationError = ErrorOnCallException.Text;
			Else
				Result.QueriesTextsGenerationError =
					StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не удалось сформировать тексты запросов на основе параметров ограничения доступа по причине:
						           |%1'; 
						           |en = 'Cannot generate query texts based on access restriction parameters due to:
						           |%1'; 
						           |pl = 'Nie udało się utworzyć tekstów wniosków na podstawie parametrów ograniczenia dostępu z powodu:
						           |%1';
						           |de = 'Die Texte von Abfragen konnten aufgrund der Parameter der Zugriffsbeschränkung aus diesem Grund nicht gebildet werden:
						           |%1';
						           |ro = 'Eșec la generarea textelor interogărilor în baza parametrilor restricției de acces din motivul:
						           |%1';
						           |tr = 'Aşağıdaki nedenle kullanıcılar için erişim kısıtlaması parametrelerine göre 
						           | istek metinleri oluşturulamadı:%1'; 
						           |es_ES = 'No se ha podido generar los textos de solicitudes a base de los parámetros de restricción del acceso a causa de:
						           |%1'"), DetailErrorDescription(ErrorInformation));
			EndIf;
			Context.DependenciesAccountingAvailable = False;
		EndTry;
	EndIf;
	
	If Context.ConsiderDependencies Then
		Return;
	EndIf;
	
	ShortenedProperties = New Structure;
	ShortenedProperties.Insert("AccessDenied", False);
	ShortenedProperties.Insert("OwnerField", Undefined);
	ShortenedProperties.Insert("BasicFields", Undefined);
	ShortenedProperties.Insert("SeparateKeysRegisterName", Undefined);
	AdditionalContext.ListRestrictionsProperties.Insert(Context.FullName, ShortenedProperties);
	
	If Not Context.DependenciesAccountingAvailable Then
		Return;
	EndIf;
	
	FillPropertyValues(ShortenedProperties, RestrictionParameters);
	
EndProcedure

// For the StoredAccessRestrictionParameters and CalculatedRestrictionParameters functions.
Function CommonVersion(CommonContext, FullName, VersionForUsers, VersionForExternalUsers)
	
	If CommonContext.ListsWithRestriction.Get(FullName) = Undefined Then
		Return Undefined;
	EndIf;
	
	Return String(VersionForUsers) + Chars.LF + String(VersionForExternalUsers);
	
EndFunction

// For the CalculatedRestrictionParameters function.
Procedure SetAccessKeysRecordProperties(Result)
	
	WithoutKeysRecord = False;
	WithAlwaysAllowedKeyRecord = False;
	
	If Result.RestrictionDisabled
	 Or Result.AccessDenied
	 Or Result.UsesRestrictionByOwner Then
		
		If Result.UsesRestrictionByOwner
		 Or Result.Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(
		 		Result.List) = Undefined Then
			
			WithoutKeysRecord = True;
		Else
			WithAlwaysAllowedKeyRecord = True;
		EndIf;
	EndIf;
	
	Result.Insert("DoNotWriteAccessKeys", WithoutKeysRecord);
	Result.Insert("WriteAlwaysAllowedAccessKey", WithAlwaysAllowedKeyRecord);
	
EndProcedure

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Function DataRestrictionDetails(CommonContext, FullName, WithoutCallingException = False)
	
	Restriction = New Structure;
	Restriction.Insert("Text", "");
	Restriction.Insert("TextForExternalUsers", "");
	Restriction.Insert("ByOwnerWithoutSavingAccessKeys", Undefined);
	Restriction.Insert("ByOwnerWithoutSavingAccessKeysForExternalUsers", Undefined);
	Restriction.Insert("TextInManagerModule", False);
	
	TextInManagerModule = CommonContext.ListsWithRestriction.Get(FullName);
	If TextInManagerModule = Undefined Then
		Return Restriction;
	EndIf;
	
	Restriction.TextInManagerModule = TextInManagerModule;
	
	If Common.SubsystemExists("StandardSubsystems.FilesOperations") Then
		ModuleFilesOperationsInternal = Common.CommonModule("FilesOperationsInternal");
		IsFilesCatalog = ModuleFilesOperationsInternal.IsFilesOrFilesVersionsCatalog(FullName);
	Else
		IsFilesCatalog = False;
	EndIf;
	
	If IsDocumentJournal(FullName) Or IsFilesCatalog Then
		// For document logs, a restriction must be by the owner document without writing access keys unless 
		// something other is required.
		// The same (by default) is required for file catalogs and file version catalogs.
		Restriction.ByOwnerWithoutSavingAccessKeys = True;
		Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers = True;
	EndIf;
	
	If TextInManagerModule Then
		Manager = Common.ObjectManagerByFullName(FullName);
		
		Try
			Manager.OnFillAccessRestriction(Restriction);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |%2'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           |Access restriction of this list is specified incorrectly in the manager module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |%2'; 
				           |pl = '""%1"" wyświetlone jako lista z ograniczeniem dostępu do procedury
				           | ПриЗаполненииСписковСОграничениемДоступа do wspólnego modułu УправлениеДоступомПереопределяемый.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w module menadżera
				           |w procedurze ПриЗаполненииОграниченияДоступа z powodu:
				           |
				           |%2';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |BeimAusfüllenVonListenMitZugriffsBeschränkung des allgemeinen Moduls ZugriffsKontrolleNeuDefinierbar angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im Modul Manager
				           |in der Prozedur BeimAusfüllenZugriffsBeschränkung aus dem Grund falsch angegeben:
				           |
				           |%2';
				           |ro = '""%1"" este indicat ca listă cu restricționarea accesului în procedura
				           |ПриЗаполненииСписковСОграничениемДоступа a modulului comun УправлениеДоступомПереопределяемый.
				           |
				           |Este indicată incorect restricționarea accesului acestei liste în modulul managerului
				           |în procedura ПриЗаполненииОграниченияДоступа din motivul:
				           |
				           |%2';
				           |tr = 'ErişimKontrolüYenidenBelirlenmiş genel modülün ErişimKısıtlamaListeleriDoldurulurken prosedüründe ""%1"" erişim 
				           |kısıtlama listesi olarak belirtilmiştir. 
				           |
				           | Aşağıdaki nedenle ErişimKısıtlamaDoldurulurken prosedüründe yönetici modülünde bu listenin %2erişim kısıtlaması yanlış belirtilmiştir: 
				           |
				           |
				           |'; 
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2'"),
				FullName,
				DetailErrorDescription(ErrorInformation));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	Else
		MetadataObject = Metadata.FindByFullName(FullName);
		Try
			AccessManagementOverridable.OnFillAccessRestriction(MetadataObject, Restriction);
		Except
			ErrorInformation = ErrorInfo();
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле УправлениеДоступомПереопределяемый
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |%2'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           |Access restriction of this list is specified incorrectly in the AccessManagementOverridable common module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |%2'; 
				           |pl = '""%1"" wyświetlone jako lista z ograniczeniem dostępu do procedury
				           | ПриЗаполненииСписковСОграничениемДоступа do wspólnego modułu УправлениеДоступомПереопределяемый.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w ogólnym module УправлениеДоступомПереопределяемый 
				           |w procedurze ПриЗаполненииОграниченияДоступа z powodu:
				           |
				           |%2';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |BeimAusfüllenVonListenMitZugriffsBeschränkung des allgemeinen Moduls ZugriffsKontrolleNeuDefinierbar angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im allgemeinen Modul ZugriffsKontrolleNeuDefinierbar
				           |in der Prozedur BeimAusfüllenZugriffsBeschränkung aus dem Grund falsch angegeben:
				           |
				           |%2';
				           |ro = '""%1"" este indicat ca listă cu restricționarea accesului în procedura
				           |ПриЗаполненииСписковСОграничениемДоступа a modulului comun УправлениеДоступомПереопределяемый.
				           |
				           |Este indicată incorect restricționarea accesului acestei liste în modulul general УправлениеДоступомПереопределяемый
				           |în procedura ПриЗаполненииОграниченияДоступа din motivul:
				           |
				           |%2';
				           |tr = 'ErişimKontrolüYenidenBelirlenmiş genel modülün ErişimKısıtlamaListeleriDoldurulurken prosedüründe ""%1"" erişim 
				           |kısıtlama listesi olarak belirtilmiştir. 
				           |
				           | Aşağıdaki nedenle ErişimKısıtlamaDoldurulurken prosedüründe yönetici modülünde bu listenin %2erişim kısıtlaması yanlış belirtilmiştir: 
				           |
				           |
				           |'; 
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |%2'"),
				FullName,
				DetailErrorDescription(ErrorInformation));
			
			If WithoutCallingException Then
				Return ErrorText;
			EndIf;
			Raise ErrorText;
		EndTry;
	EndIf;
	
	If IsDocumentJournal(FullName)
	   AND (    Restriction.ByOwnerWithoutSavingAccessKeys <> True
		  Or Restriction.ByOwnerWithoutSavingAccessKeysForExternalUsers <> True) Then
		
		If TextInManagerModule Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в модуле менеджера
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           | Access restriction of this list is specified incorrectly in the manager module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |Restriction is not supported for document journals as for registers 
				           |other than restriction by owner without writing access keys:
				           |
				           | AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'; 
				           |pl = '""%1""określono, jak lista z ograniczeniem dostępu do procedury
				           |ПриЗаполненииСписковСОграничениемДоступа wspólnego modułu УправлениеДоступомПереопределяемый.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w module menadżera
				           |w procedurze ПриЗаполненииОграниченияДоступа z powodu:
				           |
				           |Dla katalogów dokumentów nie są obsługiwane ograniczenia, takie jak dla rejestrów,
				           |czyli opcja ograniczenia właściciela bez zapisu kluczy dostępu:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Link)';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |BeimAusfüllenVonListenMitZugriffsBeschränkung des allgemeinen Moduls ZugriffsKontrolleNeuDefinierbar angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im Modul Manager
				           |in der Prozedur BeimAusfüllenZugriffsBeschränkung aus dem Grund falsch angegeben:
				           |
				           |Die Dokumentprotokolle sind nicht wie bei Registern eingeschränkt,
				           |d.h. mit Ausnahme der Möglichkeit einer Einschränkung des Eigentümers ohne Schreiben der Zugriffsschlüssel:
				           |
				           |LeseVeränderungenAktivieren
				           |WO
				           |	LeseVeränderungenErlaubt(Link)';
				           |ro = '""%1"" este indicat ca listă cu restricționarea accesului în procedura
				           |ПриЗаполненииСписковСОграничениемДоступа a modulului comun УправлениеДоступомПереопределяемый.
				           |
				           |Este indicată incorect restricția de acces a acestei liste în modulul managerului
				           |în procedura ПриЗаполненииОграниченияДоступа din motivul:
				           |
				           |Pentru registrele documentelor nu este susținută restricția ca pentru registre,
				           |adică, cu excepția variantei de restricționare conform titularului fără înregistrarea cheii de acces:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)';
				           |tr = 'ErişimKontrolüYenidenBelirlenmiş genel modülün ErişimKısıtlamaListeleriDoldurulurken prosedüründe ""%1"" erişim kısıtlama
				           | listesi olarak belirtilmiştir. 
				           |
				           | Aşağıdaki nedenle ErişimKısıtlamaDoldurulurken prosedüründe yönetici modülünde bu listenin 
				           |erişim kısıtlaması yanlış belirtilmiştir: 
				           |
				           | Belge günlükleri için kaydediciler gibi kısıtlama desteklenmiyor, 
				           | yani, erişim anahtarlarının kaydı olmadan sahibine göre kısıtlama opsiyonu hariç: 
				           |
				           |OkunabilirDeğişiklik
				           |BURADA
				           |	NesneOkunabilir (Referans)'; 
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo de gestor
				           |en el procedimiento OnFillListsWithAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)'"),
				FullName);
		Else
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = '""%1"" указан, как список с ограничением доступа в процедуре
				           |ПриЗаполненииСписковСОграничениемДоступа общего модуля УправлениеДоступомПереопределяемый.
				           |
				           |Некорректно указано ограничение доступа этого списка в общем модуле УправлениеДоступомПереопределяемый
				           |в процедуре ПриЗаполненииОграниченияДоступа по причине:
				           |
				           |Для журналов документов не поддерживается ограничение, как для регистров,
				           |то есть, кроме варианта ограничения по владельцу без записи ключей доступа:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)'; 
				           |en = '""%1"" is specified as a list with access restriction in the OnFillListsWithAccessRestriction procedure
				           |of the AccessManagementOverridable common module.
				           |
				           | Access restriction of this list is specified incorrectly in the AccessManagementOverridable common module
				           |in the OnFillAccessRestriction procedure due to:
				           |
				           |Restriction is not supported for document journals as for registers
				           |other than restriction by owner without writing access keys:
				           |
				           |AllowReadEdit
				           |WHERE
				           |	ReadObjectAllowed(Ref)'; 
				           |pl = '""%1""określono, jak lista z ograniczeniem dostępu do procedury
				           |ПриЗаполненииСписковСОграничениемдоступа wspólnego modułu УправлениеДоступомПереопределяемый.
				           |
				           |Nieprawidłowo określone ograniczenia dostępu do tej listy w ogólnym module УправлениеДоступомПереопределяемый
				           |w procedurze ПриЗаполненииОграниченияДоступа z powodu:
				           |
				           |Dla katalogów dokumentów nie są obsługiwany ograniczenia, takie jak dla rejestrów,
				           |czyli opcja ograniczenia właściciela bez zapisu kluczy dostępu:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Link)';
				           |de = '""%1""wird als Liste mit Zugriffsbeschränkung in der Prozedur
				           |BeimAusfüllenVonListenMitZugriffsBeschränkung des allgemeinen Moduls ZugriffsKontrolleNeuDefinierbar angegeben.
				           |
				           |Die Zugriffsbeschränkung dieser Liste ist im allgemeinen Modul ZugriffsKontrolleNeuDefinierbar
				           |in der Prozedur BeimAusfüllenZugriffsBeschränkung aus dem Grund falsch angegeben:
				           |
				           |Die Dokumentprotokolle sind nicht wie bei Registern eingeschränkt,
				           |d.h. mit Ausnahme der Möglichkeit einer Einschränkung des Eigentümers ohne Schreiben der Zugriffsschlüssel:
				           |
				           |LeseVeränderungenAktivieren
				           |WO
				           |	LeseVeränderungenErlaubt(Link)';
				           |ro = '""%1"" este indicat ca listă cu restricționarea accesului în procedura
				           |ПриЗаполненииСписковСОграничениемДоступа a modulului comun УправлениеДоступомПереопределяемый.
				           |
				           |Este indicată incorect restricția de acces a acestei liste în modulul general УправлениеДоступомПереопределяемый
				           |în procedura ПриЗаполненииОграниченияДоступа din motivul:
				           |
				           |Pentru registrele documentelor nu este susținută restricția ca pentru registre,
				           |adică, cu excepția variantei de restricționare conform titularului fără înregistrarea cheii de acces:
				           |
				           |РазрешитьЧтениеИзменение
				           |ГДЕ
				           |	ЧтениеОбъектаРазрешено(Ссылка)';
				           |tr = 'ErişimKontrolüYenidenBelirlenmiş genel modülün ErişimKısıtlamaListeleriDoldurulurken prosedüründe ""%1"" erişim kısıtlama
				           | listesi olarak belirtilmiştir. 
				           |
				           | Aşağıdaki nedenle ErişimKısıtlamaDoldurulurken prosedüründe yönetici modülünde bu listenin 
				           |erişim kısıtlaması yanlış belirtilmiştir: 
				           |
				           | Belge günlükleri için kaydediciler gibi kısıtlama desteklenmiyor, 
				           | yani, erişim anahtarlarının kaydı olmadan sahibine göre kısıtlama opsiyonu hariç: 
				           |
				           |OkunabilirDeğişiklik
				           |BURADA
				           |	NesneOkunabilir (Referans)'; 
				           |es_ES = '""%1"" se ha indicado como lista con restricciones de acceso en el procedimiento
				           |OnFillListsWithAccessRestriction del módulo común AccessManagementOverridable.
				           |
				           |Se ha indicado incorrectamente la restricción de acceso de esta lista en el módulo común AccessManagementOverridable
				           |en el procedimiento OnFillAccessRestriction a causa de:
				           |
				           |Para los registros de documentos no se admite la restricción como para los registros
				           |es decir, excepto la opción de restricción por el propietario sin guardar las claves de acceso:
				           |
				           |AllowReadEdit
				           |DONDE
				           |	ReadObjectAllowed(Ref)'"),
				FullName);
		EndIf;
		If WithoutCallingException Then
			Return ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	Return Restriction;
	
EndFunction

// For the DataRestrictionDetails function.
Function IsDocumentJournal(FullName)
	
	Return StrStartsWith(Upper(FullName), Upper("DocumentJournal."))
	    Or StrStartsWith(Upper(FullName), Upper("DocumentJournal."));
	
EndFunction

// For the CalculatedRestrictionParameters and RestrictionParametersForUsersKind functions.
Function CalculatedRestrictionStructure(FullName, RestrictionText, TextInManagerModule, ForExternalUsers, WithoutException = False)
	
	If Not ValueIsFilled(RestrictionText) Then
		Return Undefined;
	EndIf;
	
	ParsedRestriction = ParsedRestriction(FullName, RestrictionText);
	
	CheckFieldTablesAndFieldsTypes(ParsedRestriction);
	
	RestrictionStructure = RestrictionStructure(ParsedRestriction);
	
	If WithoutException Or Not RestrictionStructure.ErrorsDescription.HasErrors Then
		Return RestrictionStructure;
	EndIf;
	
	ErrorsText = ErrorsTextToCallException(FullName,
		RestrictionStructure.ErrorsDescription, ForExternalUsers, TextInManagerModule);
	
	Raise ErrorsText;
	
EndFunction

// For the ListPropertiesAsLeadingOne and RestrictionParameters functions, and the SessionParametersSetting,
// FillRestrictionParameters, and AddListRestrictionParameters procedures.
//
Function ActiveAccessRestrictionParameters(TransactionID, CommonContext,
			Update, SetSessionParametersForTemplates = False,
			SettingParametersForAccesRightsReport = False, HasChanges = False) Export
	
	If Update Then
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext, HasChanges);
		SetParametersVersion(ParametersVersion, TransactionID, CommonContext);
		Return SessionParameters.AccessRestrictionParameters.Parameters;
	EndIf;
	
	CurrentParameters = SessionParameters.AccessRestrictionParameters;
	
	If Not ValueIsFilled(CurrentParameters) Or CurrentParameters.Parameters = Undefined Then
		CurrentParameters = New Structure("Version, HashSum", "", "");
		TransactionIDs = New Map;
	Else
		TransactionIDs = RestrictionParametersCache().TransactionIDs;
	EndIf;
	
	If TransactionActive() Then
		If TransactionIDs.Get(TransactionID) <> Undefined Then
			Return CurrentParameters.Parameters;
		EndIf;
		
		VersionDetails = New Structure("Version, HashSum", "", "");
		If ValueIsFilled(CurrentParameters.Version) Then
			VersionDetails.Version   = CurrentParameters.Version;
			VersionDetails.HashSum = CurrentParameters.HashSum;
		EndIf;
		
		While True Do
			If Not ValueIsFilled(VersionDetails.Version) Then
				VersionDetails = LastVersionDetails();
			EndIf;
			If Not ValueIsFilled(VersionDetails.Version) Then
				Break;
			EndIf;
			DataLock = New DataLock;
			LockItem = DataLock.Add("InformationRegister.AccessRestrictionParameters");
			LockItem.SetValue("Version", VersionDetails.Version);
			LockItem.Mode = DataLockMode.Shared;
			DataLock.Lock();
			NewVersionDetails = LastVersionDetails();
			If Not ValueIsFilled(NewVersionDetails.Version) Then
				VersionDetails = NewVersionDetails;
				Break;
			EndIf;
			If VersionDetails.Version   = NewVersionDetails.Version
			   AND VersionDetails.HashSum = NewVersionDetails.HashSum Then
				Break;
			EndIf;
			VersionDetails = NewVersionDetails;
		EndDo;
	Else
		VersionDetails = LastVersionDetails();
	EndIf;
	
	If Not SetSessionParametersForTemplates
	   AND Not SettingParametersForAccesRightsReport
	   AND CurrentParameters.Version   = VersionDetails.Version
	   AND CurrentParameters.HashSum = VersionDetails.HashSum Then
		
		UpdateTransactionIDs(TransactionID);
		Return CurrentParameters.Parameters;
	EndIf;
	
	// Parameters in the database differ from the parameters in memory.
	If ValueIsFilled(VersionDetails.Version) Then
		ParametersVersion = ParametersVersion(VersionDetails.Version,
			SetSessionParametersForTemplates, SettingParametersForAccesRightsReport);
	Else
		ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
	EndIf;
	
	SetParametersVersion(ParametersVersion, TransactionID, CommonContext);
	
	Return SessionParameters.AccessRestrictionParameters.Parameters;
	
EndFunction

// For the AccessRights report.
Function AllRightsRestrictionsKindsForAccessRightsReport() Export
	
	Cache = RestrictionParametersCache();
	
	If Cache.AllRightsRestrictionsKinds <> Undefined Then
		Return Cache.AllRightsRestrictionsKinds;
	EndIf;
	
	ActiveAccessRestrictionParameters(Undefined, Undefined, False, False, True);
	
	Return AllRightsRestrictionsKindsForAccessRightsReport();
	
EndFunction

// For the ActiveAccessRestrictionParameters and NewAccessRestrictionParametersVersion functions.
Function LastVersionDetails()
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|
	|ORDER BY
	|	AccessRestrictionParameters.Version DESC";
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Return Selection;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Function ParametersVersion(Version, SetSessionParametersForTemplates, SettingParametersForAccesRightReport)
	
	Query = New Query;
	Query.Text =
	"SELECT TOP 1
	|	AccessRestrictionParameters.Version AS Version,
	|	AccessRestrictionParameters.HashSum AS HashSum,
	|	AccessRestrictionParameters.CreationDate AS CreationDate,
	|	AccessRestrictionParameters.ForTemplatesInUsersSessions AS ForTemplatesInUsersSessions,
	|	AccessRestrictionParameters.ForTemplatesInExternalUsersSessions AS ForTemplatesInExternalUsersSessions,
	|	AccessRestrictionParameters.ForWritingObjectsAndCheckingRights AS ForWritingObjectsAndCheckingRights,
	|	AccessRestrictionParameters.ForAccessRightsReport AS ForAccessRightsReport
	|FROM
	|	InformationRegister.AccessRestrictionParameters AS AccessRestrictionParameters
	|WHERE
	|	AccessRestrictionParameters.Version = &Version";
	
	If SetSessionParametersForTemplates Or SettingParametersForAccesRightReport Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForWritingObjectsAndCheckingRights", "Undefined");
	EndIf;
	If Not SettingParametersForAccesRightReport Then
		Query.Text = StrReplace(Query.Text,
			"AccessRestrictionParameters.ForAccessRightsReport", "Undefined");
	EndIf;
		
	Query.Text = StrReplace(Query.Text, ?(Users.IsExternalUserSession(),
		"AccessRestrictionParameters.ForTemplatesInUsersSessions",
		"AccessRestrictionParameters.ForTemplatesInExternalUsersSessions"), "Undefined");
	
	Query.SetParameter("Version", Version);
	
	Selection = Query.Execute().Select();
	Selection.Next();
	
	Return Selection;
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Function NewAccessRestrictionParametersVersion(CommonContext, HasChanges = False)
	
	ListsRestrictionsVersions = New Map;
	StoredParameters = StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions);
	ListsRestrictionsVersions.Insert("Catalog.SetsOfAccessGroups", "1");
	
	RecordSet = ServiceRecordSet(InformationRegisters.AccessRestrictionParameters);
	Record = RecordSet.Add();
	FillPropertyValues(Record, StoredParameters);
	
	DataLock = New DataLock;
	LockItem = DataLock.Add("InformationRegister.AccessRestrictionParameters");
	LockedVersion = 0;
	
	BeginTransaction();
	Try
		VersionDetails = LastVersionDetails();
		While True Do
			If VersionDetails.HashSum = StoredParameters.HashSum Then
				If VersionDetails.Version = LockedVersion Then
					Break;
				EndIf;
				LockItem.Mode = DataLockMode.Shared;
				LockItem.SetValue("Version", VersionDetails.Version);
				DataLock.Lock();
				LockedVersion = VersionDetails.Version;
				VersionDetails = LastVersionDetails();
				Continue;
			EndIf;
			If ValueIsFilled(VersionDetails.Version) Then
				NewVersion = VersionDetails.Version + 1;
			Else
				NewVersion = 1;
			EndIf;
			LockItem.SetValue("Version", NewVersion);
			DataLock.Lock();
			NewVersionDetails = LastVersionDetails();
			
			If VersionDetails.Version <> NewVersionDetails.Version
			 Or NewVersionDetails.Version = NewVersion Then
				
				VersionDetails = NewVersionDetails;
				Continue;
			EndIf;
			
			StoredParameters.Insert("Version", NewVersion);
			
			Record.Version = NewVersion;
			RecordSet.Filter.Version.Set(NewVersion);
			
			If DataBaseConfigurationChangedDynamically()
			 Or Catalogs.ExtensionsVersions.ExtensionsChangedDynamically() Then
				
				StandardSubsystemsServer.RequireRestartDueToApplicationVersionDynamicUpdate();
			EndIf;
			Lists = ListsWithVersionsChange(ListsRestrictionsVersions);
			PlanningParameters = AccessUpdatePlanningParameters();
			PlanningParameters.ListsRestrictionsVersions = ListsRestrictionsVersions;
			PlanningParameters.IsUpdateContinuation = True;
			PlanningParameters.Details = "NewAccessRestrictionParametersVersion";
			ScheduleAccessUpdate(Lists, PlanningParameters);
			
			RecordSet.Write();
			HasChanges = True;
			Break;
		EndDo;
		CommitTransaction();
	Except
		RollbackTransaction();
		Raise;
	EndTry;
	
	If Not StoredParameters.Property("Version") Then
		StoredParameters.Insert("Version",       VersionDetails.Version);
		StoredParameters.Insert("CreationDate", VersionDetails.CreationDate);
	EndIf;
	
	If HasChanges <> True AND Not TransactionActive() Then
		ParameterName = "StandardSubsystems.AccessManagement.AccessRestrictionParametersCheckDate";
		StandardSubsystemsServer.SetExtensionParameter(ParameterName, CurrentSessionDate(), True);
		SetAccessUpdate(True);
	EndIf;
	
	Return StoredParameters;
	
EndFunction

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function ListsWithVersionsChange(NewListsRestrictionsVersions)
	
	VersionDetails = LastVersionDetails();
	If Not ValueIsFilled(VersionDetails.Version) Then
		Return Undefined;
	EndIf;
	
	ParametersVersion = ParametersVersion(VersionDetails.Version, False, False);
	WriteParametersStorage = ParametersVersion.ForWritingObjectsAndCheckingRights;
	
	If TypeOf(WriteParametersStorage) <> Type("ValueStorage") Then
		Return Undefined;
	EndIf;
	WriteParameters = WriteParametersStorage.Get();
	
	If TypeOf(WriteParameters) <> Type("FixedStructure")
	 Or Not WriteParameters.Property("ListsRestrictionsVersions")
	 Or TypeOf(WriteParameters.ListsRestrictionsVersions) <> Type("FixedMap") Then
		Return Undefined;
	EndIf;
	
	Table = New ValueTable;
	Table.Columns.Add("List",       New TypeDescription("String"));
	Table.Columns.Add("Version",       New TypeDescription("String"));
	Table.Columns.Add("ChangeKind", New TypeDescription("Number"));
	
	For Each KeyAndValue In WriteParameters.ListsRestrictionsVersions Do
		Row = Table.Add();
		Row.List = KeyAndValue.Key;
		Row.Version = KeyAndValue.Value;
		Row.ChangeKind = -1;
	EndDo;
	
	For Each KeyAndValue In NewListsRestrictionsVersions Do
		Row = Table.Add();
		Row.List = KeyAndValue.Key;
		Row.Version = KeyAndValue.Value;
		Row.ChangeKind = 1;
	EndDo;
	
	Table.GroupBy("List, Version", "ChangeKind");
	Lists = New Array;
	
	For Each Row In Table Do
		If Row.ChangeKind = 0 Then
			Continue;
		EndIf;
		If Lists.Find(Row.List) <> Undefined Then
			Continue;
		EndIf;
		If Metadata.FindByFullName(Row.List) = Undefined Then
			Continue;
		EndIf;
		Lists.Add(Row.List);
	EndDo;
	
	Return Lists;
	
EndFunction

// For the StoredAccessRestrictionParameters procedure.
Function CacheStructureVersion()
	
	// The number has to be increased when making changes to the cache parameters, including changes to 
	// the template versions.
	Return "12";
	
EndFunction

// For the SessionParametersSetting and ClarifyAccessRestrictionTemplatesVersions procedures, and 
// the StoredTemplatesParametersStructure function.
Function AccessRestrictionTemplatesVersions()
	
	Return
	",ForObject5,
	|,ForRegister5,
	|,ByValues17,
	|,ByValuesExtended17,
	|,ByValuesAndSetsExtended17,
	|,ByValueSets17,";
	
EndFunction

// For the ActiveAccessRestrictionParameters function.
Procedure UpdateTransactionIDs(TransactionID)
	
	Cache = RestrictionParametersCache();
	
	If Not TransactionActive() AND Cache.TransactionIDs.Count() = 0
	 Or    TransactionActive() AND TransactionID = Undefined Then
		Return;
	EndIf;
	
	If TransactionID <> Undefined AND TransactionActive() Then
		Cache.TransactionIDs.Insert(TransactionID, True);
	Else
		Cache.TransactionIDs.Clear();
	EndIf;
	
EndProcedure

// For the ActiveAccessRestrictionParameters function.
Procedure SetParametersVersion(ParametersVersion, TransactionID, CommonContext, RepeatedCall = False)
	
	If Not RepeatedCall Then
		RefreshReusableValues();
	EndIf;
	
	If TransactionID <> Undefined AND TransactionActive() Then
		Cache = RestrictionParametersCache();
		Cache.TransactionIDs.Insert(TransactionID, True);
	EndIf;
	
	If TypeOf(ParametersVersion.ForWritingObjectsAndCheckingRights) = Type("ValueStorage") Then
		ForWritingObjectsAndCheckingRights = StoredWriteParametersStructure(
			ParametersVersion.ForWritingObjectsAndCheckingRights.Get());
		
		If ForWritingObjectsAndCheckingRights.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext, True);
			Return;
		EndIf;
	Else
		ForWritingObjectsAndCheckingRights = Undefined;
	EndIf;
	
	If TypeOf(ParametersVersion.ForAccessRightsReport) = Type("ValueStorage") Then
		ForAccessRightsReport = StoredReportParametersStructure(
			ParametersVersion.ForAccessRightsReport.Get());
		
		If ForAccessRightsReport.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext, True);
			Return;
		EndIf;
		Cache = RestrictionParametersCache();
		Cache.AllRightsRestrictionsKinds = ForAccessRightsReport.AllRightsRestrictionsKinds;
	EndIf;
	
	StorageForAccessRestrictionTemplates = ?(Users.IsExternalUserSession(),
		ParametersVersion.ForTemplatesInExternalUsersSessions,
		ParametersVersion.ForTemplatesInUsersSessions);
	
	If TypeOf(StorageForAccessRestrictionTemplates) = Type("ValueStorage") Then
		ForAccessRestrictionTemplates = StoredTemplatesParametersStructure(
			StorageForAccessRestrictionTemplates.Get());
		
		If ForAccessRestrictionTemplates.CacheStructureVersion <> CacheStructureVersion() Then
			ParametersVersion = NewAccessRestrictionParametersVersion(CommonContext);
			SetParametersVersion(ParametersVersion, TransactionID, CommonContext, True);
			Return;
		EndIf;
	Else
		ForAccessRestrictionTemplates = StoredTemplatesParametersStructure();
	EndIf;
	
	SessionParameters.AccessRestrictionTemplatesVersions = ForAccessRestrictionTemplates.TemplatesVersions;
	TemplatesParameters = TemplatesParametersStructure(ForAccessRestrictionTemplates.TemplatesParameters);
	FillPropertyValues(SessionParameters, TemplatesParameters);
	
	ClarifyAccessRestrictionTemplatesVersions();
	
	UpdateAllowedSetsInSessionParameters(True);
	
	RestrictionParameters = New Structure;
	RestrictionParameters.Insert("Version",       ParametersVersion.Version);
	RestrictionParameters.Insert("HashSum",     ParametersVersion.HashSum);
	RestrictionParameters.Insert("CreationDate", ParametersVersion.CreationDate);
	RestrictionParameters.Insert("Parameters",    ForWritingObjectsAndCheckingRights);
	
	FixedRestrictionParameters = New FixedStructure(RestrictionParameters);
	SessionParameters.AccessRestrictionParameters = FixedRestrictionParameters;
	
EndProcedure

// For the SetParametersVersion procedure.
Procedure ClarifyAccessRestrictionTemplatesVersions()
	
	If SessionParameters.AccessRestrictionTemplatesVersions = AccessRestrictionTemplatesVersions() Then
		Return;
	EndIf;
	
	SessionParameters.AccessRestrictionTemplatesVersions = AccessRestrictionTemplatesVersions() + "
	|,SessionRestartRequired,";
	
EndProcedure

// For the SetParametersVersion, CheckAccessToObject,
// CheckAccessToRecordSet procedures, and the AccessAllowed function.
//
Procedure UpdateAllowedSetsInSessionParameters(IsSessionPatametersSetting = False)
	
	LastCheck = AccessManagementInternalCached.LastCheckOfAllowedSetsVersion();
	
	If Not IsSessionPatametersSetting AND LastCheck.Date + 3 > CurrentSessionDate() Then
		Return;
	EndIf;
	
	LastCheck.Date = CurrentSessionDate();
	BlankAccessGroupsSet = Catalogs.SetsOfAccessGroups.EmptyRef();
	AllowedBlankAccessGroupsSet = AccessManagementInternalCached.AllowedBlankAccessGroupsSet();
	
	If Users.IsFullUser(,, False) Then
		AllowedUser            = BlankAccessGroupsSet;
		AllowedAccessGroupsSet       = BlankAccessGroupsSet;
		AllowedUserGroupsSet = BlankAccessGroupsSet;
	Else
		AllowedUser = Catalogs.SetsOfAccessGroups.GetRef(
			Users.AuthorizedUser().UUID());
		
		Query = New Query;
		Query.SetParameter("AllowedUser", AllowedUser);
		Query.Text =
		"SELECT
		|	SetsOfAccessGroups.AllowedAccessGroupsSet AS AllowedAccessGroupsSet,
		|	SetsOfAccessGroups.AllowedUserGroupsSet AS AllowedUserGroupsSet
		|FROM
		|	Catalog.SetsOfAccessGroups AS SetsOfAccessGroups
		|WHERE
		|	SetsOfAccessGroups.Ref = &AllowedUser";
		
		Selection = Query.Execute().Select();
		If Selection.Next() Then
			AllowedAccessGroupsSet       = Selection.AllowedAccessGroupsSet;
			AllowedUserGroupsSet = Selection.AllowedUserGroupsSet;
		Else
			AllowedAccessGroupsSet       = BlankAccessGroupsSet;
			AllowedUserGroupsSet = BlankAccessGroupsSet;
		EndIf;
	EndIf;
	
	If Not IsSessionPatametersSetting
	   AND SessionParameters.AllowedUser            = AllowedUser
	   AND SessionParameters.AllowedAccessGroupsSet       = AllowedAccessGroupsSet
	   AND SessionParameters.AllowedUserGroupsSet = AllowedUserGroupsSet
	   AND SessionParameters.AllowedUserGroupsSet = AllowedBlankAccessGroupsSet  Then
		
		Return;
	EndIf;
	
	SessionParameters.AllowedUser            = AllowedUser;
	SessionParameters.AllowedAccessGroupsSet       = AllowedAccessGroupsSet;
	SessionParameters.AllowedUserGroupsSet = AllowedUserGroupsSet;
	SessionParameters.AllowedBlankAccessGroupsSet = AllowedBlankAccessGroupsSet;
	
	CommonParameters = "";
	ConsiderRightsSettingsOnBuildQueryExecutionPlan(CommonParameters);
	SessionParameters.CommonAccessRestrictionTemplateParameters = CommonParameters;
	
EndProcedure

// For the UpdateAllowedSetsInSessionParameters procedure.
Procedure ConsiderRightsSettingsOnBuildQueryExecutionPlan(CommonParameters)
	
	DBMSKind = DBMSKind();
	
	If DBMSKind = "File" Or DBMSKind = "PostgreSQL" Then
		Return;
	EndIf;
	
	CommonParameters = ";ConsiderRightsSettingsOnBuildQueryExecutionPlan;"
		+ RightsSettingsHashsumDetails(SessionParameters.AllowedAccessGroupsSet)
		+ RightsSettingsHashsumDetails(SessionParameters.AllowedUser, "^");
	
EndProcedure

// For the ConsiderRightsSettingsOnBuildQueryExecutionPlan procedure.
Function DBMSKind()
	
	If Common.FileInfobase() Then
		Return "File";
	EndIf;
	
	Query = New Query;
	Query.Text =
	"SELECT
	|	Table.Field AS Field
	|FROM
	|	(SELECT
	|		NULL AS Field
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		1) AS Table
	|
	|ORDER BY
	|	Field
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Table.Field AS Field
	|FROM
	|	(SELECT
	|		""Yes1"" AS Field) AS Table
	|WHERE
	|	Table.Field LIKE ""Yes[1]""
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	Table.Field AS Field
	|FROM
	|	(SELECT
	|		""Yes_"" AS Field) AS Table
	|WHERE
	|	Table.Field LIKE ""Yes[\_]""";
	
	QueryResults = Query.ExecuteBatch();
	
	If QueryResults[0].Unload()[0].Field <> 1 Then
		Return "MSSQLServer";
	EndIf;
	
	If QueryResults[1].IsEmpty() Then
		Return "IBMDB2";
	EndIf;
	
	If QueryResults[2].IsEmpty() Then
		Return "PostgreSQL";
	EndIf;
	
	Return "OracleDatabase";
	
EndFunction

// For the ConsiderRightsSettingsOnBuildQueryExecutionPlan procedure.
Function RightsSettingsHashsumDetails(AccessGroupsSet, Char = "")
	
	DataHashing = New DataHashing(HashFunction.CRC32);
	DataHashing.Append(GetBinaryDataFromHexString(StrReplace(
		AccessGroupsSet.UUID(), "-", "")));
	Remainder = DataHashing.HashSum;
	
	Result = "";
	For Counter = 1 To 32 Do
		Integer = Int(Remainder / 2);
		Result = ?(Remainder - Integer * 2 = 0, "", String(Counter) + Char + ";") + Result;
		Remainder = Integer;
	EndDo;
	
	Return Chars.LF + ";" + Result;
	
EndFunction

// For the AccessAllowed, and the CheckAccessToObject and CheckAccessToRecordSet procedures.
Procedure SetAllowedSetsInQueryParameters(Query)
	
	Query.SetParameter("AllowedAccessGroupsSet",       SessionParameters.AllowedAccessGroupsSet);
	Query.SetParameter("AllowedBlankAccessGroupsSet", SessionParameters.AllowedBlankAccessGroupsSet);
	Query.SetParameter("AllowedUserGroupsSet", SessionParameters.AllowedUserGroupsSet);
	Query.SetParameter("AllowedUser",            SessionParameters.AllowedUser);
	Query.SetParameter("AuthorizedUser",         Users.AuthorizedUser());
	
EndProcedure

// This method is required by the NewVersionOfAccessRestrictionParameters function.
Function StoredAccessRestrictionParameters(CommonContext, ListsRestrictionsVersions = Undefined)
	
	If CommonContext = Undefined Then
		CommonContext = CommonContextOfRestrictionParametersCalculation();
		
	ElsIf CommonContext.Property("SpecialFullName") Then
		SpecialFullName           = CommonContext.SpecialFullName;
		SpecialRestrictionDetails = CommonContext.SpeacialRestrictionDetails;
	EndIf;
	
	AdditionalContextForUsers        = NewAdditionalContext();
	AdditionalContextForExternalUsers = NewAdditionalContext();
	
	FullListsNames = New Array;
	For Each ListDetails In CommonContext.ListsWithRestriction Do
		FullName = ListDetails.Key;
		FullListsNames.Add(FullName);
		If FullName = SpecialFullName Then
			RestrictionDetails = SpecialRestrictionDetails;
		Else
			RestrictionDetails = DataRestrictionDetails(CommonContext, FullName);
		EndIf;
		
		AddAdditionalContext(FullName,
			AdditionalContextForUsers, RestrictionDetails, False);
		
		AddAdditionalContext(FullName,
			AdditionalContextForExternalUsers, RestrictionDetails, True);
	EndDo;
	
	ListsWithDate = New Map;
	ListsIDs = Common.MetadataObjectIDs(FullListsNames);
	
	AllRightsRestrictionsKinds = New Map;
	AddNonStandardRightsRestrictionsKinds(AllRightsRestrictionsKinds);
	
	// Filling for users.
	ContextForUsers = New Structure;
	ContextForUsers.Insert("ForExternalUsers",  False);
	ContextForUsers.Insert("CommonContext",            CommonContext);
	ContextForUsers.Insert("AdditionalContext",   AdditionalContextForUsers);
	ContextForUsers.Insert("LeadingLists",            New Map);
	ContextForUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForUsers.Insert("TemplatesParameters",        TemplatesParametersStructure());
	ContextForUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForUsers.Insert("ListsIDs",    ListsIDs);
	ContextForUsers.Insert("AllRightsRestrictionsKinds",   AllRightsRestrictionsKinds);
	
	AddStoredRestrictionParametersForUsersKind(ContextForUsers);
	
	// Filling for external users.
	ContextForExternalUsers = New Structure;
	ContextForExternalUsers.Insert("ForExternalUsers",  True);
	ContextForExternalUsers.Insert("CommonContext",            CommonContext);
	ContextForExternalUsers.Insert("AdditionalContext",   AdditionalContextForExternalUsers);
	ContextForExternalUsers.Insert("LeadingLists",            New Map);
	ContextForExternalUsers.Insert("ListsRestrictionsVersions", New Map);
	ContextForExternalUsers.Insert("TemplatesParameters",        TemplatesParametersStructure());
	ContextForExternalUsers.Insert("ListsWithDate",             ListsWithDate);
	ContextForExternalUsers.Insert("ListsIDs",    ListsIDs);
	ContextForExternalUsers.Insert("AllRightsRestrictionsKinds",   AllRightsRestrictionsKinds);
	
	AddStoredRestrictionParametersForUsersKind(ContextForExternalUsers);
	
	// Filling in general and separate parts of leading lists for users and external users.
	LeadingLists = New Map;
	For Each LeadingListsDetails In ContextForUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	For Each LeadingListsDetails In ContextForExternalUsers.LeadingLists Do
		AddLeadingLists(LeadingLists,
			"ForExternalUsers", LeadingListsDetails.Key, LeadingListsDetails.Value);
	EndDo;
	For Each LeadingList In LeadingLists Do
		Properties = LeadingList.Value;
		If Properties.ByFieldsValues <> Undefined Then
			ByFieldsValues = Properties.ByFieldsValues;
			If ByFieldsValues.IsReferenceType Then
				TabularSections = New Array;
				For Each TabularSectionDetails In ByFieldsValues.TabularSections Do
					TabularSections.Add(TabularSectionDetails.Value);
				EndDo;
				ByFieldsValues.TabularSections = TabularSections;
			EndIf;
		EndIf;
	EndDo;
	
	// Calculation of access restriction versions.
	ListsRestrictionsVersions = New Map;
	Versions = New ValueList;
	Versions.Add(CacheStructureVersion());
	For Each VersionDetails In ContextForUsers.ListsRestrictionsVersions Do
		CommonVersion = CommonVersion(CommonContext, VersionDetails.Key, VersionDetails.Value,
			ContextForExternalUsers.ListsRestrictionsVersions.Get(VersionDetails.Key));
		ListsRestrictionsVersions.Insert(VersionDetails.Key, CommonVersion);
		Versions.Add(CommonVersion);
	EndDo;
	Versions.SortByValue();
	VersionsAsString = StrConcat(Versions.UnloadValues(), Chars.LF);
	DataHashing = New DataHashing(HashFunction.SHA256);
	DataHashing.Append(VersionsAsString);
	
	// Preparing additional context to calculate restriction parameters of a separate list.
	StoredProperties = "ListsWithDisabledRestriction, ListsWithReadRestrictionDisabled,
		|ListRestrictionsProperties, ListsWithKeysRecordForDependentListsWithoutKeys";
	ForUsers = New Structure(StoredProperties);
	FillPropertyValues(ForUsers, ContextForUsers.AdditionalContext);
	ForExternalUsers = New Structure(StoredProperties);
	FillPropertyValues(ForExternalUsers, ContextForExternalUsers.AdditionalContext);
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ForUsers", ForUsers);
	AdditionalContext.Insert("ForExternalUsers", ForExternalUsers);
	
	WriteParameters = StoredWriteParametersStructure();
	WriteParameters.ListsRestrictionsVersions = ListsRestrictionsVersions;
	WriteParameters.LeadingLists            = LeadingLists;
	WriteParameters.AdditionalContext   = AdditionalContext;
	WriteParameters.ListsWithDate             = ListsWithDate;
	
	StoredParameters = New Structure;
	
	StoredTemplatesParametersForUsers = StoredTemplatesParametersStructure();
	StoredTemplatesParametersForUsers.TemplatesParameters = ContextForUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForUsers)));
	
	StoredTemplatesParametersForExternalUsers = StoredTemplatesParametersStructure();
	StoredTemplatesParametersForExternalUsers.TemplatesParameters = ContextForExternalUsers.TemplatesParameters;
	StoredParameters.Insert("ForTemplatesInExternalUsersSessions",
		New ValueStorage(Common.FixedData(StoredTemplatesParametersForExternalUsers)));
	
	StoredParameters.Insert("ForWritingObjectsAndCheckingRights",
		New ValueStorage(Common.FixedData(WriteParameters)));
	
	AllRestrictionsKinds = New ValueList;
	For Each KeyAndValue In AllRightsRestrictionsKinds Do
		AllRestrictionsKinds.Add(KeyAndValue.Key);
	EndDo;
	AllRestrictionsKinds.SortByValue();
	AllRestrictionsKindsAsString = StrConcat(AllRestrictionsKinds.UnloadValues(), Chars.LF);
	
	ReportParametersToStore = StoredReportParametersStructure();
	ReportParametersToStore.AllRightsRestrictionsKinds = AllRestrictionsKindsAsString;
	DataHashing.Append(AllRestrictionsKindsAsString);
	
	StoredParameters.Insert("ForAccessRightsReport",
		New ValueStorage(Common.FixedData(ReportParametersToStore)));
	
	StoredParameters.Insert("HashSum", Base64String(DataHashing.HashSum));
	StoredParameters.Insert("CreationDate", CurrentSessionDate());
	
	Return StoredParameters;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Procedure AddNonStandardRightsRestrictionsKinds(AllRightsRestrictionsKinds)
	
	AllRightsRestrictionsKinds.Insert("Catalog.ExternalUsers.Read.ExternalUsers");
	AllRightsRestrictionsKinds.Insert("Catalog.ExternalUsers.Update.ExternalUsers");
	AllRightsRestrictionsKinds.Insert("Catalog.ExternalUsersGroups.Read.ExternalUsers");
	AllRightsRestrictionsKinds.Insert("Catalog.UserGroups.Read.Users");
	AllRightsRestrictionsKinds.Insert("Catalog.Users.Read.Users");
	AllRightsRestrictionsKinds.Insert("Catalog.Users.Update.Users");
	AllRightsRestrictionsKinds.Insert("InformationRegister.UserGroupCompositions.Read.ExternalUsers");
	AllRightsRestrictionsKinds.Insert("InformationRegister.UserGroupCompositions.Read.Users");
	
EndProcedure

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Function NewAdditionalContext()
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("RestrictionsDetails",                  New Map);
	AdditionalContext.Insert("ListRestrictionsProperties",           New Map);
	AdditionalContext.Insert("ListsWithRestrictionByOwner",       New Map);
	AdditionalContext.Insert("ListsWithDisabledRestriction",       New Map);
	AdditionalContext.Insert("ListsWithReadRestrictionDisabled", New Map);
	AdditionalContext.Insert("ListsWithKeysRecordForDependentListsWithoutKeys", Undefined);
	
	Return AdditionalContext;
	
EndFunction

// For the CalculatedRestrictionParameters and StoredAccessRestrictionParameters functions.
Procedure AddAdditionalContext(FullName, AdditionalContext,
				RestrictionDetails, ForExternalUsers)
	
	If ForExternalUsers Then
		Text               = RestrictionDetails.TextForExternalUsers;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeysForExternalUsers;
	Else
		Text               = RestrictionDetails.Text;
		ByOwner         = RestrictionDetails.ByOwnerWithoutSavingAccessKeys;
	EndIf;
	InManagerModule = RestrictionDetails.TextInManagerModule;
	
	BriefRestrictionDetails = New Structure;
	BriefRestrictionDetails.Insert("Text",               Text);
	BriefRestrictionDetails.Insert("InManagerModule",    InManagerModule);
	
	AdditionalContext.RestrictionsDetails.Insert(FullName, BriefRestrictionDetails);
	
	If ByOwner <> Undefined Then
		AdditionalContext.ListsWithRestrictionByOwner.Insert(FullName, ByOwner);
	EndIf;
	
EndProcedure

// For the StoredAccessRestrictionParameters procedure.
Procedure AddStoredRestrictionParametersForUsersKind(Context)
	
	// Prepare parameters considering dependencies by access keys only.
	PropertiesTable = New ValueTable;
	PropertiesTable.Columns.Add("FullName", New TypeDescription("String"));
	PropertiesTable.Columns.Add("DependentItem", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("LeadingItems",   New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Level",   New TypeDescription("Number"));
	PropertiesTable.Columns.Add("Master",   New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("DependentItems", New TypeDescription("Array"));
	PropertiesTable.Columns.Add("Parameters", New TypeDescription("Structure"));
	PropertiesTable.Columns.Add("Processed", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerPossible",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerEnabled",  New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("RestrictionByOwnerDisabled", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAccessKeys",       New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("HasDependantListsWithoutAccessKeysRecords", New TypeDescription("Boolean"));
	PropertiesTable.Columns.Add("UsersAndAccessGroupsAccessKeys",    New TypeDescription("Boolean"));
	
	ListsWithRestriction = New Map(Context.CommonContext.ListsWithRestriction);
	ListsWithDisabledRestriction       = New Map;
	ListsWithReadRestrictionDisabled = New Map;
	
	For Each ListDetails In ListsWithRestriction Do
		FullName = ListDetails.Key;
		
		If TypeOf(ListDetails.Value) = Type("Boolean") Then
			Properties = PropertiesTable.Add();
			Properties.FullName = FullName;
			ListsWithRestriction.Insert(FullName, Properties);
			Parameters = RestrictionParametersForUsersKind(FullName, Context);
			Properties.Parameters = Parameters;
		Else
			Properties = ListDetails.Value;
			Parameters = Properties.Parameters;
		EndIf;
		
		If Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		If Parameters.HasUsersRestriction Then
			Properties.UsersAccessKeys = True;
		EndIf;
		
		LeadingLists = Parameters.LeadingLists;
		If LeadingLists.ByAccessKeys.Count() > 0 Then
			Properties.DependentItem = True;
			For Each KeyAndValue In LeadingLists.ByAccessKeys Do
				LeadingList = KeyAndValue.Key;
				Properties.LeadingItems.Add(LeadingList);
				LeadingListProperties = ListsWithRestriction.Get(LeadingList);
				If LeadingListProperties = Undefined Or TypeOf(LeadingListProperties) = Type("Boolean") Then
					LeadingListProperties = PropertiesTable.Add();
					LeadingListProperties.FullName = LeadingList;
					ListsWithRestriction.Insert(LeadingList, LeadingListProperties);
					LeadingListParameters = RestrictionParametersForUsersKind(LeadingList, Context);
					LeadingListProperties.Parameters = LeadingListParameters;
					If LeadingListParameters.RightToWriteRestrictionDisabled Then
						ListsWithReadRestrictionDisabled.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.RestrictionDisabled Then
						ListsWithDisabledRestriction.Insert(LeadingList, True);
					EndIf;
					If LeadingListParameters.HasUsersRestriction Then
						LeadingListProperties.UsersAccessKeys = True;
					EndIf;
				EndIf;
				LeadingListProperties.Master = True;
				LeadingListProperties.DependentItems.Add(FullName);
			EndDo;
		EndIf;
	EndDo;
	
	MaxLevel = 0;
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", False, True));
	For Each Row In Rows Do
		SetDependentListsLevel(Row, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	// Processing dependent lists being leading for themselves (looped on themselves).
	Rows = PropertiesTable.FindRows(New Structure("Processed", False));
	For Each Row In Rows Do
		SetDependentListsLevel(Row, ListsWithRestriction, New Array, MaxLevel);
	EndDo;
	
	Rows = PropertiesTable.FindRows(New Structure("DependentItem, Master", True, False));
	For Each Row In Rows Do
		SetOptimizationByOwnerField(Row, ListsWithRestriction, Context);
	EndDo;
	
	// Shortening dependencies by access keys of dependent objects.
	ListsWithKeysRecordForDependentListsWithoutKeys = New Map;
	Filter = New Structure("HasDependantListsWithoutAccessKeysRecords", True);
	Rows = PropertiesTable.FindRows(Filter);
	For Each Row In Rows Do
		ListsWithKeysRecordForDependentListsWithoutKeys.Insert(Row.FullName, False);
	EndDo;
	AdditionalContext = Context.AdditionalContext;
	AdditionalContext.ListsWithReadRestrictionDisabled = ListsWithReadRestrictionDisabled;
	AdditionalContext.ListsWithDisabledRestriction       = ListsWithDisabledRestriction;
	AdditionalContext.ListsWithKeysRecordForDependentListsWithoutKeys
		= ListsWithKeysRecordForDependentListsWithoutKeys;
	
	ListsPropertiesByLevels = New Array;
	For Level = 1 To MaxLevel Do
		ListsProperties = PropertiesTable.FindRows(New Structure("Level", Level));
		ListsPropertiesByLevels.Add(ListsProperties);
	EndDo;
	
	CommonContextListsWithRestriction = Context.CommonContext.ListsWithRestriction;
	
	For Each ListsProperties In ListsPropertiesByLevels Do
		For Each ListProperties In ListsProperties Do
			
			UsersAccessKeys = False;
			AccessGroupsAccessKeys = False;
			For Each Master In ListProperties.LeadingItems Do
				LeadingListProperties = ListsWithRestriction.Get(Master);
				If LeadingListProperties.UsersAccessKeys Then
					UsersAccessKeys = True;
				Else
					AccessGroupsAccessKeys = True;
				EndIf;
			EndDo;
			If UsersAccessKeys Then
				ListProperties.UsersAccessKeys = True;
				If AccessGroupsAccessKeys Then
					ListProperties.UsersAndAccessGroupsAccessKeys = True;
				EndIf;
			EndIf;
			If ListProperties.RestrictionByOwnerEnabled Then
				Continue;
			EndIf;
			
			AllLeadingListsWithRestriction = True;
			For Each Master In ListProperties.LeadingItems Do
				If CommonContextListsWithRestriction.Get(Master) = Undefined
				 Or ListsWithDisabledRestriction.Get(Master) <> Undefined Then
					AllLeadingListsWithRestriction = False;
					Break;
				EndIf;
			EndDo;
			If AllLeadingListsWithRestriction Then
				Continue;
			EndIf;
			
			ListProperties.Parameters =
				RestrictionParametersForUsersKind(ListProperties.FullName, Context);
			
			If ListsWithKeysRecordForDependentListsWithoutKeys.Get(ListProperties.FullName) = False Then
				ListsWithKeysRecordForDependentListsWithoutKeys.Insert(ListProperties.FullName, True);
			EndIf;
			
			LeadingLists = ListProperties.Parameters.LeadingLists.ByAccessKeys;
			If LeadingLists.Count() = ListProperties.LeadingItems.Count() Then
				Continue;
			EndIf;
			
			For Each Master In ListProperties.LeadingItems Do
				If LeadingLists.Get(Master) = Undefined Then
					LeadingListProperties = ListsWithRestriction.Get(Master);
					ItemIndex = LeadingListProperties.DependentItems.Find(ListProperties.FullName);
					LeadingListProperties.DependentItems.Delete(ItemIndex);
					LeadingListProperties.Master = LeadingListProperties.DependentItems.Count() > 0;
				EndIf;
			EndDo;
			
			If ListProperties.Parameters.RightToWriteRestrictionDisabled Then
				ListsWithReadRestrictionDisabled.Insert(ListProperties.FullName, True);
			EndIf;
			If ListProperties.Parameters.RestrictionDisabled Then
				ListsWithDisabledRestriction.Insert(ListProperties.FullName, True);
			EndIf;
			
			NewDependencyLevel = 0;
			For Each Master In ListProperties.LeadingItems Do
				LeadingListProperties = ListsWithRestriction.Get(Master);
				If NewDependencyLevel < LeadingListProperties.Level + 1 Then
					NewDependencyLevel = LeadingListProperties.Level + 1;
				EndIf;
				If LeadingListProperties.UsersAccessKeys Then
					ListProperties.UsersAccessKeys = True;
				EndIf;
			EndDo;
			ListProperties.Level = NewDependencyLevel;
			ListProperties.DependentItem = ListProperties.LeadingItems.Count() > 0;
		EndDo;
	EndDo;
	
	// Filling in stored list properties.
	For Each ListProperties In PropertiesTable Do
		FullName = ListProperties.FullName;
		UpdateParametersVersion = False;
		
		If ListProperties.Parameters.AccessDenied Then
			SetRestrictionProperty(FullName, "AccessDenied", True, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.SeparateKeysRegisterName) Then
			SetRestrictionProperty(FullName,
				"SeparateKeysRegisterName", ListProperties.Parameters.SeparateKeysRegisterName, Context);
		EndIf;
		If ValueIsFilled(ListProperties.Parameters.BasicFields) Then
			BasicFields = New Structure("All, AllItemsTypes, Used");
			FillPropertyValues(BasicFields, ListProperties.Parameters.BasicFields);
			SetRestrictionProperty(FullName, "BasicFields", BasicFields, Context);
		EndIf;
		If Not ListProperties.RestrictionByOwnerEnabled
		   AND ListProperties.UsersAccessKeys Then
			
			If Not ListProperties.Parameters.CalculateUserRights Then
				UpdateParametersVersion = True;
			EndIf;
			SetRestrictionProperty(FullName, "CalculateUserRights", True, Context);
		EndIf;
		If ListProperties.UsersAndAccessGroupsAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeysAndAccessGroups", True, Context);
		ElsIf ListProperties.UsersAccessKeys Then
			SetRestrictionProperty(FullName,
				"TemplateRestrictionsWithUserAccessKeys", True, Context);
		EndIf;
		If ListProperties.RestrictionByOwnerEnabled Then
			If Not ListProperties.Parameters.UsesRestrictionByOwner Then
				UpdateParametersVersion = True;
			EndIf;
			SetRestrictionProperty(FullName,
				"OwnerField", ListProperties.Parameters.OwnerField, Context);
		EndIf;
		If ListProperties.Parameters.RightToWriteRestrictionDisabled Then
			ListsWithReadRestrictionDisabled.Insert(FullName, True);
		EndIf;
		If ListProperties.Parameters.RestrictionDisabled Then
			ListsWithDisabledRestriction.Insert(FullName, True);
		EndIf;
		If ListsWithKeysRecordForDependentListsWithoutKeys.Get(ListProperties.FullName) = False Then
			UpdateParametersVersion = True;
			ListsWithKeysRecordForDependentListsWithoutKeys.Insert(ListProperties.FullName, True);
		EndIf;
		SetRestrictionProperty(FullName, "UsedAccessValuesTypes",
			New ValueStorage(ListProperties.Parameters.UsedAccessValuesTypes), Context);
		
		If UpdateParametersVersion Then
			ListProperties.Parameters = RestrictionParametersForUsersKind(ListProperties.FullName, Context);
		EndIf;
		Context.ListsRestrictionsVersions.Insert(FullName, ListProperties.Parameters.Version);
		
		LeadingLists = ListProperties.Parameters.LeadingLists;
		
		If LeadingLists.ByFieldsValues.Count() > 0
		 Or LeadingLists.ByAccessKeys.Count() > 0
		 Or LeadingLists.ByValuesWithGroups.Count() > 0 Then
			
			Context.LeadingLists.Insert(FullName, LeadingLists);
		EndIf;
		
		SetTemplatesParameters(ListProperties, Context.TemplatesParameters);
		
		If ListProperties.Parameters.ListWithDate Then
			Context.ListsWithDate.Insert(ListProperties.FullName, True);
		EndIf;
		
		For Each KeyAndValue In ListProperties.Parameters.AllRightsRestrictionsKinds Do
			Context.AllRightsRestrictionsKinds.Insert(ListProperties.FullName + "." + KeyAndValue.Key, True);
		EndDo;
	EndDo;
	
EndProcedure

// For the StoredRestrictionParametersForUsersKind procedure.
Function RestrictionParametersForUsersKind(FullName, Context)
	
	RestrictionDetails = Context.AdditionalContext.RestrictionsDetails.Get(FullName);
	
	If RestrictionDetails = Undefined Then
		RestrictionStructure = Undefined;
	Else
		RestrictionStructure = CalculatedRestrictionStructure(FullName,
			RestrictionDetails.Text, RestrictionDetails.InManagerModule, Context.ForExternalUsers);
	EndIf;
	
	Return RestrictionParametersByRestrictionStructure(FullName,
		RestrictionStructure,
		Context.ForExternalUsers,
		Context.CommonContext,
		Context.AdditionalContext);
	
EndFunction

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetDependentListsLevel(LeadingListProperties, ListsProperties, PreviousLeadingLists,
			MaxLevel)
	
	PreviousLeadingLists.Add(LeadingListProperties.FullName);
	
	For Each DependentList In LeadingListProperties.DependentItems Do
		If PreviousLeadingLists.Find(DependentList) <> Undefined Then
			LoopMembers = "";
			Index = PreviousLeadingLists.Count() - 1;
			While True Do
				LoopMembers = "- " + PreviousLeadingLists[Index] + Chars.LF + LoopMembers;
				If PreviousLeadingLists[Index] = DependentList Then
					Break;
				EndIf;
				Index = Index - 1;
			EndDo;
			LoopMembers = LoopMembers + "(!) " + DependentList;
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ограничения доступа, заполненные в процедурах ПриЗаполненииОграниченияДоступа
				           |модулей менеджеров или общем модуле УправлениеДоступомПереопределяемый,
				           |содержат недопустимую циклическую зависимость при использовании функции
				           |ЧтениеОбъектаРазрешено или ИзменениеОбъектаРазрешено в одном или нескольких
				           |списках-участниках цикла:
				           |%1'; 
				           |en = 'Access restrictions filled in the OnFillAccessRestriction procedures
				           |of manager modules or the AccessManagementOverridable common module
				           |contain invalid circular dependency while using function
				           |ReadObjectAllowed or EditObjectAllowed in one or several
				           |lists of the cycle:
				           |%1'; 
				           |pl = 'Ograniczenia dostępu, wypełnione w procedurach ПриЗаполненииОграниченияДоступа
				           |modułów menedżerów lub ogólnym module УправлениеДоступомПереопределяемый,
				           |zawierają niedozwoloną cykliczną zależność przy użyciu функции
				           |ЧтениеОбъектаРазрешено lub ИзменениеОбъектаРазрешено w jednym lub kilku
				           |listach uczestniczących w cyklu:
				           |%1';
				           |de = 'Zugriffsbeschränkungen, die in den Prozeduren BeimAusfüllenZugriffsBeschränkungen
				           |der Manager-Module oder des allgemeinen Moduls  ZugriffsKontrolleNeudefinierbare ausgefüllt wurden,
				           |enthalten eine inakzeptable zyklische Abhängigkeit bei Verwendung der Funktion
				           |LesenObjektAktiviert oder VerändernObjektErlaubt in einer oder mehreren
				           |Listen der Zyklusteilnehmer:
				           |%1';
				           |ro = 'Restricțiile de acces completate în procedurile ПриЗаполненииОграниченияДоступа
				           |a modulelor sau modulului general УправлениеДоступомПереопределяемый,
				           |conțin dependența circulară la utilizarea funcției
				           |ЧтениеОбъектаРазрешено sau ИзменениеОбъектаРазрешено în una sau mai multe
				           |liste-participante ale ciclului:
				           |%1';
				           |tr = 'Yönetici modüllerinin ErişimKısıtlamasıDoldurulurken prosedürlerinde veya ErişimKontrolüYenidenBelirlenen ortak modülünde doldurulan erişim kısıtlamaları, 
				           |NesneOkunabilir veya NesneDeğişikliğineİzinVerildi işlevi
				           |
				           | döngüye katılan bir veya birkaç %1listelerde kullanılırken izin verilmeyen döngüsel bağlılık içermektedir: 
				           |
				           |'; 
				           |es_ES = 'Restricciones de acceso rellenadas en los procedimientos OnFillAccessRestriction
				           |de los módulos de gestores o en el módulo común AccessManagementOverridable
				           |que contienen una dependencia cíclica no admisible al usar la función
				           |ReadObjectAllowed o EditObjectAllowed en una o varias
				           |listas-miembros del ciclo:
				           |%1'"), LoopMembers);
			Raise ErrorText;
		EndIf;
		DependentListProperties = ListsProperties.Get(DependentList);
		If DependentListProperties.Level < LeadingListProperties.Level + 1 Then
			DependentListProperties.Level = LeadingListProperties.Level + 1;
			If MaxLevel < DependentListProperties.Level Then
				MaxLevel = DependentListProperties.Level;
			EndIf;
		EndIf;
		If Not DependentListProperties.Master Then
			DependentListProperties.Processed = True;
			Continue;
		EndIf;
		SetDependentListsLevel(DependentListProperties, ListsProperties, PreviousLeadingLists, MaxLevel);
	EndDo;
	
	PreviousLeadingLists.Delete(PreviousLeadingLists.Count() - 1);
	LeadingListProperties.Processed = True;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetOptimizationByOwnerField(DependentListProperties, ListsProperties, Context)
	
	DependentListProperties.RestrictionByOwnerPossible =
		DependentListProperties.Parameters.OwnerField <> Undefined;
	
	DependentListProperties.RestrictionByOwnerEnabled =
		     DependentListProperties.RestrictionByOwnerPossible
		AND Not DependentListProperties.RestrictionByOwnerDisabled;
	
	DependentListWithOptimization = DependentListProperties.RestrictionByOwnerEnabled;
	
	For Each LeadingList In DependentListProperties.LeadingItems Do
		LeadingListProperties = ListsProperties.Get(LeadingList);
		If LeadingListProperties.Parameters.AccessDenied Then
			Continue;
		EndIf;
		If Not LeadingListProperties.DependentItem Then
			If DependentListWithOptimization Then
				LeadingListProperties.HasDependantListsWithoutAccessKeysRecords = True;
			EndIf;
			Continue;
		EndIf;
		If DependentListWithOptimization Then
			If LeadingListProperties.Parameters.OwnerField <> Undefined Then
				If LeadingListProperties.Parameters.RestrictionByOwnerRequired Then
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Установлен признак оптимизации ограничения %1, но такая
						           |оптимизация невозможна, так как она требуется для зависимого списка ""%2"".'; 
						           |en = '%1 restriction optimization check box is selected but such
						           |optimization is not possible as it is required for the dependent ""%2"" list.'; 
						           |pl = 'Ustawiony znak optymalizacji ograniczenia %1, ale ta
						           |optymalizacja nie jest możliwa, ponieważ to jest wymagane dla zależnej listy ""%2"".';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt %1, aber eine solche
						           |Optimierung ist nicht möglich, da sie für die abhängige Liste ""%2"" erforderlich ist.';
						           |ro = 'Este setat indicele de optimizare a restricției %1, însă astfel de
						           |optimizare nu este posibilă, deoarece este necesară pentru lista dependentă ""%2"".';
						           |tr = 'Bir kısıtlama optimizasyon işareti belirlendi%1, ancak bu nedenle bağlı "
" liste için gerekli olduğu için optimasyon %2yapılamaz.'; 
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1, pero esta
						           |optimización es imposible porque se requiere para la lista dependiente ""%2"".'"),
						"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
						DependentListProperties.FullName);
					ErrorContext = New Structure("ListsWithRestriction, RestrictionsDetails");
					ErrorContext.Insert("List",                  LeadingListProperties.FullName);
					ErrorContext.Insert("RestrictionsDetails",     Context.AdditionalContext.RestrictionsDetails);
					ErrorContext.Insert("ForExternalUsers", Context.ForExternalUsers);
					ErrorText = ErrorTextWithTitle(ErrorText, ErrorContext);
					Raise ErrorText;
				Else
					LeadingListProperties.RestrictionByOwnerDisabled = True;
				EndIf;
			EndIf;
			LeadingListProperties.HasDependantListsWithoutAccessKeysRecords = True;
		EndIf;
		SetOptimizationByOwnerField(LeadingListProperties, ListsProperties, Context);
	EndDo;
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetRestrictionProperty(FullName, PropertyName, PropertyValue, Context)
	
	Properties = ListRestrictionProperties(FullName, Context.AdditionalContext, True);
	
	Properties[PropertyName] = PropertyValue;
	
EndProcedure

// For the SetRestrictionProperty and FillReadUpdateRightCheckQueries procedures.
Function ListRestrictionProperties(FullName, Context, AddToCollection = False)
	
	Properties = Context.ListRestrictionsProperties.Get(FullName);
	
	If Properties = Undefined Then
		Properties = New Structure;
		Properties.Insert("AccessDenied", False);
		Properties.Insert("OwnerField",  Undefined);
		Properties.Insert("BasicFields",    Undefined);
		Properties.Insert("SeparateKeysRegisterName", "");
		Properties.Insert("CalculateUserRights", False);
		Properties.Insert("TemplateRestrictionsWithUserAccessKeys", False);
		Properties.Insert("TemplateRestrictionsWithUserAccessKeysAndAccessGroups", False);
		Properties.Insert("UsedAccessValuesTypes", Undefined);
		If AddToCollection Then
			Context.ListRestrictionsProperties.Insert(FullName, Properties);
		EndIf;
	EndIf;
	
	Return Properties;
	
EndFunction

// For the StoredAccessRestrictionParameters function.
Procedure AddLeadingLists(LeadingLists, UsersKindPropertyName, DependentList,
			LeadingListsOfDependentList)
	
	For Each LeadingListDetails In LeadingListsOfDependentList.ByFieldsValues Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		FieldsToAdd = LeadingListDetails.Value;
		
		If LeadingList.ByFieldsValues = Undefined Then
			ByFieldsValues = New Structure;
			ByFieldsValues.Insert("IsReferenceType", FieldsToAdd.IsReferenceType);
			ByFieldsValues.Insert("HeaderFields", LeadingListFieldsDetails());
			If ByFieldsValues.IsReferenceType Then
				ByFieldsValues.Insert("TabularSections", New Map);
			EndIf;
			LeadingList.ByFieldsValues = ByFieldsValues;
		Else
			ByFieldsValues = LeadingList.ByFieldsValues;
		EndIf;
		
		AddLeadingListFields(ByFieldsValues.HeaderFields, FieldsToAdd.ForTracking.HeaderFields,
			FieldsToAdd.ForFilter.HeaderFields, DependentList, UsersKindPropertyName);
		
		For Each TabularSection In FieldsToAdd.ForTracking.TabularSections Do
			TabularSectionDetails = ByFieldsValues.TabularSections.Get(TabularSection.Key);
			If TabularSectionDetails = Undefined Then
				TabularSectionDetails = LeadingListFieldsDetails();
				TabularSectionDetails.Insert("Name", TabularSection.Key);
				ByFieldsValues.TabularSections.Insert(TabularSection.Key, TabularSectionDetails);
			EndIf;
			FilterFieldTabularSection = FieldsToAdd.ForFilter.TabularSections.Get(TabularSection.Key);
			AddLeadingListFields(TabularSectionDetails, TabularSection.Value,
				FilterFieldTabularSection, DependentList, UsersKindPropertyName);
		EndDo;
	EndDo;
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByAccessKeys");
	
	AddLeadingListsByDependencyKind(LeadingLists,
		UsersKindPropertyName, DependentList, LeadingListsOfDependentList, "ByValuesWithGroups");
	
EndProcedure

// For the AddLeadingLists procedure.
Function LeadingListFieldsDetails()
	
	Details = New Structure;
	Details.Insert("AllFields",       New Array);
	Details.Insert("AllFieldsTypes", New Map);
	Details.Insert("FieldsSets",   New Structure("ForUsers, ForExternalUsers"));
	
	Return Details;
	
EndFunction

// For the AddLeadingLists procedure.
Procedure AddLeadingListsByDependencyKind(LeadingLists, UsersKindPropertyName,
			DependentList, LeadingListsOfDependentList, DependencyKind)
	
	For Each LeadingListDetails In LeadingListsOfDependentList[DependencyKind] Do
		LeadingList = CurrentLeadingListProperties(LeadingLists, LeadingListDetails.Key);
		LeadingList.DependentLists.Insert(DependentList, True);
		
		If LeadingList[DependencyKind] = Undefined Then
			Properties = New Structure;
			Properties.Insert("ForUsers",        Undefined);
			Properties.Insert("ForExternalUsers", Undefined);
			LeadingList[DependencyKind] = Properties;
		Else
			Properties = LeadingList[DependencyKind];
		EndIf;
		
		If Properties[UsersKindPropertyName] = Undefined Then
			Properties[UsersKindPropertyName] = New Array;
		EndIf;
		
		Properties[UsersKindPropertyName].Add(DependentList);
	EndDo;
	
EndProcedure

// For the AddLeadingLists procedure.
Function CurrentLeadingListProperties(LeadingLists, FullName)
	
	LeadingList = LeadingLists.Get(FullName);
	If LeadingList = Undefined Then
		LeadingList = New Structure;
		LeadingList.Insert("DependentLists",      New Map);
		LeadingList.Insert("ByFieldsValues",     Undefined);
		LeadingList.Insert("ByAccessKeys",      Undefined);
		LeadingList.Insert("ByValuesWithGroups", Undefined);
		LeadingLists.Insert(FullName, LeadingList)
	EndIf;
	
	Return LeadingList;
	
EndFunction

// For the AddLeadingLists procedure.
Procedure AddLeadingListFields(CurrentFields, FieldsDetails, FilterFieldsDetails, DependentList,
			UsersKindPropertyName)
	
	FieldsList = New ValueList;
	For Each FieldDetails In FieldsDetails Do
		If CurrentFields.AllFields.Find(FieldDetails.Key) = Undefined Then
			CurrentFields.AllFields.Add(FieldDetails.Key);
			CurrentFields.AllFieldsTypes.Insert(FieldDetails.Key, FieldDetails.Value);
		EndIf;
		FieldsList.Add(FieldDetails.Key);
	EndDo;
	FieldsList.SortByValue();
	FieldsSet = StrConcat(FieldsList.UnloadValues(), ", ");
	
	FieldsSets = CurrentFields.FieldsSets[UsersKindPropertyName];
	If FieldsSets = Undefined Then
		FieldsSets = New Map;
		CurrentFields.FieldsSets[UsersKindPropertyName] = FieldsSets;
	EndIf;
	DependentListsByFilterFields = FieldsSets.Get(FieldsSet);
	If DependentListsByFilterFields = Undefined Then
		DependentListsByFilterFields = New Map;
		FieldsSets.Insert(FieldsSet, DependentListsByFilterFields);
	EndIf;
	
	FieldsList = New ValueList;
	For Each FieldDetails In FilterFieldsDetails Do
		FieldsList.Add(FieldDetails.Key);
	EndDo;
	FieldsList.SortByValue();
	FilterFieldsSet = StrConcat(FieldsList.UnloadValues(), ", ");
	
	DependentLists = DependentListsByFilterFields.Get(FilterFieldsSet);
	If DependentLists = Undefined Then
		DependentLists = New Array;
		DependentListsByFilterFields.Insert(FilterFieldsSet, DependentLists);
	EndIf;
	DependentLists.Add(DependentList);
	
EndProcedure

// For the AddStoredRestrictionParametersForUsersKind procedure.
Procedure SetTemplatesParameters(ListProperties, TemplatesParameters)
	
	Parameters = ListProperties.Parameters;
	If Parameters.AccessDenied Then
		Return;
	EndIf;
	
	If Parameters.RightToWriteRestrictionDisabled Then
		TemplatesParameters.ListsWithReadRestrictionDisabled =
			TemplatesParameters.ListsWithReadRestrictionDisabled
				+ ListProperties.FullName + Chars.LF;
		Return;
	EndIf;
	
	If Parameters.OwnerField <> Undefined Then
		Fields = ":" + Parameters.OwnerField.Name;
		
	ElsIf Parameters.IsReferenceType Then
		Fields = ":";
	Else
		BasicFields = Parameters.BasicFields;
		If ValueIsFilled(Parameters.SeparateKeysRegisterName) Then
			Fields = "AccessKeysToRegister" + StrSplit(ListProperties.FullName, ".")[1];
		Else
			Fields = AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				ListProperties.FullName);
		EndIf;
		Fields = ":[" + Fields + "]";
		Number = 1;
		NumberOfUsedOne = 1;
		For Each FieldName In BasicFields.All Do
			Fields = Fields + ":" + FieldName;
			If BasicFields.Used.Find(FieldName) <> Undefined Then
				TemplatesParameters.ListsWithRestrictionByFields = TemplatesParameters.ListsWithRestrictionByFields
					+ ListProperties.FullName + ":Field" + NumberOfUsedOne + "=Field" + Number + ";" + Chars.LF;
				NumberOfUsedOne = NumberOfUsedOne + 1;
			EndIf;
			Number = Number + 1;
		EndDo;
		For Number = NumberOfUsedOne To BasicFields.MaxCount Do
			TemplatesParameters.ListsWithRestrictionByFields = TemplatesParameters.ListsWithRestrictionByFields
				+ ListProperties.FullName + ":Field" + Number + "=Null;" + Chars.LF;
		EndDo;
		BlankFieldNumber = BasicFields.All.Count() + 1;
		For Number = BlankFieldNumber To BasicFields.MaxQuantity Do
			Fields = Fields + ":";
		EndDo;
	EndIf;
	
	TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction =
		TemplatesParameters.ListsWithAccessGroupsAccessKeysRestriction
			+ ListProperties.FullName + Fields + ";*" + Chars.LF;
	
	If ListProperties.UsersAndAccessGroupsAccessKeys
	 Or ListProperties.UsersAccessKeys Then
		
		TemplatesParameters.ListsWithUsersAccessKeysRestriction =
			TemplatesParameters.ListsWithUsersAccessKeysRestriction
				+ ListProperties.FullName + Fields + ";+" + Chars.LF;
	EndIf;
	
EndProcedure

// For the SetParametersVersion procedure and the StoredAccessRestrictionParameters function.
Function StoredWriteParametersStructure(Values = "Create")
	
	StoredWriteParameters = New Structure;
	StoredWriteParameters.Insert("CacheStructureVersion",      ?(Values = "Create", CacheStructureVersion(), ""));
	StoredWriteParameters.Insert("ListsRestrictionsVersions", New Map);
	StoredWriteParameters.Insert("LeadingLists",            New Map);
	StoredWriteParameters.Insert("AdditionalContext",   New Structure);
	StoredWriteParameters.Insert("ListsWithDate",             New Map);
	
	If TypeOf(Values)                          = Type("FixedStructure")
	   AND TypeOf(Values.CacheStructureVersion)      = Type("String")
	   AND TypeOf(Values.ListsRestrictionsVersions) = Type("FixedMap")
	   AND TypeOf(Values.LeadingLists)            = Type("FixedMap")
	   AND TypeOf(Values.AdditionalContext)   = Type("FixedStructure")
	   AND TypeOf(Values.ListsWithDate)             = Type("FixedMap") Then
		
		FillPropertyValues(StoredWriteParameters, Values);
	EndIf;
	
	Return ?(Values = "Create", StoredWriteParameters,
		New FixedStructure(StoredWriteParameters));
	
EndFunction

// For the SetParametersVersion procedure and the StoredAccessRestrictionParameters function.
Function StoredTemplatesParametersStructure(Values = "Create")
	
	StoredTemplatesParameters = New Structure;
	StoredTemplatesParameters.Insert("CacheStructureVersion", ?(Values = "Create", CacheStructureVersion(), ""));
	StoredTemplatesParameters.Insert("TemplatesVersions",      AccessRestrictionTemplatesVersions());
	StoredTemplatesParameters.Insert("TemplatesParameters",   TemplatesParametersStructure());
	
	If TypeOf(Values)                     = Type("FixedStructure")
	   AND TypeOf(Values.CacheStructureVersion) = Type("String")
	   AND TypeOf(Values.TemplatesVersions)      = Type("String")
	   AND TypeOf(Values.TemplatesParameters)   = Type("FixedStructure") Then
		
		FillPropertyValues(StoredTemplatesParameters, Values);
	EndIf;
	
	Return ?(Values = "Create", StoredTemplatesParameters,
		New FixedStructure(StoredTemplatesParameters));
	
EndFunction

// For the SetParametersVersion procedure, the StoredAccessRestrictionParameters and
// StoredTemplatesParametersStructure functions.
Function TemplatesParametersStructure(Values = Undefined)
	
	TemplatesParameters = New Structure;
	TemplatesParameters.Insert("ListsWithAccessGroupsAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithUsersAccessKeysRestriction", "");
	TemplatesParameters.Insert("ListsWithRestrictionByFields", "");
	TemplatesParameters.Insert("ListsWithReadRestrictionDisabled", "");
	
	If TypeOf(Values) <> Type("FixedStructure")
	 Or Values.Count() <> TemplatesParameters.Count() Then
		
		Return TemplatesParameters;
	EndIf;
	
	For Each KeyAndValue In TemplatesParameters Do
		If Not Values.Property(KeyAndValue.Key)
		 Or Not TypeOf(Values[KeyAndValue.Key]) = TypeOf(KeyAndValue.Value) Then
			Return TemplatesParameters;
		EndIf;
	EndDo;
	FillPropertyValues(TemplatesParameters, Values);
	
	Return TemplatesParameters;
	
EndFunction

// For the SetParametersVersion procedure and the StoredAccessRestrictionParameters function.
Function StoredReportParametersStructure(Values = "Create")
	
	ReportParametersToStore = New Structure;
	ReportParametersToStore.Insert("CacheStructureVersion", ?(Values = "Create", CacheStructureVersion(), ""));
	ReportParametersToStore.Insert("AllRightsRestrictionsKinds", "");
	
	If TypeOf(Values)                        = Type("FixedStructure")
	   AND TypeOf(Values.CacheStructureVersion)    = Type("String")
	   AND TypeOf(Values.AllRightsRestrictionsKinds) = Type("String") Then
		
		FillPropertyValues(ReportParametersToStore, Values);
	EndIf;
	
	Return ?(Values = "Create", ReportParametersToStore,
		New FixedStructure(ReportParametersToStore));
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersForListSeparately

// The main area function, which returns access restriction parameters for the list user kind, 
// without considering dependencies on other lists both by access keys and by presence of the Users 
// and ExternalUsers access kinds.
//
Function RestrictionParametersByRestrictionStructure(List, RestrictionStructure,
			ForExternalUsers, CommonContext, AdditionalContext)
	
	LeadingLists = New Structure;
	// Lists with fields, on which access restriction depends (for registering update jobs).
	LeadingLists.Insert("ByFieldsValues", New Map);
	// Lists, on whose access keys access restriction depends (for setting session parameters and 
	// registering update jobs).
	LeadingLists.Insert("ByAccessKeys",  New Map);
	// Lists of access values with groups, on which access restriction depends (for registering update jobs).
	LeadingLists.Insert("ByValuesWithGroups", New Map);
	
	Result = New Structure;
	// Full name of the metadata object table.
	Result.Insert("List", List);
	// User kind, for which the parameters are intended.
	Result.Insert("ForExternalUsers", ForExternalUsers);
	// Hash of access restriction parameters to track their changes.
	Result.Insert("Version", "");
	// Lists with fields, on which access restriction depends.
	Result.Insert("LeadingLists", LeadingLists);
	// True if the restriction text is "WHERE FALSE", and it is also not specified for external users.
	Result.Insert("AccessDenied", ForExternalUsers);
	// True if the restriction text is not specified or it is specified but the restriction is disabled 
	// because of disabling the use of access kinds involved in it.
	Result.Insert("RestrictionDisabled", Not ForExternalUsers);
	// True if a reading restriction text is not specified or it is specified but the restriction is 
	// disabled because of disabling the use of access kinds involved in it.
	Result.Insert("RightToWriteRestrictionDisabled", Not ForExternalUsers);
	
	// Owner field, when restriction is possible only by the owner object.
	Result.Insert("OwnerField");
	// The optimization flag specified by the developer next to the restriction text.
	Result.Insert("RestrictionByOwnerRequired", False);
	
	// Flag of using optimization calculated on the second pass of the graph.
	Result.Insert("UsesRestrictionByOwner", False);
	// Flag of calculation of rights to access keys for users, not for access groups, calculated on the 
	// second pass of the graph. Makes sense only when flag UsesRestrictionByOwner = False.
	Result.Insert("CalculateUserRights", False);
	// Shows that the leading list must write keys for dependent lists that do not write their own keys.
	//  The flag is calculated on the second pass of the graph.
	Result.Insert("HasDependantListsWithoutAccessKeysRecords", False);
	// The flag calculated on the second pass of the graph. When HasDependentListsWithoutWriteAccessKeys 
	// = True, it indicates that the Read right is available in one of the BasicRights* or BasicExternalUsersRights* roles.
	Result.Insert("ReadingAllowedForAllUsers", False);
	// The flag calculated on the second pass of the graph. When HasDependentListsWithoutWriteAccessKeys 
	// = True, it indicates that the Update right is available in one of the BasicRights* or BasicExternalUsersRights* roles.
	Result.Insert("EditionAllowedForAllUsers", False);
	
	// Shows that there are leading access keys in the restriction.
	Result.Insert("HasMasterAccessKeys", False);
	// Shows that there are leading lists by rights in the restriction.
	Result.Insert("HasHeadRightsLists", False);
	
	// Types of right setting owners used when calculating rights to access keys.
	Result.Insert("RightsSettingsOwnersTypes", CommonContext.RightsSettingsOwnersTypes);
	// List ID if separate right settings or a blank ID are used for it.
	Result.Insert("RightSettingsTableID", Catalogs.MetadataObjectIDs.EmptyRef());
	// Shows if there are restrictions by right settings owner.
	Result.Insert("HasRightsSettingsOwners", False);
	// Description of access value types used in access restriction.
	Result.Insert("UsedAccessValuesTypes", New Array);
	// All access restriction kinds (not considering usage).
	Result.Insert("AllRightsRestrictionsKinds", New Map);
	
	Result.Insert("SeparateKeysRegisterName", ""); // For registers.
	Result.Insert("BasicFields"); // For registers.
	
	// Number describing attributes used in the key.
	Result.Insert("FieldsComposition");
	
	// It is set if the read restriction differs from "WHERE TRUE".
	Result.Insert("HasReadRestriction", False);
	// It is set if the change restriction differs from "WHERE TRUE".
	Result.Insert("HasLimitChanges", False);
	
	// It is set if User or UsersGroup or ExternalUser or ExternalUsersGroup values are checked for the 
	// ValueAllowed or IsAuthorizedUser functions.
	// 
	Result.Insert("HasUsersRestriction", False);
	
	
	// Contains a restriction structure adjusted to the format of placing values in access keys.
	Result.Insert("ReadRightCalculationStructure",    New Structure);
	Result.Insert("EditRightCalculationStructure", New Structure);
	
	TypeCollectionName = "";
	Result.Insert("IsReferenceType", ?(ValueIsFilled(List),
		IsReferenceTableType(List, TypeCollectionName), False));
	
	Result.Insert("ListWithDate",
		    TypeCollectionName = "Documents"
		Or TypeCollectionName = "BusinessProcesses"
		Or TypeCollectionName = "Tasks");
	
	If TypeCollectionName = "InformationRegisters" Then
		RegisterMetadata = Metadata.InformationRegisters[StrSplit(List, ".")[1]];
		Result.Insert("ListWithPeriod",
			RegisterMetadata.InformationRegisterPeriodicity
				<> Metadata.ObjectProperties.InformationRegisterPeriodicity.Nonperiodical);
	Else
		Result.Insert("ListWithPeriod",
			    TypeCollectionName = "AccumulationRegisters"
			Or TypeCollectionName = "AccountingRegisters"
			Or TypeCollectionName = "CalculationRegisters");
	EndIf;
	
	Context = New Structure;
	Result.Insert("Context", Context);
	
	For Each KeyAndValue In CommonContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	For Each KeyAndValue In AdditionalContext Do
		Context.Insert(KeyAndValue.Key, KeyAndValue.Value);
	EndDo;
	
	Context.Insert("List",                  List);
	Context.Insert("ForExternalUsers", ForExternalUsers);
	Context.Insert("IsReferenceType",         Result.IsReferenceType);
	Context.Insert("ListWithDate",            Result.ListWithDate);
	Context.Insert("ListWithPeriod",         Result.ListWithPeriod);
	Context.Insert("TypeCollectionName",        TypeCollectionName);
	Context.Insert("VersionProperties",          New Array);
	
	AddVersionProperty(Context, Context, "List");
	AddVersionProperty(Context, Context, "ForExternalUsers");
	
	RestrictionDetails = Context.RestrictionsDetails.Get(Context.List);
	If RestrictionDetails = Undefined Then
		RestrictionDetails = New Structure("Text", "");
	EndIf;
	AddVersionProperty(Context, RestrictionDetails, "Text");
	
	AddVersionProperty(Context, Context, "IsReferenceType");
	AddVersionProperty(Context, Context, "ListWithDate");
	
	// Basic fields are not required for reference data types (always Ref).
	FillNewBasicFieldsDetails(Result, Context);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined Then
		Properties = ListRestrictionProperties(Context.List, Context);
		Result.UsesRestrictionByOwner        = Properties.OwnerField <> Undefined;
		Result.CalculateUserRights            = Properties.CalculateUserRights;
		If Context.ListsWithKeysRecordForDependentListsWithoutKeys.Get(List) <> Undefined Then
			Result.HasDependantListsWithoutAccessKeysRecords = True;
			MetadataObject = Metadata.FindByFullName(List);
			Result.ReadingAllowedForAllUsers =
				RightAllowedForAllUsers("Read",    MetadataObject, ForExternalUsers);
			Result.EditionAllowedForAllUsers =
				RightAllowedForAllUsers("Update", MetadataObject, ForExternalUsers);
		EndIf;
	EndIf;
	Context.Insert("UsesRestrictionByOwner",        Result.UsesRestrictionByOwner);
	Context.Insert("CalculateUserRights",            Result.CalculateUserRights);
	Context.Insert("HasDependantListsWithoutAccessKeysRecords", Result.HasDependantListsWithoutAccessKeysRecords);
	Context.Insert("ReadingAllowedForAllUsers",       Result.ReadingAllowedForAllUsers);
	Context.Insert("EditionAllowedForAllUsers",    Result.EditionAllowedForAllUsers);
	
	If RestrictionStructure = Undefined Then
		Return Result;
	EndIf;
	
	Context.Insert("RestrictionStructure",                    RestrictionStructure);
	Context.Insert("LeadingListsByFieldsValues",           LeadingListsDetailsByFieldsValues());
	Context.Insert("LeadingListsByAccessKeys",            LeadingListsDetailsByFieldsRef());
	Context.Insert("LeadingListsByValuesWithGroups",       LeadingListsDetailsByFieldsRef());
	Context.Insert("HasAuthorizedUserCheck", False);
	Context.Insert("UnusedAccessValueTypes",       New Array);
	Context.Insert("AllRightsRestrictionsKinds",                  Result.AllRightsRestrictionsKinds);
	
	FillFieldProperties(Context);
	
	If ForExternalUsers AND Not CommonContext.ExternalUsersEnabled Then
		Return Result;
	EndIf;
	
	Result.AccessDenied = False;
	Result.RestrictionDisabled = True;
	Result.RightToWriteRestrictionDisabled = True;
	
	FillHasRestrictionByRights(Context, Result, RestrictionStructure);
	FillRestrictionByOwnerObject(Result, Context);
	FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context);
	DeleteNotUsedAccessKindsFields(Result, Context);
	FillHasRestrictionByUsersAccessKind(Result, Context);
	FillHasReadRestriction(Result, Context);
	
	Context.Insert("HasUsersRestriction", Result.HasUsersRestriction);
	
	If Context.ListsWithKeysRecordForDependentListsWithoutKeys = Undefined Then
		Result.UsesRestrictionByOwner = Result.OwnerField <> Undefined;
		Result.CalculateUserRights     = Result.HasUsersRestriction;
		
		Context.Insert("UsesRestrictionByOwner", Result.UsesRestrictionByOwner);
		Context.Insert("CalculateUserRights",     Result.CalculateUserRights);
	EndIf;
	AddVersionProperty(Context, Context, "UsesRestrictionByOwner");
	AddVersionProperty(Context, Context, "CalculateUserRights");
	AddVersionProperty(Context, Context, "HasDependantListsWithoutAccessKeysRecords");
	AddVersionProperty(Context, Context, "ReadingAllowedForAllUsers");
	AddVersionProperty(Context, Context, "EditionAllowedForAllUsers");
	
	Context.Insert("FieldsGroups");
	Context.Insert("ObjectTabularSectionsAliases");
	Context.Insert("AdditionalTablesGroups");
	Context.Insert("KeyTabularSectionsCount");
	
	FillFieldsAndAdditionalTablesGroups(Context);
	
	If Context.FieldsProperties.Count() = 0 Then // Restriction disabled.
		Return Result;
	EndIf;
	
	Result.RestrictionDisabled = False;
	
	Result.FieldsComposition = Context.FieldsComposition;
	
	Context.Insert("RightName", "Read");
	FillRightCalculationStructure(Result.ReadRightCalculationStructure,
		RestrictionStructure.ReadRestriction, Context);
	
	Context.Insert("RightName", "Update");
	FillRightCalculationStructure(Result.EditRightCalculationStructure,
		RestrictionStructure.UpdateRestriction, Context);
	
	Context.Delete("RightName");
	
	If Not Context.IsReferenceType Then
		Result.SeparateKeysRegisterName = Context.SeparateKeysRegisterName;
	EndIf;
	
	If Result.UsesRestrictionByOwner Then
		Context.LeadingListsByFieldsValues = LeadingListsDetailsByFieldsValues();
	EndIf;
	LeadingLists.ByFieldsValues     = Context.LeadingListsByFieldsValues.Fields;
	LeadingLists.ByAccessKeys      = Context.LeadingListsByAccessKeys.Lists;
	LeadingLists.ByValuesWithGroups = Context.LeadingListsByValuesWithGroups.Lists;
	
	DataHashing = New DataHashing(HashFunction.SHA256);
	VersionPropertiesString = StrConcat(Context.VersionProperties, Chars.LF);
	DataHashing.Append(VersionPropertiesString);
	Result.Version = Base64String(DataHashing.HashSum);
	
	Return Result;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure procedure.
Function RightAllowedForAllUsers(RightName, MetadataObject, ForExternalUsers)
	
	If MetadataObject = Undefined Then
		Return False;
	EndIf;
	
	RolesNamesBasicRights = AccessManagementInternalCached.RolesNamesBasicRights(ForExternalUsers);
	RoleMetadata = Metadata.Roles;
	
	For Each RoleName In RolesNamesBasicRights Do
		If AccessRight(RightName, MetadataObject, RoleMetadata[RoleName]) Then
			Return True;
		EndIf;
	EndDo;
	
	Return False;
	
EndFunction

// For the DeleteNotUsedAccessKindsFields procedure and AdditionalTablesGroups function.
Procedure AddVersionProperties(Context, Structure, FieldsNames = "")
	
	If ValueIsFilled(FieldsNames) Then
		StructureToSave = New Structure(FieldsNames);
		FillPropertyValues(StructureToSave, Structure);
	Else
		StructureToSave = Structure;
	EndIf;
	
	ValueList = New ValueList;
	For Each KeyAndValue In StructureToSave Do
		ValueList.Add(KeyAndValue.Value, KeyAndValue.Key)
	EndDo;
	ValueList.SortByPresentation();
	
	For Each ListItem In ValueList Do
		AddVersionItem(Context, ListItem.Presentation, ListItem.Value);
	EndDo;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure procedure.
Procedure AddVersionProperty(Context, Structure, FieldName)
	
	AddVersionItem(Context, FieldName, Structure[FieldName]);
	
EndProcedure

// For the AddVersionProperties and AddVersionProperty procedures.
Procedure AddVersionItem(Context, FieldName, Value)
	
	If TypeOf(Value) = Type("String") Then
		Context.VersionProperties.Add(FieldName + " = " + Value);
		
	ElsIf TypeOf(Value) = Type("Number") Then
		
		Context.VersionProperties.Add(FieldName + " = " + Format(Value, "NG="));
		
	ElsIf TypeOf(Value) = Type("Boolean")
	      Or TypeOf(Value) = Type("Undefined") Then
		
		Context.VersionProperties.Add(FieldName + " = " + String(Value));
		
	ElsIf TypeOf(Value) = Type("FixedArray") Then
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(New Array(Value)));
		
	ElsIf TypeOf(Value) = Type("TypeDescription")
	      Or TypeOf(Value) = Type("Array") Then
		
		Context.VersionProperties.Add(FieldName + " = " + DataStringForHashing(Value));
	Else
		ErrorText = NStr("ru = 'Некорректный тип данных для версии ограничения доступа.'; en = 'Incorrect data type for access restriction version.'; pl = 'Nieprawidłowy typ danych dla wersji ograniczenia dostępu.';de = 'Falscher Datentyp für die Version mit Zugriffsbeschränkung.';ro = 'Tip de date incorect pentru versiunea de restricționare a accesului.';tr = 'Erişim kısıtlama sürümü için yanlış veri türü.'; es_ES = 'Tipo incorrecto de datos para la versión de restricción de acceso.'");
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure function and the AccessUpdateManualControl form.
Function IsReferenceTableType(FullName, TypeCollectionName = "") Export
	
	LanguageSyntax = AccessManagementInternalCached.LanguageSyntax();
	NameContent = StrSplit(FullName, ".", False);
	
	TableType = LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
	If TableType = Undefined Then
		Return False;
	EndIf;
	
	TypeCollectionName = TableType.CollectionName;
	
	Return TableType.IsReferenceType;
	
EndFunction

// For the RestrictionParametersByRestrictionStructure function.
Procedure FillNewBasicFieldsDetails(Result, Context)
	
	BasicFields = New Structure;
	BasicFields.Insert("List",           New ValueList);
	BasicFields.Insert("All",              New Array);
	BasicFields.Insert("AllItemsTypes",         New Array);
	BasicFields.Insert("Used",     New Array);
	BasicFields.Insert("UsedItemsTypes", New Array);
	BasicFields.Insert("MaxCount", 0);
	BasicFields.Insert("MaxQuantity", 0);
	
	Context.Insert("BasicFields", BasicFields);
	
	If Context.IsReferenceType Then
		Return;
	EndIf;
	
	If ValueIsFilled(Context.List) Then
		SeparateKeysRegisterName = "AccessKeysToRegister" + StrSplit(Context.List, ".")[1];
		If Metadata.InformationRegisters.Find(SeparateKeysRegisterName) = Undefined Then
			SeparateKeysRegisterName = "";
		EndIf;
	Else
		SeparateKeysRegisterName = "";
	EndIf;
	Context.Insert("SeparateKeysRegisterName", SeparateKeysRegisterName);
	
	BasicFields.MaxCount =
		AccessManagementInternalCached.BasicRegisterFieldsCount(SeparateKeysRegisterName);
	
	BasicFields.MaxQuantity =
		AccessManagementInternalCached.MaxBasicRegisterFieldsCount();
	
	If BasicFields.MaxCount > BasicFields.MaxQuantity Then
		// Increasing the quantity of basic fields in a separate register.
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Количество опорных полей в регистре сведений %1
			           |превышает максимально допустимое количество: %2'; 
			           |en = 'Number of basic fields in the %1 information register
			           |exceeds the maximum allowed value: %2'; 
			           |pl = 'Ilość oporowych pól w rejestrze informacji %1
			           | jest większa niż maksymalna liczba: %2';
			           |de = 'Die Anzahl der Referenzfelder im Datenregister %1
			           |überschreitet die maximal zulässige Anzahl: %2';
			           |ro = 'Numărul de câmpuri de bază în registrul de date %1
			           |depășește cantitatea maximă admisă: %2';
			           |tr = 'Bilgi kaydındaki %1
			           |referans alanların sayısı izin verilen maksimum sayıyı aşıyor: %2'; 
			           |es_ES = 'Cantidad de campos base en el registro de información%1
			           |supera la cantidad máxima admitida: %2'"),
			?(SeparateKeysRegisterName = "", "AccessKeysForRegisters", SeparateKeysRegisterName),
			BasicFields.MaxQuantity);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	AddVersionProperty(Context, BasicFields, "MaxCount");
	
	Result.BasicFields = New Structure("All, AllItemsTypes, Used, UsedItemsTypes,
	|MaxCount, MaxQuantity");
	FillPropertyValues(Result.BasicFields, Context.BasicFields);
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasRestrictionByRights(Context, Result, RestrictionStructure)
	
	Result.HasReadRestriction =
		ValueIsFilled(RestrictionStructure.ReadRestriction)
		AND (    RestrictionStructure.ReadRestriction.Node <> "Constant"
		   Or RestrictionStructure.ReadRestriction.Value <> True);
	
	Result.HasLimitChanges =
		ValueIsFilled(RestrictionStructure.UpdateRestriction)
		AND (    RestrictionStructure.UpdateRestriction.Node <> "Constant"
		   Or RestrictionStructure.UpdateRestriction.Value <> True);
	
	AddVersionProperty(Context, Result, "HasReadRestriction");
	AddVersionProperty(Context, Result, "HasLimitChanges");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillRestrictionByOwnerObject(Result, Context)
	
	RestrictionByOwner = Context.ListsWithRestrictionByOwner.Get(Context.List);
	If TypeOf(RestrictionByOwner) = Type("Boolean") AND Not RestrictionByOwner Then
		Return;
	EndIf;

	RestrictionByOwnerRequired = ?(TypeOf(RestrictionByOwner) = Type("Boolean"),
		RestrictionByOwner, False);
	
	Result.RestrictionByOwnerRequired = RestrictionByOwnerRequired;
	OwnerField = New Structure("Name, EditAsRead", "", False);
	
	ReadRestriction    = Context.RestrictionStructure.ReadRestriction;
	UpdateRestriction = Context.RestrictionStructure.UpdateRestriction;
	
	If Result.HasReadRestriction Then
		
		If ReadRestriction.Node <> "ObjectReadingAllowed" Then
			If RestrictionByOwnerRequired Then
				If ValueIsFilled(UpdateRestriction) Then
					ErrorTemplate =
						NStr("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения изменения не представлено одной функцией ЧтениеОбъектаРазрешено.'; 
						           |en = '%1 restriction optimization check box is selected
						           |but the specified change reading restriction is not provided by the ReadObjectAllowed function.'; 
						           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
						           |ale ograniczenie odczytu zmiany nie przedstawiono jedną funkcją ЧтениеОбъектаРазрешено.';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
						           |aber die angegebene Einschränkung des Lesens der Änderung wird nicht durch eine Funktion LesenObjektErlaubt dargestellt.';
						           |ro = 'Este setat indicele de optimizare a restricționării %1,
						           |însă restricția indicată de citire modificare nu este prezentată de o funcție ЧтениеОбъектаРазрешено.';
						           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
						           |ancak belirtilen değişiklik okuma kısıtlaması tek NesneOkunabilir işlevi tarafından temsil edilmedi.'; 
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer el cambio indicada no está presenta con ninguna de funciones ReadObjectAllowed.'");
				Else
					ErrorTemplate =
						NStr("ru = 'Установлен признак оптимизации ограничения %1,
						           |но указанное ограничение чтения не представлено одной функцией ЧтениеОбъектаРазрешено.'; 
						           |en = '%1 restriction optimization check box is selected
						           |but the specified reading restriction is not provided by the ReadObjectAllowed function.'; 
						           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
						           |ale ograniczenie odczytu nie przedstawiono jedną funkcją ЧтениеОбъектаРазрешено.';
						           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
						           |aber die angegebene Einschränkung des Lesens wird nicht durch eine Funktion LesenObjektErlaubt dargestellt.';
						           |ro = 'Este setat indicele de optimizare a restricționării %1,
						           |însă restricția indicată de citire nu este prezentată de o funcție ЧтениеОбъектаРазрешено.';
						           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
						           |ancak belirtilen okuma kısıtlaması tek NesneOkunabilir işlevi tarafından temsil edilmedi.'; 
						           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
						           |pero la restricción de leer no está presenta con ninguna de funciones ReadObjectAllowed.'");
				EndIf;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(ReadRestriction) Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции ЧтениеОбъектаРазрешено не представлены
					           |только одним параметром - полем владельцем без других параметров.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but parameters of the ReadObjectAllowed function are not provided
					           |only by one parameter which is an owner field without other parameters.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale parametry funkcji ЧтениеОбъектаРазрешено nie są przedstawione
					           |tylko jednym parametrem - polem właścicielem bez innych opcji.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber die Parameter der Funktion LesenObjektErlaubt werden nicht
					           |nur durch einen Parameter repräsentiert - dem Feld vom Eigentümer ohne weitere Parameter.';
					           |ro = 'Este setat indicele de optimizare a restricționării %1,
					           |însă parametrii funcției ЧтениеОбъектаРазрешено nu sunt prezentați
					           |de un singur parametru - câmpul titular fără alți parametri.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak NesneOkunabilir işlev parametreleri yalnızca bir parametre - 
					           |alan sahibi tarafından temsil edilmedi.'; 
					           |es_ES = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función ReadObjectAllowed no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		OwnerField.Name = ReadRestriction.Field.Name;
	EndIf;
	
	If Result.HasLimitChanges Then
		
		If UpdateRestriction.Node <> "ObjectReadingAllowed"
		   AND UpdateRestriction.Node <> "ObjectUpdateAllowed" Then
			
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но указанное ограничение изменения не представлено одной функцией
					           |ЧтениеОбъектаРазрешено или ИзменениеОбъектаРазрешено.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but the specified change reading restriction is not provided by the 
					           |ReadObjectAllowed or EditObjectAllowed function.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale ograniczenie to nie przedstawiono jedną funkcją
					           |ЧтениеОбъектаРазрешено lub ИзменениеОбъектаРазрешено.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt %1,
					           |aber die angegebene Einschränkung wird nicht durch eine Funktion
					           | LesenObjektErlaubt oder ÄndernObjektErlaubt repräsentiert.';
					           |ro = 'Este setat indicele de optimizare a restricționării %1,
					           |însă restricția indicată de modificare nu este prezentată de o funcție
					           |ЧтениеОбъектаРазрешено sau ИзменениеОбъектаРазрешено.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak belirtilen değişiklik kısıtlaması tek NesneOkunabilir ya da NesneDeğiştirilebilir 
					           |işlevi tarafından temsil edilmedi.'; 
					           |es_ES = 'Se ha establecido un atributo de optimización de restricción %1,
					           |pero la restricción de cambio indicada no está presenta con ninguna de funciones
					           | ReadObjectAllowed o EditObjectAllowed.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		If Not FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(UpdateRestriction) Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но параметры функции %2 не представлены
					           |только одним параметром - полем владельцем без других параметров.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but parameters of the %2 function are not provided
					           |only by one parameter, which is an owner field without other parameters.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale parametry funkcji %2 nie są tylko przedstawione
					           |tylko jednym parametrem - polem właścicielem bez innych parametrów.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber die Parameter der Funktion %2 werden nicht
					           |nur durch einen Parameter repräsentiert- das Feld vom Eigentümer ohne andere Parameter.';
					           |ro = 'Este setat indicele de optimizare a restricționării %1,
					           |însă parametrii funcției %2 nu sunt prezentați
					           |de un singur parametru - câmpul titular fără alți parametri.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           |ancak %2 işlev parametreleri yalnızca bir parametre - 
					           |alan sahibi tarafından temsil edilmedi.'; 
					           |es_ES = 'Se ha instalado un atributo de optimización de restricción%1,
					           |pero los parámetros de función %2 no están presentes
					           |solo por un parámetro - campo de propietario sin otros parámetros.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
					UpdateRestriction.Node);
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		
		If OwnerField.Name = "" Then
			OwnerField.Name = UpdateRestriction.Field.Name;
			
		ElsIf OwnerField.Name <> UpdateRestriction.Field.Name Then
			If RestrictionByOwnerRequired Then
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Установлен признак оптимизации ограничения %1,
					           |но поле владельца не совпадает в ограничениях чтения и изменения.'; 
					           |en = '%1 restriction optimization check box is selected
					           |but owner field does not match in read and change restrictions.'; 
					           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
					           |ale pole właściciel nie pokrywa się z ograniczeniami odczytu i zmiany.';
					           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
					           |aber das Feld des Eigentümers stimmt nicht mit den Lese- und Änderungsbeschränkungen überein.';
					           |ro = 'Este setat indicele de optimizare a restricționării %1,
					           |însă câmpul titularului nu coincide în restricțiile de citire și modificare.';
					           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
					           | ancak sahibin alanı okuma ve değişiklik kısıtlamalarında uyumlu değildir.'; 
					           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
					           |pero el campo de propietario no corresponde en las restricciones de lectura y cambio.'"),
					"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
					UpdateRestriction.Node);
				ErrorText = ErrorTextWithTitle(ErrorText, Context);
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			Else
				Return;
			EndIf;
		EndIf;
		OwnerField.EditAsRead =
			UpdateRestriction.Node <> "ObjectUpdateAllowed";
	Else
		OwnerField.EditAsRead = True;
	EndIf;
	
	FieldsProperties = Context.FieldsProperties;
	
	If FieldsProperties.Count() <> 1 Then
		If RestrictionByOwnerRequired AND FieldsProperties.Count() <> 0 Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Установлен признак оптимизации ограничения %1,
				           |но количество полей, используемых в ограничении, более одного.'; 
				           |en = '%1 restriction optimization check box is selected
				           |but the number of fields used in the restriction is more than one.'; 
				           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
				           |ale ilość pól używanych w ograniczeniu, więcej niż jeden.';
				           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
				           |aber die Anzahl der in der Einschränkung verwendeten Felder ist größer als eins.';
				           |ro = 'Este setat indicele de optimizare a restricționării %1,
				           |însă numărul de câmpuri utilizate în restricție este mai mult de unu.';
				           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
				           | ancak kısıtlamada kullanılan alanların sayısı birden fazladır.'; 
				           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero la cantidad de campos usados en la restricción es más que uno.'"),
				"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""));
			ErrorText = ErrorTextWithTitle(ErrorText, Context);
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		Else
			Return;
		EndIf;
	EndIf;
	
	FieldProperties = FieldsProperties[0];
	
	MOIDType = Type("CatalogRef.MetadataObjectIDs");
	EOIDType = Type("CatalogRef.ExtensionObjectIDs");
	
	IDsTypesCountInFinalField = 0;
	If FieldProperties.EndFieldType.ContainsType(MOIDType) Then
		IDsTypesCountInFinalField = 1;
	EndIf;
	If FieldProperties.EndFieldType.ContainsType(EOIDType) Then
		IDsTypesCountInFinalField = IDsTypesCountInFinalField + 1;
	EndIf;
	
	If FieldProperties.EndFieldType.Types().Count() - IDsTypesCountInFinalField
	  <> FieldProperties.AccessKeySavingTypes.Count() Then
		
		IncorrectTypes = New Array;
		For Each Type In FieldProperties.EndFieldType.Types() Do
			If FieldProperties.AccessKeySavingTypes.Find(Type) <> Undefined
			 Or Type = MOIDType
			 Or Type = EOIDType Then
				Continue;
			EndIf;
			IncorrectTypes.Add(TypeNameInQueryLanguage(Type));
		EndDo;
		If RestrictionByOwnerRequired Then
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Установлен признак оптимизации ограничения %1,
				           |но для следующих таблиц невозможно записать ключи доступа:
				           |%2'; 
				           |en = '%1 restriction optimization check box is selected
				           |but you cannot write access keys for the following tables:
				           |%2'; 
				           |pl = 'Ustawiony znak optymalizacji ograniczenia %1,
				           |ale dla następujących tabel nie można zapisać klucze dostępu:
				           |%2';
				           |de = 'Ein Zeichen der Limit- Optimierung wird gesetzt%1,
				           |aber die Zugriffsschlüssel für die folgenden Tabellen können nicht aufgeschrieben werden:
				           |%2';
				           |ro = 'Este setat indicele de optimizare a restricționării %1,
				           |însă pentru tabelele următoare nu pot fi înregistrate cheile de acces:
				           |%2';
				           |tr = 'Kısıtlama optimizasyon işareti belirlendi%1, 
				           | ancak aşağıdaki tablolar için erişim anahtarları kaydedilemez: 
				           |%2'; 
				           |es_ES = 'Se ha establecido un atributo de optimización de restricción%1,
				           |pero para las siguientes tablas es imposible guardar las claves de acceso:
				           |%2'"),
				"ByOwnerWithoutSavingAccessKeys" + ?(Context.ForExternalUsers, "ForExternalUsers", ""),
				StrConcat(IncorrectTypes, Chars.LF));
			ErrorText = ErrorTextWithTitle(ErrorText, Context);
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		Else
			Return;
		EndIf;
	EndIf;
	
	Result.OwnerField = OwnerField;
	
	AddVersionProperty(Context, OwnerField, "EditAsRead");
	AddVersionProperty(Context, OwnerField, "Name");
	
EndProcedure

// For the FillRestrictionByOwnerObject function and the SetOptimizationByOwnerField procedure.
Function ErrorTextWithTitle(ErrorText, Context)
	
	ErrorsDescription = New Structure;
	ErrorsDescription.Insert("HasErrors", True);
	ErrorsDescription.Insert("Errors", New Array(1));
	ErrorsDescription.Insert("ErrorsText", ErrorText);
	ErrorsDescription.Insert("Restriction", "");
	ErrorsDescription.Insert("AddOn", "");
	
	RestrictionDetails = Context.RestrictionsDetails.Get(Context.List);
	
	ErrorsDescription.Restriction =
		NumberedRestrictionTextWithErrorsMarks(RestrictionDetails.Text,
			New Array, StrLen(Format(StrLineCount(RestrictionDetails.Text), "NG=")));
	
	Return TrimAll(ErrorsTextToCallException(Context.List,
		ErrorsDescription, Context.ForExternalUsers, RestrictionDetails.InManagerModule));
	
EndFunction

// For the FillRestrictionByOwnerObject procedure.
Function FunctionWithoutClarificationOfTypesWithFieldWithoutAttachments(Restriction)
	
	If Restriction.Types.Count() <> 0
	 Or Restriction.ComparisonClarifications.Count() <> 0 Then
		Return False;
	EndIf;
	
	Field = Restriction.Field;
	
	Return Not ValueIsFilled(Field.Cast)
	      AND Not ValueIsFilled(Field.Attachment)
	      AND Not ValueIsFilled(Field.IsNull);
	
EndFunction

// For the AccessRestrictionParameters function.
Procedure FillHasLeadingKeysAndListsAndRightsSettingsOwners(Result, Context)
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			Result.HasMasterAccessKeys = True;
		EndIf;
		If FieldProperties.HasHeadListType Then
			Result.HasHeadRightsLists = True;
		EndIf;
		If FieldProperties.HasRightsSettingsOwnerType Then
			Result.HasRightsSettingsOwners = True;
		EndIf;
		If FieldProperties.HasAuthorizedUserCheck Then
			Context.HasAuthorizedUserCheck = True;
		EndIf;
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			Result.UsedAccessValuesTypes.Add(Type);
		EndDo;
		For Each Type In FieldProperties.UnusedAccessValueTypes Do
			Context.UnusedAccessValueTypes.Add(Type);
		EndDo;
	EndDo;
	
	For Each KeyAndValue In Context.SeparateRightsSettingsTables Do
		If KeyAndValue.Value = Context.List Then
			Result.RightSettingsTableID = KeyAndValue.Key;
			Break;
		EndIf;
	EndDo;
	
	AddVersionProperty(Context, Result, "HasMasterAccessKeys");
	AddVersionProperty(Context, Result, "HasHeadRightsLists");
	AddVersionProperty(Context, Result, "HasRightsSettingsOwners");
	AddVersionProperty(Context, Result, "UsedAccessValuesTypes");
	AddVersionProperty(Context, Context,  "UnusedAccessValueTypes");
	
	PropertiesToSave = New Structure("SeparateRightsSettingsTable",
		ValueIsFilled(Result.RightSettingsTableID));
	
	AddVersionProperty(Context, PropertiesToSave, "SeparateRightsSettingsTable");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure DeleteNotUsedAccessKindsFields(Result, Context)
	
	FieldsProperties = Context.FieldsProperties;
	
	If Not Result.HasMasterAccessKeys
	   AND Not Result.HasHeadRightsLists
	   AND Not Result.HasRightsSettingsOwners
	   AND Not Context.HasAuthorizedUserCheck
	   AND Result.UsedAccessValuesTypes.Count() = 0
	   AND Context.UnusedAccessValueTypes.Count() > 0 Then
		
		FieldsProperties.Clear();
		Return;
	EndIf;
	
	Index = FieldsProperties.Count();
	While Index > 0 Do
		Index = Index - 1;
		FieldProperties = FieldsProperties.Get(Index);
		
		If FieldProperties.EndFieldType.Types().Count()
				= FieldProperties.UnusedAccessValueTypes.Count() Then
			
			FieldsProperties.Delete(Index);
			Continue;
		EndIf;
		SetBasicFieldUse(Context.BasicFields, FieldProperties);
		AddVersionProperties(Context, FieldProperties,
		"HasAdjustmentNull,
		|HasAdjustmentUndefined,
		|FieldNameForQuery,
		|MultipleValuesGroups,
		|EndFieldType,
		|ValueGroupSavingTypes,
		|ValueSavingTypes,
		|AccessKeySavingTypes,
		|EmptyRefSavingTypes,
		|AllowedTypeSavingTypes,
		|ProhibitedTypeSavingTypes,
		|TypeSavingTypes,
		|ConfigurationTypeSavingTypes,
		|SimpleTypeSavingTypes,
		|ExtensionTypeSavingTypes,
		|TypesString");
	EndDo;
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasRestrictionByUsersAccessKind(Result, Context)
	
	If Result.HasRightsSettingsOwners Then
		Result.HasUsersRestriction = True;
	Else
		For Each FieldProperties In Context.FieldsProperties Do
			If FieldProperties.ValueSavingTypes.Count() = 0 Then
				Continue;
			EndIf;
			TypesDetails = New TypeDescription(FieldProperties.ValueSavingTypes);
			If Not Result.ForExternalUsers
			   AND (    TypesDetails.ContainsType(Type("CatalogRef.Users"))
			      Or TypesDetails.ContainsType(Type("CatalogRef.UserGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
			If Result.ForExternalUsers
			   AND (    TypesDetails.ContainsType(Type("CatalogRef.ExternalUsers"))
			      Or TypesDetails.ContainsType(Type("CatalogRef.ExternalUsersGroups")) ) Then
				
				Result.HasUsersRestriction = True;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	AddVersionProperty(Context, Result, "HasUsersRestriction");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillHasReadRestriction(Result, Context)
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.Read Then
			Result.RightToWriteRestrictionDisabled = False;
			Break;
		EndIf;
	EndDo;
	
	AddVersionProperty(Context, Result, "RightToWriteRestrictionDisabled");
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillFieldsAndAdditionalTablesGroups(Context)
	
	// Header fields (start from the header, grouping by a blank alias if there is no tabular section name).
	// Fields of each tabular section (start from the tabular section, grouping by the tabular section name).
	// Fields of a group of linked additional tables (start from an instance of an additional table - 
	// grouping by alias. If one table refers to another in the connection, a group of tables is generated).
	
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	LastObjectTabularSectionNumber = 0;
	ObjectTabularSectionsNumbers = New Map;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList"
		   AND FieldProperties.MultipleValuesGroups Then
			
			LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
			
		ElsIf FieldProperties.TableAlias <> "CurrentList"
		        AND StrStartsWith(FieldProperties.TableAlias, "CurrentList")
			    AND ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias) = Undefined Then
			
			LastObjectTabularSectionNumber = LastObjectTabularSectionNumber + 1;
			ObjectTabularSectionsNumbers.Insert(FieldProperties.TableAlias, LastObjectTabularSectionNumber);
		EndIf;
	EndDo;
	
	AccessKeyDimensions = AccessManagementInternalCached.AccessKeyDimensions();
	
	KeyTabularSectionsCountForObjectHeaderAttributes = Int(
		(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
			+ AccessKeyDimensions.TabularSectionAttributesCount - 1)
		/ AccessKeyDimensions.TabularSectionAttributesCount);
	
	AdditionalTablesGroups = AdditionalTablesGroups(Context);
	KeyTabularSectionsCount = LastObjectTabularSectionNumber
		+ AdditionalTablesGroups.TablesByGroups.Count()
		+ KeyTabularSectionsCountForObjectHeaderAttributes;
	
	CompleteBasicFieldsPreparation(Context);
	
	If KeyTabularSectionsCount > AccessKeyDimensions.TabularSectionsCount Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В ограничении доступа списка %1
			           |количество полей, требующих отдельных табличных частей в ключе доступа,
			           |более, чем количество доступных табличных частей в ключе доступа.
			           |
			           |К таким полям относятся:
			           |- поля табличных частей,
			           |- поля дополнительных таблиц, присоединенных к списку,
			           |- поля шапки, у которых значение доступа может иметь более одной группы значений доступа.'; 
			           |en = 'In the %1 list access restriction,
			           |the number of fields requiring separate tabular sections in the access key
			           |is more than the number of available tabular sections in the access key.
			           |
			           |These fields include:
			           |- Fields of tabular sections.
			           |- Fields of additional tables attached to the list.
			           |- Header fields, in which the access value can have more than one access value group.'; 
			           |pl = 'W ograniczeniu dostępu listy %1
			           | ilość pól, które wymagają oddzielnych części tabelarycznych w kluczu dostępu,
			           |bardziej niż ilość dostępnych części tabelarycznych w kluczu dostępu.
			           |
			           |Do takich pól należą:
			           |- pola tabelarycznych części,
			           |- pola dodatkowych tabel, przyłączonych do listy,
			           |- pola nagłówka, u których wartość dostępu może mieć więcej niż jedną grupę wartości dostępu.';
			           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
			           | ist die Anzahl der Felder, die separate Tabellenteile im Zugriffsschlüssel erfordern,
			           |größer als die Anzahl der verfügbaren Tabellenteile im Zugriffsschlüssel. 
			           |
			           |Zu diesen Feldern gehören:
			           |- Tabellenteilfelder,
			           |- Felder von Zusatztabellen, die an die Liste angehängt sind,
			           |- Kopffelder, in denen der Zugriffswert mehr als eine Gruppe von Zugriffswerten haben kann.';
			           |ro = 'În restricționarea accesului listei %1
			           |numărul de câmpuri care necesită secțiuni tabelare aparte în cheia de acces
			           |este mai mare decât numărul de secțiuni tabelare accesibile în cheia de acces.
			           |
			           |Asemenea câmpuri sunt:
			           |- câmpurile secțiunilor tabelare,
			           |- câmpurile tabelelor suplimentare atașate la listă,
			           |- câmpurile antetului, la care valoarea de acces poate avea mai mult de un grup al valorilor de acces.';
			           |tr = 'Liste %1
			           |erişimi kısıtlamasında, erişim anahtarındaki tek tek tablo kısımlarını gerektiren alanların sayısı, 
			           |erişim anahtarındaki mevcut tablo kısımlarının sayısından daha fazladır.
			           |
			           |Bu alanlar şunları içerir: 
			           |- tablo bölümleri alanları, 
			           |- listeye eklenen ek tablolar alanları 
			           |- erişim değeri birden fazla erişim değeri grubuna sahip olan başlık alanları.'; 
			           |es_ES = 'En la restricción de acceso de la lista %1
			           | la cantidad de campos que requieren las secciones tabulares separadas en la clave de acceso
			           |más de cantidad de secciones tabulares disponibles en la clave de acceso.
			           |
			           |A estos campos se refieren:
			           |- campos de secciones tabulares,
			           |- campos de tablas adicionales adjuntas a la lista,
			           |- campos de encabezado cuyo valor de acceso puede tener más de un grupo de valores de acceso.'"),
			Context.List);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	If Not Context.IsReferenceType
	   AND Context.BasicFields.All.Count() > Context.BasicFields.MaxCount Then
		
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В ограничении доступа списка %1
			           |количество полей списка, используемых в ограничении доступа,
			           |превышает максимально допустимое количество опорных полей: %2.'; 
			           |en = 'In the %1 list access restriction,
			           |the number of list fields used in access restriction
			           |exceeds the maximum allowed number of basic fields: %2.'; 
			           |pl = 'W ograniczeniu dostępu do listy %1
			           |ilość pól listy stosowanych w ograniczeniu dostępu,
			           |przekracza maksymalną dopuszczalną ilość oporowych pól: %2.';
			           |de = 'Bei der Einschränkung des Zugriffs auf die Liste%1
			           | überschreitet die Anzahl der Listenfelder, die bei der Einschränkung des Zugriffs verwendet werden,
			           |die maximale Anzahl der Referenzfelder: %2.';
			           |ro = 'În restricția de acces a listei %1
			           |numărul de câmpuri ale listei utilizate în restricționarea accesului
			           |depășește numărul maxim al câmpurilor de bază: %2.';
			           |tr = 'Liste erişimi %1
			           |kısıtlamasında, erişim kısıtlamasında kullanılan liste alanı sayısı, 
			           |izin verilen maksimum referans alanı sayısını aşmaktadır:%2.'; 
			           |es_ES = 'En la restricción de acceso de lista %1
			           |la cantidad de campos usados en la restricción de acceso
			           |supera la cantidad máxima admitida de la cantidad de campos base: %2.'"),
			Context.List,
			Context.BasicFields.MaxCount);
		
		If Context.Property("ErrorOnCallException") Then
			Context.ErrorOnCallException.Text = ErrorText;
		EndIf;
		Raise ErrorText;
	EndIf;
	
	FieldsGroups = New Map;
	ObjectTabularSectionsAliases = New Map;
	LastHeaderAttributeNumber = 0;
	LastHeaderAttributeNumberWithSeveralAccessValuesGroups = 0;
	
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			
			If FieldProperties.MultipleValuesGroups Then
				LastHeaderAttributeNumberWithSeveralAccessValuesGroups =
					LastHeaderAttributeNumberWithSeveralAccessValuesGroups + 1;
				
				KeyTabularSectionNumber = Int(LastHeaderAttributeNumberWithSeveralAccessValuesGroups
					/ AccessKeyDimensions.TabularSectionAttributesCount) + 1;
				
				FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
			Else
				LastHeaderAttributeNumber = LastHeaderAttributeNumber + 1;
				If LastHeaderAttributeNumber < 6 Then
					FieldsGroupName = "Header0";
				ElsIf LastHeaderAttributeNumber < 11 Then
					FieldsGroupName = "Header1";
				ElsIf LastHeaderAttributeNumber < 16 Then
					FieldsGroupName = "Header2";
				Else
					ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'В ограничении доступа списка %1
						           |количество полей списка, используемых в ограничении доступа,
						           |превышает максимально допустимое количество: 15.'; 
						           |en = 'In the %1 list access restriction,
						           |the number of list fields used in access restriction
						           |exceeds the maximum allowed number: 15.'; 
						           |pl = 'W ograniczeniu dostępu do listy %1
						           | ilość pól listy, stosowanych w ograniczeniu dostępu,
						           |przekracza maksymalną dopuszczalną ilość: 15.';
						           |de = 'Bei der Einschränkung des Zugriffs auf die Liste %1
						           |überschreitet die Anzahl der Felder in der Liste, die bei der Einschränkung des Zugriffs verwendet werden,
						           |die maximal zulässige Anzahl: 15.';
						           |ro = 'În restricția de acces a listei %1
						           |numărul de câmpuri ale listei utilizate în restricționarea accesului
						           |depășește numărul maxim admisibil: 15.';
						           |tr = 'Liste erişimi %1
						           |kısıtlamasında, erişim kısıtlamasında kullanılan liste alanı sayısı, 
						           |izin verilen maksimum referans alanı sayısını aşmaktadır: 15.'; 
						           |es_ES = 'En la restricción de acceso de lista %1
						           |la cantidad de campos usados en la restricción de acceso
						           |supera la cantidad máxima admitida: 15.'"),
						Context.List);
					If Context.Property("ErrorOnCallException") Then
						Context.ErrorOnCallException.Text = ErrorText;
					EndIf;
					Raise ErrorText;
				EndIf;
			EndIf;
		Else
			If FieldProperties.TableAlias <> "CurrentList"
			   AND StrStartsWith(FieldProperties.TableAlias, "CurrentList") Then
				
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Get(FieldProperties.TableAlias);
				
				If ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber) = Undefined Then
					ObjectTabularSectionsAliases.Insert(KeyTabularSectionNumber, FieldProperties.TableAlias)
				EndIf;
			Else
				KeyTabularSectionNumber = KeyTabularSectionsCountForObjectHeaderAttributes
					+ ObjectTabularSectionsNumbers.Count()
					+ AdditionalTablesGroups.NumbersByAliases.Get(FieldProperties.TableAlias);
			EndIf;
			FieldsGroupName = "TabularSection" + KeyTabularSectionNumber;
		EndIf;
		FieldsGroup = FieldsGroups.Get(FieldsGroupName);
		If FieldsGroup = Undefined Then
			FieldsGroup = New Array;
			FieldsGroups.Insert(FieldsGroupName, FieldsGroup);
		EndIf;
		FieldsGroup.Add(FieldProperties);
		FieldProperties.Insert("AccessKeyFieldsGroupName", FieldsGroupName);
		FieldProperties.Insert("AccessKeyFieldsGroupAttributeName", "Value" + String(
			FieldsGroup.Count() + ?(FieldsGroupName = "Header1" Or FieldsGroupName = "Header2", 5, 0)));
		
		If Not StrStartsWith(FieldsGroupName, "Header")
		   AND FieldsGroup.Count() > AccessKeyDimensions.TabularSectionAttributesCount Then
			
			ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'В ограничении доступа списка %1
				           |количество полей одной табличной части, используемых в ограничении доступа,
				           |превышает максимально допустимое количество: %2.'; 
				           |en = 'In the %1 list access restriction,
				           |the number of fields of one tabular section used in access restriction
				           |exceeds the maximum allowed number: %2.'; 
				           |pl = 'W ograniczeniu dostępu do listy %1
				           | ilość pól jednej tabelarycznej części używanych do ograniczenia dostępu,
				           |przekracza maksymalną liczbę: %2.';
				           |de = 'Bei der Einschränkung des Zugriffs auf die Liste%1
				           |überschreitet die Anzahl der Felder in einem Tabellenteil, die bei der Einschränkung des Zugriffs verwendet werden,
				           |die maximal zulässige Anzahl von Feldern: %2.';
				           |ro = 'În restricția de acces a listei %1
				           |numărul de câmpuri ale unei secțiuni tabelare, utilizate în restricționarea accesului,
				           |depășește numărul maxim admisibil: %2.';
				           |tr = 'Liste erişimi %1
				           |kısıtlamasında, erişim kısıtlamasında kullanılan bir tablo kısmının sayısı, 
				           |izin verilen maksimum referans alanı sayısını aşmaktadır:%2.'; 
				           |es_ES = 'En la restricción de acceso de lista %1
				           |la cantidad de campos usados en la restricción de acceso
				           |supera la cantidad máxima admitida: %2.'"),
				Context.List,
				AccessKeyDimensions.TabularSectionAttributesCount);
			
			If Context.Property("ErrorOnCallException") Then
				Context.ErrorOnCallException.Text = ErrorText;
			EndIf;
			Raise ErrorText;
		EndIf;
	EndDo;
	
	Context.Insert("FieldsGroups",                      FieldsGroups);
	Context.Insert("ObjectTabularSectionsAliases", ObjectTabularSectionsAliases);
	Context.Insert("AdditionalTablesGroups",       AdditionalTablesGroups);
	Context.Insert("KeyTabularSectionsCount",   KeyTabularSectionsCount);
	
	// Calculating the FieldsContent number.
	
	// Header and tabular sections:     TS4  TS3  TS2  TS1    H.
	// Binary format:           0000 0000 0000 0000 0000.
	// Hex format:    x0   x0   x0   x0   x0.
	//
	// For example, H0=1, TS1=1.
	// Binary format:           0000 0000 0000 0001 0001.
	// Hex format:    x0   x0   x0   x1   x1.
	// Number = 1*16^0 + 1*16^1 = 1 + 16 = 17.
	
	FieldsContent = LastHeaderAttributeNumber;
	
	For KeyTabularSectionNumber = 1 To KeyTabularSectionsCount Do
		KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
		FieldsGroup = FieldsGroups.Get(KeyTabularSectionName);
		FieldsContent = FieldsContent + FieldsGroup.Count() * Power16(KeyTabularSectionNumber);
	EndDo;
	
	Context.Insert("FieldsComposition", FieldsContent);
	
EndProcedure

// For the AccessRestrictionParameters function.
Procedure FillRightCalculationStructure(CalculationCondition, Condition, Context, ConditionRoot = True)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	
	If ConditionRoot Then
		Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		Context.Insert("VersionPropertiesRightCalculationStructure", New Array);
	EndIf;
	
	FieldProperties = Undefined;
	AddCalculationStructureVersionProperty(Context, "Node", Condition.Node);
	
	If Condition.Node = "Field" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition);
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) // PATCHED:
	      Or Condition.Node = "Or" Then
		
		CalculationCondition = New Structure("Node, Arguments", Condition.Node, New Array);
		Index = 0;
		For Each Argument In Condition.Arguments Do
			CalculationCondition.Arguments.Add(Undefined);
			FillRightCalculationStructure(CalculationCondition.Arguments[Index], Argument, Context, False);
			Index = Index + 1;
		EndDo;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Not" Then
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		If Not ConditionRoot Then
			RequiredKeyTabularSectionsAttributes = Context.RequiredKeyTabularSectionsAttributes;
			Context.Insert("RequiredKeyTabularSectionsAttributes", New Map);
		EndIf;
		
		CalculationCondition = New Structure("Node, Argument", Condition.Node, Undefined);
		FillRightCalculationStructure(CalculationCondition.Argument, Condition.Argument, Context, False);
		
		If Not ConditionRoot Then
			CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes", Context.RequiredKeyTabularSectionsAttributes);
			Context.Insert("RequiredKeyTabularSectionsAttributes", RequiredKeyTabularSectionsAttributes);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "IsNull" Then
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.Argument);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.FirstArgument);
		If FieldProperties = Undefined Then
			FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SecondArgument);
		EndIf;
		
	ElsIf Upper( Condition.Node ) = Upper( "IN" ) Then // PATCHED:
		FieldProperties = Context.AccessKeyFieldsProperties.Get(Condition.SearchFor);
		
	ElsIf Condition.Node = "Case" Then
		CalculationCondition = New Structure("Node, When, Else", Condition.Node, New Array, Undefined);
		For Each When In Condition.When Do
			StructureWhen = New Structure("Condition, Value");
			CalculationCondition.When.Add(StructureWhen);
			If Condition.Case = Undefined Then
				FillRightCalculationStructure(StructureWhen.Condition, When.Condition, Context, False);
			Else
				Properties = Context.AccessKeyFieldsProperties.Get(When.Condition);
				AddCalculationStructureVersionProperty(Context, "Node", "Field");
				CalculationConditionField(StructureWhen.Condition, Properties, Context);
			EndIf;
			FillRightCalculationStructure(StructureWhen.Value, When.Value, Context, False);
		EndDo;
		FillRightCalculationStructure(CalculationCondition.Else, Condition.Else, Context, False);
		FieldProperties = Null;
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		CalculationCondition = New Structure("Node, Field", Condition.Node, Undefined);
		CalculationCondition.Insert("ComparisonClarifications", New Map);
		For Each KeyAndValue In Condition.ComparisonClarifications Do
			If KeyAndValue.Key = "Null"
			 Or KeyAndValue.Key = "Undefined"
			 Or KeyAndValue.Key = "EmptyRef"
			 Or KeyAndValue.Key = "Disabled" Then
			 	CalculationCondition.ComparisonClarifications.Insert(KeyAndValue.Key, KeyAndValue.Value);
			Else
				TypeName = StrReplace(KeyAndValue.Key, ".", "Ref.");
				CalculationCondition.ComparisonClarifications.Insert(Type(TypeName), KeyAndValue.Value);
			EndIf;
		EndDo;
		AddCalculationStructureVersionProperty(Context, "ComparisonClarifications", Condition.ComparisonClarifications);
		FillRightCalculationStructure(CalculationCondition.Field, Condition.Field, Context, False);
		
		If CalculationCondition.Field = Null Then
			CalculationCondition = New Structure("Node, Value", "Constant", True);
		EndIf;
		FieldProperties = Null;
		
	ElsIf Condition.Node = "Constant" Then
		CalculationCondition = New Structure("Node, Value", Condition.Node, Condition.Value);
		AddCalculationStructureVersionProperty(Context, "Value", Condition.Value);
		FieldProperties = Null;
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |узел не поддерживается ""%3"".'; 
			           |en = 'When filling the structure of calculation of right %1 to access keys
			           |of the ""%2"" list,
			           |the ""%3"" node is not supported.'; 
			           |pl = 'Po wypełnieniu struktury obliczenia prawa %1 do kluczy dostępu
			           |do listy ""%2""
			           |węzeł nie jest obsługiwany ""%3"".';
			           |de = 'Beim Ausfüllen der Struktur zur Berechnung der Zugriffsrechte %1 auf die Zugriffsschlüssel
			           |in der Liste ""%2""
			           |wird der Knoten nicht von ""%3"" unterstützt.';
			           |ro = 'La completarea structurii de calculare a dreptului %1 la cheile de acces
			           |ale listei ""%2""
			           |nodul nu este susținut ""%3"".';
			           |tr = '"
" ünite desteklenmiyor""%3"" listesinin erişim anahtar hakları 
			           |hesaplama yapısı doldurulurken ünite %1%2 desteklenmiyor.'; 
			           |es_ES = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |el nodo no se admite ""%3"".'"),
			Context.RightName,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties = Undefined Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'При заполнении структуры расчета права %1 на ключи доступа
			           |списка ""%2""
			           |свойства поля не определены для узла ""%3"".'; 
			           |en = 'When filling the structure of calculation of right %1 to access keys
			           |of the ""%2"" list,
			           |field properties are not determined for the ""%3"" node.'; 
			           |pl = 'Po wypełnieniu struktury obliczenia prawa %1 do kluczy dostępu
			           |do listy ""%2""
			           |właściwości pola nie są określone dla węzła ""%3"".';
			           |de = 'Beim Ausfüllen der Struktur zur Berechnung der Rechte %1 auf die Zugriffsschlüssel
			           |in der Liste ""%2""
			           |sind die Feldeigenschaften für den Knoten ""%3"" nicht definiert.';
			           |ro = 'La completarea structurii de calculare a dreptului %1 la cheile de acces
			           |ale listei ""%2""
			           |proprietățile câmpului nu sunt determinate pentru nodul ""%3"".';
			           |tr = '"
" listesinin erişim anahtar hakları 
			           |hesaplama yapısı %2%3doldurulurken ""%1"" ünite için alan özellikleri belirlenmemiştir. '; 
			           |es_ES = 'Al rellenar la estructura de calcular el derecho %1en claves de acceso
			           |de la lista ""%2""
			           |la propiedad del campo no se han determinado para el nodo ""%3"".'"),
			Context.RightName,
			Context.List,
			Condition.Node);
		Raise ErrorText;
	EndIf;
	
	If FieldProperties <> Null Then
		CalculationConditionField(CalculationCondition, FieldProperties, Context);
	EndIf;
	
	If ConditionRoot Then
		CalculationCondition.Insert("RequiredKeyTabularSectionsAttributes",
			Context.RequiredKeyTabularSectionsAttributes);
		
		AddVersionItem(Context, "RightCalculationStructure" + Context.RightName,
			Context.VersionPropertiesRightCalculationStructure);
		
		Context.Delete("VersionPropertiesRightCalculationStructure");
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure procedure.
Procedure CalculationConditionField(CalculationCondition, FieldProperties, Context)
	
	If Context.FieldsProperties.Find(FieldProperties) = Undefined Then
		CalculationCondition = Null; // Field is deleted due to not used access value types.
	Else
		CalculationCondition = New Structure("Node", "Field");
		CalculationCondition.Insert("Table",  FieldProperties.AccessKeyFieldsGroupName);
		CalculationCondition.Insert("Attribute", FieldProperties.AccessKeyFieldsGroupAttributeName);
		If StrStartsWith(CalculationCondition.Table, "TabularSection") Then
			Attributes = Context.RequiredKeyTabularSectionsAttributes.Get(CalculationCondition.Table);
			If Attributes = Undefined Then
				Attributes = New Array;
				Context.RequiredKeyTabularSectionsAttributes.Insert(CalculationCondition.Table, Attributes);
			EndIf;
			If Attributes.Find(CalculationCondition.Attribute) = Undefined Then
				Attributes.Add(CalculationCondition.Attribute);
			EndIf;
		EndIf;
		AddCalculationStructureVersionProperty(Context, "Table",  CalculationCondition.Table);
		AddCalculationStructureVersionProperty(Context, "Attribute", CalculationCondition.Attribute);
		If FieldProperties.Property("CheckHasNull") Then
			CalculationCondition.Insert("CheckHasNull");
			AddCalculationStructureVersionProperty(Context, "CheckHasNull", True);
		EndIf;
	EndIf;
	
EndProcedure

// For the FillRightCalculationStructure and CalculationConditionField procedures.
Procedure AddCalculationStructureVersionProperty(Context, Name, Value);
	
	If TypeOf(Value) = Type("Map") Then
		ValueList = New ValueList;
		For Each KeyAndValue In Value Do
			ValueList.Add(KeyAndValue.Value, KeyAndValue.Key);
		EndDo;
		ValueList.SortByPresentation();
		For Each ListItem In ValueList Do
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Presentation);
			Context.VersionPropertiesRightCalculationStructure.Add(ListItem.Value);
		EndDo;
	Else
		Context.VersionPropertiesRightCalculationStructure.Add(Name);
		Context.VersionPropertiesRightCalculationStructure.Add(Value);
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
Function Power16(Power)
	
	Power16 = 1;
	
	For Counter = 1 To Power Do
		Power16 = Power16 * 16;
	EndDo;
	
	Return Power16;
	
EndFunction

// For the FillFieldsAndAdditionalTablesGroups function.
Function AdditionalTablesGroups(Context)
	
	AdditionalTables = Context.RestrictionStructure.AdditionalTables;
	GroupsNumbersByAliases = New Map;
	
	BasicFields = Context.BasicFields;
	BasicFields.Insert("ByAdditionalTables", New Map);
	
	Context.Insert("AdditionalTablesConnectionConditionsFields", New Array);
	
	LastGroup = 0;
	For Each AdditionalTable In AdditionalTables Do
		AdditionalTable.Insert("RequiredTablesAliases", New Array);
		AdditionalTable.Insert("ConnectionConditionFields", New Array);
		AdditionalTable.Insert("ConnectionTestField", "");
		
		ConnectionConditionText = ConnectionConditionText(AdditionalTable, Context);
		AdditionalTable.Insert("ConnectionConditionText", ?(Left(ConnectionConditionText, 1) = "(",
			ConnectionConditionText, "(" + ConnectionConditionText + ")"));
		
		If Not ValueIsFilled(AdditionalTable.ConnectionTestField) Then
			AccessKeyFields = Context.RestrictionStructure.InternalData.AccessKeyFields;
			For Each FieldDetails In AccessKeyFields Do
				If FieldDetails.Field.Alias = AdditionalTable.Alias Then
					AdditionalTable.ConnectionTestField =
						AdditionalTable.Alias + "." + FieldDetails.Field.Name;
				EndIf;
			EndDo;
		EndIf;
		
		CurrentGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If CurrentGroup = Undefined Then
			LastGroup = LastGroup + 1;
			CurrentGroup = LastGroup;
			GroupsNumbersByAliases.Insert(AdditionalTable.Alias, CurrentGroup);
		EndIf;
		
		For Each Alias In AdditionalTable.RequiredTablesAliases Do
			RequiredTableGroup = GroupsNumbersByAliases.Get(Alias);
			If RequiredTableGroup = Undefined Then
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup);
				Continue;
			EndIf;
			If RequiredTableGroup = CurrentGroup Then
				Continue;
			EndIf;
			GroupToReplaceAliases = New Array;
			For Each KeyAndValue In GroupsNumbersByAliases Do
				If KeyAndValue.Value <> RequiredTableGroup Then
					Continue;
				EndIf;
				GroupToReplaceAliases.Add(KeyAndValue.Key);
			EndDo;
			For Each Alias In GroupToReplaceAliases Do
				GroupsNumbersByAliases.Insert(Alias, CurrentGroup);
			EndDo;
		EndDo;
	EndDo;
	
	TablesWithFiledsAliases = New Map;
	For Each FieldProperties In Context.FieldsProperties Do
		If FieldProperties.TableAlias = "CurrentList" Then
			Continue;
		EndIf;
		TablesWithFiledsAliases.Insert(FieldProperties.TableAlias, True);
	EndDo;
	
	GroupsUse = New Map;
	For Folder = 1 To LastGroup Do
		For Each KeyAndValue In GroupsNumbersByAliases Do
			If KeyAndValue.Value <> Folder Then
				Continue;
			EndIf;
			If GroupsUse.Get(Folder) = Undefined Then
				GroupsUse.Insert(Folder, False);
			EndIf;
			If TablesWithFiledsAliases.Get(KeyAndValue.Key) <> Undefined Then
				GroupsUse.Insert(Folder, True);
			EndIf;
		EndDo;
	EndDo;
	
	NewGroup = 1;
	NewGroups = New Map;
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		If NewGroups.Get(OldGroup) <> Undefined Then
			Continue;
		EndIf;
		NewGroups.Insert(OldGroup, NewGroup);
		NewGroup = NewGroup + 1;
	EndDo;
	
	Groups = New Structure;
	Groups.Insert("NumbersByAliases",     New Map);
	Groups.Insert("TablesByGroups",        New Map);
	Groups.Insert("TablesWithFiledsAliases", TablesWithFiledsAliases);
	
	For Each AdditionalTable In AdditionalTables Do
		OldGroup = GroupsNumbersByAliases.Get(AdditionalTable.Alias);
		If Not GroupsUse.Get(OldGroup) Then
			Continue;
		EndIf;
		SetBasicFieldUse(BasicFields, , AdditionalTable);
		Folder = NewGroups.Get(OldGroup);
		Groups.NumbersByAliases.Insert(AdditionalTable.Alias, Folder);
		TablesGroup = Groups.TablesByGroups.Get(Folder);
		If TablesGroup = Undefined Then
			TablesGroup = New Array;
			Groups.TablesByGroups.Insert(Folder, TablesGroup);
		EndIf;
		TablesGroup.Add(AdditionalTable);
	EndDo;
	
	For Each FieldProperties In Context.FieldsProperties Do
		CurrentProperties = FieldProperties;
		While CurrentProperties <> Undefined Do
			AddLeadingListsByFieldsValues(Context,
				CurrentProperties.FieldNode,
				CurrentProperties.AttachmentProperties,
				?(CurrentProperties.IsListField, Undefined, CurrentProperties.TableAlias));
			CurrentProperties = CurrentProperties.AttachmentProperties;
		EndDo;
	EndDo;
	
	For Each ConditionFieldDetails In Context.AdditionalTablesConnectionConditionsFields Do
		Folder = Groups.NumbersByAliases.Get(ConditionFieldDetails.ConditionTableAlias);
		If Folder <> Undefined Then
			FieldNode = ConditionFieldDetails.FieldNode;
			AddVersionProperties(Context, FieldNode, "Alias, Name, TypesString");
			AddLeadingListsByFieldsValues(Context, FieldNode,,
				Groups.TablesByGroups.Get(Folder), ConditionFieldDetails.ConditionTableAlias);
		EndIf;
	EndDo;
	
	For Each Details In Context.LeadingListsByFieldsValues.FiltersConnections Do
		FillFiltersByLeadingListFieldsValues(Details.Key,
			Details.Value, Groups, Context);
	EndDo;
	FillLeadingListsFiltersByFieldRef(Context.LeadingListsByAccessKeys, Groups, Context);
	FillLeadingListsFiltersByFieldRef(Context.LeadingListsByValuesWithGroups, Groups, Context);
	
	Return Groups;
	
EndFunction

// For the AdditionalTablesGroups function.
Function ConnectionConditionText(AdditionalTable, Context,
			Condition = Null, Field = Undefined, Alias = Undefined)
	
	If Condition = Null Then
		Condition = AdditionalTable.ConnectionCondition;
	EndIf;
	
	// Possible nodes: "Field", ''Value", "Constant", "AND", "=".
	
	If Condition.Node = "Field" Then
		Context.AdditionalTablesConnectionConditionsFields.Add(New Structure(
			"FieldNode, ConditionTableAlias", Condition, AdditionalTable.Alias));
		If Condition.Alias = Context.RestrictionStructure.MainTableAlias Then
			AddBasicField(Context, Condition, , AdditionalTable);
			Alias = "CurrentList";
			Field = Alias + "." + Condition.Name;
			Return FieldNameExpandingBasicFieldsByTypes(Alias, Condition);
		EndIf;
		Alias = Condition.Alias;
		If Alias = AdditionalTable.Alias Then
			If AdditionalTable.ConnectionTestField = "" Then
				AdditionalTable.ConnectionTestField = Alias + "." + Condition.Name;
			EndIf;
		ElsIf AdditionalTable.RequiredTablesAliases.Find(Alias) = Undefined Then
			AdditionalTable.RequiredTablesAliases.Add(Alias);
		EndIf;
		Field = Alias + "." + Condition.Name;
		Return Field;
	EndIf;
	
	If Condition.Node = "Value"
	 Or Condition.Node = "Constant" Then
		
		Field = ValueOrConstantNodeExpression(Condition);
		Return Field;
	EndIf;
	
	If Upper( Condition.Node ) = Upper( "AND" ) Then // PATCHED:
		Text = "";
		For Each Argument In Condition.Arguments Do
			Text = Text + ?(Text = "", "", Chars.LF + "AND ");
			Text = Text + ConnectionConditionText(AdditionalTable, Context, Argument);
		EndDo;
		Return Text;
	EndIf;
	
	If Condition.Node = "=" Then
		FirstField = New Structure("Field, Alias");
		SecondField = New Structure("Field, Alias");
		
		FirstArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.FirstArgument, FirstField.Field, FirstField.Alias);
		
		SecondArgument = ConnectionConditionText(AdditionalTable,
			Context, Condition.SecondArgument, SecondField.Field, SecondField.Alias);
		
		If FirstField.Alias = AdditionalTable.Alias
		 Or Not ValueIsFilled(SecondField.Alias) Then
			ConditionText = "(" + FirstArgument + " = " + SecondArgument + ")";
			ConditionFields = New Structure("FirstField, SecondField", FirstField, SecondField);
		Else
			ConditionText = "(" + SecondArgument + " = " + FirstArgument + ")";
			ConditionFields = New Structure("FirstField, SecondField", SecondField, FirstField);
		EndIf;
		AdditionalTable.ConnectionConditionFields.Add(ConditionFields);
		Return ConditionText;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert';ro = 'Nu a fost determinată procesarea nodului ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir'; es_ES = 'El procesamiento del nodo no se ha realizado ""%1""'"), Condition.Node);
	
	Raise ErrorText;
	
EndFunction

// For the FieldProperties and ConnectionConditionText functions.
Procedure AddBasicField(Context, FieldNode, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If Not FieldNode.Property("DefaultOrder") Then
		Return;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	If Position = 0 Then
		BasicFieldName = FieldNode.Name;
	Else
		BasicFieldName = Left(FieldNode.Name, Position - 1);
	EndIf;
	
	BasicFields = Context.BasicFields;
	
	If FieldProperties <> Undefined Then
		BasicFields.ByFIeldProperties.Insert(FieldProperties, BasicFieldName);
	EndIf;
	
	If AdditionalTable <> Undefined Then
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames = Undefined Then
			BasicFieldsNames = New Array;
			BasicFields.ByAdditionalTables.Insert(AdditionalTable, BasicFieldsNames);
		EndIf;
		BasicFieldsNames.Add(BasicFieldName);
	EndIf;
	
	If BasicFields.List.FindByValue(BasicFieldName) = Undefined Then
		BasicFields.List.Add(BasicFieldName, FieldNode.DefaultOrder);
		BasicFieldTypes = FieldNode.FieldTypes[0];
		BasicFields.TypesByFieldNames.Insert(BasicFieldName, BasicFieldTypes);
		If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
			RestrictedTypes = New Array;
			If HasSimpleType(BasicFieldTypes) Then
				For Each Type In BasicFieldTypes.Types() Do
					If IsSimpleType(Type) Then
						RestrictedTypes.Add(String(Type));
					EndIf;
				EndDo;
				ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'В ограничении доступа списка %1
					           |опорное поле %2 содержит простые типы: %3.
					           |
					           |Это недопустимо при использовании общего регистра сведений КлючиДоступаКРегистрам.
					           |Требуется либо исключить простые типы из состава типов опорного поля,
					           |либо создать отдельный регистр ключей доступа для этого списка.'; 
					           |en = 'In the %1 list access restriction
					           |, basic field %2 contains simple types: %3.
					           |
					           |It is not allowed when using common information register AccessKeysForRegisters.
					           |Either exclude simple types from the basic field types
					           |or create a separate register of access keys for this list.'; 
					           |pl = 'W ograniczeniu dostępu do listy %1
					           |referencyjne pole %2 zawiera proste typy: %3.
					           |
					           |To niedopuszczalne przy użyciu wspólnego rejestru informacji КлючиДоступаКРегистрам.
					           |Należy wykluczyć proste typy ze składu typów referencyjnego pola,
					           |albo utworzyć oddzielny rejestr kluczy dostępu do tej listy.';
					           |de = 'In der Listenzugriffsbeschränkung enthält %1
					           |das Referenzfeld %2 einfache Typen: %3.
					           |
					           |Dies ist bei Verwendung des allgemeinen Datenregisters ZugriffSchlüsselZuRegister nicht erlaubt.
					           |Sie müssen entweder einfache Typen von den Referenzfeldtypen ausschließen
					           |oder ein eigenes Register der Zugriffsschlüssel für diese Liste erstellen. ';
					           |ro = 'În restricția de acces a listei %1
					           |câmpul de bază %2 conține tipurile simple: %3.
					           |
					           |Acest fapt este inadmisibil în cadrul utilizării registrului de date comun КлючиДоступаКРегистрам.
					           |Trebuie sau să excludeți tipurile simple din componența tipurilor câmpului de bază,
					           |sau să creați un registru separat al cheilor de acces pentru această listă.';
					           |tr = 'Liste erişim kısıtlamasında %1
					           | referans alanı %2 basit türleri içerir: %3. 
					           |
					           |
					           | KaydedicilereErişimAnahtarları ortak veri kaydedicisi kullanılırken buna izin verilmez. 
					           | Referans alanın türlerinin arasından basit türler çıkarılmalı, ya da bu liste için ayri anahtar kaydedicisi oluşturulmalıdır.'; 
					           |es_ES = 'En la restricción de acceso de la lista %1
					           |el campo base %2 contiene tipos simples: %3.
					           |
					           |No se admite al usar el registro común de información AccessKeysForRegisters.
					           |Se requiere excluir los tipos simples del contenido del campo base
					           |o crear un registro separado de claves de acceso para esta lista.'"),
					Context.List,
					BasicFieldName,
					StrConcat(RestrictedTypes, ", "));
				
				If Context.Property("ErrorOnCallException") Then
					Context.ErrorOnCallException.Text = ErrorText;
				EndIf;
				Raise ErrorText;
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// For the DeleteNotUsedAccessKindsFields and AdditionalTablesGroups procedures.
Procedure SetBasicFieldUse(BasicFields, FieldProperties = Undefined, AdditionalTable = Undefined)
	
	If FieldProperties <> Undefined Then
		BasicFieldName = BasicFields.ByFIeldProperties.Get(FieldProperties);
		If BasicFieldName <> Undefined Then
			BasicFields.List.FindByValue(BasicFieldName).Check = True;
		EndIf;
	Else
		BasicFieldsNames = BasicFields.ByAdditionalTables.Get(AdditionalTable);
		If BasicFieldsNames <> Undefined Then
			For Each BasicFieldName In BasicFieldsNames Do
				BasicFields.List.FindByValue(BasicFieldName).Check = True;
			EndDo;
		EndIf;
	EndIf;
	
EndProcedure

// For the FillFieldsAndAdditionalTablesGroups procedure.
Procedure CompleteBasicFieldsPreparation(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.List.SortByPresentation();
	
	For Each ListItem In BasicFields.List Do
		BasicFields.All.Add(ListItem.Value);
		BasicFields.AllItemsTypes.Add(New ValueStorage(
			BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		
		If ListItem.Check Then
			BasicFields.Used.Add(ListItem.Value);
			BasicFields.UsedItemsTypes.Add(New ValueStorage(
				BasicFields.TypesByFieldNames.Get(ListItem.Value)));
		EndIf;
	EndDo;
	
	BasicFields.Delete("List");
	BasicFields.Delete("TypesByFieldNames");
	BasicFields.Delete("ByFIeldProperties");
	BasicFields.Delete("ByAdditionalTables");
	
EndProcedure

// For the ConnectionConditionText and FieldProperties functions.
Function FieldNameExpandingBasicFieldsByTypes(Alias, FieldNode)
	
	If Not FieldNode.Property("DefaultOrder")
	 Or Not FieldNode.Property("NextFieldTables") Then
		
		Return Alias + "." + FieldNode.Name;
	EndIf;
	
	Position = StrFind(FieldNode.Name, ".");
	BasicField = Alias + "." + Left(FieldNode.Name, Position - 1);
	OtherFields = Mid(FieldNode.Name, Position + 1);
	
	FieldName = "";
	For Each TypeName In FieldNode.NextFieldTables[0] Do
		CurrentFieldName = "CAST(" + BasicField + " AS " + TypeName + ")." + OtherFields;
		If ValueIsFilled(FieldName) Then
			FieldName =
				"ISNULL(" + CurrentFieldName + ",
				|	" + TextWithIndent(FieldName, "	") + ")";
		Else
			FieldName = CurrentFieldName;
		EndIf;
	EndDo;
	
	Return FieldName;
	
EndFunction

// For the AccessRestrictionParameters function.
Procedure FillFieldProperties(Context)
	
	// 1. For argument fields of =, <>, In, IsNull comparison nodes, the comparison result is calculated 
	// and saved to the key.
	
	// 2. These values are saved for values of the Boolean type:
	// - Enumerations.AdditionalAccessValues.ValueTrue,
	// - Enumerations.AdditionalAccessValues.ValueFalse.
	
	// 3. For the values of types Number, Date, and String, the result of the comparison with the True 
	//    value is saved as indicated in clause 2.
	
	Context.Insert("AccessKeyFieldsProperties", New Map);
	
	Context.BasicFields.Insert("TypesByFieldNames", New Map);
	Context.BasicFields.Insert("ByFIeldProperties",  New Map);
	
	AddedFields = New Map;
	FieldsNamesForQuery = New Array;
	AccessKeyFields = Context.RestrictionStructure.InternalData.AccessKeyFields;
	For Each FieldDetails In AccessKeyFields Do
		FieldProperties = FieldProperties(FieldDetails.Field, Context);
		FieldProperties.Insert("Read", FieldDetails.Read);
		ClarifyComparisonFieldProperties(FieldProperties, FieldDetails, Context);
		FieldsSet = WhenConditionFieldsSet(FieldProperties, FieldDetails, Context);
		For Each FieldProperties In FieldsSet Do
			AddFieldTypesProperties(FieldProperties, FieldDetails, Context);
			SimilarFields = AddedFields.Get(Upper(FieldProperties.FieldNameForQuery));
			If SimilarFields = Undefined Then
				SimilarFields = New Array;
				AddedFields.Insert(Upper(FieldProperties.FieldNameForQuery), SimilarFields);
				FieldsNamesForQuery.Add(FieldProperties.FieldNameForQuery);
			EndIf;
			SimilarFields.Add(FieldProperties);
		EndDo;
	EndDo;
	
	FieldsProperties = New Array;
	CombinedFields = New Map;
	For Each FieldNameForQuery In FieldsNamesForQuery Do
		SimilarFields = AddedFields.Get(Upper(FieldNameForQuery));
		ProcessedSimilarFields = New Array;
		For Each FieldProperties In SimilarFields Do
			CombinedField = ProcessedCombinedField(ProcessedSimilarFields, FieldProperties);
			If CombinedField <> Undefined Then
				CombinedFields.Insert(FieldProperties, CombinedField);
				Continue;
			EndIf;
			ProcessedSimilarFields.Add(FieldProperties);
		EndDo;
		For Each FieldProperties In ProcessedSimilarFields Do
			FieldsProperties.Add(FieldProperties);
		EndDo;
	EndDo;
	
	For Each Details In Context.AccessKeyFieldsProperties Do
		CombinedField = CombinedFields.Get(Details.Value);
		If CombinedField <> Undefined Then
			Context.AccessKeyFieldsProperties[Details.Key] = CombinedField;
		EndIf;
	EndDo;
	
	For Each FieldProperties In FieldsProperties Do
		FieldProperties.Insert("ConfigurationTypeSavingTypes", New Array);
		FieldProperties.Insert("ExtensionTypeSavingTypes",   New Array);
		FieldProperties.Insert("SimpleTypeSavingTypes",      New Array);
		
		For Each Type In FieldProperties.TypeSavingTypes Do
			MetadataObject = Undefined;
			TypeName = TypeNameInQueryLanguage(Type, MetadataObject);
			
			If StrFind(TypeName, ".") = 0 Then
				FieldProperties.SimpleTypeSavingTypes.Add(Type);
				
			ElsIf MetadataObject.ConfigurationExtension() = Undefined Then
				FieldProperties.ConfigurationTypeSavingTypes.Add(Type);
			Else
				FieldProperties.ExtensionTypeSavingTypes.Add(Type);
			EndIf;
		EndDo;
	EndDo;
	
	Context.Insert("FieldsProperties", FieldsProperties);
	
EndProcedure

// For the FillFieldsProperties procedure.
Function ProcessedCombinedField(ProcessedSimilarFields, FieldProperties)
	
	For Each Field In ProcessedSimilarFields Do
		Compatible = True;
		If Field.TableAlias = "CurrentList"
		   AND Field.MultipleValuesGroups <> FieldProperties.MultipleValuesGroups Then
			Continue;
		EndIf;
		// Cannot determine a value type by a blank reference to an access key or a Null value, that is why 
		// saving the access key is incompatible with the other options.
		For Each Type In FieldProperties.AccessKeySavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.AccessKeySavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.ValueGroupSavingTypes.Find(Type)   <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible Then
			Continue;
		EndIf;
		// Cannot determine a value type by a Null value, that is why saving a group of values is 
		// incompatible with the other options.
		For Each Type In FieldProperties.ValueGroupSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ValueGroupSavingTypes Do
			If FieldProperties.ValueSavingTypes.Find(Type)        <> Undefined
			 Or FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.ProhibitedTypeSavingTypes.Find(Type) <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		// Instead of simple types, the AllowedType or RestrictedType values are saved, that is why saving 
		// of a restricted simple type is incompatible with other options.
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		For Each Type In Field.ProhibitedTypeSavingTypes Do
			If Not IsSimpleType(Type) Then
				Continue;
			EndIf;
			If FieldProperties.TypeSavingTypes.Find(Type)           <> Undefined
			 Or FieldProperties.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Compatible = False;
				Break;
			EndIf;
		EndDo;
		If Not Compatible Then
			Continue;
		EndIf;
		// Merging clarifications of special values.
		Field.HasAdjustmentNull =
			Field.HasAdjustmentNull Or FieldProperties.HasAdjustmentNull;
		Field.HasAdjustmentUndefined =
			Field.HasAdjustmentUndefined Or FieldProperties.HasAdjustmentUndefined;
		Field.HasHeadListType =
			Field.HasHeadListType Or FieldProperties.HasHeadListType;
		Field.HasRightsSettingsOwnerType =
			Field.HasRightsSettingsOwnerType Or FieldProperties.HasRightsSettingsOwnerType;
		Field.HasAuthorizedUserCheck =
			Field.HasAuthorizedUserCheck Or FieldProperties.HasAuthorizedUserCheck;
		// Merging types of saving of a blank reference.
		For Each Type In FieldProperties.EmptyRefSavingTypes Do
			If Field.EmptyRefSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.EmptyRefSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of the AllowedType value.
		For Each Type In FieldProperties.AllowedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.AllowedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.AllowedTypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of the RestrictedType value.
		For Each Type In FieldProperties.ProhibitedTypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type)        <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)           <> Undefined
			 Or Field.ProhibitedTypeSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
				Field.TypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			Field.ProhibitedTypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving of a value type.
		For Each Type In FieldProperties.TypeSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined
			 Or Field.TypeSavingTypes.Find(Type)    <> Undefined Then
				Continue;
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
			EndIf;
			Field.TypeSavingTypes.Add(Type);
		EndDo;
		// Merging types of saving a value.
		For Each Type In FieldProperties.ValueSavingTypes Do
			If Field.ValueSavingTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Index = Field.TypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.TypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.ProhibitedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.ProhibitedTypeSavingTypes.Delete(Index);
			EndIf;
			Index = Field.AllowedTypeSavingTypes.Find(Type);
			If Index <> Undefined Then
				Field.AllowedTypeSavingTypes.Delete(Index);
			EndIf;
			Field.ValueSavingTypes.Add(Type);
		EndDo;
		// Merging not used types of access values.
		For Each Type In FieldProperties.UnusedAccessValueTypes Do
			If Field.UnusedAccessValueTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UnusedAccessValueTypes.Add(Type);
		EndDo;
		// Merging used access value types.
		For Each Type In FieldProperties.UsedAccessValuesTypes Do
			If Field.UsedAccessValuesTypes.Find(Type) <> Undefined Then
				Continue;
			EndIf;
			Field.UsedAccessValuesTypes.Add(Type);
		EndDo;
		Field.Read = Field.Read Or FieldProperties.Read;
		If Field.TypesString <> FieldProperties.TypesString Then
			Field.TypesString = Field.TypesString + Chars.LF + FieldProperties.TypesString;
		EndIf;
		Return Field;
	EndDo;
	
	Return Undefined;
	
EndFunction

// For the FillFieldsProperties procedure.
Procedure ClarifyComparisonFieldProperties(Properties, FieldDetails, Context)
	
	Context.AccessKeyFieldsProperties.Insert(FieldDetails.Field, Properties);
	
	Parent = FieldDetails.Parents[0];
	
	Nodes = ",ValueType,=,<>,IN,IsNull,"; // A comparison result is saved to the key.
	If StrFind(Nodes, "," + Parent.Node + ",") = 0 Then
		Return;
	EndIf;
	
	If Parent.Node = "ValueType" Then
		ComparisonNodeParent = FieldDetails.Parents[1];
		
		If ComparisonNodeParent.SecondArgument = Parent Then
			NodeType         = ComparisonNodeParent.FirstArgument;
			NodeValueType = ComparisonNodeParent.SecondArgument;
		Else
			NodeType         = ComparisonNodeParent.SecondArgument;
			NodeValueType = ComparisonNodeParent.FirstArgument;
		EndIf;
		Context.AccessKeyFieldsProperties.Insert(NodeValueType, Properties);
		
		ValueTypeExpression = "VALUETYPE(" + Properties.FieldNameForQuery + ")";
		TypeExpression = "TYPE(" + NodeType.Name + ")";
		AsOneString = StrLen(ValueTypeExpression) + StrLen(TypeExpression) < 60;
		
		Properties.FieldNameForQuery = ValueTypeExpression + ?(AsOneString, " ", "
		|			") + ComparisonNodeParent.Node + " " + TypeExpression;
		
	ElsIf Parent.Node = "="
	      Or Parent.Node = "<>" Then
		
		ValueOrConstantNode = ?(Parent.SecondArgument = FieldDetails.Field,
			Parent.FirstArgument, Parent.SecondArgument);
		
		NodeExpression = ValueOrConstantNodeExpression(ValueOrConstantNode);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " ", "
		|			") + Parent.Node + " " + NodeExpression;
		
	ElsIf Upper( Parent.Node ) = Upper( "IN" ) Then // PATCHED:
		
		ValueList = "";
		For Each ValueOrConstantNode In Parent.Values Do
			ValueList = ValueList + ?(ValueList = "", "", ",");
			LastRow = StrGetLine(ValueList, StrLineCount(ValueList));
			If StrLen(LastRow) > 40 Then
				ValueList = ValueList + "
				|			";
			Else
				ValueList = ValueList + " ";
			EndIf;
			ValueList = ValueList
				+ ValueOrConstantNodeExpression(ValueOrConstantNode);
		EndDo;
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + "
		|	IN (" + ValueList + ")";
	
	Else // Parent.Node = "IsNull".
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + " IS NULL";
		Properties.Insert("CheckHasNull");
	EndIf;
	
	Properties.EndFieldType = New TypeDescription("Boolean");
	
EndProcedure

// For the FillFieldsProperties procedure.
Function WhenConditionFieldsSet(InitialFieldProperties, FieldDetails, Context)
	
	Parent = FieldDetails.Parents[0];
	FieldsSet = New Array;
	
	If Parent.Node <> "Case"
	 Or Parent.Case = Undefined Then
		
		FieldsSet.Add(InitialFieldProperties);
		Return FieldsSet;
	EndIf;
	
	// For "CASE <Field> WHEN <Value>" comparison result "<Field> = <Value>" is saved to key.
	// 
	
	For Each WhenDetails In Parent.When Do
		FixedProperties = New FixedStructure(InitialFieldProperties);
		Properties = New Structure(FixedProperties);
		
		NodeExpression = ValueOrConstantNodeExpression(WhenDetails.Condition);
		AsOneString = StrLen(Properties.FieldNameForQuery) + StrLen(NodeExpression) < 60;
		
		Properties.FieldNameForQuery = Properties.FieldNameForQuery + ?(AsOneString, " = ", "
		|			= ") + NodeExpression;
		
		Properties.EndFieldType = New TypeDescription("Boolean");
		FieldsSet.Add(Properties);
		
		Context.AccessKeyFieldsProperties.Insert(WhenDetails.Condition, Properties);
	EndDo;
	
	Return FieldsSet;
	
EndFunction

// For FieldProperties, ClarifyComparisonFieldProperties, and WhenConditionFieldsSet functions.
Function NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	Return StrOccurrenceCount(FieldProperties.FieldNameForQuery, ".") = 1
	      AND Not FieldProperties.Property("FieldContainsNull")
	      AND (    StrStartsWith(FieldProperties.FieldNameForQuery, "CurrentList")
	         Or OneAdditionalTableWithFieldsInGroup);
	
EndFunction

// For the FillFieldsProperties procedure.
Procedure AddFieldTypesProperties(Properties, FieldDetails, Context)
	
	Properties.Insert("AccessKeySavingTypes",               New Array);
	Properties.Insert("ValueGroupSavingTypes",               New Array);
	Properties.Insert("ValueSavingTypes",                    New Array);
	Properties.Insert("EmptyRefSavingTypes",                New Array);
	Properties.Insert("TypeSavingTypes",                       New Array);
	Properties.Insert("ProhibitedTypeSavingTypes",             New Array);
	Properties.Insert("AllowedTypeSavingTypes",             New Array);
	Properties.Insert("UnusedAccessValueTypes",         New Array);
	Properties.Insert("UsedAccessValuesTypes",           New Array);
	Properties.Insert("MultipleValuesGroups",                    False);
	Properties.Insert("IsAccessValueListWithValueGroups", False);
	Properties.Insert("HasAdjustmentNull",                         False);
	Properties.Insert("HasAdjustmentUndefined",                 False);
	Properties.Insert("HasHeadListType",                     False);
	Properties.Insert("HasRightsSettingsOwnerType",              False);
	Properties.Insert("HasAuthorizedUserCheck",   False);
	
	Parent = FieldDetails.Parents[0];
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed"
	 Or Parent.Node = "ValueAllowed"
	 Or Parent.Node = "IsAuthorizedUser" Then
		
		HasBlankRefClarification          = TypeClarified(Parent, "EmptyRef");
		Properties.HasAdjustmentNull         = TypeClarified(Parent, "Null") Or Properties.Property("HasExpress");
		Properties.HasAdjustmentUndefined = TypeClarified(Parent, "Undefined");
	EndIf;
	
	If Parent.Node = "ObjectReadingAllowed"
	 Or Parent.Node = "ObjectUpdateAllowed"
	 Or Parent.Node = "ListReadingAllowed"
	 Or Parent.Node = "ListUpdateAllowed" Then
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If IsSimpleType(Type) Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type = Type("CatalogRef.MetadataObjectIDs")
			 Or Type = Type("CatalogRef.ExtensionObjectIDs") Then
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Parent.Node = "ListReadingAllowed"
			 Or Parent.Node = "ListUpdateAllowed" Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If Context.ListsWithKeysRecordForDependentListsWithoutKeys <> Undefined
			   AND Not Context.UsesRestrictionByOwner
			   AND (    Context.ListsWithRestriction.Get(TypeName) = Undefined
			      Or Context.ListsWithDisabledRestriction.Get(TypeName) <> Undefined) Then
				
				Properties.TypeSavingTypes.Add(Type);
				Properties.HasHeadListType = True;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			Value = Context.RightsSettingsOwnersTypes.Get(Type);
			If Value <> Undefined
			   AND Upper(Context.List) = Upper(Value[0].RightsOwner) Then
				
				Properties.ValueSavingTypes.Add(Type);
				Properties.HasRightsSettingsOwnerType = True;
				AddRightsRestrictionKind("RightsSettings." + TypeName, Properties, Context);
				Continue;
			EndIf;
			
			Properties.AccessKeySavingTypes.Add(Type);
			AddLeadingListByFieldRef(Context.LeadingListsByAccessKeys,
				TypeName, FieldDetails, Properties, Context);
			AddRightsRestrictionKind("Object." + TypeName, Properties, Context);
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "ValueAllowed" Then
		AccessKindsProperties = Context.AccessKindsProperties;
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			AccessKindProperties = AccessKindsProperties.ByGroupsAndValuesTypes.Get(Type);
			If AccessKindProperties = Undefined Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			AddRightsRestrictionKind(AccessKindProperties.Name, Properties, Context);
			
			If Context.ValuesTypesToUse.Get(AccessKindProperties.ValuesType) = Undefined Then
				Properties.UnusedAccessValueTypes.Add(AccessKindProperties.ValuesType);
				
				If TypeClarification(Parent, "Disabled") = "False" Then
					Properties.ProhibitedTypeSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			Properties.UsedAccessValuesTypes.Add(AccessKindProperties.ValuesType);
			
			If AccessKindsProperties.ByValuesTypes.Get(Type) = Undefined Then
				// Group type of access values.
				If Context.List = Metadata.FindByType(Type).FullName() Then
					Properties.ValueSavingTypes.Add(Type);
				Else
					Properties.AllowedTypeSavingTypes.Add(Type);
				EndIf;
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			If AccessKindsProperties.AccessValuesTypesWithGroups.Get(Type) = Undefined
			 Or Context.UserTypes.Find(Type) <> Undefined Then
				
				Properties.ValueSavingTypes.Add(Type);
				Continue;
			EndIf;
			Properties.ValueGroupSavingTypes.Add(Type);
			
			If Context.List = TypeName
			   AND Upper(Properties.FieldNameForQuery) = Upper("CurrentList.Ref") Then
				
				Properties.IsAccessValueListWithValueGroups = True;
			Else
				AddLeadingListByFieldRef(Context.LeadingListsByValuesWithGroups,
					TypeName, FieldDetails, Properties, Context);
			EndIf;
			
			If AccessKindsProperties.WithOneGroupForAccessValue.Find(Type) = Undefined Then
				Continue;
			EndIf;
			Properties.MultipleValuesGroups = True;
		EndDo;
		
		Return;
	EndIf;
	
	If Parent.Node = "IsAuthorizedUser" Then
		Properties.HasAuthorizedUserCheck = True;
		
		For Each Type In Properties.EndFieldType.Types() Do
			TypeName = TypeNameInQueryLanguage(Type);
			
			Clarification = TypeClarification(Parent, TypeName);
			If Clarification = "True" Then
				Properties.AllowedTypeSavingTypes.Add(Type);
				Continue;
			ElsIf Clarification = "False" Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Not CheckingType(Parent, TypeName) Then
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If Type <> Type("CatalogRef.Users")
			   AND Type <> Type("CatalogRef.ExternalUsers") Then
				
				Properties.ProhibitedTypeSavingTypes.Add(Type);
				Continue;
			EndIf;
			
			If HasBlankRefClarification Then
				Properties.EmptyRefSavingTypes.Add(Type);
			EndIf;
			
			Properties.ValueSavingTypes.Add(Type);
		EndDo;
		
		Return;
	EndIf;
	
	// Only Field nodes are available to receive the Boolean value.
	Properties.ValueSavingTypes.Add(Type("Boolean"));
	
	If Properties.EndFieldType.Types().Count() = 1
	   AND Properties.EndFieldType.ContainsType(Type("Boolean")) Then
		Return;
	EndIf;
	Properties.EndFieldType = New TypeDescription("Boolean");
	Properties.FieldNameForQuery = Properties.FieldNameForQuery + " = TRUE";
	
EndProcedure

// For the FieldsProperties and AddFieldTypesProperties functions.
Function TypeNameInQueryLanguage(Type, MetadataObject = Undefined)
	
	MetadataObject = Metadata.FindByType(Type);
	If MetadataObject <> Undefined Then
		Return MetadataObject.FullName();
	EndIf;
	
	Return String(Type);
	
EndFunction

// For the AddFieldTypesProperties procedure.
Procedure AddRightsRestrictionKind(RestrictionKind, FieldProperties, Context)
	
	If FieldProperties.Read Then
		Context.AllRightsRestrictionsKinds.Insert("Read." + RestrictionKind, True);
	EndIf;
	
	Context.AllRightsRestrictionsKinds.Insert("Update." + RestrictionKind, True);
	
EndProcedure

// For the FillFieldsProperties procedure.
Function FieldProperties(FieldNode, Context, FieldProperties = Undefined)
	
	Properties = New Structure;
	IsRootNode = FieldProperties = Undefined;
	
	If IsRootNode Then
		FieldProperties = Properties;
		// The IsNull() function can have only a field inside, it cannot have the Express() function.
		If ValueIsFilled(FieldNode.Cast) Then
			Types = New Array;
			Types.Add(RefTypeByFullMetadataName(FieldNode.Cast));
			EndFieldType = New TypeDescription(Types);
		Else
			EndFieldType = FieldNode.FieldTypes[FieldNode.FieldTypes.Count() - 1];
			If ValueIsFilled(FieldNode.IsNull) Then
				Types = New Array;
				Types.Add(ValueOrConstantNodeValueType(FieldNode.IsNull));
				EndFieldType = New TypeDescription(EndFieldType, Types);
			EndIf;
		EndIf;
	EndIf;
	
	If FieldNode.Attachment <> Undefined Then
		AttachmentProperties = FieldProperties(FieldNode.Attachment, Context, FieldProperties);
		TabularSection    = AttachmentProperties.TabularSection;
		TableAlias  = AttachmentProperties.TableAlias;
		FieldNameForQuery = AttachmentProperties.FieldNameForQuery + "." + FieldNode.Name;
		TypesString       = AttachmentProperties.TypesString + Chars.LF + FieldNode.TypesString;
	Else
		If TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription") Then
			TabularSection = "";
			If ValueIsFilled(FieldNode.Alias)
			   AND FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
				
				TableAlias = FieldNode.Alias;
				FieldNameForQuery = TableAlias + "." + FieldNode.Name;
			Else
				TableAlias = "CurrentList";
				AddBasicField(Context, FieldNode, FieldProperties);
				If Not ValueIsFilled(FieldNode.Cast) Then
					FieldNameForQuery = TextWithIndent(
						FieldNameExpandingBasicFieldsByTypes(TableAlias, FieldNode), "		");
				Else
					FieldNameForQuery = TableAlias + "." + FieldNode.Name;
				EndIf;
			EndIf;
		Else // The first part of the field name is a tabular section name.
			TabularSection = FieldNode.FieldTypes[0];
			TableAlias = "CurrentList" + TabularSection;
			NameParts = StrSplit(FieldNode.Name, ".");
			NameParts.Delete(0);
			FieldNameForQuery = TableAlias + "." + StrConcat(NameParts, ".");
		EndIf;
		TypesString = FieldNode.TypesString;
	EndIf;
	
	// The IsNull() function can have only a field inside, it cannot have the Express() function.
	If ValueIsFilled(FieldNode.IsNull) Then
		FieldNameForQuery = "ISNULL(" + FieldNameForQuery + ", "
			+ ValueOrConstantNodeExpression(FieldNode.IsNull) + ")";
		
		If IsRootNode Then
			Properties.Insert("NoNullValue", True);
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		FieldNameForQuery = "CAST(" + FieldNameForQuery + " AS " + FieldNode.Cast + ")";
		FieldProperties.Insert("HasExpress");
	EndIf;
	
	Properties.Insert("TableAlias",  TableAlias);
	Properties.Insert("FieldNameForQuery", FieldNameForQuery);
	Properties.Insert("EndFieldType",  EndFieldType);
	Properties.Insert("TypesString",       TypesString);
	
	If FieldNode.Property("FieldContainsNull") Then
		Properties.Insert("FieldContainsNull");
	EndIf;
	
	// To calculate leading lists.
	Properties.Insert("TabularSection",    TabularSection);
	Properties.Insert("AttachmentProperties",  AttachmentProperties);
	Properties.Insert("FieldNode",          FieldNode);
	Properties.Insert("IsListField",
		TableAlias = "CurrentList"
		Or AttachmentProperties <> Undefined
		  AND ValueIsFilled(AttachmentProperties.TabularSection));
	
	Return Properties;
	
EndFunction


// For the RestrictionParametersByRestrictionStructure function.
Function LeadingListsDetailsByFieldsValues()
	
	Return New Structure("Fields, FiltersConnections", New Map, New Map);
	
EndFunction

// For the AdditionalTablesGroups and FieldProperties functions.
Procedure AddLeadingListsByFieldsValues(Context, FieldNode, AttachmentProperties = Undefined,
			TablesGroup = Undefined, ConditionTableAlias = Undefined)
	
	AdditionalContext = New Structure;
	AdditionalContext.Insert("ParentFieldProperties",    AttachmentProperties);
	AdditionalContext.Insert("TablesGroup",            TablesGroup);
	AdditionalContext.Insert("ConditionTableAlias", ConditionTableAlias);
	AdditionalContext.Insert("FieldtableAlias",    FieldNode.Alias);
	
	FieldsNames = StrSplit(FieldNode.Name, ".");
	
	If FieldNode.Attachment <> Undefined Then
		AddLeadingListFieldByFieldsValues(Context, FieldNode.Table, FieldsNames[0],
			FieldNode.FieldTypes[0], AdditionalContext, True, True);
		
	ElsIf ValueIsFilled(FieldNode.Alias)
	        AND FieldNode.Alias <> Context.RestrictionStructure.MainTableAlias Then
		
		AddLeadingListFieldByFieldsValues(Context, FieldNode.Table, FieldsNames[0],
			FieldNode.FieldTypes[0], AdditionalContext);
	EndIf;
	
	FirstFieldIndex = ?(TypeOf(FieldNode.FieldTypes[0]) = Type("TypeDescription"), 0, 1);
	
	If FirstFieldIndex + 2 > FieldsNames.Count() Then
		Return;
	EndIf;
	
	ParentFieldProperties = New Structure("FieldNameForQuery, TabularSection");
	If AttachmentProperties <> Undefined Then
		FillPropertyValues(ParentFieldProperties, AttachmentProperties);
		ParentFieldProperties.FieldNameForQuery = ParentFieldProperties.FieldNameForQuery + "." + FieldsNames[FirstFieldIndex];
	Else
		If FirstFieldIndex > 0 Then
			ParentFieldProperties.TabularSection = FieldsNames[0];
		EndIf;
		If Not ValueIsFilled(FieldNode.Alias)
		 Or FieldNode.Alias = Context.RestrictionStructure.MainTableAlias Then
			
			ParentFieldAlias = "CurrentList";
			AdditionalContext.TablesGroup = Undefined;
		Else
			ParentFieldAlias = FieldNode.Alias;
		EndIf;
		ParentFieldProperties.FieldNameForQuery = ParentFieldAlias + "." + FieldsNames[FirstFieldIndex];
	EndIf;
	AdditionalContext.ParentFieldProperties = ParentFieldProperties;
	
	For Index = FirstFieldIndex + 1 To FieldsNames.Count()-1 Do
		Field = FieldsNames[Index];
		FieldType = FieldNode.FieldTypes[Index];
		For Each Table In FieldNode.NextFieldTables[Index-1] Do
			AddLeadingListFieldByFieldsValues(Context, Table, Field,
				FieldType, AdditionalContext, True, True);
		EndDo;
		ParentFieldProperties.FieldNameForQuery = ParentFieldProperties.FieldNameForQuery + "." + Field;
	EndDo;
	
EndProcedure

// For the AddLeadingListsByFieldsValues procedure.
Procedure AddLeadingListFieldByFieldsValues(Context, Table, Field, FieldType, AdditionalContext,
			IsMainTable = False, IsReferenceTableType = Undefined)
	
	If Not IsMainTable
	   AND StrOccurrenceCount(Table, ".") = 2 Then
		
		NameContent = StrSplit(Table, ".");
		TabularSection = NameContent[2];
		NameContent.Delete(2);
		FullName = StrConcat(NameContent, ".");
	Else
		TabularSection = "";
		FullName = Table;
	EndIf;
	
	If TypeOf(AdditionalContext.TablesGroup) <> Type("Array")
	   AND (    Upper(Field) = Upper("Ref")
	      Or Upper(Field) = Upper("Ref")) Then
		
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		If IsReferenceTableType Then
			Return;
		EndIf;
	EndIf;
	
	FieldsDetails      = Context.LeadingListsByFieldsValues.Fields.Get(FullName);
	ConnectionsDetails = Context.LeadingListsByFieldsValues.FiltersConnections.Get(FullName);
	
	If FieldsDetails = Undefined Then
		If IsReferenceTableType = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
			IsReferenceTableType = TableType.IsReferenceType;
		EndIf;
		FieldsDetails = New Structure;
		FieldsDetails.Insert("IsReferenceType", IsReferenceTableType);
		FieldsDetails.Insert("ForTracking", New Structure("HeaderFields, TabularSections",
			New Map, New Map));
		FieldsDetails.Insert("ForFilter", New Structure("HeaderFields, TabularSections",
			New Map, New Map));
		Context.LeadingListsByFieldsValues.Fields.Insert(FullName, FieldsDetails);
		
		ConnectionsDetails = New Structure("HeaderFields, TabularSections", New Map, New Map);
		Context.LeadingListsByFieldsValues.FiltersConnections.Insert(FullName, ConnectionsDetails);
	EndIf;
	
	InsertLeadingListFieldByFieldsValues(FieldsDetails.ForTracking, TabularSection, Field, FieldType);
	
	If ValueIsFilled(TabularSection) Then
		FiltersConnections = ConnectionsDetails.TabularSections.Get(TabularSection);
		If FiltersConnections = Undefined Then
			FiltersConnections = New Map;
			ConnectionsDetails.TabularSections.Insert(TabularSection, FiltersConnections);
		EndIf;
	Else
		FiltersConnections = ConnectionsDetails.HeaderFields;
	EndIf;
	
	If AdditionalContext.ParentFieldProperties <> Undefined Then
		If NameContent = Undefined Then
			NameContent = StrSplit(Table, ".");
			TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
		EndIf;
		RefType = New TypeDescription(TableType.LanguageRussian + "Ref." + NameContent[1]);
		InsertLeadingListFieldByFieldsValues(FieldsDetails.ForTracking, "", "Ref", RefType);
		InsertLeadingListFieldByFieldsValues(FieldsDetails.ForFilter,       "", "Ref", RefType);
		FieldNameForQuery = AdditionalContext.ParentFieldProperties.FieldNameForQuery;
		FilterConnection = FiltersConnections.Get(Upper(FieldNameForQuery));
		If FilterConnection = Undefined Then
			FilterConnection = New Structure;
			FilterConnection.Insert("FieldOrAlias", FieldNameForQuery);
			FilterConnection.Insert("FieldForFilter",    "Ref");
			FilterConnection.Insert("TabularSection",   AdditionalContext.ParentFieldProperties.TabularSection);
			FilterConnection.Insert("TablesGroup",     AdditionalContext.TablesGroup);
			FiltersConnections.Insert(Upper(FieldNameForQuery), FilterConnection);
			If TypeOf(AdditionalContext.TablesGroup) = Type("Array") Then
				FilterConnection.Insert("AllFieldsInTableCondition",
					AdditionalContext.FieldtableAlias = AdditionalContext.ConditionTableAlias);
			EndIf;
		EndIf;
	Else
		If TypeOf(AdditionalContext.TablesGroup) = Type("Array") Then
			InsertLeadingListFieldByFieldsValues(FieldsDetails.ForFilter, TabularSection, Field, FieldType);
			FilterConnection = FiltersConnections.Get(Upper(AdditionalContext.FieldtableAlias));
			If FilterConnection = Undefined Then
				FilterConnection = New Structure;
				FilterConnection.Insert("FieldOrAlias", AdditionalContext.FieldtableAlias);
				FilterConnection.Insert("FieldForFilter",    New Array);
				FilterConnection.Insert("TabularSection",   Undefined);
				FilterConnection.Insert("TablesGroup",     AdditionalContext.TablesGroup);
				FilterConnection.Insert("AllFieldsInTableCondition", True);
				FiltersConnections.Insert(Upper(AdditionalContext.FieldtableAlias), FilterConnection);
			EndIf;
			If FilterConnection.FieldForFilter.Find(Field) = Undefined Then
				FilterConnection.FieldForFilter.Add(Field);
				If AdditionalContext.FieldtableAlias <> AdditionalContext.ConditionTableAlias Then
					FilterConnection.AllFieldsInTableCondition = False;
				EndIf;
			EndIf;
		EndIf;
	EndIf;
	
EndProcedure

// For the AddLeadingListFieldByFieldsValues procedure.
Procedure InsertLeadingListFieldByFieldsValues(FieldsDetails, TabularSection, Field, FieldType)
	
	If ValueIsFilled(TabularSection) Then
		Fields = FieldsDetails.TabularSections.Get(TabularSection);
		If Fields = Undefined Then
			Fields = New Map;
			FieldsDetails.TabularSections.Insert(TabularSection, Fields);
		EndIf;
	Else
		Fields = FieldsDetails.HeaderFields;
	EndIf;
	
	If Fields.Get(Field) <> Undefined Then
		Return;
	EndIf;
	
	Fields.Insert(Field, New ValueStorage(FieldType));
	
EndProcedure

// For the RestrictionParametersByRestrictionStructure function.
Function LeadingListsDetailsByFieldsRef()
	
	Details = New Structure;
	Details.Insert("Lists",               New Map);
	Details.Insert("QueryKeysByTypes", New Map);
	Details.Insert("FiltersConnections",    New Map);
	Details.Insert("RefType",            New TypeDescription);
	
	Return Details;
	
EndFunction

// For the AddFieldTypesProperties procedure.
Procedure AddLeadingListByFieldRef(LeadingLists, LeadingList, FieldNode, FieldProperties, Context)
	
	NameContent = StrSplit(LeadingList, ".");
	TableType = Context.RestrictionStructure.InternalData.TablesTypesByNames.Get(Upper(NameContent[0]));
	RefTypeName = TableType.LanguageRussian + "Ref." + NameContent[1];
	
	LeadingLists.RefType = New TypeDescription(LeadingLists.RefType, RefTypeName);
	RefType = Type(RefTypeName);
	
	Keys = LeadingLists.QueryKeysByTypes.Get(LeadingList);
	If Keys = Undefined Then
		Keys = New Array;
		LeadingLists.QueryKeysByTypes.Insert(RefType, Keys);
		LeadingLists.Lists.Insert(LeadingList, True);
	EndIf;
	
	varKey = Upper(FieldProperties.FieldNameForQuery);
	If Keys.Find(varKey) = Undefined Then
		Keys.Add(varKey);
	EndIf;
	
	TablesGroup = ?(FieldProperties.IsListField, Undefined, FieldProperties.TableAlias);
	
	FilterConnection = LeadingLists.FiltersConnections.Get(varKey);
	If FilterConnection = Undefined Then
		FilterConnection = New Structure;
		FilterConnection.Insert("FieldOrAlias", FieldProperties.FieldNameForQuery);
		FilterConnection.Insert("FieldForFilter",    "Ref");
		FilterConnection.Insert("TabularSection",   FieldProperties.TabularSection);
		FilterConnection.Insert("TablesGroup",     TablesGroup);
		LeadingLists.FiltersConnections.Insert(varKey, FilterConnection);
	EndIf;
	
EndProcedure

// For the AdditionalTablesGroups function.
Procedure FillFiltersByLeadingListFieldsValues(LeadingList, Details, Groups, Context)
	
	FiltersConnections = New Array;
	For Each FilterConnection In Details.HeaderFields Do
		FiltersConnections.Add(FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
	EndDo;
	Details.HeaderFields = FiltersConnections;
	
	TabularSections = New Map;
	For Each TabularSectionDetails In Details.TabularSections Do
		FiltersConnections = New Array;
		TabularSections.Insert(TabularSectionDetails.Key, FiltersConnections);
		For Each FilterConnection In TabularSectionDetails.Value Do
			FiltersConnections.Add(FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
		EndDo;
	EndDo;
	Details.TabularSections = TabularSections;
	
EndProcedure

// For the AdditionalTablesGroups function.
Procedure FillLeadingListsFiltersByFieldRef(LeadingLists, Groups, Context)
	
	FiltersConnections = New Map;
	For Each FilterConnection In LeadingLists.FiltersConnections Do
		FiltersConnections.Insert(FilterConnection.Key,
			FilterConnectionTextByFieldsValues(FilterConnection.Value, Groups, Context));
	EndDo;
	LeadingLists.FiltersConnections = FiltersConnections;
	
EndProcedure

// For the FillFiltersByLeadingListFieldsValues procedure.
Function FilterConnectionTextByFieldsValues(Condition, Groups, Context)
	
	If Context.IsReferenceType Then
		AdditionalCondition = "";
	Else
		AdditionalCondition = ?(Not ValueIsFilled(Context.SeparateKeysRegisterName), "
		|		AND (CurrentList.Register = &RegisterID)", "") + "
		|		AND (CurrentList.ForExternalUsers = " + ?(Context.ForExternalUsers, "TRUE", "FALSE") + ")";
	EndIf;
	
	If Condition.TablesGroup = Undefined Or ValueIsFilled(Condition.TabularSection) Then
		ConnectionText =
		"#CurrentDataForFilter AS CurrentDataForFilter
		|	INNER JOIN &CurrentList AS CurrentList
		|	ON (" + Condition.FieldOrAlias + " = CurrentDataForFilter." + Condition.FieldForFilter + ")";
		If ValueIsFilled(Condition.TabularSection) Then
			ConnectionText = StrReplace(ConnectionText,
				"&CurrentList", "&CurrentList." + Condition.TabularSection);
			ConnectionText = StrReplace(ConnectionText,
				"CurrentList" + Condition.TabularSection + ".", "CurrentList.");
		EndIf;
		Return ConnectionText + AdditionalCondition;
	EndIf;
	
	If TypeOf(Condition.TablesGroup) = Type("String") Then
		IsConnectionConditionField = False;
		FilterFieldsAlias = Condition.TablesGroup;
		Folder = Groups.NumbersByAliases.Get(FilterFieldsAlias);
		TablesGroup = Groups.TablesByGroups.Get(Folder);
	Else
		IsConnectionConditionField = True;
		TablesGroup = Condition.TablesGroup;
		FieldToReplace = Condition.FieldOrAlias;
		FilterFieldsAlias = StrSplit(FieldToReplace, ".")[0];
	EndIf;
	
	Index = TablesGroup.Count();
	FirstAdditionalTableFound = False;
	BackwardTablesGroup = New Array;
	RequiredAliases = New Map;
	
	While Index >= 1 Do
		Index = Index - 1;
		AdditionalTable = TablesGroup[Index];
		FirstAlias = AdditionalTable.Alias;
		If Not FirstAdditionalTableFound AND FirstAlias <> FilterFieldsAlias Then
			Continue;
		EndIf;
		FirstAdditionalTableFound = True;
		If FirstAlias <> FilterFieldsAlias
		   AND RequiredAliases.Get(AdditionalTable.Alias) = Undefined Then
			Continue;
		EndIf;
		TableProperties = New Structure("Table, Alias, ConnectionConditionFields",
			AdditionalTable.Table, AdditionalTable.Alias, New Array);
		BackwardTablesGroup.Add(TableProperties);
		For Each FieldsPair In AdditionalTable.ConnectionConditionFields Do
			RequiredAliases.Insert(FieldsPair.FirstField.Alias, True);
			RequiredAliases.Insert(FieldsPair.SecondField.Alias, True);
			TableProperties.ConnectionConditionFields.Add(
				New Structure(New FixedStructure(FieldsPair)));
		EndDo;
	EndDo;
	
	AuxiliaryTable = Undefined;
	FirstTable = BackwardTablesGroup[0];
	AllFieldsReplaceable = True;
	
	If IsConnectionConditionField AND FirstTable.ConnectionConditionFields.Count() > 1 Then
		For Each FieldsPair In FirstTable.ConnectionConditionFields Do
			If StrFind(FieldsPair.FirstField.Field, FirstTable.Alias + ".") > 0
			   AND StrFind(FieldsPair.FirstField.Field, FieldToReplace + ".") = 0 Then
				AllFieldsReplaceable = False;
				Break;
			EndIf;
		EndDo;
	EndIf;
	
	If Not IsConnectionConditionField Or Not AllFieldsReplaceable Then
		AuxiliaryTable = New Structure("Table, Alias, ConnectionConditionFields",
			FirstTable.Table, "CurrentDataForFilter", New Array);
		BackwardTablesGroup.Insert(0, AuxiliaryTable);
		FieldsPair = New Structure("FirstField, SecondField");
		AuxiliaryTable.ConnectionConditionFields.Add(FieldsPair);
		FieldsPair.FirstField = New Structure("Field, Alias",
			Condition.FieldOrAlias, "CurrentDataForFilter");
		FieldsPair.SecondField = New Structure("Field, Alias",
			"CurrentDataForFilter." + Condition.FieldForFilter, FilterFieldsAlias);
		
	ElsIf TypeOf(Condition.TablesGroup) = Type("Array")
	        AND Not Condition.AllFieldsInTableCondition Then
		
		AuxiliaryTable = New Structure("Table, Alias, ConnectionConditionFields",
			FirstTable.Table, "CurrentDataForFilter", New Array);
		BackwardTablesGroup.Insert(0, AuxiliaryTable);
		If TypeOf(Condition.FieldForFilter) = Type("Array") Then
			For Each FieldForFilter In Condition.FieldForFilter Do
				FieldsPair = New Structure("FirstField, SecondField");
				AuxiliaryTable.ConnectionConditionFields.Add(FieldsPair);
				FieldsPair.FirstField = New Structure("Field, Alias",
					Condition.FieldOrAlias + "." + FieldForFilter, "CurrentDataForFilter");
				FieldsPair.SecondField = New Structure("Field, Alias",
					"CurrentDataForFilter." + FieldForFilter, FilterFieldsAlias);
			EndDo;
		Else
			FieldsPair = New Structure("FirstField, SecondField");
			AuxiliaryTable.ConnectionConditionFields.Add(FieldsPair);
			FieldsPair.FirstField = New Structure("Field, Alias",
				Condition.FieldOrAlias, "CurrentDataForFilter");
			FieldsPair.SecondField = New Structure("Field, Alias",
				"CurrentDataForFilter." + Condition.FieldForFilter, FilterFieldsAlias);
		EndIf;
		Index = FirstTable.ConnectionConditionFields.Count() - 1;
		InsertIndex = AuxiliaryTable.ConnectionConditionFields.Count();
		While Index >= 0 Do
			FieldsPair = FirstTable.ConnectionConditionFields[Index];
			If FieldsPair.FirstField.Alias = FirstTable.Alias Then
				FirstTable.ConnectionConditionFields.Delete(Index);
				AuxiliaryTable.ConnectionConditionFields.Insert(InsertIndex, FieldsPair);
			EndIf;
			Index = Index - 1;
		EndDo;
	EndIf;
	
	ConnectionText =
	"#CurrentDataForFilter AS CurrentDataForFilter";
	RemainingAliases = New Map;
	RemainingAliases.Insert("CurrentList", New Array);
	
	For Each AdditionalTable In BackwardTablesGroup Do
		RemainingAliases.Insert(AdditionalTable.Alias,
			New Array(New FixedArray(AdditionalTable.ConnectionConditionFields)));
	EndDo;
	
	ReplaceFirstField = True;
	Index = -1;
	For Each AdditionalTable In BackwardTablesGroup Do
		Index = Index + 1;
		
		FirstAlias = AdditionalTable.Alias;
		ConnectionConditionFields = RemainingAliases.Get(FirstAlias);
		RemainingAliases.Delete(FirstAlias);
		
		If Index >= BackwardTablesGroup.Count() - 1 Then
			SecondAlias = "CurrentList";
		Else
			SecondAlias = BackwardTablesGroup[Index + 1].Alias;
		EndIf;
		RemainingConnectionConditionFields = RemainingAliases.Get(SecondAlias);
		For Each FieldsPair In RemainingConnectionConditionFields Do
			ConnectionConditionFields.Add(FieldsPair);
		EndDo;
		RemainingAliases.Insert(SecondAlias, New Array);
		
		ConnectionConditions = New Array;
		For Each FieldsPair In ConnectionConditionFields Do
			If Not ValueIsFilled(FieldsPair.FirstField.Alias)
			   AND Not ValueIsFilled(FieldsPair.SecondField.Alias) Then
				
				ConnectionConditions.Add(FieldsPair.FirstField.Field
					+ " = " + FieldsPair.SecondField.Field);
				
			ElsIf FieldsPair.FirstField.Alias = FirstAlias
			        AND (Not ValueIsFilled(FieldsPair.SecondField.Alias)
			           Or FieldsPair.SecondField.Alias = SecondAlias)
			      Or FieldsPair.FirstField.Alias = SecondAlias
			        AND Not ValueIsFilled(FieldsPair.SecondField.Alias) Then
				
				FirstField = FieldsPair.FirstField.Field;
				
				If FieldsPair.FirstField.Alias = FirstAlias
				   AND ReplaceFirstField
				   AND AuxiliaryTable = Undefined Then
					
					Position = StrFind(FirstField, FieldToReplace);
					FieldBeginning = Left(FirstField, Position - 1);
					If Not StrStartsWith(FirstField, FieldToReplace) Then
						ErrorText = NStr("ru = 'Не удалось подготовить условие соединения запроса данных по зависимостям.'; en = 'Cannot prepare the join condition for data request by dependencies.'; pl = 'Nie udało się przygotować warunek połączenia danych zapytania na uzależnienia.';de = 'Es war nicht möglich, die Bedingung der Verknüpfung der Datenanforderung durch Abhängigkeiten vorzubereiten.';ro = 'Eșec la pregătirea condiției de conexiune a interogării datelor conform dependențelor.';tr = 'Veri talebi için bağımlılık durumuna göre birleştirme koşulu hazırlanamadı.'; es_ES = 'No se ha podido preparar la condición de conexión de solicitud de datos por dependencias.'");
						Raise ErrorText;
					EndIf;
					FieldEnd = Mid(FirstField, Position + StrLen(FieldToReplace));
					FirstField = FieldBeginning + "CurrentDataForFilter"
						+ ?(FieldToReplace <> FirstAlias, ".Ref", "") + FieldEnd;
				EndIf;
				If StrStartsWith(FirstField, "CurrentDataForFilter.") Then
					ConnectionConditions.Add(FieldsPair.SecondField.Field + " = " + FirstField);
					
				ElsIf StrStartsWith(FieldsPair.SecondField.Field, "CurrentDataForFilter.") Then
					ConnectionConditions.Add(FirstField + " = " + FieldsPair.SecondField.Field);
					
				ElsIf FieldsPair.SecondField.Alias = SecondAlias Then
					ConnectionConditions.Add(FieldsPair.SecondField.Field + " = " + FirstField);
				Else
					ConnectionConditions.Add(FirstField + " = " + FieldsPair.SecondField.Field);
				EndIf;
			Else
				RemainingConditions = RemainingAliases.Get(FieldsPair.FirstField.Alias);
				RemainingConditions.Add(FieldsPair);
			EndIf;
		EndDo;
		If SecondAlias = "CurrentList" Then
			TableAndAlias = "&CurrentList AS CurrentList";
		Else
			NextTable = BackwardTablesGroup[Index + 1];
			TableAndAlias = NextTable.Table + " AS " + NextTable.Alias;
		EndIf;
		ConnectionText = ConnectionText + "
		|	INNER JOIN " + TableAndAlias + "
		|	ON (" + StrConcat(ConnectionConditions, ")
		|		AND (") + ")";
		ReplaceFirstField = False;
	EndDo;
	
	Return ConnectionText + AdditionalCondition;
	
EndFunction


// For the AddBasicField, AddDimensionTypes, AddFieldTypesProperties, and
// AddCheckByTypes procedures and the FieldProperties function.
//
Function IsSimpleType(Type)
	
	Return Type = Type("Boolean")
	    Or Type = Type("Date")
	    Or Type = Type("String")
	    Or Type = Type("Number")
	    Or Type = Type("UUID")
	    Or Type = Type("ValueStorage");
	
EndFunction

// For the AddFieldTypesProperties function.
Function CheckingType(Node, FullName)
	
	If Node.Types.Count() = 0 Then
		Return True;
	EndIf;
	
	TypeSpecified = False;
	For Each TableName In Node.Types Do
		If Upper(TableName) = Upper(FullName) Then
			TypeSpecified = True;
			Break;
		EndIf;
	EndDo;
	
	Return Node.CheckTypesExceptListed AND Not TypeSpecified
	 Or Not Node.CheckTypesExceptListed AND    TypeSpecified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarified(Node, TypeNameInQueryLanguage)
	
	TypeClarified = False;
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			TypeClarified = True;
			Break;
		EndIf;
	EndDo;
	
	Return TypeClarified;
	
EndFunction

// For the AddFieldTypesProperties function.
Function TypeClarification(Node, TypeNameInQueryLanguage)
	
	Clarification = "";
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If Upper(ComparisonClarification.Key) = Upper(TypeNameInQueryLanguage) Then
			Clarification = ComparisonClarification.Value;
			Break;
		EndIf;
	EndDo;
	
	Return Clarification;
	
EndFunction

// For the FieldProperties function.
Function ValueOrConstantNodeValueType(Node)
	
	If Node.Node = "Value" Then
		Return RefTypeByFullPredefinedItemName(Node.Name);
	EndIf;
	
	Return TypeOf(Node.Value);
	
EndFunction

// For the ConnectionConditionText, FieldProperties, and WhenConditionFieldsSet functions and the 
// ClarifyComparisonFieldProperties procedure.
//
Function ValueOrConstantNodeExpression(Node)
	
	If Node.Node = "Value" Then
		Expression = "Value(" + Node.Name + ")";
	
	ElsIf TypeOf(Node.Value) = Type("Boolean") Then
		Expression = ?(Node.Value, "True", "False");
		
	ElsIf TypeOf(Node.Value) = Type("Number") Then
		Expression = Format(Node.Value, "NG=");
		
	ElsIf TypeOf(Node.Value) = Type("Undefined") Then
		Expression = "Undefined";
	Else
		Expression = """" + Node.Value + """";
	EndIf;
	
	Return Expression;
	
EndFunction

// For the ValueOrConstantNodeValueType function.
Function RefTypeByFullPredefinedItemName(FullPredefinedItemName)
	
	NameParts = StrSplit(FullPredefinedItemName, ".");
	NameParts.Delete(2);
	
	FullName = StrConcat(NameParts, ".");
	
	Return RefTypeByFullMetadataName(FullName);
	
EndFunction

// For the FieldProperties and RefTypeByFullPredefinedItemName functions.
Function RefTypeByFullMetadataName(FullName)
	
	If IsRussianVersionOfMetadataObjectKind(FullName) Then
		RefTypeName = StrReplace(FullName, ".", "Ref.");
	Else
		RefTypeName = StrReplace(FullName, ".", "Ref.");
	EndIf;
	
	Return Type(RefTypeName);
	
EndFunction

// For the RefTypeByFullMetadataName function.
Function IsRussianVersionOfMetadataObjectKind(FullName)
	
	FirstChar = Left(FullName, 1);
	
	Return FirstChar > "A" AND FirstChar < "Z"
	    Or FirstChar > "a" AND FirstChar < "z";
	
EndFunction

#EndRegion

#Region AccessRestrictionParametersQueryTextsForList

// The main function of the area, which is the second part of the 
// RestrictionParametersByRestrictionStructure function. It is not used when preparing stored access 
// restriction parameters, but is used when calling the RestrictionParameters function.
// 
//
Procedure AddQueryTextsToRestrictionParameters(Result)
	
	CheckTypeToDefineAccessKeysToRegistersRegisterField(Result.Context);
	
	Context = Result.Context;
	Result.Delete("Context");
	
	// Checking the Read and Update object rights or a record set in the database.
	Result.Insert("ReadEditRightsCheckQueryText");
	// Checking the Read object right or a record set in the database.
	Result.Insert("ReadRightsCheckQueryText");
	
	AddDateQueryTextOfNextDataItem(Result, Context); 
	
	If Result.DoNotWriteAccessKeys
	 Or Result.WriteAlwaysAllowedAccessKey Then
		
		// Query of objects or record filters to delete or set blank keys.
		Result.Insert("ObsoleteDataItemsQueryText");
		AddQueryTextOfObsoleteDataItems(Result, Context);
		
		If Result.WriteAlwaysAllowedAccessKey Then
			// Query of objects or record filters whose key is not allowed.
			Result.Insert("DataItemWithObsoleteAllowedKeyQueryText");
			AddQueryTextOfDataItemsWithObsoleteAllowedKey(Result, Context);
			
		ElsIf Result.UsesRestrictionByOwner Then
			// Generating right checking queries.
			FillReadUpdateRightsCheckQueries(Result, Context);
		EndIf;
		
		Return;
	EndIf;
	
	// Names of used key tables.
	Result.Insert("KeyTables");
	// Names of used key table attributes.
	Result.Insert("KeyTablesAttributes");
	
	// Query of objects or record filters whose access keys are obsolete.
	Result.Insert("DataItemWithObsoleteKeysQueryText");
	// Query of record filters that are missing in the register of register access keys upon background update.
	Result.Insert("DataItemsWithoutAccessKeysQueryText");
	// Query of record filters that are missing in the register of register access keys upon recording a new set.
	Result.Insert("NewCombinationsOfBasicFieldsValuesQueryText");
	// Query of objects or record filters whose access keys are obsolete by changes composition of 
	// leading objects (for a point job).
	Result.Insert("DetailsOfObsoleteAccessKeysForLeadingObjects", New Map);
	// Query of non-existent objects or record filters that are out of use.
	Result.Insert("ObsoleteDataItemsQueryText");
	
	// Query of current access keys of register record filters before writing calculated access keys.
	Result.Insert("CurrentRegisterAccessKeysQueryText");
	
	// Query of object values or record filters.
	Result.Insert("DataItemValueForAccessKeysQueryText");
	// Query of values from used access keys to compare them with values from objects or record filters.
	Result.Insert("ValueFromAccessKeysInUseForComparisonQueryText");
	// Query of values from all access keys to compare them with values from objects or record filters 
	// before writing a new key.
	Result.Insert("ValueFromAllAccessKeysForComparisonQueryText");
	// Query of checking if access key exists before writing a new key.
	Result.Insert("KeysForComparisonExistenceQueryText");
	
	// Query of access keys to update users and access groups, for which they are allowed.
	Result.Insert("AccessKeysQueryTextToUpdateRights");
	// Query of access keys by leading keys to update users and access groups, for which they are allowed.
	Result.Insert("KeysQueryTextByLeadingKeysToUpdateRights");
	// Query of values from access keys to calculate users and access groups, for which they are allowed.
	Result.Insert("ValueFromAccessKeysForRightsCalculationQueryText");
	// Query of not used access keys to set date of not using or deletion.
	Result.Insert("ObsoleteAccessKeysQueryText");
	
	Context.Insert("SeparateRegister", True); // Clarifying a key register for non-reference types.
	
	Context.Insert("KeyTables",                                       New Array);
	Context.Insert("KeyTablesAttributes",                               New Map);
	Context.Insert("CheckConditionParts",                               New Array);
	Context.Insert("PartsOfValuesFromObjectsQuery",                     New Array);
	Context.Insert("PartsOfValuesFromObjectsQueryToCompare",           New Array);
	Context.Insert("QueryPartsOfKeysExistenceToMap",        New Array);
	Context.Insert("PartsOfValuesFromKeysQueryToCalculateRights",         New Array);
	Context.Insert("ConditionPartsToSelectLeadingAccessKeysRights",         New Array);
	Context.Insert("ConditionPartsToSelectLeadingListsRights",               New Array);
	Context.Insert("ConditionPartsToSelectRightsByRightsSettingsOwners",     New Array);
	Context.Insert("PartsOfFilterConditionByLeadingAccessKeys",           New Array);
	Context.Insert("DetailsOfValidationRequestsOnLeadingObjects",          New Map);
	
	// Generating a query of data items with obsolete keys.
	FillTemplatesOfCheckQueryParts(Context);
	
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderCheck(Context, HeaderNumber);
	EndDo;
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeCheckQueryParts(Result, Context);
	
	// Generating queries of values from data items and keys.
	For HeaderNumber = 0 To 2 Do
		AddKeyHeaderFilling(Context, HeaderNumber);
	EndDo;
	AddKeysChoiceWithoutFieldsInHeader(Context);
	
	For KeyTabularSectionNumber = 1 To Context.KeyTabularSectionsCount Do
		AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber);
	EndDo;
	ComposeFillQueryParts(Result, Context);
	
	Result.KeyTables         = Context.KeyTables;
	Result.KeyTablesAttributes = Context.KeyTablesAttributes;
	
	AddQueryTextOfObsoleteDataItems(Result, Context);
	
	// Generating right checking queries.
	FillReadUpdateRightsCheckQueries(Result, Context);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure CheckTypeToDefineAccessKeysToRegistersRegisterField(Context)
	
	If Context.IsReferenceType Or Context.UsesRestrictionByOwner Then
		Return;
	EndIf;
	
	If ValueIsFilled(Context.SeparateKeysRegisterName) Then
		Dimensions = Metadata.InformationRegisters[Context.SeparateKeysRegisterName].Dimensions;
	Else
		Dimensions = Metadata.InformationRegisters.AccessKeysForRegisters.Dimensions;
	EndIf;
	
	MissingTypes = New Map;
	Fields = New Map;
	MissingTypesList = New ValueList;
	FieldsList = New ValueList;
	
	Index = Context.BasicFields.AllItemsTypes.Count() - 1;
	While Index >= 0 Do
		RequiredType = Context.BasicFields.AllItemsTypes.Get(Index).Get();
		DimensionType = Dimensions["Field" + (Index + 1)].Type;
		MissingType = New TypeDescription(RequiredType, , DimensionType.Types());
		For Each Type In MissingType.Types() Do
			If MissingTypes.Get(Type) = Undefined Then
				MissingTypes.Insert(Type, True);
				MissingTypesList.Add(RefTypeName(TypeNameInQueryLanguage(Type),
					Context.RestrictionStructure.InternalData.TablesTypesByNames));
				Field = Context.BasicFields.All.Get(Index);
				If Fields.Get(Field) = Undefined Then
					Fields.Insert(Field, True);
					FieldsList.Add(Field);
				EndIf;
			EndIf;
		EndDo;
		Index = Index - 1;
	EndDo;
	
	If MissingTypesList.Count() = 0 Then
		Return;
	EndIf;
	
	MissingTypesList.SortByValue();
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Для списка %1 
		           |не удалось подготовить параметры ограничения доступа к работе, так как
		           |в определяемом типе ПолеРегистраКлючейДоступаКРегистрам не хватает типов:
		           |	- %2,
		           |имеющихся у полей (%3) в ограничении доступа:
		           |	%4'; 
		           |en = 'Cannot prepare operation access restriction parameters for the %1 
		           |list due to
		           |missing types in the AccessKeysToRegistersRegisterField type to be defined:
		           |	- %2,
		           |that fields (%3) have in access restriction:
		           |	%4'; 
		           |pl = 'Dla listy %1 
		           |nie było możliwe przygotowanie parametrów, ograniczających dostęp do pracy, ponieważ
		           |w zdefiniowanym rodzaju ПолеРегистраКлючейДоступаКРегистрам nie wystarczające rodzajów:
		           |	- %2,
		           |istniejące u pól (%3) w ograniczeniu dostępu:
		           |	%4';
		           |de = 'Die Liste %1 
		           |konnte die Parameter für die Einschränkung des Zugriffs auf die Arbeit nicht vorbereiten, da
		           |im angegebenen Typ SchlüsselregisterfeldZugriffAufDieRegister nicht genügend Typen vorhanden sind:
		           |	- %2,
		           |Verfügbare Felder (%3) in Zugriffsbeschränkung:
		           |	%4';
		           |ro = 'Pentru lista %1 
		           |nu au putut fi pregătiți parametrii de restricționare a accesului la lucru, deoarece
		           |în tipul determinat ПолеРегистраКлючейДоступаКРегистрам sunt insuficiente tipurile:
		           |	- %2,
		           |existente la câmpurile (%3) în restricția de acces:
		           |	%4';
		           |tr = 'Liste için, %1
		           |iş erişim kısıtlama parametreleri hazırlanamadı, çünkü belirlenebilir
		           |KaydediciErişimAnahtarlarınınKayıtAlanının tanımlanmış türünde 
		           |\ t-,%2
		           | erişim kısıtlamasındaki%3 kullanılabilir alanlar yeterli değil: 
		           |\ t%4'; 
		           |es_ES = 'Para la lista %1 
		           |no se ha podido preparar los parámetros de restricción de acceso al trabajo porque 
		           |en el tipo determinado ПолеРегистраКлючейДоступаКРегистрам faltan tipos:
		           |	- %2,
		           | de los campos (%3) en restricción de acceso:
		           |	%4'"),
		Context.List,
		StrConcat(MissingTypesList.UnloadValues(), "," + Chars.LF + "	- "),
		StrConcat(FieldsList.UnloadValues(), ", "),
		TextWithIndent(Context.RestrictionsDetails.Get(Context.List).Text, "	"));
	
	Raise ErrorText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddDateQueryTextOfNextDataItem(Result, Context)
	
	If Not Result.ListWithDate AND Not Result.ListWithPeriod Then
		Return;
	EndIf;
	
	If Result.ListWithDate Then
		QueryText =
		"SELECT TOP 1
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|WHERE
		|	CurrentList.Date < &StartDate
		|
		|ORDER BY
		|	CurrentList.Date DESC";
	Else
		QueryText =
		"SELECT TOP 1
		|	CurrentList.Period AS Period
		|FROM
		|	&CurrentList AS CurrentList
		|WHERE
		|	CurrentList.Period < &StartDate
		|
		|ORDER BY
		|	CurrentList.Period DESC";
		If Context.TypeCollectionName = "CalculationRegisters" Then
			QueryText = StrReplace(QueryText, ".Period", ".RegistrationPeriod");
		EndIf;
	EndIf;
	
	QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
	
	Result.Insert("NextDataItemDateQueryText", QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddQueryTextOfDataItemsWithObsoleteAllowedKey(Result, Context)
	
	If Not Result.IsReferenceType Then
		Return;
	EndIf;
	
	FillTemplatesOfObjectCheckQueryParts(Context);
	QueryText = Context.CheckQueryPartText;
	
	Condition = "AccessKeysForObjects.Object IS NULL";
	If Result.ForExternalUsers Then
		ConnectionCondition = "	AND AccessKeysForObjects.ExternalUsersAccessKey = &AllowedAccessKey";
	Else
		ConnectionCondition = "	AND AccessKeysForObjects.UsersAccessKey = &AllowedAccessKey";
	EndIf;
	QueryText = StrReplace(QueryText, "#Joins", ConnectionCondition);
	QueryText = StrReplace(QueryText, "#Condition", Condition);
	QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
	
	Result.DataItemWithObsoleteAllowedKeyQueryText = QueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddQueryTextOfObsoleteDataItems(Result, Context)
	
	If Result.IsReferenceType Then
		If Result.ForExternalUsers Then
			If Result.DoNotWriteAccessKeys
			   AND Not Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
				QueryText =
				"SELECT TOP " + BatchSizeMarker() + "
				|	AccessKeysForObjects.Object AS CurrentRef
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
				|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
				|	AND AccessKeysForObjects.ExternalUsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)
				|
				|ORDER BY
				|	AccessKeysForObjects.Object";
			Else
				QueryText = "";
			EndIf;
		ElsIf Result.DoNotWriteAccessKeysForUsersAndExternalUsers Then
			QueryText =
			"SELECT TOP " + BatchSizeMarker() + "
			|	AccessKeysForObjects.Object AS CurrentRef
			|FROM
			|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
			|WHERE
			|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
			|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
			|
			|ORDER BY
			|	AccessKeysForObjects.Object";
		Else
			QueryText =
			"SELECT TOP " + BatchSizeMarker() + "
			|	AccessKeysForObjects.Object AS CurrentRef,
			|	CurrentList.Ref IS NULL AS Delete
			|FROM
			|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
			|		LEFT JOIN &CurrentList AS CurrentList
			|		ON (VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList))
			|			AND (CurrentList.Ref = AccessKeysForObjects.Object)
			|WHERE
			|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
			|	AND CAST(AccessKeysForObjects.Object AS &CurrentList) > &LastProcessedRef
			|	AND #Condition
			|
			|ORDER BY
			|	AccessKeysForObjects.Object";
			If Result.DoNotWriteAccessKeys Then
				Condition =
				"(AccessKeysForObjects.UsersAccessKey <> VALUE(Catalog.AccessKeys.EmptyRef)
				|		OR CurrentList.Ref IS NULL)";
			Else
				Condition = "CurrentList.Ref IS NULL";
			EndIf;
			QueryText = StrReplace(QueryText, "#Condition", Condition);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
		Result.ObsoleteDataItemsQueryText = QueryText;
		Return;
	EndIf;
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		RegisterName   = Result.SeparateKeysRegisterName;
		MainFilter = "";
	Else
		RegisterName   = "AccessKeysForRegisters";
		MainFilter = "AccessKeysForRegisters.Register = &RegisterID";
	EndIf;
	
	If Result.ForExternalUsers Then
		MainFilter = MainFilter + ?(MainFilter = "", "", "
		|	AND ") + "AccessKeysForRegisters.ForExternalUsers = TRUE";
	Else
		MainFilter = MainFilter + ?(MainFilter = "", "", "
		|	AND ") + "AccessKeysForRegisters.ForExternalUsers = FALSE";
	EndIf;
	BasicFields = Context.BasicFields;
	If BasicFields = Undefined Then
		MaxBasicFieldsCount =
			AccessManagementInternalCached.BasicRegisterFieldsCount(RegisterName);
	Else
		MaxBasicFieldsCount = BasicFields.MaxCount;
	EndIf;
	
	BasicFilterFields = "";
	BasicFieldsForFilter = "";
	BasicFieldsForOrdering = "";
	
	For Number = 1 To MaxBasicFieldsCount Do
		// Fields for selection.
		BasicFilterFields = BasicFilterFields + ?(BasicFilterFields = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + Number + " AS Field" + Number;
		
		// Fields for filter.
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|	AND ") + "AccessKeysForRegisters.Field" + AdditionalNumber + " = &Field" + AdditionalNumber;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "AccessKeysForRegisters.Field" + Number + " > &Field" + Number;
		
		Filter = ?(Number = 1, ?(MaxBasicFieldsCount > 1, "(", "") + Filter, "
		|			OR " + TextWithIndent(Filter, "			"));
		
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter;
		
		// Fields for ordering.
		BasicFieldsForOrdering = BasicFieldsForOrdering + ?(BasicFieldsForOrdering = "", "", ",
		|	") + "AccessKeysForRegisters.Field" + Number;
	EndDo;
	If MaxBasicFieldsCount > 1 Then
		BasicFieldsForFilter  = BasicFieldsForFilter  + ")";
	EndIf;
	
	If Result.DoNotWriteAccessKeys Then
		QueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	" + BasicFilterFields + "
		|FROM
		|	InformationRegister." + RegisterName + " AS AccessKeysForRegisters
		|WHERE
		|	" + MainFilter + "
		|	AND " + BasicFieldsForFilter + "
		|
		|ORDER BY
		|	" + BasicFieldsForOrdering;
	Else
		If ValueIsFilled(Result.SeparateKeysRegisterName) Then
			ClearingQueryText =
			"SELECT TOP " + BatchSizeMarker() + "
			|	" + BasicFilterFields + "
			|FROM
			|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|WHERE
			|	AccessKeysForRegisters.Register = &RegisterID
			|	AND " + BasicFieldsForFilter + "
			|
			|ORDER BY
			|	" + BasicFieldsForOrdering;
			Result.Insert("ObsoleteDataItemsFromCommonRegisterQueryText", ClearingQueryText);
		EndIf;
		Number = 1;
		BasicFilterFieldsOnCheck = "";
		BasicFieldsToMap = "";
		For Each BasicFieldName In BasicFields.Used Do
			// Fields for selection when checking if fields are obsolete before writing.
			BasicFilterFieldsOnCheck = BasicFilterFieldsOnCheck + ?(BasicFilterFieldsOnCheck = "", "", ",
			|	") + "AccessKeysForRegisters.Field" + Number + " AS Field" + Number;
			// Fields for mapping.
			BasicFieldsToMap = BasicFieldsToMap + ?(BasicFieldsToMap = "", "", "
			|AND ") + "CurrentList." + BasicFieldName + " = AccessKeysForRegisters.Field" + Number;
			Number = Number + 1;
		EndDo;
		
		InitialNumber = BasicFields.Used.Count() + 1;
		NonBlankFields = "";
		For Number = InitialNumber To BasicFields.MaxCount Do
			NonBlankFields = NonBlankFields + ?(NonBlankFields = "", "", "
			|		OR ") + "AccessKeysForRegisters.Field" + Number + " <> VALUE(Enum.AdditionalAccessValues.Null)";
		EndDo;
		NonBlankFields = ?(NonBlankFields = "", "FALSE", NonBlankFields);
		
		QueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	" + BasicFilterFields + ",
		|	" + NonBlankFields + " AS Delete
		|FROM
		|	InformationRegister." + RegisterName + " AS AccessKeysForRegisters
		|WHERE
		|	" + MainFilter + "
		|	AND " + BasicFieldsForFilter + "
		|	AND (" + TextWithIndent(NonBlankFields, "	") + "
		|			OR NOT TRUE IN
		|					(SELECT TOP 1
		|						TRUE
		|					FROM
		|						&CurrentList AS CurrentList
		|					WHERE
		|						" + TextWithIndent(BasicFieldsToMap, "						") + "))
		|
		|ORDER BY
		|	" + BasicFieldsForOrdering;
		
		CheckQueryText =
		"SELECT
		|	" + BasicFilterFieldsOnCheck + "
		|INTO AccessKeysForRegisters
		|FROM
		|	&AccessKeysForRegisters AS AccessKeysForRegisters
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|SELECT
		|	" + BasicFilterFieldsOnCheck + "
		|FROM
		|	AccessKeysForRegisters AS AccessKeysForRegisters
		|WHERE
		|	NOT TRUE IN
		|				(SELECT TOP 1
		|					TRUE
		|				FROM
		|					&CurrentList AS CurrentList
		|				WHERE
		|					" + TextWithIndent(BasicFieldsToMap, "						") + ")";
		
		QueryText = StrReplace(QueryText, "&CurrentList", Result.List);
		CheckQueryText = StrReplace(CheckQueryText, "&CurrentList", Result.List);
		Result.Insert("ObsoleteDataItemsCheckQueryText", CheckQueryText);
	EndIf;
	
	Result.ObsoleteDataItemsQueryText = QueryText;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillTemplatesOfCheckQueryParts(Context)
	
	If Context.IsReferenceType Then
		FillTemplatesOfObjectCheckQueryParts(Context);
	Else
		FillTemplatesOfRegisterCheckQueryParts(Context);
	EndIf;
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfObjectCheckQueryParts(Context)
	
	Context.Insert("CheckQueryText");
	Context.Insert("CheckQueryPartText");
	Context.Insert("SpotCheckQueryText");
	
	If Context.ListWithDate Then
		Context.CheckQueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR #Condition)
		|
		|ORDER BY
		|	CurrentList.Date DESC";
		
		Context.CheckQueryPartText =
		"SELECT DISTINCT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef,
		|	CurrentList.Date AS Date
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Date BETWEEN &StartDate AND &EndDate
		|	AND #Condition
		|
		|ORDER BY
		|	CurrentList.Date DESC";
	Else
		Context.CheckQueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND (AccessKeysForObjects.Object IS NULL
		|			OR #Condition)
		|
		|ORDER BY
		|	CurrentList.Ref";
		
		Context.CheckQueryPartText =
		"SELECT DISTINCT TOP " + BatchSizeMarker() + "
		|	CurrentList.Ref AS CurrentRef
		|FROM
		|	&CurrentList AS CurrentList
		|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
		|		#Joins
		|WHERE
		|	CurrentList.Ref >= &LastProcessedRef
		|	AND #Condition
		|
		|ORDER BY
		|	CurrentList.Ref";
	EndIf;
	
	Context.SpotCheckQueryText =
	"SELECT
	|	CurrentList.Ref AS CurrentRef
	|FROM
	|	&CurrentList AS CurrentList
	|		INNER JOIN CurrentListByLeadingObjects AS CurrentListByLeadingObjects
	|		ON (CurrentListByLeadingObjects.Ref = CurrentList.Ref)
	|		LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
	|		ON (AccessKeysForObjects.Object = CurrentList.Ref)
	|WHERE
	|	AccessKeysForObjects.Object IS NULL
	|			OR #Condition";
	
	If Not Context.Property("DetailsOfValidationRequestsOnLeadingObjects") Then
		Return;
	EndIf;
	
	DataChoiceForSpotCheckWrapperQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	CurrentList.Ref AS Ref
	|INTO CurrentListByLeadingObjects
	|FROM
	|	(#DataSelectionRequests) AS CurrentList";
	
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("DataSelectionWrapQueryText",
		DataChoiceForSpotCheckWrapperQueryText);
	
	QueryTemplate =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	CurrentList.Ref AS Ref
	|FROM
	|	";
	AddCheckQueriesByLeadingLists(QueryTemplate, Context);
	
EndProcedure

// For the FillTemplatesOfCheckQueryParts procedure.
Procedure FillTemplatesOfRegisterCheckQueryParts(Context)
	
	BasicFields = Context.BasicFields;
	BasicFields.Insert("ForSelection",         "");
	BasicFields.Insert("ConnectionCondition", "");
	BasicFields.Insert("ForFilter",         "");
	BasicFields.Insert("ForOrdering",   "");
	
	// For a new combination query.
	BasicFieldsForSelection = "";
	BasicFieldsConnectionCondition = "";
	BasicFieldsForGroupingOrOrdering = "";
	BasicFieldsForFilter = "";
	
	// To request current access keys.
	FilterCriterion = "";
	
	If Not ValueIsFilled(Context.SeparateKeysRegisterName) Then
		Context.SeparateRegister = False;
		// For a new combination query.
		BasicFieldsConnectionCondition  = "(AccessKeysForRegisters.Register = &RegisterID)";
		// To request current access keys.
		FilterCriterion                 = "CurrentList.Register = &RegisterID";
		// For other queries.
		BasicFields.ConnectionCondition = "(CurrentListSource.Register = CurrentList.Register)";
		BasicFields.ForFilter         = "CurrentList.Register = &RegisterID";
	EndIf;
	
	FilterByUsersType = ?(Context.ForExternalUsers, "TRUE", "FALSE");
	
	// For a new combination query.
	BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
	|			AND ") + "(AccessKeysForRegisters.ForExternalUsers = " + FilterByUsersType + ")";
	
	// To request current access keys.
	FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "", "
	|	AND ") + "CurrentList.ForExternalUsers = " + FilterByUsersType;
	
	// For other queries.
	BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
	|	AND ") + "(CurrentListSource.ForExternalUsers = " + FilterByUsersType + ")";
	
	BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", "
	|	AND ") + "CurrentList.ForExternalUsers = " + FilterByUsersType;
	
	Number = 0;
	For Each BasicFieldName In BasicFields.Used Do
		Number = Number + 1;
		
		// For a new combination query.
		BasicFieldsForSelection = BasicFieldsForSelection + ?(BasicFieldsForSelection = "", "", ",
		|	") + "CurrentRegister." + BasicFieldName + " AS Field" + Number;
		
		BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + Number + " = CurrentRegister." + BasicFieldName + ")";
		
		BasicFieldsForGroupingOrOrdering = BasicFieldsForGroupingOrOrdering
			+ ?(BasicFieldsForGroupingOrOrdering = "", "", ", ") + BasicFieldName;
		
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			CurrentBasicFieldName = BasicFields.Used[AdditionalNumber - 1];
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|	AND ") + "CurrentRegister." + CurrentBasicFieldName + " = &Field" + AdditionalNumber;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentRegister." + BasicFieldName + " > &Field" + Number;
		
		Filter = ?(Number = 1, ?(BasicFields.Used.Count() > 1, "(", "") + Filter, "
		|		OR " + TextWithIndent(Filter, "		"));
		
		BasicFieldsForFilter = BasicFieldsForFilter + ?(BasicFieldsForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter;
		
		// To request current access keys.
		FilterCriterion = FilterCriterion + ?(FilterCriterion = "", "", "
		|	AND ") + "CurrentList.Field" + Number + " = &Field" + Number + "_%1";
		
		// For other queries.
		BasicFields.ForSelection = BasicFields.ForSelection + ?(BasicFields.ForSelection = "", "", ",
		|	") + "CurrentList.Field" + Number + " AS Field" + Number;
		
		BasicFields.ConnectionCondition = BasicFields.ConnectionCondition + ?(BasicFields.ConnectionCondition = "", "", "
		|	AND ") + "(CurrentListSource.Field" + Number + " = CurrentList.Field" + Number + ")";
		
		Filter = "";
		For AdditionalNumber = 1 To Number - 1 Do
			Filter = Filter + ?(AdditionalNumber = 1, "", "
			|		AND ") + "CurrentList.Field" + AdditionalNumber + " = &Field" + AdditionalNumber;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|		AND ") + "CurrentList.Field" + Number + " > &Field" + Number;
		
		Filter = ?(Number = 1, ?(BasicFields.Used.Count() > 1, "(", "") + Filter, "
		|			OR " + TextWithIndent(Filter, "		"));
		
		BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", ?(Number = 1, "
		|	AND ", "")) + Filter;
		
		BasicFields.ForOrdering = BasicFields.ForOrdering + ?(BasicFields.ForOrdering = "", "", ", ") + "Field" + Number;
	EndDo;
	
	If BasicFields.Used.Count() > 1 Then
		BasicFieldsForFilter  = BasicFieldsForFilter  + ")";
		BasicFields.ForFilter = BasicFields.ForFilter + ")";
	EndIf;
	
	InitialNumber = Number + 1;
	For Number = InitialNumber To BasicFields.MaxCount Do
		// For a new combination query.
		BasicFieldsConnectionCondition = BasicFieldsConnectionCondition + ?(BasicFieldsConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + Number + " = VALUE(Enum.AdditionalAccessValues.Null))";
		// For check query.
		BasicFields.ForFilter = BasicFields.ForFilter + ?(BasicFields.ForFilter = "", "", "
		|	AND ") + "CurrentList.Field" + Number + " = VALUE(Enum.AdditionalAccessValues.Null)";
	EndDo;
	
	// Setting query templates.
	CheckCombinationsQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFields.ForSelection + "
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	" + BasicFields.ForFilter + "
	|	AND (#Condition)
	|
	|ORDER BY
	|	" + BasicFields.ForOrdering;
	
	Context.Insert("CheckQueryText", CheckCombinationsQueryText);
	
	SpotCombinationsCheckQueryText =
	"SELECT
	|	" + BasicFields.ForSelection + "
	|FROM
	|	CurrentListByLeadingObjects AS CurrentList
	|WHERE
	|	#Condition";
	
	Context.Insert("SpotCheckQueryText", SpotCombinationsCheckQueryText);
	
	DataChoiceWrapperForSpotCombinationsCheckQueryText =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFields.ForSelection + ",
	|	CurrentList.AccessKey AS AccessKey
	|INTO CurrentListByLeadingObjects
	|FROM
	|	(#DataSelectionRequests) AS CurrentList";
	
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("DataSelectionWrapQueryText",
		DataChoiceWrapperForSpotCombinationsCheckQueryText);
	
	QueryTemplate =
	"SELECT DISTINCT TOP " + BatchSizeMarker() + "
	|	" + BasicFields.ForSelection + ",
	|	CurrentList.AccessKey AS AccessKey
	|FROM
	|	";
	AddCheckQueriesByLeadingLists(QueryTemplate, Context);
	
	If Context.ListWithPeriod Then
		NewCombinationsQueryText =
		"SELECT TOP " + BatchSizeMarker() + "
		|	MAX(CurrentRegister.Period) AS Period,
		|	" + BasicFieldsForSelection + "
		|FROM
		|	&CurrentRegister AS CurrentRegister
		|		LEFT JOIN &CurrentList AS AccessKeysForRegisters
		|		ON " + BasicFieldsConnectionCondition + "
		|WHERE
		|	CurrentRegister.Period >= &StartDate
		|	AND (CurrentRegister.Period < &EndDate
		|		OR CurrentRegister.Period = &EndDate
		|			AND " + TextWithIndent(BasicFieldsForFilter, "	") + ")
		|	AND AccessKeysForRegisters.ForExternalUsers IS NULL
		|
		|GROUP BY
		|	" + BasicFieldsForGroupingOrOrdering + "
		|
		|ORDER BY
		|	Period DESC, " + BasicFieldsForGroupingOrOrdering;
		If Context.TypeCollectionName = "CalculationRegisters" Then
			NewCombinationsQueryText = StrReplace(NewCombinationsQueryText,
				".Period", ".RegistrationPeriod");
		EndIf;
	Else
		NewCombinationsQueryText =
		"SELECT DISTINCT TOP " + BatchSizeMarker() + "
		|	" + BasicFieldsForSelection + "
		|FROM
		|	&CurrentRegister AS CurrentRegister
		|		LEFT JOIN &CurrentList AS AccessKeysForRegisters
		|		ON " + BasicFieldsConnectionCondition + "
		|WHERE
		|	" + BasicFieldsForFilter + "
		|	AND AccessKeysForRegisters.ForExternalUsers IS NULL
		|
		|ORDER BY
		|	" + BasicFieldsForGroupingOrOrdering;
	EndIf;
	Context.Insert("NewCombinationsQueryText", NewCombinationsQueryText);
	
	// Current access keys query text.
	CurrentAccessKeysQueryText =
	"SELECT TOP 2
	|	CurrentList.AccessKey AS AccessKey
	|FROM
	|	&CurrentList AS CurrentList
	|WHERE
	|	" + FilterCriterion;
	Context.Insert("CurrentAccessKeysQueryText", CurrentAccessKeysQueryText);
	
EndProcedure

// For the FillTemplatesOfObjectCheckQueryParts and FillTemplatesOfRegisterCheckQueryParts procedures.
Procedure AddCheckQueriesByLeadingLists(QueryTemplate, Context)
	
	QueriesDetails = New Map;
	For Each FilterConnection In Context.LeadingListsByFieldsValues.FiltersConnections Do
		ConnectionDetails = FilterConnection.Value;
		Fields = Context.LeadingListsByFieldsValues.Fields.Get(FilterConnection.Key);
		LeadingTable = FilterConnection.Key;
		If ConnectionDetails.HeaderFields.Count() > 0 Then
			QueriesDetails.Insert(LeadingTable,
				CheckQueriesByLeadingListsDetails(ConnectionDetails.HeaderFields,
					Fields.ForFilter.HeaderFields, LeadingTable, QueryTemplate, Context));
		EndIf;
		For Each TabularSectionDetails In ConnectionDetails.TabularSections Do
			LeadingTable = FilterConnection.Key + "." + TabularSectionDetails.Key;
			FieldsTypes = Fields.ForFilter.TabularSections.Get(TabularSectionDetails.Key);
			QueriesDetails.Insert(LeadingTable,
				CheckQueriesByLeadingListsDetails(TabularSectionDetails.Value,
					FieldsTypes, LeadingTable, QueryTemplate, Context));
		EndDo;
	EndDo;
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("ByFieldsValues", QueriesDetails);
	
	AddCheckQueriesByLeadingListsRefField("ByValuesWithGroups", QueryTemplate, Context);
	AddCheckQueriesByLeadingListsRefField("ByAccessKeys", QueryTemplate, Context);
	
EndProcedure

// For the AddCheckQueriesByLeadingLists procedure.
Function CheckQueriesByLeadingListsDetails(FiltersConnections, FieldsTypes,
			LeadingTable, QueryTemplate, Context)
	
	LeadingTableWithoutDots = StrReplace(LeadingTable, ".", "_");
	
	Fields = New Array;
	For Each FieldDetails In FieldsTypes Do
		Fields.Add(FieldDetails.Key + " AS " + FieldDetails.Key);
	EndDo;
	
	ParametersQueryText =
	"SELECT
	|	CurrentDataForFilter." + StrConcat(Fields, ",
	|	CurrentDataForFilter.") + "
	|INTO " + LeadingTableWithoutDots + "
	|FROM
	|	&" + LeadingTableWithoutDots + " AS CurrentDataForFilter";
	
	QueriesDetails = New Structure;
	QueriesDetails.Insert("FieldsTypes", FieldsTypes);
	QueriesDetails.Insert("ParametersQueryText", ParametersQueryText);
	QueriesDetails.Insert("DataQueryTexts", New Array);
	
	For Each FilterConnection In FiltersConnections Do
		QueryText = QueryTemplate + TextWithIndent(FilterConnection, "	");
		QueryText = StrReplace(QueryText, "#CurrentDataForFilter", LeadingTableWithoutDots);
		InsertCommonParametersIntoQuery(QueryText, Context);
		QueriesDetails.DataQueryTexts.Add(QueryText);
	EndDo;
	
	Return QueriesDetails;
	
EndFunction

// For the AddCheckQueriesByLeadingLists procedure.
Procedure AddCheckQueriesByLeadingListsRefField(LaedingListKind, QueryTemplate, Context)
	
	Properties = ?(LaedingListKind = "ByAccessKeys",
		Context.LeadingListsByAccessKeys, Context.LeadingListsByValuesWithGroups);
	
	If Not ValueIsFilled(Properties.FiltersConnections) Then
		Return;
	EndIf;
	
	TempTableName = "CurrentDataForFilter" + LaedingListKind;
	
	ParametersQueryText =
	"SELECT
	|	CurrentDataForFilter.Ref
	|INTO " + TempTableName + "
	|FROM
	|	&" + LaedingListKind + " AS CurrentDataForFilter";
	
	QueriesTextsByKeys = New Map;
	For Each FilterConnection In Properties.FiltersConnections Do
		QueryText = QueryTemplate + TextWithIndent(FilterConnection.Value, "	");
		QueryText = StrReplace(QueryText, "#CurrentDataForFilter", TempTableName);
		InsertCommonParametersIntoQuery(QueryText, Context);
		QueriesTextsByKeys.Insert(FilterConnection.Key, QueryText);
	EndDo;
	
	QueriesDetails = New Structure;
	QueriesDetails.Insert("RefType",              New ValueStorage(Properties.RefType));
	QueriesDetails.Insert("QueryKeysByTypes",   Properties.QueryKeysByTypes);
	QueriesDetails.Insert("QueriesTextsByKeys", QueriesTextsByKeys);
	QueriesDetails.Insert("ParametersQueryText", ParametersQueryText);
	
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert(LaedingListKind, QueriesDetails);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeCheckQueryParts(Result, Context)
	
	Condition = "";
	For Each ConditionPartText In Context.CheckConditionParts Do
		If ValueIsFilled(Condition) Then
			Condition = Condition + "
			|		OR ";
		EndIf;
		Condition = Condition + TextWithIndent(ConditionPartText, "			");
	EndDo;
	Condition = TextWithIndent(Condition, "	");
	
	Context.CheckQueryText = StrReplace(Context.CheckQueryText,
		"#Condition", ?(Context.IsReferenceType, Condition, TextWithIndent(Condition, "		")));
	InsertCommonParametersIntoQuery(Context.CheckQueryText, Context);
	Result.DataItemWithObsoleteKeysQueryText = Context.CheckQueryText;
	
	QueryText = StrReplace(Context.SpotCheckQueryText, "#Condition", Condition);
	InsertCommonParametersIntoQuery(QueryText, Context);
	Context.DetailsOfValidationRequestsOnLeadingObjects.Insert("SpotCheckQueryText", QueryText);
	
	Result.DetailsOfObsoleteAccessKeysForLeadingObjects =
		Context.DetailsOfValidationRequestsOnLeadingObjects;
	
	If Not Context.IsReferenceType Then
		InsertCommonParametersIntoQuery(Context.NewCombinationsQueryText, Context);
		Result.DataItemsWithoutAccessKeysQueryText = Context.NewCombinationsQueryText;
		
		InsertCommonParametersIntoQuery(Context.CurrentAccessKeysQueryText, Context);
		Result.CurrentRegisterAccessKeysQueryText = Context.CurrentAccessKeysQueryText;
	EndIf;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure ComposeFillQueryParts(Result, Context)
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQuery,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.DataItemValueForAccessKeysQueryText = QueryText;
	
	QueryText = StrConcat(Context.PartsOfValuesFromObjectsQueryToCompare,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysInUseForComparisonQueryText = QueryText;
	Result.ValueFromAllAccessKeysForComparisonQueryText = StrReplace(QueryText,
		".NotUsedSince = DATETIME(1, 1, 1)", ".List = &List");
	
	QueryText = StrConcat(Context.QueryPartsOfKeysExistenceToMap,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.KeysForComparisonExistenceQueryText = QueryText;
	
	AddQueryPartOfLeadingKeysRightsSelection(Context);
	AddQueryPartOfLeadingListsRightsSelection(Context);
	AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context);
	QueryText = StrConcat(Context.PartsOfValuesFromKeysQueryToCalculateRights,
		Common.QueryBatchSeparator());
	InsertCommonParametersIntoQuery(QueryText, Context);
	Result.ValueFromAccessKeysForRightsCalculationQueryText = QueryText;
	
	Result.AccessKeysQueryTextToUpdateRights =
		AccessKeysQueryTextToUpdateRights(Context);
	
	Result.KeysQueryTextByLeadingKeysToUpdateRights =
		KeysQueryTextByLeadingKeysToUpdateRights(Context);
	
	Result.ObsoleteAccessKeysQueryText =
		ObsoleteAccessKeysQueryText(Context);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingKeysRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingAccessKeysRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingAccessKeysRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingAccessKeysRights,
			Chars.LF + "			OR ") + ")";
	EndIf;
	
	QueryText =
	"SELECT
	|	RightsToLeadingAccessKeysLists.Table AS List,
	|	RightsToLeadingAccessKeysLists.AccessGroup AS AccessGroup,
	|	RightsToLeadingAccessKeysLists.Update AS Update
	|FROM
	|	InformationRegister.AccessGroupsTables AS RightsToLeadingAccessKeysLists
	|WHERE
	|	RightsToLeadingAccessKeysLists.Table IN
	|			(SELECT DISTINCT
	|				HeadAccessKeyLists.List
	|			FROM
	|				Catalog.AccessKeys AS HeadAccessKeyLists
	|			WHERE
	|				&FilterCriterion)
	|TOTALS BY
	|	List";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	QueryText =
	"SELECT
	|	HeadAccessKeyLists.Ref AS AccessKey,
	|	HeadAccessKeyLists.List AS List
	|FROM
	|	Catalog.AccessKeys AS HeadAccessKeyLists
	|WHERE
	|	&FilterCriterion";
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "HeadAccessKeyLists.Ref"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	If Not Context.CalculateUserRights Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	VALUETYPE(RightsToAccessKeys.AccessGroup) = TYPE(Catalog.AccessGroups)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	ElsIf Not Context.ForExternalUsers Then
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.User.User,
		|	RightsToAccessKeys.Update
		|FROM
		|	InformationRegister.UsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.User.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	Else
		QueryText =
		"SELECT
		|	RightsToAccessKeys.AccessKey AS AccessKey,
		|	RightsToAccessKeys.AccessGroup AS RightsOwner,
		|	RightsToAccessKeys.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsAccessKeys AS RightsToAccessKeys
		|WHERE
		|	&FilterCriterion
		|
		|UNION ALL
		|
		|SELECT
		|	RightsToAccessKeys.AccessKey,
		|	RightsToAccessKeys.ExternalUser.User,
		|	RightsToAccessKeys.Update
		|FROM
		|	InformationRegister.ExternalUsersAccessKeys AS RightsToAccessKeys
		|WHERE
		|	RightsToAccessKeys.AreGroupSetRights = FALSE
		|	AND ISNULL(RightsToAccessKeys.ExternalUser.User, VALUE(Catalog.Users.EmptyRef)) <> VALUE(Catalog.Users.EmptyRef)
		|	AND &FilterCriterion
		|TOTALS BY
		|	AccessKey";
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FilterCriterion",
		StrReplace(FilterCriterion, "#FieldToCheck", "RightsToAccessKeys.AccessKey"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfLeadingListsRightsSelection(Context)
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 0 Then
		Return;
	EndIf;
	
	If Context.Property("HeadListsWithTypesRightsSelectionCriteriaParts") Then
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	VALUETYPE(RightsToLists.Table.EmptyRefValue) AS ValueType,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|TOTALS BY
		|	List";
	Else
		QueryText =
		"SELECT
		|	RightsToLists.Table AS List,
		|	RightsToLists.AccessGroup AS RightsOwner,
		|	RightsToLists.Update AS Update
		|FROM
		|	InformationRegister.AccessGroupsTables AS RightsToLists
		|WHERE
		|	&FilterCriterion
		|TOTALS BY
		|	List";
	EndIf;
	
	If Context.ConditionPartsToSelectLeadingListsRights.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectLeadingListsRights[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.ConditionPartsToSelectLeadingListsRights,
			Chars.LF + "			OR ") + ")";
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "RightsToLists.Table");
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Procedure AddQueryPartOfRightsSelectionByRightsSettingsOwners(Context)
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 0 Then
		Return;
	EndIf;
	
	QueryText =
	"SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithReadProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|			AND (&FilterCriterion)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT DISTINCT
	|	SettingsInheritance.Object AS Object
	|INTO ObjectsWithEditProhibition
	|FROM
	|	InformationRegister.ObjectsRightsSettings AS RightsSettings
	|		INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|		ON RightsSettings.Object = SettingsInheritance.Parent
	|			AND (RightsSettings.Table = &RightSettingsTableID)
	|			AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|			AND (&FilterCriterion)
	|
	|INDEX BY
	|	Object
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|SELECT
	|	RightsSettings.Object AS RightsSettingsOwner,
	|	RightsSettings.User AS RightsOwner,
	|	MAX(RightsSettings.EditionAllowed) = TRUE
	|		AND MAX(RightsSettings.DataChangesDenied) = FALSE AS Update
	|FROM
	|	(SELECT
	|		SettingsInheritance.Object AS Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END AS User,
	|		TRUE AS ReadingAllowed,
	|		FALSE AS ReadProhibited,
	|		FALSE AS EditionAllowed,
	|		FALSE AS DataChangesDenied
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingPermissionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		TRUE,
	|		FALSE,
	|		FALSE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithReadProhibition.Object
	|					FROM
	|						ObjectsWithReadProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ReadingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		CASE
	|			WHEN SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition)
	|				THEN UserGroupCompositions.User
	|			ELSE UserGroupCompositions.UsersGroup
	|		END,
	|		FALSE,
	|		FALSE,
	|		TRUE,
	|		FALSE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)
	|	
	|	UNION ALL
	|	
	|	SELECT
	|		SettingsInheritance.Object,
	|		UserGroupCompositions.User,
	|		FALSE,
	|		FALSE,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.ObjectsRightsSettings AS RightsSettings
	|			INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|			ON (SettingsInheritance.Object IN
	|					(SELECT
	|						ObjectsWithEditProhibition.Object
	|					FROM
	|						ObjectsWithEditProhibition))
	|				AND RightsSettings.Object = SettingsInheritance.Parent
	|				AND (RightsSettings.Table = &RightSettingsTableID)
	|				AND (SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel)
	|				AND (&FilterCriterion)
	|			INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|			ON (UserGroupCompositions.UsersGroup = RightsSettings.User)
	|				AND (VALUETYPE(UserGroupCompositions.User) = TYPE(Catalog.Users))
	|				AND (UserGroupCompositions.Used)
	|				AND (UserGroupCompositions.User.IBUserID <> &BlankUUID)) AS RightsSettings
	|
	|GROUP BY
	|	RightsSettings.Object,
	|	RightsSettings.User
	|
	|HAVING
	|	MAX(RightsSettings.ReadingAllowed) = TRUE AND
	|	MAX(RightsSettings.ReadProhibited) = FALSE
	|TOTALS BY
	|	RightsSettingsOwner";
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "Catalog.Users", "Catalog.ExternalUsers");
	EndIf;
	
	If Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Count() = 1 Then
		FilterCriterion = Context.ConditionPartsToSelectRightsByRightsSettingsOwners[0];
	Else
		FilterCriterion =  StrConcat(Context.ConditionPartsToSelectRightsByRightsSettingsOwners,
			Chars.LF + "			OR ");
	EndIf;
	FilterCriterion = StrReplace(FilterCriterion, "#FieldToCheck", "SettingsInheritance.Object");
	QueryText = StrReplace(QueryText, "&FilterCriterion", TextWithIndent(FilterCriterion, "	"));
	
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the ComposeFillQueriesParts procedure.
Function AccessKeysQueryTextToUpdateRights(Context)
	
	QueryText =
	"SELECT TOP " + BatchSizeMarker() + "
	|	AccessKeys.Ref AS Ref
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.Ref > &LastAccessKey
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	Return QueryText;
	
EndFunction

// For the ComposeFillQueriesParts procedure.
Function KeysQueryTextByLeadingKeysToUpdateRights(Context)
	
	If Context.PartsOfFilterConditionByLeadingAccessKeys.Count() = 0 Then
		Return "";
	EndIf;
	
	QueryText =
	"SELECT TOP " + BatchSizeMarker() + "
	|	AccessKeys.Ref AS Ref
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND &FilterCriterion
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	If Context.PartsOfFilterConditionByLeadingAccessKeys.Count() = 1 Then
		FilterCriterion = Context.PartsOfFilterConditionByLeadingAccessKeys[0];
	Else
		FilterCriterion = "(" + StrConcat(Context.PartsOfFilterConditionByLeadingAccessKeys,
			Chars.LF + "			OR ") + ")";
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	
	Return QueryText;
	
EndFunction

// For the ComposeFillQueriesParts procedure.
Function ObsoleteAccessKeysQueryText(Context)
	
	If Context.IsReferenceType Then
		UsedKeysQueryText =
		"SELECT DISTINCT
		|	AccessKeysForObjects.#UsersAccessKey AS AccessKey
		|INTO AccessKeysToUse
		|FROM
		|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
		|WHERE
		|	VALUETYPE(AccessKeysForObjects.Object) = TYPE(&CurrentList)
		|	AND AccessKeysForObjects.#UsersAccessKey > &LastAccessKey
		|
		|INDEX BY
		|	AccessKey"
	Else
		UsedKeysQueryText =
		"SELECT DISTINCT
		|	AccessKeysForRegisters.AccessKey AS AccessKey
		|INTO AccessKeysToUse
		|FROM
		|	&CurrentList AS AccessKeysForRegisters
		|WHERE
		|	AccessKeysForRegisters.Register = &List
		|	AND AccessKeysForRegisters.ForExternalUsers = &ForExternalUsers
		|	AND AccessKeysForRegisters.AccessKey > &LastAccessKey
		|
		|INDEX BY
		|	AccessKey";
		If ValueIsFilled(Context.SeparateKeysRegisterName) Then
			UsedKeysQueryText = StrReplace(UsedKeysQueryText,
				"AccessKeysForRegisters.Register = &List
				|	AND ", "");
		EndIf;
	EndIf;
	
	QueryText =
	"SELECT TOP " + BatchSizeMarker() + "
	|	AccessKeys.Ref AS Ref,
	|	AccessKeys.List AS List,
	|	AccessKeys.FieldsComposition AS FieldsComposition,
	|	AccessKeys.Hash AS Hash,
	|	NOT AccessKeysToUse.AccessKey IS NULL AS Used,
	|	AccessKeys.NotUsedSince <> DATETIME(1, 1, 1)
	|		AND AccessKeys.NotUsedSince < &DateOfBecomingObsolete AS Delete
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|		LEFT JOIN AccessKeysToUse AS AccessKeysToUse
	|		ON (AccessKeysToUse.AccessKey = AccessKeys.Ref)
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.Ref > &LastAccessKey
	|	AND CASE
	|			WHEN AccessKeys.NotUsedSince = DATETIME(1, 1, 1)
	|				THEN AccessKeysToUse.AccessKey IS NULL
	|			ELSE NOT AccessKeysToUse.AccessKey IS NULL
	|					OR AccessKeys.NotUsedSince < &DateOfBecomingObsolete
	|		END
	|
	|ORDER BY
	|	AccessKeys.Ref";
	
	QueryText = UsedKeysQueryText
		+ Common.QueryBatchSeparator() + QueryText;
	
	InsertCommonParametersIntoQuery(QueryText, Context);
	Return QueryText;
	
EndFunction

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure FillReadUpdateRightsCheckQueries(Result, Context)
	
	If Context.TypeCollectionName = "DocumentJournals" Then
		Return;
	EndIf;
	
	Properties = ListRestrictionProperties(Context.List, Context);
	
	If Context.IsReferenceType
	 Or Result.UsesRestrictionByOwner Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeysAndAccessGroups
		 Or Properties.TemplateRestrictionsWithUserAccessKeys Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|WHERE
				|	AccessKeysForObjects.Object = &Object
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			EndIf;
		Else
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForObjects.Object = &Object)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		EndIf;
	EndIf;
	
	If Not Result.UsesRestrictionByOwner Then
		QueryTextWithCheckByRightsSettingsOwners = "";
	Else
		EndFieldType = Context.FieldsProperties[0].EndFieldType;
		FieldRightsSettingsOwnersTypes = New Map;
		For Each KeyAndValue In Context.RightsSettingsOwnersTypes Do
			If EndFieldType.ContainsType(KeyAndValue.Key) Then
				FieldRightsSettingsOwnersTypes.Insert(KeyAndValue.Key,
					TypeNameInQueryLanguage(KeyAndValue.Key));
			EndIf;
		EndDo;
		If FieldRightsSettingsOwnersTypes.Count() = 0 Then
			QueryTextWithCheckByRightsSettingsOwners = "";
			
		ElsIf EndFieldType.Types().Count() = FieldRightsSettingsOwnersTypes.Count() Then
			QueryTextWithCheckByRightsSettingsOwners =
				QueryTextWithCheckByRightsSettingsOwners();
		Else
			If Context.IsReferenceType Then
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|WHERE
				|	CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
			Else
				QueryTextWithCheckByRightsSettingsOwners =
				"SELECT TOP 1
				|	FALSE AS FalseValue
				|FROM
				|	" + Context.List + " AS CurrentTable
				|WHERE
				|	&FilterByDimensions
				|	AND CASE
				|			WHEN &RightsSettingsOwnerTypeCheckCondition
				|				THEN &ConditionWithRightsSettingsOwnersCheck
				|			ELSE TRUE IN
				|				(&StandardCheckQueryText)
				|		END";
			EndIf;
			TypeCheckCondition = "";
			For Each TypeProperties In FieldRightsSettingsOwnersTypes Do
				TypeCheckCondition = TypeCheckCondition + ?(TypeCheckCondition = "", "", "
				|					") + "VALUETYPE(&Object) = TYPE(" + TypeProperties.Value + ")";
			EndDo;
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&RightsSettingsOwnerTypeCheckCondition",
				TypeCheckCondition);
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&ConditionWithRightsSettingsOwnersCheck",
				TextWithIndent(ConditionFromQueryWithCheckByRightsSettingsOwners(),
					"				"));
			
			QueryTextWithCheckByRightsSettingsOwners = StrReplace(
				QueryTextWithCheckByRightsSettingsOwners,
				"&StandardCheckQueryText",
				TextWithIndent(QueryText, "				"));
		EndIf;
	EndIf;
	
	If Result.UsesRestrictionByOwner Then
		If Context.IsReferenceType Then
			ObjectField = "CAST(&Object AS " + Context.List + ")." + Result.OwnerField.Name;
		Else
			ObjectField = "CurrentTable." + Result.OwnerField.Name;
		EndIf;
		QueryText = StrReplace(QueryText, "&Object", ObjectField);
		QueryTextWithCheckByRightsSettingsOwners =
			StrReplace(QueryTextWithCheckByRightsSettingsOwners, "&Object", ObjectField);
		
	ElsIf Not Context.IsReferenceType Then
		
		If Properties.TemplateRestrictionsWithUserAccessKeys Then
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|WHERE
				|	AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				|	AND AccessKeysForRegisters.ForExternalUsers = TRUE
				|	AND AccessKeysForRegisters.Field1 = &CurrentTableField1
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.ExternalUsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.ExternalUser IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|WHERE
				|	AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				|	AND AccessKeysForRegisters.ForExternalUsers = FALSE
				|	AND AccessKeysForRegisters.Field1 = &CurrentTableField1
				|	AND (TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.UsersAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.User IN (&AllowedUser, &AllowedUserGroupsSet)
				|					AND AllowedAccessKeys.Update)
				|			OR TRUE IN
				|				(SELECT TOP 1
				|					TRUE
				|				FROM
				|					InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|				WHERE
				|					AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
				|					AND AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet)
				|					AND AllowedAccessKeys.Update))";
			EndIf;
		Else
			If Context.ForExternalUsers Then
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = TRUE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			Else
				QueryText =
				"SELECT TOP 1
				|	TRUE AS TrueValue
				|FROM
				|	InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
				|		INNER JOIN InformationRegister.AccessGroupSetsAccessKeys AS AllowedAccessKeys
				|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
				|			AND (AccessKeysForRegisters.ForExternalUsers = FALSE)
				|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
				|			AND (AllowedAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey)
				|			AND (AllowedAccessKeys.AccessGroupsSet IN (&AllowedAccessGroupsSet, &AllowedBlankAccessGroupsSet))
				|			AND (AllowedAccessKeys.Update)";
			EndIf;
		EndIf;
		
		ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context);
		
		If Context.ForExternalUsers Then
			NewCombinationsOfBasicFieldsValuesQueryText =
			"SELECT DISTINCT
			|	&CurrentTableField1 AS CurrentTableField1
			|FROM
			|	&List AS CurrentTable
			|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
			|			AND (AccessKeysForRegisters.ForExternalUsers = TRUE)
			|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
			|WHERE
			|	&FilterByDimensions
			|	AND AccessKeysForRegisters.ForExternalUsers IS NULL";
		Else
			NewCombinationsOfBasicFieldsValuesQueryText =
			"SELECT DISTINCT
			|	&CurrentTableField1 AS CurrentTableField1
			|FROM
			|	&List AS CurrentTable
			|		LEFT JOIN InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
			|		ON (AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef))
			|			AND (AccessKeysForRegisters.ForExternalUsers = FALSE)
			|			AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)
			|WHERE
			|	&FilterByDimensions
			|	AND AccessKeysForRegisters.ForExternalUsers IS NULL";
		EndIf;
		ClarifyKeysRegisterAndConnectionCondition(NewCombinationsOfBasicFieldsValuesQueryText,
			Result, Context, True);
		
		Result.NewCombinationsOfBasicFieldsValuesQueryText =
			NewCombinationsOfBasicFieldsValuesQueryText;
	EndIf;
	
	If Not Context.IsReferenceType Then
		QueryText =
		"SELECT TOP 1
		|	FALSE AS FalseValue
		|FROM
		|	" + Context.List + " AS CurrentTable
		|WHERE
		|	&FilterByDimensions
		|	AND NOT TRUE IN
		|				(" + TextWithIndent(QueryText, "				") + ")";
	EndIf;
	
	If ValueIsFilled(QueryTextWithCheckByRightsSettingsOwners) Then
		Result.ReadEditRightsCheckQueryText = QueryTextWithCheckByRightsSettingsOwners;
	Else
		Result.ReadEditRightsCheckQueryText = QueryText;
	EndIf;
	
	If Not Result.RightToWriteRestrictionDisabled Then
		Result.ReadRightsCheckQueryText = StrReplace(QueryText,
			"AllowedAccessKeys.Update", "True");
	EndIf;
	
	If Result.UsesRestrictionByOwner
	   AND Result.OwnerField.EditAsRead Then
		
		Result.ReadEditRightsCheckQueryText = Result.ReadRightsCheckQueryText;
	EndIf;
	
EndProcedure

// For the FillReadUpdateRightsCheckQueries procedure.
Function ConditionFromQueryWithCheckByRightsSettingsOwners()
	
	Rows = StrSplit(QueryTextWithCheckByRightsSettingsOwners(), Chars.LF, "");
	Rows.Delete(0);
	Rows.Delete(0);
	Rows.Delete(0);
	
	Return TrimAll(StrConcat(Rows, Chars.LF));
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Function QueryTextWithCheckByRightsSettingsOwners()
	
	Return
	"SELECT TOP 1
	|	TRUE AS TrueValue
	|WHERE
	|	TRUE IN
	|			(SELECT TOP 1
	|				TRUE
	|			FROM
	|				InformationRegister.ObjectsRightsSettings AS RightsSettings
	|					INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|					ON
	|						SettingsInheritance.Object = &Object
	|							AND RightsSettings.Object = SettingsInheritance.Parent
	|							AND RightsSettings.Table = &RightSettingsTableID
	|							AND SettingsInheritance.UsageLevel < RightsSettings.ChangingPermissionLevel
	|					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|					ON
	|						UserGroupCompositions.User = &AuthorizedUser
	|							AND UserGroupCompositions.UsersGroup = RightsSettings.User)
	|	AND NOT FALSE IN
	|				(SELECT TOP 1
	|					FALSE
	|				FROM
	|					InformationRegister.ObjectsRightsSettings AS RightsSettings
	|						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
	|						ON
	|							SettingsInheritance.Object = &Object
	|								AND RightsSettings.Object = SettingsInheritance.Parent
	|								AND RightsSettings.Table = &RightSettingsTableID
	|								AND SettingsInheritance.UsageLevel < RightsSettings.ChangingProhibitionLevel
	|						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
	|						ON
	|							UserGroupCompositions.User = &AuthorizedUser
	|								AND UserGroupCompositions.UsersGroup = RightsSettings.User)";
	
EndFunction

// For the FillReadUpdateRightsCheckQueries procedure.
Procedure ClarifyKeysRegisterAndConnectionCondition(QueryText, Result, Context, AddSelectionFields = False)
	
	If ValueIsFilled(Result.SeparateKeysRegisterName) Then
		QueryText = StrReplace(QueryText,
			"InformationRegister.AccessKeysForRegisters",
			"InformationRegister." + Result.SeparateKeysRegisterName);
		QueryText = StrReplace(QueryText,
			"AccessKeysForRegisters.Register = VALUE(Catalog.MetadataObjectIDs.EmptyRef)",
			"TRUE");
	Else
		QueryText = StrReplace(QueryText,
			"MetadataObjectIDs.EmptyRef",
			AccessManagementInternalCached.PredefinedMetadataObjectIDDetails(
				Context.List));
	EndIf;
	
	FilterCriterion = "";
	ConnectionCondition = "";
	FieldNumber = 1;
	For Each Field In Result.BasicFields.Used Do
		FilterCriterion = FilterCriterion + Chars.LF
			+ "AND AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + Field;
		ConnectionCondition = ConnectionCondition + Chars.LF
			+ "AND (AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + Field + ")";
		FieldNumber = FieldNumber + 1;
	EndDo;
	For CurrentNumber = FieldNumber To Result.BasicFields.MaxCount Do
		FilterCriterion = FilterCriterion + Chars.LF
			+ "AND AccessKeysForRegisters.Field" + CurrentNumber
			+ " = Value(Enum.AdditionalAccessValues.Null)";
		ConnectionCondition = ConnectionCondition + Chars.LF
			+ "AND (AccessKeysForRegisters.Field" + CurrentNumber
			+ " = Value(Enum.AdditionalAccessValues.Null))";
	EndDo;
	QueryText = StrReplace(QueryText,
		"AND AccessKeysForRegisters.Field1 = &CurrentTableField1",
		TextWithIndent(TrimL(FilterCriterion), "	"));
	QueryText = StrReplace(QueryText,
		"AND (AccessKeysForRegisters.Field1 = &CurrentTableField1)",
		TextWithIndent(TrimL(ConnectionCondition), "			"));
	
	If Not AddSelectionFields Then
		Return;
	EndIf;
	
	SelectionFields = "";
	FieldNumber = 1;
	For Each Field In Result.BasicFields.Used Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", "," + Chars.LF)
			+ "CurrentTable." + Field + " AS Field" + FieldNumber;
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	QueryText = StrReplace(QueryText,
		"&CurrentTableField1 AS CurrentTableField1",
		TextWithIndent(TrimL(SelectionFields), "	"));
	
	QueryText = StrReplace(QueryText, "&List", Context.List);
	
EndProcedure

// For the ComposeQueriesParts function.
Procedure InsertCommonParametersIntoQuery(QueryText, Context)
	
	If Context.ForExternalUsers Then
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "ExternalUsersAccessKey");
	Else
		QueryText = StrReplace(QueryText, "#ObjectUserAccessKey", "UsersAccessKey");
	EndIf;
	
	If Context.IsReferenceType Then
		QueryText = StrReplace(QueryText, "&CurrentList", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "AccessKeysForObjects");
		
		If Context.ForExternalUsers Then
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "ExternalUsersAccessKey");
		Else
			QueryText = StrReplace(QueryText, "#UsersAccessKey", "UsersAccessKey");
		EndIf;
	Else
		QueryText = StrReplace(QueryText, "&CurrentRegister", Context.List);
		QueryText = StrReplace(QueryText, "#DataAccessKeys", "CurrentList");
		Number = 0;
		For Each BasicFieldName In Context.BasicFields.Used Do
			Number = Number + 1;
			QueryText = StrReplace(QueryText, "CurrentList."
				+ BasicFieldName, "CurrentList.Field" + Number);
			
			QueryText = StrReplace(QueryText, "CurrentListSource."
				+ BasicFieldName, "CurrentListSource.Field" + Number);
		EndDo;
		QueryText = StrReplace(QueryText, "&CurrentList", ?(Context.SeparateKeysRegisterName = "",
			"InformationRegister.AccessKeysForRegisters", "InformationRegister." + Context.SeparateKeysRegisterName));
		
		QueryText = StrReplace(QueryText, "#UsersAccessKey", "AccessKey");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&FieldsComposition", Format(Context.FieldsComposition, "NG="));
	QueryText = StrReplace(QueryText, "&ForExternalUsers",
		?(Context.ForExternalUsers, "TRUE", "FALSE"));
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderCheck(Context, HeaderNumber)
	
	FieldsGroup = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If FieldsGroup = Undefined Then
		If HeaderNumber > 0 Then
			Return;
		EndIf;
		ConnectionsAndFields = New Structure("Joins, Fields", "", "");
	Else
		ConnectionsAndFields = ConnectionsAndFieldsByTables(FieldsGroup,
			False, HeaderNumber).Get("CurrentList");
	EndIf;
	
	If HeaderNumber = 0 Then
		Connections = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys AS Header0
		|ON (Header0.Ref = #DataAccessKeys.#UsersAccessKey)
		|	AND (Header0.FieldsComposition = &FieldsComposition)";
	Else
		Connections = ConnectionsAndFields.Joins + "
		|LEFT JOIN Catalog.AccessKeys.Header AS Header?
		|ON (Header?.Ref = #DataAccessKeys.#UsersAccessKey)
		|	AND (Header?.LineNumber = " + HeaderNumber + ")";
	EndIf;
	
	Connections = TrimL(Connections) + TextWithIndent(ConnectionsAndFields.Fields, "	");
	Connections = TextWithIndent(Connections, "		");
	
	Condition = "NOT Header?.Ref IS NULL";
	Condition = TextWithIndent(Condition, "	");
	
	ConditionPartTextTemplate =
	"NOT TRUE IN
	|(SELECT TOP 1
	|	TRUE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	#Condition)";
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins", Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",    Condition);
	
	ConditionPartText = StrReplace(ConditionPartText, "Header?", "Header" + HeaderNumber);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionCheck(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber);
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	FieldsGroup = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(FieldsGroup,
		True, , , OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	Connections = "";
	Condition = "";
	Fields = "";
	
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
		Connections = Connections + "
		|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias + "
		|ON " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref"
		+ ConnectionsAndFields.Joins;
		Condition = ObjectTabularSectionAlias + ".Ref #CheckNULL";
		Fields = ConnectionsAndFields.Fields;
	Else
		For Each AdditionalTable In AdditionalTablesGroup Do
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|ON " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	");
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Connections = Connections + ConnectionsAndFields.Joins;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " #CheckNULL";
			Fields = Fields + ConnectionsAndFields.Fields;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
	EndIf;
	InitialConnections = Connections;
	InitialCondition = Condition;
	
	ConditionPartTextTemplate =
	"FALSE IN
	|(SELECT TOP 1
	|	FALSE
	|FROM
	|	(SELECT
	|		TRUE AS TrueValue) AS TrueValue
	|		#Joins
	|WHERE
	|	#Condition)";
	
	// Direct connection (checking if required records are in the key).
	Connections = InitialConnections + "
	|LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
	|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)";
	Connections = TrimL(Connections) + TextWithIndent(Fields, "	");
	Connections = TextWithIndent(Connections, "		");
	
	Condition =
	"TabularSection?.Ref IS NULL
	|AND " + TextWithIndent(TrimL(InitialCondition), "	");
	Condition = TextWithIndent(Condition, "	");
	Condition = StrReplace(Condition, "#CheckNULL", "IS NOT NULL");
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",        Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
	// Reversed connection (checking if there are excess records in the key).
	If AdditionalTablesGroup = Undefined
	 Or AdditionalTablesGroup.Count() = 1 Then
		
		Connections =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)";
		
		If AdditionalTablesGroup = Undefined Then
			Connections = Connections + "
			|LEFT JOIN &CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias
				  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
			|ON " + ObjectTabularSectionAlias + ".Ref = CurrentList.Ref"
			      + TextWithIndent(ConnectionsAndFields.Fields, "	");
		Else
			AdditionalTable = AdditionalTablesGroup[0];
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias
				  + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
			|ON " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	")
			      + TextWithIndent(ConnectionsAndFields.Fields, "	");
		EndIf;
		Connections = TextWithIndent(Connections, "		");
		
		Condition =
		"TabularSection?.Ref IS NOT NULL
		|AND " + TrimL(InitialCondition);
		Condition = TextWithIndent(Condition, "	");
		Condition = StrReplace(Condition, "#CheckNULL", "IS NULL");
	Else
		Connections =
		"LEFT JOIN Catalog.AccessKeys.TabularSection? AS TabularSection?
		|ON (TabularSection?.Ref = #DataAccessKeys.#UsersAccessKey)
		|LEFT JOIN &CurrentList AS CurrentListSource"
			+ TextWithIndent(InitialConnections, "	") + "
		|ON " + ?(Context.IsReferenceType, "(CurrentListSource.Ref = CurrentList#.Ref)",
			Context.BasicFields.ConnectionCondition);
		
		Connections = Connections + TextWithIndent(Fields, "	");
		Connections = TextWithIndent(Connections, "		");
		Connections = StrReplace(Connections, "CurrentList.", "CurrentListSource.");
		Connections = StrReplace(Connections, "CurrentList#.", "CurrentList.");
		
		If Context.IsReferenceType Then
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Ref IS NULL";
		Else
			Condition =
			"TabularSection?.Ref IS NOT NULL
			|AND CurrentListSource.Field1 IS NULL";
		EndIf;
		Condition = TextWithIndent(Condition, "	");
	EndIf;
	
	ConditionPartText = ConditionPartTextTemplate;
	ConditionPartText = StrReplace(ConditionPartText, "#Joins",     Connections);
	ConditionPartText = StrReplace(ConditionPartText, "#Condition",        Condition);
	ConditionPartText = StrReplace(ConditionPartText, "TabularSection?", KeyTabularSectionName);
	Context.CheckConditionParts.Add(ConditionPartText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyHeaderFilling(Context, HeaderNumber)
	
	If Not Context.IsReferenceType AND HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef,
		|	" + Context.BasicFields.ForSelection + "
		|	INTO CurrentList
		|FROM
		|	&BasicFieldsValues AS CurrentList";
		Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	EndIf;
	
	FieldsGroup = Context.FieldsGroups.Get("Header" + HeaderNumber);
	If FieldsGroup = Undefined Then
		Return;
	EndIf;
	AddKeyTableDetails("Header" + HeaderNumber, FieldsGroup, Context);
	
	ConnectionsAndFields = ConnectionsAndFieldsByTables(FieldsGroup, False,
		HeaderNumber, True).Get("CurrentList");
	
	// Selecting values from objects to search and create access keys.
	If Context.IsReferenceType Then
		QueryText =
		"SELECT
		|	CurrentList.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Fields, "	") + "
		|FROM
		|	&CurrentList AS CurrentList" + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
		|WHERE
		|	CurrentList.Ref IN (&ObjectsRefs)
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	Else
		QueryText =
		"SELECT
		|	CurrentList.CurrentRef AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Fields, "	") + "
		|FROM
		|	CurrentList AS CurrentList" + TextWithIndent(ConnectionsAndFields.Joins, "	") + "
		|
		|ORDER BY
		|	CurrentRef, " + Context.BasicFields.ForOrdering + "
		|TOTALS BY
		|	CurrentRef";
	EndIf;
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	
	// Selecting values from access keys to compare with the required key values.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	Header0.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	Catalog.AccessKeys AS Header0
		|WHERE
		|	Header0.Hash IN(&Hashes)
		|	AND Header0.List = &List
		|	AND Header0.FieldsComposition = &FieldsComposition
		|	AND Header0.ForExternalUsers = &ForExternalUsers
		|	AND Header0.NotUsedSince = DATETIME(1, 1, 1)
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	Else
		QueryText =
		"SELECT
		|	Header?.Ref AS CurrentRef" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	Catalog.AccessKeys.Header AS Header?
		|WHERE
		|	Header?.LineNumber = " + HeaderNumber + "
		|	AND Header?.Ref.Hash IN(&Hashes)
		|	AND Header?.Ref.List = &List
		|	AND Header?.Ref.FieldsComposition = &FieldsComposition
		|	AND Header?.Ref.ForExternalUsers = &ForExternalUsers
		|	AND Header?.Ref.NotUsedSince = DATETIME(1, 1, 1)
		|
		|ORDER BY
		|	CurrentRef
		|TOTALS BY
		|	CurrentRef";
	EndIf;
	
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Checking if access key exists before writing a new key.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	TRUE AS TrueValue
		|FROM
		|	Catalog.AccessKeys AS Header0
		|WHERE
		|	Header0.Hash = &Hash
		|	AND Header0.List = &List
		|	AND Header0.FieldsComposition = &FieldsComposition
		|	AND Header0.ForExternalUsers = &ForExternalUsers";
		Context.QueryPartsOfKeysExistenceToMap.Add(QueryText);
	EndIf;
	
	// Query of access keys by leading keys to update users and access groups, for which they are allowed.
	AddFilterConditionByLeadingAccessKeys(Context, FieldsGroup, HeaderNumber);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	AccessKeys.Ref AS Ref
		|INTO KeysBatch
		|FROM
		|	&AccessKeys AS AccessKeys
		|
		|INDEX BY
		|	Ref";
		Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	EndIf;
	
	If HeaderNumber = 0 Then
		QueryText =
		"SELECT
		|	KeysBatch.Ref AS Ref" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN @Catalog.AccessKeys AS Header0
		|	ON
		|		Header0.Ref = KeysBatch.Ref
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref";
	Else
		QueryText =
		"SELECT
		|	KeysBatch.Ref AS Ref" + TextWithIndent(ConnectionsAndFields.Attributes, "	") + "
		|FROM
		|	KeysBatch AS KeysBatch
		|	LEFT JOIN @Catalog.AccessKeys.Header AS Header?
		|	ON
		|		Header?.Ref = KeysBatch.Ref
		|		AND Header?.LineNumber = " + HeaderNumber + "
		|
		|ORDER BY
		|	Ref
		|TOTALS BY
		|	Ref";
	EndIf;
	
	QueryText = StrReplace(QueryText, "Header?", "Header" + HeaderNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyHeaderFilling procedure.
Procedure AddRightsFilterConditionForKeyHeader(Context, FieldsGroup, HeaderNumber, ConditionAssignment)
	
	// The selection condition of leading access key rights.
	For Each FieldProperties In FieldsGroup Do
		If ConditionAssignment = "ForLeadingKeys"
		   AND FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   AND Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   AND Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   AND FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, Header?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(Header?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							Header?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(Header?.Attribute?))";
		Else
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					Header?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys AS Header?
			|						ON
			|							Header?.Ref = KeysBatch.Ref)";
		EndIf;
		If HeaderNumber > 0 Then
			FilterCriterion = StrReplace(FilterCriterion,
				"Catalog.AccessKeys AS Header?", "Catalog.AccessKeys.Header AS Header?");
			FilterCriterion = StrReplace(FilterCriterion,
				"Header?.Ref = KeysBatch.Ref", TextWithIndent(
				"Header?.Ref = KeysBatch.Ref
				|	AND Header?.LineNumber = " + HeaderNumber, "							"));
		EndIf;
		FilterCriterion = StrReplace(FilterCriterion, "Header?", "Header" + HeaderNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeysChoiceWithoutFieldsInHeader(Context)
	
	If Context.FieldsGroups.Get("Header0") <> Undefined Then
		Return;
	EndIf;
	
	// Selecting values from access keys to compare with the required key values.
	QueryText =
	"SELECT
	|	AccessKeys.Ref AS CurrentRef
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.Hash IN(&Hashes)
	|	AND AccessKeys.List = &List
	|	AND AccessKeys.FieldsComposition = &FieldsComposition
	|	AND AccessKeys.ForExternalUsers = &ForExternalUsers
	|	AND AccessKeys.NotUsedSince = DATETIME(1, 1, 1)
	|
	|ORDER BY
	|	CurrentRef";
	
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Checking if access key exists before writing a new key.
	QueryText =
	"SELECT
	|	TRUE AS TrueValue
	|FROM
	|	Catalog.AccessKeys AS Header0
	|WHERE
	|	Header0.Hash = &Hash
	|	AND Header0.List = &List
	|	AND Header0.FieldsComposition = &FieldsComposition
	|	AND Header0.ForExternalUsers = &ForExternalUsers";
	Context.QueryPartsOfKeysExistenceToMap.Add(QueryText);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	QueryText =
	"SELECT
	|	AccessKeys.Ref AS Ref
	|INTO KeysBatch
	|FROM
	|	&AccessKeys AS AccessKeys
	|
	|INDEX BY
	|	Ref";
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
EndProcedure

// For the AddQueriesTextsToRestrictionParameters procedure.
Procedure AddKeyTabularSectionFilling(Context, KeyTabularSectionNumber)
	
	TablesByGroups  = Context.AdditionalTablesGroups.TablesByGroups;
	AdditionalTablesGroup = TablesByGroups.Get(KeyTabularSectionNumber);
	
	KeyTabularSectionName = "TabularSection" + KeyTabularSectionNumber;
	FieldsGroup = Context.FieldsGroups.Get(KeyTabularSectionName);
	
	AddKeyTableDetails(KeyTabularSectionName, FieldsGroup, Context);
	
	ConnectionsAndFieldsByTables = ConnectionsAndFieldsByTables(FieldsGroup,
		True, , True, OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup));
	
	// Selecting values from objects to search and create access keys.
	If AdditionalTablesGroup = Undefined Then
		ObjectTabularSectionAlias = Context.ObjectTabularSectionsAliases.Get(KeyTabularSectionNumber);
		ObjectTabularSectionName = StrReplace(ObjectTabularSectionAlias, "CurrentList", "");
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(ObjectTabularSectionAlias);
		SelectionFields = TextWithIndent(ConnectionsAndFields.Fields, "	");
		Connections = TextWithIndent(ConnectionsAndFields.Joins, "	");
		OrderingFields = ConnectionsAndFields.OrderingFields;
		Attributes        = ConnectionsAndFields.Attributes;
		QueryText =
		"SELECT DISTINCT
		|	" + ObjectTabularSectionAlias + ".Ref AS CurrentRef" + SelectionFields + "
		|FROM
		|	&CurrentList." + ObjectTabularSectionName + " AS " + ObjectTabularSectionAlias + Connections + "
		|WHERE
		|	" + ObjectTabularSectionAlias + ".Ref IN (&ObjectsRefs)
		|
		|ORDER BY
		|	CurrentRef" + OrderingFields + "
		|TOTALS BY
		|	CurrentRef";
	Else
		SelectionFields = "";
		Connections = "";
		Condition = "";
		OrderingFields = "";
		Attributes = "";
		For Each AdditionalTable In AdditionalTablesGroup Do
			ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(AdditionalTable.Alias);
			Connections = Connections + "
			|LEFT JOIN " + AdditionalTable.Table + " AS " + AdditionalTable.Alias + "
			|ON " + TextWithIndent(AdditionalTable.ConnectionConditionText, "	");
			If ConnectionsAndFields = Undefined Then
				Continue;
			EndIf;
			Connections = Connections + ConnectionsAndFields.Joins;
			Condition = Condition + ?(Condition = "", "", "
			|OR ") + AdditionalTable.ConnectionTestField + " IS NOT NULL";
			SelectionFields       = SelectionFields       + ConnectionsAndFields.Fields;
			OrderingFields = OrderingFields + ConnectionsAndFields.OrderingFields;
			Attributes        = Attributes        + ConnectionsAndFields.Attributes;
		EndDo;
		If StrLineCount(Condition) > 1 Then
			Condition = "(" + Condition + ")";
		EndIf;
		If Context.IsReferenceType Then
			QueryText =
			"SELECT DISTINCT
			|	CurrentList.Ref AS CurrentRef" + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	&CurrentList AS CurrentList" + TextWithIndent(Connections, "	") + "
			|WHERE
			|	CurrentList.Ref IN (&ObjectsRefs)
			|	AND " + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef" + OrderingFields + "
			|TOTALS BY
			|	CurrentRef";
		Else
			QueryText =
			"SELECT
			|	CurrentList.CurrentRef AS CurrentRef"  + TextWithIndent(SelectionFields, "	") + "
			|FROM
			|	CurrentList AS CurrentList" + TextWithIndent(Connections, "	") + "
			|WHERE
			|	" + TextWithIndent(Condition, "	") + "
			|
			|ORDER BY
			|	CurrentRef, " + Context.BasicFields.ForOrdering + OrderingFields + "
			|TOTALS BY
			|	CurrentRef";
		EndIf;
	EndIf;
	
	Context.PartsOfValuesFromObjectsQuery.Add(QueryText);
	
	// Query of access keys by leading keys to update users and access groups, for which they are allowed.
	AddFilterConditionByLeadingAccessKeys(Context, FieldsGroup, , KeyTabularSectionNumber);
	
	// Selecting values from access keys to compare with the required key values.
	QueryText =
	"SELECT
	|	TabularSection?.Ref AS CurrentRef" + TextWithIndent(Attributes, "	") + "
	|FROM
	|	Catalog.AccessKeys.TabularSection? AS TabularSection?
	|WHERE
	|	TabularSection?.Ref.Hash IN(&Hashes)
	|	AND TabularSection?.Ref.List = &List
	|	AND TabularSection?.Ref.FieldsComposition = &FieldsComposition
	|	AND TabularSection?.Ref.ForExternalUsers = &ForExternalUsers
	|	AND TabularSection?.Ref.NotUsedSince = DATETIME(1, 1, 1)
	|
	|ORDER BY
	|	CurrentRef" + OrderingFields + "
	|TOTALS BY
	|	CurrentRef";
	
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromObjectsQueryToCompare.Add(QueryText);
	
	// Selecting values from access keys to calculate users and access groups, to which they are allowed.
	QueryText =
	"SELECT
	|	KeysBatch.Ref AS Ref" + TextWithIndent(Attributes, "	") + "
	|FROM
	|	KeysBatch AS KeysBatch
	|	LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
	|	ON
	|		TabularSection?.Ref = KeysBatch.Ref
	|
	|ORDER BY
	|	Ref
	|TOTALS BY
	|	Ref";
	
	QueryText = StrReplace(QueryText, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
	Context.PartsOfValuesFromKeysQueryToCalculateRights.Add(QueryText);
	
	// The filter condition of leading access key rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForLeadingKeys");
	
	// The filter condition of leading list rights.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForLeadingLists");
	
	// The filter condition of rights by right setting owners.
	AddRightsFilterConditionForKeyTabularSection(Context,
		FieldsGroup, KeyTabularSectionNumber, "ForRightSettingsOwners");
	
EndProcedure

// For the AddKeyTabularSectionFilling procedure.
Procedure AddRightsFilterConditionForKeyTabularSection(Context, FieldsGroup,
			KeyTabularSectionNumber, ConditionAssignment)
	
	For Each FieldProperties In FieldsGroup Do
		If ConditionAssignment = "ForLeadingKeys"
		   AND FieldProperties.AccessKeySavingTypes.Count() = 0
		 Or ConditionAssignment = "ForLeadingLists"
		   AND Not FieldProperties.HasHeadListType
		 Or ConditionAssignment = "ForRightSettingsOwners"
		   AND Not FieldProperties.HasRightsSettingsOwnerType Then
			Continue;
		EndIf;
		
		If ConditionAssignment = "ForLeadingLists"
		   AND FieldProperties.ValueSavingTypes.Count() > 0 Then
			
			Context.Insert("HeadListsWithTypesRightsSelectionCriteriaParts");
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					ISNULL(ConfigurationTypes.Ref, ISNULL(ExtensionTypes.Ref, TabularSection?.Attribute?))
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref
			|							
			|						LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.MetadataObjectIDs)
			|							AND VALUETYPE(TabularSection?.Attribute?) <> TYPE(Catalog.ExtensionObjectIDs)
			|							AND VALUETYPE(ConfigurationTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?)
			|							
			|						LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes
			|						ON
			|							TabularSection?.Attribute? <> UNDEFINED
			|							AND VALUETYPE(ExtensionTypes.EmptyRefValue) = VALUETYPE(TabularSection?.Attribute?))";
		Else
			FilterCriterion =
			"#FieldToCheck IN
			|				(SELECT
			|					TabularSection?.Attribute?
			|				FROM
			|					KeysBatch AS KeysBatch
			|						LEFT JOIN @Catalog.AccessKeys.TabularSection? AS TabularSection?
			|						ON
			|							TabularSection?.Ref = KeysBatch.Ref)";
		EndIf;
		
		FilterCriterion = StrReplace(FilterCriterion, "TabularSection?", "TabularSection" + KeyTabularSectionNumber);
		FilterCriterion = StrReplace(FilterCriterion, "Attribute?", FieldProperties.AccessKeyFieldsGroupAttributeName);
		
		If ConditionAssignment = "ForLeadingKeys" Then
			Context.ConditionPartsToSelectLeadingAccessKeysRights.Add(FilterCriterion);
			
		ElsIf ConditionAssignment = "ForLeadingLists" Then
			Context.ConditionPartsToSelectLeadingListsRights.Add(FilterCriterion);
		Else
			Context.ConditionPartsToSelectRightsByRightsSettingsOwners.Add(FilterCriterion);
		EndIf;
	EndDo;
	
EndProcedure

// For the AddKeyHeaderFilling and AddKeyTabularSectionFilling procedures.
Procedure AddKeyTableDetails(KeyTableName, FieldsGroup, Context)
	
	KeyTableFields = New Array;
	
	For Each FieldProperties In FieldsGroup Do
		KeyTableFields.Add(FieldProperties.AccessKeyFieldsGroupAttributeName);
	EndDo;
	
	Context.KeyTables.Add(KeyTableName);
	Context.KeyTablesAttributes.Insert(KeyTableName, KeyTableFields);
	
EndProcedure

// For the AddKeyHeaderFilling and AddKeyTabularSectionFilling procedures.
Procedure AddFilterConditionByLeadingAccessKeys(Context, FieldsGroup, HeaderNumber = 0, KeyTabularSectionNumber = 0)
	
	ConnectionsAndFields = ConnectionsAndFieldsByTables(FieldsGroup, False,
		HeaderNumber, True).Get("CurrentList");
	
	FilterCriterion = "";
	AttributeNumber = ?(HeaderNumber = 0, 0, 5);
	
	For Each FieldProperties In FieldsGroup Do
		AttributeNumber = AttributeNumber + 1;
		
		If FieldProperties.AccessKeySavingTypes.Count() = 0 Then
			Continue;
		EndIf;
		
		FilterCriterion =
		"AccessKeys.Ref IN
		|				(SELECT
		|					Header?.Ref
		|				FROM
		|					Catalog.AccessKeys AS Header?
		|				WHERE
		|					Header?.Value? IN (&LeadingAccessKeys))";
		
		FilterCriterion = StrReplace(FilterCriterion, "Value?", "Value" + AttributeNumber);
		
		If HeaderNumber > 0 Then
			FilterCriterion = StrReplace(FilterCriterion,
				"Catalog.AccessKeys AS Header?", "Catalog.AccessKeys.Header AS Header?");
		EndIf;
		
		If KeyTabularSectionNumber = 0 Then
			FilterCriterion = StrReplace(FilterCriterion, "Header?", "Header" + HeaderNumber);
		Else
			TabularSectionName = "TabularSection" + KeyTabularSectionNumber;
			FilterCriterion = StrReplace(FilterCriterion, " AS", "." + TabularSectionName + " AS");
			FilterCriterion = StrReplace(FilterCriterion, "Header?", TabularSectionName);
		EndIf;
		
		Context.PartsOfFilterConditionByLeadingAccessKeys.Add(FilterCriterion);
	EndDo;
	
EndProcedure

// For the AddKeyHeaderCheck and AddKeyTabularSectionCheck procedures.
Function ConnectionsAndFieldsByTables(FieldsGroup, KeyTabularSection, HeaderNumber = 0, ForValuesSelection = False,
			OneAdditionalTableWithFieldsInGroup = False)
	
	ConnectionsAndFieldsByTables = New Map;
	AttributeNumber = 1 + ?(HeaderNumber = 0, 0, 5);
	
	For Each FieldProperties In FieldsGroup Do
		
		ConnectionsAndFields = ConnectionsAndFieldsByTables.Get(FieldProperties.TableAlias);
		If ConnectionsAndFields = Undefined Then
			ConnectionsAndFields = New Structure;
			ConnectionsAndFields.Insert("Joins",       "");
			ConnectionsAndFields.Insert("Fields",             "");
			ConnectionsAndFields.Insert("OrderingFields", "");
			ConnectionsAndFields.Insert("Attributes",        "");
			ConnectionsAndFieldsByTables.Insert(FieldProperties.TableAlias, ConnectionsAndFields);
		EndIf;
		
		Connections = "";
		If FieldProperties.AccessKeySavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN InformationRegister.AccessKeysForObjects AS AccessKeysForObjects?
			|ON (AccessKeysForObjects?.Object = #FieldNameForQuery)";
		EndIf;
		
		If FieldProperties.ValueGroupSavingTypes.Count() > 0 Then
			If Not FieldProperties.IsAccessValueListWithValueGroups Then
				Connections = Connections + "
				|LEFT JOIN InformationRegister.AccessValuesGroups AS ValueGroups?
				|ON (ValueGroups?.AccessValue = #FieldNameForQuery)
				|	AND (ValueGroups?.DataGroup = 0)";
			ElsIf FieldProperties.MultipleValuesGroups Then
				Connections = Connections + "
				|LEFT JOIN &CurrentList.AccessGroups AS ValueGroups?
				|ON (ValueGroups?.Ref = #FieldNameForQuery)";
			EndIf;
		EndIf;
		
		If FieldProperties.ConfigurationTypeSavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN Catalog.MetadataObjectIDs AS ConfigurationTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ConfigurationTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() > 0 Then
			Connections = Connections + "
			|LEFT JOIN Catalog.ExtensionObjectIDs AS ExtensionTypes?
			|ON (#FieldNameForQuery <> UNDEFINED)
			|	AND (VALUETYPE(ExtensionTypes?.EmptyRefValue) = VALUETYPE(#FieldNameForQuery))";
		EndIf;
		
		Field = FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup);
		
		If ForValuesSelection Then
			MagicNumber = StrLen("END");
			Field = StrReplace(Field, "Header?.Value? = ", "");
			Field = StrReplace(Field, "						", "			");
			Field = "," + Chars.LF + Mid(Field, 5, StrLen(Field) - MagicNumber) + " AS Value?";
			
			ConnectionsAndFields.OrderingFields = ConnectionsAndFields.OrderingFields
				+ ", " + "Value" + AttributeNumber;
			
			ConnectionsAndFields.Attributes  = ConnectionsAndFields.Attributes + ",
			|Header?.Value"  + AttributeNumber + " AS Value" + AttributeNumber;
		EndIf;
		
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "Value?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ValueGroups?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "AccessKeysForObjects?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ConfigurationTypes?");
		FillAliasByAttributeNumber(Connections, Field, AttributeNumber, "ExtensionTypes?");
		
		Connections = StrReplace(Connections, "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		Field       = StrReplace(Field,       "#FieldNameForQuery", FieldProperties.FieldNameForQuery);
		
		If KeyTabularSection Then
			Field = StrReplace(Field, "Header?", "TabularSection?");
			ConnectionsAndFields.Attributes = StrReplace(ConnectionsAndFields.Attributes, "Header?", "TabularSection?");
		EndIf;
		
		ConnectionsAndFields.Joins = ConnectionsAndFields.Joins + Connections;
		ConnectionsAndFields.Fields       = ConnectionsAndFields.Fields       + Field;
		AttributeNumber = AttributeNumber + 1;
	EndDo;
	
	Return ConnectionsAndFieldsByTables;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function OneAdditionalTableWithFieldsInGroup(Context, AdditionalTablesGroup)
	
	If AdditionalTablesGroup = Undefined Then
		Return False;
	EndIf;
	
	If AdditionalTablesGroup.Count() = 1 Then
		Return True;
	EndIf;
	
	TablesWithFiledsAliases = Context.AdditionalTablesGroups.TablesWithFiledsAliases;
	
	AdditionalTablesWithFieldsCount = 0;
	For Each AdditionalTable In AdditionalTablesGroup Do
		If TablesWithFiledsAliases.Get(AdditionalTable.Alias) = Undefined Then
			Continue;
		EndIf;
		AdditionalTablesWithFieldsCount = AdditionalTablesWithFieldsCount + 1;
	EndDo;
	
	Return AdditionalTablesWithFieldsCount = 1;
	
EndFunction

// For the ConnectionsAndFieldsByTables function.
Function FieldComparison(FieldProperties, OneAdditionalTableWithFieldsInGroup)
	
	FieldTypesCount = FieldProperties.EndFieldType.Types().Count();
	
	WithoutUndefinedValue = FieldTypesCount = 1;
	If FieldProperties.Property("NoNullValue") Then
		NoNullValue = FieldProperties.NoNullValue;
	Else
		NoNullValue = NoNullValue(FieldProperties, OneAdditionalTableWithFieldsInGroup);
	EndIf;
	
	WithoutClarificationUndefined = Not FieldProperties.HasAdjustmentUndefined Or WithoutUndefinedValue;
	WithoutClarificationNull         = Not FieldProperties.HasAdjustmentNull         Or NoNullValue;
	
	// Saving access keys only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   AND WithoutClarificationUndefined
	   AND WithoutClarificationNull
	   AND FieldProperties.AccessKeySavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|						VALUE(Enum.AdditionalAccessValues.Null)))";
	EndIf;
	
	// Saving access value groups only.
	If FieldProperties.EmptyRefSavingTypes.Count() = 0
	   AND WithoutClarificationUndefined
	   AND WithoutClarificationNull
	   AND FieldProperties.ValueGroupSavingTypes.Count() = FieldTypesCount Then
		
		If Not FieldProperties.IsAccessValueListWithValueGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		ElsIf FieldProperties.MultipleValuesGroups Then
			Return "
			|AND (Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		Else
			Return "
			|AND (Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		EndIf;
	EndIf;
	
	// Saving values only.
	If Not HasSimpleType(FieldProperties.EndFieldType)
	   AND FieldProperties.ValueSavingTypes.Count() = FieldTypesCount Then
		
		If NoNullValue Then
			Return "
			|AND (Header?.Value? = #FieldNameForQuery)";
		Else
			Return "
			|AND (Header?.Value? = ISNULL(#FieldNameForQuery,
			|						VALUE(Enum.AdditionalAccessValues.Null)))";
		EndIf;
	EndIf;
	
	// Saving a reference type.
	If WithoutClarificationNull
	   AND FieldTypesCount = 1
	   AND FieldProperties.TypeSavingTypes.Count() = FieldTypesCount
	   AND FieldProperties.SimpleTypeSavingTypes.Count() = 0 Then
		
		If FieldProperties.ExtensionTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
			|						VALUE(Catalog.MetadataObjectIDs.EmptyRef)))";
		ElsIf FieldProperties.ConfigurationTypeSavingTypes.Count() = 0 Then
			Return "
			|AND (Header?.Value? = ISNULL(ExtensionTypes?.Ref,
			|						VALUE(Catalog.ExtensionObjectIDs.EmptyRef)))";
		EndIf;
	EndIf;
	
	// Saving one simple type.
	If WithoutClarificationNull
	   AND FieldTypesCount = 1
	   AND FieldProperties.SimpleTypeSavingTypes.Count() = 1 Then
		
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType))";
	EndIf;
	
	If FieldProperties.ProhibitedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType))";
	EndIf;
	
	// Saving the AllowedType value only.
	If FieldProperties.AllowedTypeSavingTypes.Count() = FieldTypesCount Then
		Return "
		|AND (Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType))";
	EndIf;
	
	FieldComparison = "
	|AND (CASE
	|	#SelectionContent
	|END)";
	SelectionContent = "";
	
	SaveBooleanValue = FieldProperties.ValueSavingTypes.Find(Type("Boolean")) <> Undefined;
	
	If Not NoNullValue
	   AND Not (SaveBooleanValue AND FieldTypesCount = 1) Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery IS NULL
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Null)";
	EndIf;
	If FieldTypesCount > 1 Then
		SelectionContent = SelectionContent + "
		|WHEN #FieldNameForQuery = UNDEFINED
		|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.Undefined)";
	EndIf;
	If SaveBooleanValue Then
		If FieldTypesCount > 1 Then
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|WHEN NOT #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)";
		Else
			SelectionContent = SelectionContent + "
			|WHEN #FieldNameForQuery
			|	THEN Header?.Value? = VALUE(Enum.AdditionalAccessValues.True)
			|ELSE Header?.Value? = VALUE(Enum.AdditionalAccessValues.False)";
		EndIf;
	EndIf;
	
	ChecksByTypes = New ValueList;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.SimpleTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType)");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AccessKeySavingTypes,
		"Header?.Value? = ISNULL(AccessKeysForObjects?.#ObjectUserAccessKey,
		|					VALUE(Enum.AdditionalAccessValues.Null))");
	
	If Not FieldProperties.IsAccessValueListWithValueGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessValuesGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	ElsIf FieldProperties.MultipleValuesGroups Then
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(ValueGroups?.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	Else
		AddCheckByTypes(ChecksByTypes, FieldProperties.ValueGroupSavingTypes,
			"Header?.Value? = ISNULL(CurrentList.AccessGroup,
			|					VALUE(Enum.AdditionalAccessValues.Null))");
	EndIf;
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ValueSavingTypes,
		"Header?.Value? = #FieldNameForQuery", , SaveBooleanValue);
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.EmptyRefSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.EmptyRefAnyType)",
		"IsEmptyRefCheck");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ConfigurationTypeSavingTypes,
		"Header?.Value? = ISNULL(ConfigurationTypes?.Ref,
		|					VALUE(Catalog.MetadataObjectIDs.EmptyRef))");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ExtensionTypeSavingTypes,
		"Header?.Value? = ISNULL(ExtensionTypes?.Ref,
		|					VALUE(Catalog.ExtensionObjectIDs.EmptyRef))");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.ProhibitedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.ProhibitedType)");
	
	AddCheckByTypes(ChecksByTypes, FieldProperties.AllowedTypeSavingTypes,
		"Header?.Value? = VALUE(Enum.AdditionalAccessValues.AllowedType)");
	
	ChecksByTypes.SortByPresentation();
	
	For Each CheckByTypes In ChecksByTypes Do
		If CheckByTypes.Value.Types.Count() = 0 Then
			Continue;
		EndIf;
		If ChecksByTypes.IndexOf(CheckByTypes) < ChecksByTypes.Count() - 1 Then
			TypesCheck = "";
			For Each Type In CheckByTypes.Value.Types Do
				If IsSimpleType(Type) Then
					TypeName = String(Type);
				Else
					TypeName = Metadata.FindByType(Type).FullName();
				EndIf;
				If TypesCheck <> "" Then
					TypesCheck = TypesCheck + "
					|			OR ";
				EndIf;
				CheckTemplate = ?(CheckByTypes.Value.Property("IsEmptyRefCheck"),
					"#FieldNameForQuery = VALUE(#TypeName.EmptyRef)",
					"VALUETYPE(#FieldNameForQuery) = TYPE(#TypeName)");
				TypesCheck = TypesCheck + StrReplace(CheckTemplate, "#TypeName", TypeName);
			EndDo;
			CheckSSL = "
			|WHEN #CheckTypes
			|	THEN #CheckSSL";
			CheckSSL = StrReplace(CheckSSL, "#CheckTypes", TypesCheck);
		Else
			CheckSSL = "
			|ELSE #CheckSSL";
		EndIf;
		CheckSSL = StrReplace(CheckSSL, "#CheckSSL", CheckByTypes.Value.CheckSSL);
		SelectionContent = SelectionContent + CheckSSL;
	EndDo;
	
	Return StrReplace(FieldComparison, "#SelectionContent", TextWithIndent(TrimL(SelectionContent), "	"));
	
EndFunction

// For the FieldComparison function.
Procedure AddCheckByTypes(ChecksByTypes, InitialTypes, CheckSSL, AdditionalProperty = "", SkipBoolean = False)
	
	Types = New Array;
	For Each Type In InitialTypes Do
		If SkipBoolean AND Type = Type("Boolean") Then
			Continue;
		EndIf;
		Types.Add(Type);
	EndDo;
	
	If Types.Count() = 0 Then
		Return;
	EndIf;
	
	Structure = New Structure("Types, CheckSSL", Types, CheckSSL);
	ChecksByTypes.Add(Structure, Format(Structure.Types.Count(), "ND=10; NLZ=; NG="));
	
	If AdditionalProperty = "" Then
		Return;
	EndIf;
	
	Structure.Insert(AdditionalProperty);
	
EndProcedure

// For the AddKeyHeaderCheck function.
Procedure FillAliasByAttributeNumber(Connections, Field, AttributeNumber, Alias)
	
	AliasWithNumber = StrReplace(Alias, "?", AttributeNumber);
	
	Connections = StrReplace(Connections, Alias, AliasWithNumber);
	Field       = StrReplace(Field,       Alias, AliasWithNumber);
	
EndProcedure

// For the AddKeyHeaderCheck and FieldComparison functions.
Function TextWithIndent(Text, Indent)
	
	Return StrReplace(Text, Chars.LF, Chars.LF + Indent);
	
EndFunction

// For the FieldComparison and AddBasicField functions.
Function HasSimpleType(TypesDetails)
	
	Return TypesDetails.ContainsType(Type("Boolean"))
	    Or TypesDetails.ContainsType(Type("Date"))
	    Or TypesDetails.ContainsType(Type("String"))
	    Or TypesDetails.ContainsType(Type("Number"))
	    Or TypesDetails.ContainsType(Type("UUID"))
	    Or TypesDetails.ContainsType(Type("ValueStorage"));
	
EndFunction

#EndRegion

#EndRegion

#Region TransformRestrictionsTextsIntoStructures

// See AccessManagement.ParsedRestriction. 
Function ParsedRestriction(MainTable, RestrictionText) Export
	
	InternalData = New Structure;
	InternalData.Insert("MainTable",  MainTable);
	InternalData.Insert("RestrictionText", TrimAll(RestrictionText));
	
	InternalData.Insert("LanguageSyntax", AccessManagementInternalCached.LanguageSyntax());
	InternalData.Insert("TablesFields",     New Map);
	InternalData.Insert("Aliases",     New Map);
	
	InternalData.Insert("AccessKeyFields", New Array);
	
	InternalData.Insert("CharsetsTable", CharsetsTable(InternalData));
	InternalData.Insert("RestrictionParts",       RestrictionParts(InternalData));
	
	Result = New Structure;
	Result.Insert("InternalData", InternalData);
	Result.Insert("TablesFields", InternalData.TablesFields);
	
	Return Result;
	
EndFunction

// See AccessManagement.RestrictionStructure. 
Function RestrictionStructure(ParsedRestriction) Export
	
	InternalData = ParsedRestriction.InternalData;
	
	MarkIncorrectFieldsTablesAndFieldsTypesNames(ParsedRestriction.TablesFields,
		InternalData);
	
	// Filling found errors.
	ErrorsDescription = New Structure;
	ErrorsDescription.Insert("HasErrors",  False);
	ErrorsDescription.Insert("ErrorsText", "");
	ErrorsDescription.Insert("Restriction", "");
	ErrorsDescription.Insert("Errors",      New Array);
	ErrorsDescription.Insert("AddOn",  "");
	
	Table = InternalData.CharsetsTable;
	FilterRowsWithoutErrors = New Structure("ErrorText", "");
	If Table.Count() <> Table.FindRows(FilterRowsWithoutErrors).Count() Then
		ErrorsDescription.HasErrors = True;
		AdditionRequired = False;
		RowNumberLength = StrLen(Format(StrLineCount(InternalData.RestrictionText), "NG="));
		For Each Row In Table Do
			If Row.ErrorText = "" Then
				Continue;
			EndIf;
			AddError(Row, ErrorsDescription, InternalData, RowNumberLength);
			If Row.ErrorPosition = -1 Then
				AdditionRequired = True;
			EndIf;
		EndDo;
		ErrorsDescription.Restriction = NumberedRestrictionTextWithErrorsMarks(
			InternalData.RestrictionText, ErrorsDescription.Errors, RowNumberLength);
		If AdditionRequired Then
			ErrorsDescription.AddOn = AllowedTemplatesDetails();
		EndIf;
	EndIf;
	
	RestrictionParts = InternalData.RestrictionParts;
	
	RestrictionStructure = New Structure;
	RestrictionStructure.Insert("ErrorsDescription",           ErrorsDescription);
	RestrictionStructure.Insert("AdditionalTables",    RestrictionParts.AdditionalTables);
	RestrictionStructure.Insert("MainTableAlias", RestrictionParts.MainTableAlias);
	RestrictionStructure.Insert("ReadRestriction",        RestrictionParts.ReadRestriction);
	RestrictionStructure.Insert("UpdateRestriction",     RestrictionParts.UpdateRestriction);
	
	// Additional information for internal use.
	TableTypeName = StrSplit(InternalData.MainTable, ".")[0];
	TablesTypeProperties = InternalData.LanguageSyntax.TablesTypes.ByNames.Get(Upper(TableTypeName));
	
	NewInternalData = New Structure;
	NewInternalData.Insert("AccessKeyFields",   InternalData.AccessKeyFields);
	NewInternalData.Insert("IsReferenceType",    TablesTypeProperties.IsReferenceType);
	NewInternalData.Insert("TypeCollectionName",   TablesTypeProperties.CollectionName);
	NewInternalData.Insert("TablesTypesByNames", InternalData.LanguageSyntax.TablesTypes.ByNames);
	
	RestrictionStructure.Insert("InternalData", NewInternalData);
	
	For Each Row In InternalData.CharsetsTable Do
		Row.Rows.Clear();
		Row.EndString = Undefined;
	EndDo;
	InternalData.CharsetsTable.Clear();
	InternalData.RestrictionParts.Clear();
	InternalData.Clear();
	
	Return RestrictionStructure;
	
EndFunction

// Generates a full text of errors in access restriction description with an addition that can be 
// specified as a text to call an exception.
//
// Parameters:
//  FullName               - String    - a full name of a list table.
//  ErrorsDescription          - Structure - a value returned by the RestrictionStructure function.
//  ForExternalUsers - Boolean    - if True is passed, an error text will contain the restriction 
//                                        purpose for external users.
//
// Returns:
//  String - a text to call an exception.
//
Function ErrorsTextToCallException(FullName, ErrorsDescription, ForExternalUsers, InManagerModule)
	
	If Not ErrorsDescription.HasErrors Then
		Return "";
	EndIf;
	
	If ErrorsDescription.Errors.Count() = 1 Then
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"":'; en = 'An error in restriction of external user access to the ""%1"" list:'; pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"":';de = 'Fehler bei der Einschränkung des Zugriffs externer Benutzer auf die Liste ""%1"":';ro = 'Eroare la restricționarea accesului utilizatorilor externi la lista ""%1"":';tr = 'Harici kullanıcıların ""%1"" listesine erişim kısıtlamasında bir hata oluştu:'; es_ES = 'Error al restringir el acceso de los usuarios externos a la lista ""%1"":'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"":'; en = 'An error in restriction of user access to the ""%1"" list:'; pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"":';de = 'Fehler bei der Einschränkung des Benutzerzugriffs auf die Liste ""%1"":';ro = 'Eroare la restricționarea accesului utilizatorilor la lista ""%1"":';tr = 'Kullanıcıların ""%1"" listesine erişim kısıtlamasında bir hata oluştu:'; es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"":'");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'; 
					           |en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze ПриЗаполненииОграниченияДоступа modułu menadżera obiektu metadanych:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur BeimAufüllenZugriffsBeschränkung des Metadaten-Objekt-Manager-Moduls angegeben ist:';
					           |ro = 'Eroare la restricționarea accesului utilizatorilor externi la lista ""%1"",
					           |indicată în procedura ПриЗаполненииОграниченияДоступа a modulului managerului obiectului de metadate:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken bir hata oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor de objeto de metadatos:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'; 
					           |en = 'An error in restriction of user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze ПриЗаполненииОграниченияДоступа do modułu menadżera obiektu metadanych:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur BeimAufüllenZugriffsBeschränkung des Metadaten-Objekt-Manager-Moduls angegeben ist:';
					           |ro = 'Eroare la restricționarea accesului utilizatorilor la lista ""%1"",
					           |indicată în procedura ПриЗаполненииОграниченияДоступа a modulului managerului obiectului de metadate:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken bir hata oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:'");
			EndIf;
		Else
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'; 
					           |en = 'An error in restriction of external user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur ZugriffsKontrolleNeudefinierbar.BeimAufüllenZugriffsBeschränkung angegeben ist:';
					           |ro = 'Eroare la restricționarea accesului utilizatorilor externi la lista ""%1"",
					           |indicată în procedura УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |tr = 'ErişimKontrolüYenidenTanımlanmış. ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken bir hata oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибка в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'; 
					           |en = 'An error in restriction of user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błąd w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur ZugriffsKontrolleNeudefinierbar.BeimAufüllenZugriffsBeschränkung angegeben ist:';
					           |ro = 'Eroare la restricționarea accesului utilizatorilor la lista ""%1"",
					           |indicată în procedura УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |tr = 'ErişimKontrolüYenidenTanımlanmış. ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken bir hata oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:'");
			EndIf;
		EndIf;
	Else
		If InManagerModule = Undefined Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"":'; en = 'Errors in restriction of external user access to the ""%1"" list:'; pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"":';de = 'Fehler bei der Einschränkung des Zugriffs externer Benutzer auf die Liste ""%1"":';ro = 'Erori la restricționarea accesului utilizatorilor externi la lista ""%1"":';tr = 'Harici kullanıcıların ""%1"" listesine erişim kısıtlamasında bir hata oluştu:'; es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"":'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"":'; en = 'Errors in restriction of user access to the ""%1"" list:'; pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"":';de = 'Fehler bei der Einschränkung des Benutzerzugriffs auf die Liste ""%1"":';ro = 'Erori la restricționarea accesului utilizatorilor la lista ""%1"":';tr = 'Kullanıcıların ""%1"" listesine erişim kısıtlamasında hatalar oluştu:'; es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"":'");
			EndIf;
		ElsIf InManagerModule Then
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'; 
					           |en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze ПриЗаполненииОграниченияДоступа modułu menadżera obiektu metadanych:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur BeimAufüllenZugriffsBeschränkung des Metadaten-Objekt-Manager-Moduls angegeben ist:';
					           |ro = 'Erori la restricționarea accesului utilizatorilor externi la lista ""%1"",
					           |indicată în procedura ПриЗаполненииОграниченияДоступа a modulului managerului obiectului de metadate:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedüründe belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken hatalar oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре ПриЗаполненииОграниченияДоступа модуля менеджера объекта метаданных:'; 
					           |en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in the OnFillAccessRestriction procedure of the metadata object manager module:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze ПриЗаполненииОграниченияДоступа do modułu menadżera obiektu metadanych:';
					           |de = 'Fehler bei der Beschränkung des Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur BeimAufüllenZugriffsBeschränkung des Metadaten-Objekt-Manager-Moduls angegeben ist:';
					           |ro = 'Erori la restricționarea accesului utilizatorilor la lista ""%1"",
					           |indicată în procedura ПриЗаполненииОграниченияДоступа a modulului managerului obiectului de metadate:';
					           |tr = 'Metaveri nesne yönetici modülünün ErişimKısıtlamasıDoldurulurken prosedüründe belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken hatalar oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento OnFillAccessRestriction del módulo de gestor del objeto de metadatos:'");
			EndIf;
		Else
			If ForExternalUsers Then
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа внешних пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'; 
					           |en = 'Errors in restriction of external user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników zewnętrznych do listy ""%1"",
					           |podanemu w procedurze УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |de = 'Fehler bei der Beschränkung des Zugriffs externer Benutzer auf die Liste ""%1"",
					           |die in der Prozedur ZugriffsKontrolleNeudefinierbar.BeimAufüllenZugriffsBeschränkung angegeben ist:';
					           |ro = 'Erori la restricționarea accesului utilizatorilor externi la lista ""%1"",
					           |indicată în procedura УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |tr = 'ErişimKontrolüYenidenTanımlanmış. ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine harici kullanıcıların erişimi kısıtlanırken hatalar oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios externos a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:'");
			Else
				ErrorTitle = 
					NStr("ru = 'Ошибки в ограничении доступа пользователей к списку ""%1"",
					           |указанному в процедуре УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:'; 
					           |en = 'Errors in restriction of user access to the ""%1"" list
					           |specified in the AccessManagementOverridable.OnFillAccessRestriction procedure:'; 
					           |pl = 'Błędy w ograniczeniu dostępu użytkowników do listy ""%1"",
					           |podanemu w procedurze УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |de = 'Fehler bei der Beschränkung des  Benutzerzugriffs auf die Liste ""%1"",
					           |die in der Prozedur ZugriffsKontrolleNeudefinierbar.BeimAufüllenZugriffsBeschränkung angegeben ist:';
					           |ro = 'Erori la restricționarea accesului utilizatorilor la lista ""%1"",
					           |indicată în procedura УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа:';
					           |tr = 'ErişimKontrolüYenidenTanımlanmış. ErişimKısıtlamasıDoldurulurken prosedürümde belirtilen ""%1""
					           | listesine kullanıcıların erişimi kısıtlanırken hatalar oluştu:'; 
					           |es_ES = 'Error al restringir el acceso de usuarios a la lista ""%1"",
					           |indicada en el procedimiento AccessManagementOverridable.OnFillAccessRestriction:'");
			EndIf;
		EndIf;
	EndIf;
	
	ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTitle, FullName);
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.ErrorsText;
	ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.Restriction;
	
	If ValueIsFilled(ErrorsDescription.AddOn) Then
		ErrorText = ErrorText + Chars.LF + Chars.LF + ErrorsDescription.AddOn;
	EndIf;
	
	Return Chars.LF + ErrorText + Chars.LF;
	
EndFunction

// For the RestrictionStructure function.
Procedure AddError(Row, ErrorsDescription, InternalData, RowNumberLength)
	
	PositionInText = Row.Position;
	ErrorPositionInRowEnd = False;
	RestrictionText = InternalData.RestrictionText;
	
	If Row.ErrorPosition > 0 Then
		PositionInText = PositionInText + Row.ErrorPosition;
		If Row.ErrorPosition = StrLen(Row.Chars) Then
			PositionInText = PositionInText - 1;
			ErrorPositionInRowEnd = True;
		EndIf;
	ElsIf Row.Position > StrLen(RestrictionText) Then
		PositionInText = PositionInText - 1;
		ErrorPositionInRowEnd = True;
	EndIf;
	
	Coordinates = PositionCoordinatesInText(RestrictionText, PositionInText);
	Coordinates.PositionInRow = Coordinates.PositionInRow + ?(ErrorPositionInRowEnd, 1, 0);
	
	ErrorRow = StrGetLine(RestrictionText, Coordinates.LineNumber);
	ErrorRow = Left(ErrorRow, Coordinates.PositionInRow - 1)
		+ "<<?>>" + Mid(ErrorRow, Coordinates.PositionInRow);
	
	Error = New Structure;
	Error.Insert("LineNumber",    Coordinates.LineNumber);
	Error.Insert("PositionInRow", Coordinates.PositionInRow);
	Error.Insert("ErrorText",    Row.ErrorText);
	Error.Insert("ErrorRow",   ErrorRow);
	
	ErrorsDescription.Errors.Add(Error);
	
	If ValueIsFilled(ErrorsDescription.ErrorsText) Then
		ErrorsDescription.ErrorsText = ErrorsDescription.ErrorsText + Chars.LF + Chars.LF;
	EndIf;
	
	ErrorsDescription.ErrorsText = ErrorsDescription.ErrorsText
		+ "{(" + Format(Error.LineNumber, "ND=" + RowNumberLength + "; NLZ=; NG=")
		+ ", " + Format(Error.PositionInRow, "NG=") + ")}:"
		+ " " + Error.ErrorText + Chars.LF + Error.ErrorRow;
	
EndProcedure

// For the RestrictionStructure function.
Function NumberedRestrictionTextWithErrorsMarks(RestrictionText, Errors, RowNumberLength)
	
	RowsCount = StrLineCount(RestrictionText);
	RestrictionTextRows = New Array;
	
	For RowNumber = 1 To RowsCount Do
		Row = StrGetLine(RestrictionText, RowNumber);
		RestrictionTextRows.Add(Row);
	EndDo;
	
	Index = Errors.Count() - 1;
	While Index >= 0 Do
		Error = Errors[Index];
		Row = RestrictionTextRows[Error.LineNumber - 1];
		RestrictionTextRows[Error.LineNumber - 1] = Left(Row, Error.PositionInRow - 1)
			+ "<<?>>" + Mid(Row, Error.PositionInRow);
		Index = Index - 1;
	EndDo;
	
	Text = "";
	RowNumber = 1;
	
	For Each Row In RestrictionTextRows Do
		Text = Text + ?(Text = "", "", Chars.LF)
			+ ?(StrFind(Row, "<<?>>") > 0, "*", " ")
			+ " " + Format(RowNumber, "ND=" + RowNumberLength + "; NLZ=; NG=") + " " + Row;
		RowNumber = RowNumber + 1;
	EndDo;
	
	Return Text;
	
EndFunction

// For the RestrictionStructure function.
Function AllowedTemplatesDetails()
	
	If ScriptVariantRussian() Then
		Template1 =
		"        AllowReadUpdate
		|        WHERE ...";
		
		Template2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowUpdateIfReadingAllowed
		|        WHERE ...";
		
		Template3 =
		"        AttachAdditionalTables
		|        ThisList AS <Alias>
		|        LEFT JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowUpdateIfReadingAllowed
		|        WHERE ...";
	Else
		Template1 =
		"        AllowReadWrite
		|        WHERE ...";
		
		Template2 =
		"        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
		
		Template3 =
		"        AttachAdditionalTables
		|        LIST AS <Alias>
		|        LEFT/INNER JOIN ...
		|        ;
		|        AllowRead
		|        WHERE ...
		|        ;
		|        AllowWriteIfAllowRead
		|        WHERE ...";
	EndIf;
	
	Details = StringFunctionsClientServer.SubstituteParametersToString(
		NStr("ru = 'Ограничение может состоять из 1-3 частей в одном из 4 вариантов:
		           |1) одинаковое ограничение чтения и изменения:
		           |%1
		           |2) разные ограничения чтения и изменения:
		           |%2
		           |3) любой из вариантов выше с дополнительными таблицами, например:
		           |%3'; 
		           |en = 'Restriction can contain 1-3 parts in one of 4 options:
		           |1. Similar read and update restriction:
		           |%1
		           | 2. Different read and update restrictions:
		           |%2
		           | 3. Any of the options mentioned above with additional tables, for example:
		           |%3'; 
		           |pl = 'Ograniczenie może składać się z 1 do 3 sztuk w jednym z 4 opcji:
		           |1) takie same ograniczenia odczytu i zmiany:
		           |%1
		           | 2) różne ograniczenia odczytu i zmiany:
		           |%2
		           | 3) w każdej z opcji powyżej, z dodatkowymi tabelami, np.:
		           |%3';
		           |de = 'Die Einschränkung kann aus 1-3 Teilen in einer von 4 Varianten bestehen:
		           |1) die gleiche Einschränkung beim Lesen und Ändern:
		           |%1
		           |2) unterschiedliche Einschränkung beim Lesen und Ändern:
		           |%2
		           |3) eine der oben genannten Optionen mit zusätzlichen Tabellen, zum Beispiel:
		           |%3 ';
		           |ro = 'Restricția poate fi compusă din 1-3 părți în una din 4 variante:
		           |1) restricții egale de citire și modificare:
		           |%1
		           |2) restricții diferite de citire și modificare:
		           |%2
		           |3) orice variantă de mai sus cu tabele suplimentare, de exemplu:
		           |%3';
		           |tr = 'Kısıtlama, 4 seçenekten birinde 1-3 bölümden oluşabilir: 
		           |1) Okuma ve değiştirmenin aynı kısıtlaması: 
		           |%1
		           |2) farklı okuma ve değiştirme kısıtlamaları: 
		           |%2
		           |3) ek tablolarla yukarıdaki seçeneklerden herhangi biri, örneğin :
		           |%3'; 
		           |es_ES = 'La restricción puede ser compuesta de 1-3 partes en una de las 4 opciones: 
		           |1) la misma restricción de lectura y modificación:
		           |%1
		           |2) restricciones diferentes de lectura y modificación:
		           |%2
		           |3) cualquiera de las opciones superiores con las tablas adicionales, por ejemplo:
		           |%3'"),
		Template1, Template2, Template3);
	
	Return Details;
	
EndFunction

// For the AddError procedure.
Function PositionCoordinatesInText(Text, PositionInText)
	
	Result = New Structure;
	Result.Insert("LineNumber", 0);
	Result.Insert("PositionInRow", 0);
	
	RowsCount = StrLineCount(Text);
	RowBeginningPosition = 1;
	For RowNumber = 1 To RowsCount Do
		CurrentRowLength = StrLen(StrGetLine(Text, RowNumber));
		If PositionInText < RowBeginningPosition + CurrentRowLength Then
			Break;
		EndIf;
		RowBeginningPosition = RowBeginningPosition + CurrentRowLength + 1;
	EndDo;
	
	Result.LineNumber = RowNumber;
	Result.PositionInRow = PositionInText - RowBeginningPosition + 1;
	
	Return Result;
	
EndFunction

#Region LexicalAnalysis

// For the ParsedRestriction function.
// Splits the text in a table of character sets, in which:
// - There are no indent characters (spaces, tabs, line breaks).
// - Characters of arbitrary strings and numbers are highlighted.
// - Keywords and operations are defined.
// - Format of names and numbers is checked.
// - Errors with description are added.
// 
// Parameters:
//  RestrictionText - String - an access restriction text.
//
// Returns:
//  ValueTable - a table with the following columns:
//    * Chars       - String - a character, a pair of characters, or a word.
//    * Position       - Number  - a position of characters in the restriction text.
//    * Kind           - String - "KeyWord", "Operation", "Name", "Separator",
//                               "Number", "ArbitraryString", "ProhibitedChar", "End".
//    * Type           - String - a type for the "KeyWord" and "Operation" kinds.
//    * Priority     - Number  - a priority for the "KeyWord" and "Operation" kinds.
//    * Clarification     - Number  - a numeric value for the "Number" kind.
//                    - String - a name for the "KeyWord" kind, a string of characters for the "ArbitraryString" kind.
//    * IsReserve     - Boolean - if True, this is a reserved operation or a keyword.
//    * ErrorPosition - Number  - an error position in a restriction text if the error text is not blank.
//    * ErrorText   - String - an error text if an error occurs.
//
Function CharsetsTable(InternalData)
	
	CharsetsTable = New ValueTable;
	CharsetsTable.Columns.Add("Chars",       New TypeDescription("String"));
	CharsetsTable.Columns.Add("Position",       New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Kind",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Type",           New TypeDescription("String"));
	CharsetsTable.Columns.Add("Priority",     New TypeDescription("Number"));
	CharsetsTable.Columns.Add("Clarification",     New TypeDescription("Number, String"));
	CharsetsTable.Columns.Add("IsReserve",     New TypeDescription("Boolean"));
	CharsetsTable.Columns.Add("ErrorPosition", New TypeDescription("Number"));
	CharsetsTable.Columns.Add("ErrorText",   New TypeDescription("String"));
	
	RestrictionText = InternalData.RestrictionText;
	
	If Not ValueIsFilled(RestrictionText) Then
		Return CharsetsTable;
	EndIf;
	
	RestrictionTextLength = StrLen(RestrictionText);
	
	LanguageSyntax = InternalData.LanguageSyntax;
	LanguageChars = LanguageSyntax.LanguageChars;
	
	CharsetKind = ""; // Word, ArbitraryString, Operation.
	CharsetPosition = 0;
	Charset = New Array;
	TableRow = Undefined;
	
	For CharNumber = 1 To RestrictionTextLength Do
		Char = Mid(RestrictionText, CharNumber, 1);
		CharType = LanguageChars.Get(Char);
		// Processing word characters first as they are the most common.
		If CharType = "WordChar" AND CharsetKind = "Word" Then
			Charset.Add(Char);
			Continue;
		EndIf;
		// Processing an arbitrary string of characters.
		If CharsetKind = "ArbitraryLine" Then
			If CharType = "LineLimiter" Then
				If Mid(RestrictionText, CharNumber + 1, 1) <> Char Then
					TableRow.Clarification = StrConcat(Charset);
					TableRow.Position = CharsetPosition;
					Charset = New Array;
					CharsetKind = "";
					Continue;
				Else
					CharNumber = CharNumber + 1;
				EndIf;
			EndIf;
			Charset.Add(Char);
			Continue;
		EndIf;
		If CharsetKind = "Word" Then
			// At the beginning of the cycle, CharType = "WordChar" is already processed, for the remaining 
			// character types the word is completed and it needs to be added to the tree.
			CharsetKind = "";
			AddWordToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing a set of composite separators.
		If CharsetKind = "Operation" Then
			If CharType = "OperationChar" Then
				Charset.Add(Char);
				Continue;
			EndIf;
			CharsetKind = "";
			AddOperationToCharsetsTable(CharsetsTable,
				Charset, CharsetPosition, LanguageSyntax);
			Charset = New Array;
		EndIf;
		// Processing the first character of character sets.
		If CharsetKind = "" Then
			If CharType = "WordChar" Then
				CharsetKind = "Word";
				CharsetPosition = CharNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "OperationChar" Then
				CharsetKind = "Operation";
				CharsetPosition = CharNumber;
				Charset.Add(Char);
				Continue;
			EndIf;
			If CharType = "LineLimiter" Then
				CharsetKind = "ArbitraryLine";
				CharsetPosition = CharNumber;
				TableRow = CharsetsTable.Add();
				TableRow.Chars = Char;
				TableRow.Kind = CharsetKind;
				Continue;
			EndIf;
		EndIf;
		// Processing separate characters.
		If CharType = "Indent" Then
			Continue;
		EndIf;
		If CharType = "Separator" Then
			TableRow = CharsetsTable.Add();
			TableRow.Chars = Char;
			TableRow.Position = CharNumber;
			TableRow.Kind = "Separator";
			Continue;
		EndIf;
		TableRow = CharsetsTable.Add();
		TableRow.Chars = Char;
		TableRow.Position = CharNumber;
		TableRow.Kind = "InvalidChar";
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимый символ ""%1"" с кодом %2'; en = 'Invalid character ""%1"" with code %2'; pl = 'Nieprawidłowy symbol ""%1"" z kodem %2';de = 'Ungültiges Symbol ""%1"" mit Code %2';ro = 'Simbol inadmisibil ""%1"" cu codul %2';tr = '%1Kodlu izin verilmeyen karakter ""%2""'; es_ES = 'Símbolo no disponible ""%1"" con el código %2'"), Char, CharCode(Char));
	EndDo;
	
	If CharsetKind = "Word" Then
		AddWordToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "Operation" Then
		AddOperationToCharsetsTable(CharsetsTable,
			Charset, CharsetPosition, LanguageSyntax);
		
	ElsIf CharsetKind = "ArbitraryLine" Then
		TableRow.Clarification = StrConcat(Charset);
		TableRow.Position = CharsetPosition;
		TableRow.ErrorPosition = CharNumber - CharsetPosition;
		TableRow.ErrorText   = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не указан символ окончания произвольной строки %1'; en = 'Character of %1 arbitrary string end is not specified'; pl = 'Nie podano symbol zakończenia dowolnego wiersza %1';de = 'Kein beliebiger Zeilenabschluss angegeben %1';ro = 'Nu este indicat simbolul sfârșitului rândului arbitrar %1';tr = 'Rasgele satır sonu karakteri belirtilmedi%1'; es_ES = 'No se ha indicado un símbolo de terminación de línea libre %1'"), TableRow.Chars);
	EndIf;
	
	LastRow = CharsetsTable.Add();
	LastRow.Position = StrLen(RestrictionText) + 1;
	LastRow.Kind = "End"; // To set the lack of description error text.
	CharsetsTable.Indexes.Add("Kind, Clarification");
	
	Return CharsetsTable;
	
EndFunction

// For the CharsetsTable function.
Procedure AddWordToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharactersString = StrConcat(Charset);
	WordProperties  = LanguageSyntax.LanguageWords.Get(Upper(CharactersString));
	
	NewRow = Table.Add();
	NewRow.Chars = CharactersString;
	NewRow.Position = CharsetPosition;
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
		NewRow.Clarification = WordProperties.ID;
		NewRow.IsReserve = WordProperties.IsReserve;
		
		If WordProperties.IsReserve Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Ключевое слово ""%1"" не поддерживается'; en = 'Keyword ""%1"" is not supported'; pl = 'Słowo kluczowe ""%1"" nie jest obsługiwane';de = 'Das Schlüsselwort ""%1"" wird nicht unterstützt';ro = 'Cuvântul-cheie ""%1"" nu este susținut';tr = '""%1"" anahtar kelimesi desteklenmiyor'; es_ES = 'Palabra clave ""%1"" no se admite'"), CharactersString);
		EndIf;
		Return;
	EndIf;
	
	// The word is a name or a number.
	NumbersChars = LanguageSyntax.NumbersChars;
	
	If Charset[0] = "." Then
		If Charset.Count() > 1 Then
			IsNumber = False;
		Else
			NewRow.Kind = "Name";
			NewRow.ErrorText = NStr("ru = 'Имя не может начинаться с точки'; en = 'Name cannot start with a period'; pl = 'Nazwa nie może zaczynać się od kropki';de = 'Der Name kann nicht mit einem Punkt beginnen';ro = 'Numele nu poate începe cu punct';tr = 'Isim nokta ile başlayamaz'; es_ES = 'Nombre no puede empezarse con el punto'");
			Return;
		EndIf;
	Else
		IsNumber = NumbersChars.Get(Charset[0]) <> Undefined;
	EndIf;
	
	If IsNumber Then
		NewRow.Kind = "Number";
		CharNumber = 1;
		For Each Char In Charset Do
			If NumbersChars.Get(Char) = Undefined Then
				NewRow.ErrorPosition = CharNumber - 1;
				NewRow.ErrorText   = NStr("ru = 'Число может состоять только из цифр'; en = 'Number can contain only digits'; pl = 'Numer może składać się tylko z cyfr';de = 'Die Nummer kann nur aus Zahlen bestehen';ro = 'Numărul trebuie să conțină numai cifre';tr = 'Sayı sadece rakamlardan oluşabilir'; es_ES = 'Número puede estar compuesto solo de cifras'");
				Return;
			EndIf;
			CharNumber = CharNumber + 1;
		EndDo;
		NumberChars = Left(CharactersString, CharNumber - 1);
		If StrLen(NumberChars) > 16 Then
			NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Слишком большое число ""%1""'; en = 'Number ""%1"" is too big'; pl = 'Zbyt duża liczba ""%1""';de = 'Zu hohe Anzahl ""%1""';ro = 'Număr prea mare ""%1""';tr = 'Çok büyük sayı ""%1""'; es_ES = 'Número demasiado grande ""%1""'"), NumberChars);
			Return;
		EndIf;
		NewRow.Clarification = Number(NumberChars);
	Else
		NewRow.Kind = "Name";
		NameParts = StrSplit(CharactersString, ".");
		NamePartPosition = 1;
		For Each NamePart In NameParts Do
			If NamePart = "" AND NamePartPosition > 1 Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("ru = 'После точки не указано имя'; en = 'No name after period'; pl = 'Po kropce nie podano nazwy';de = 'Kein Name nach dem Punkt';ro = 'După punct nu este indicat numele';tr = 'Noktadan isim belirtilmemiştir'; es_ES = 'Después del punto no está indicado el nombre'");
				Return;
			ElsIf NumbersChars.Get(Left(NamePart, 1)) <> Undefined Then
				NewRow.ErrorPosition = NamePartPosition - 1;
				NewRow.ErrorText   = NStr("ru = 'После точки в имени не может следовать число'; en = 'Number cannot be used after period in a name'; pl = 'Po kropce w nazwie nie może podążać liczba';de = 'Nach einem Punkt im Namen kann die Nummer nicht folgen';ro = 'După punct în nume nu poate urma un număr';tr = 'Addaki noktadan sonra sayı bulunamaz'; es_ES = 'Después del punto en el nombre no puede seguir el número'");
				Return;
			EndIf;
			NamePartPosition = NamePartPosition + StrLen(NamePart) + 1;
		EndDo;
	EndIf;
	
EndProcedure

// For the CharsetsTable function.
Procedure AddOperationToCharsetsTable(Table,
			Charset, CharsetPosition, LanguageSyntax)
	
	CharactersString = StrConcat(Charset);
	OperationProperties = LanguageSyntax.LanguageOperations.Get(CharactersString);
	
	NewRow = Table.Add();
	NewRow.Chars   = CharactersString;
	NewRow.Position   = CharsetPosition;
	NewRow.Kind       = "Operation";
	NewRow.Type       = OperationProperties.Type;
	NewRow.Priority = OperationProperties.Priority;
	NewRow.IsReserve = OperationProperties.IsReserve;
	
	If OperationProperties = Undefined Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Недопустимая операция ""%1""'; en = 'Invalid operation ""%1""'; pl = 'Nieprawidłowa operacja ""%1""';de = 'Ungültige Operation ""%1""';ro = 'Operație inadmisibilă ""%1""';tr = 'Geçersiz işlem ""%1""'; es_ES = 'Operación no admitida ""%1""'"), CharactersString);
		
	ElsIf OperationProperties.IsReserve Then
		NewRow.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Операция ""%1"" не поддерживается'; en = 'Operation ""%1"" is not supported'; pl = 'Operacja ""%1"" nie jest obsługiwana';de = 'Operation ""%1"" wird nicht unterstützt';ro = 'Operația ""%1"" nu este susținută';tr = 'Işlem ""%1"" desteklenmez'; es_ES = 'Operación ""%1"" no se admite'"), CharactersString);
	EndIf;
	
EndProcedure

// For the ParsedRestriction function and for many other functions indirectly.
Function LanguageSyntax() Export
	
	LanguageSyntax = New Structure;
	LanguageSyntax.Insert("LanguageChars",  LanguageChars());
	LanguageSyntax.Insert("NumbersChars",   NumbersChars());
	LanguageSyntax.Insert("LanguageOperations", LanguageOperations());
	LanguageSyntax.Insert("LanguageWords",    LanguageWords());
	LanguageSyntax.Insert("TablesTypes",    TablesTypes());
	
	Return New FixedStructure(LanguageSyntax);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageChars()
	
	LanguageChars = New Map;
	
	For CharCode = CharCode("A") To CharCode("Z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("a") To CharCode("z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("A") To CharCode("Z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	For CharCode = CharCode("a") To CharCode("z") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert("_", "WordChar");
	LanguageChars.Insert(".", "WordChar");
	
	For CharCode = CharCode("0") To CharCode("9") Do
		LanguageChars.Insert(Char(CharCode), "WordChar");
	EndDo;
	
	LanguageChars.Insert(" ",         "Indent");
	LanguageChars.Insert(Chars.Tab, "Indent");
	LanguageChars.Insert(Chars.LF,  "Indent");
	
	LanguageChars.Insert("""", "LineLimiter");
	
	LanguageChars.Insert("(", "Separator");
	LanguageChars.Insert(")", "Separator");
	LanguageChars.Insert(",", "Separator");
	LanguageChars.Insert(";", "Separator");
	LanguageChars.Insert("=", "OperationChar");
	LanguageChars.Insert("<", "OperationChar");
	LanguageChars.Insert(">", "OperationChar");
	
	// Not supported.
	LanguageChars.Insert("+", "OperationChar");
	LanguageChars.Insert("-", "OperationChar");
	LanguageChars.Insert("*", "OperationChar");
	LanguageChars.Insert("/", "OperationChar");
	
	Return New FixedMap(LanguageChars);
	
EndFunction

// For the LanguageSyntax function.
Function NumbersChars()
	
	NumbersChars = New Map;
	
	For CharCode = CharCode("0") To CharCode("9") Do
		NumbersChars.Insert(Char(CharCode), True);
	EndDo;
	
	Return New FixedMap(NumbersChars);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageWords()
	
	Words = New Map;
	
	AddLanguageWord(Words, "AttachAdditionalTables",     "AttachAdditionalTables",      "Begin",       False);
	AddLanguageWord(Words, "ThisList",                            "ThisList",                    "StartList", False);
	AddLanguageWord(Words, "AllowReadUpdate",              "AllowReadUpdate",             "Begin",       False);
	AddLanguageWord(Words, "AllowRead",                       "AllowRead",                   "Begin",       False);
	AddLanguageWord(Words, "AllowUpdateIfReadingAllowed", "AllowUpdateIfReadingAllowed", "Begin",       False);
	AddLanguageWord(Words, "Where",                                   "Where",                       "StartWhere");
	
	AddLanguageWord(Words, "Left",      "Left", "Joining");
	AddLanguageWord(Words, "Join", "Join", "Joining");
	AddLanguageWord(Words, "On",         "On",   "Joining");
	
	AddLanguageWord(Words, "AND",      "AND",    "Connector", , 2);
	AddLanguageWord(Words, "Or",    "Or",     "Connector", , 1);
	AddLanguageWord(Words, "IN",      "IN",     "Connector", , 5);
	AddLanguageWord(Words, "As",    "As",     "Connector");
	AddLanguageWord(Words, "Except",  "Except", "Connector");
	AddLanguageWord(Words, "Only", "Only",   "Connector");
	AddLanguageWord(Words, "Is",   "Is",     "Connector", , 7);
	AddLanguageWord(Words, "Not",     "Not",    "Operator",    , 3);
	
	AddLanguageWord(Words, "Case",  "Case", "SelectionWord");
	AddLanguageWord(Words, "When",  "When", "SelectionWord");
	AddLanguageWord(Words, "Then",  "Then", "SelectionWord");
	AddLanguageWord(Words, "Else",  "Else", "SelectionWord");
	AddLanguageWord(Words, "End",  "End",  "SelectionWord");
	
	AddLanguageWord(Words, "IsNull",                      "IsNull",               "Function", False);
	AddLanguageWord(Words, "Cast",                      "Cast",                 "Function", False);
	AddLanguageWord(Words, "Value",                      "Value",                "Function", False);
	AddLanguageWord(Words, "ValueType",                   "ValueType",            "Function", False);
	AddLanguageWord(Words, "Type",                           "Type",                 "Function", False);
	AddLanguageWord(Words, "ValueAllowed",             "ValueAllowed",         "Function", False);
	AddLanguageWord(Words, "ObjectReadingAllowed",        "ObjectReadingAllowed", "Function", False);
	AddLanguageWord(Words, "ObjectUpdateAllowed",     "ObjectUpdateAllowed",  "Function", False);
	AddLanguageWord(Words, "ListReadingAllowed",         "ListReadingAllowed",   "Function", False);
	AddLanguageWord(Words, "ListUpdateAllowed",      "ListUpdateAllowed",    "Function", False);
	AddLanguageWord(Words, "ForAllRows",                  "ForAllRows",           "Function", False);
	AddLanguageWord(Words, "ForAtLeastOneRow",               "ForAtLeastOneRow",     "Function", False);
	AddLanguageWord(Words, "IsAuthorizedUser", "IsAuthorizedUser",     "Function", False);
	
	AddLanguageWord(Words, "EmptyRef", "EmptyRef",  "ComparisonValue");
	AddLanguageWord(Words, "Disabled",    "Disabled",  "ComparisonValue");
	AddLanguageWord(Words, "Undefined", "Undefined", "ComparisonValue");
	AddLanguageWord(Words, "Null",         "Null",      "ComparisonValue");
	AddLanguageWord(Words, "False",         "False",     "ClarificationValue");
	AddLanguageWord(Words, "True",       "True",      "ClarificationValue");
	
	AddLanguageWord(Words, "String",       "String",    "TypeName");
	AddLanguageWord(Words, "Number",        "Number",    "TypeName");
	AddLanguageWord(Words, "Date",         "Date",      "TypeName");
	AddLanguageWord(Words, "Boolean",       "Boolean",   "TypeName");
	
	// Not supported, reserved words.
	AddLanguageWord(Words, "Select",             "Select",          "Undefined",   , , True);
	AddLanguageWord(Words, "Top",              "Top",             "Undefined",   , , True);
	AddLanguageWord(Words, "Distinct",           "Distinct",        "Undefined",   , , True);
	AddLanguageWord(Words, "From",                  "From",            "Undefined",   , , True);
	AddLanguageWord(Words, "Inner",          "Inner",           "Joining", , , True);
	AddLanguageWord(Words, "Full",              "Full",            "Joining", , , True);
	AddLanguageWord(Words, "Group",       "Group",           "Undefined",   , , True);
	AddLanguageWord(Words, "Having",             "Having",          "Undefined",   , , True);
	AddLanguageWord(Words, "Order",         "Order",           "Undefined",   , , True);
	AddLanguageWord(Words, "Totals",               "Totals",          "Undefined",   , , True);
	AddLanguageWord(Words, "Year",                 "Year",            "Function",   False, , True);
	AddLanguageWord(Words, "Quarter",             "Quarter",         "Function",   False, , True);
	AddLanguageWord(Words, "Month",               "Month",           "Function",   False, , True);
	AddLanguageWord(Words, "DayOfYear",            "DayOfYear",       "Function",   False, , True);
	AddLanguageWord(Words, "Day",                "Day",             "Function",   False, , True);
	AddLanguageWord(Words, "Week",              "Week",            "Function",   False, , True);
	AddLanguageWord(Words, "Weekday",          "Weekday",         "Function",   False, , True);
	AddLanguageWord(Words, "Hour",                 "Hour",            "Function",   False, , True);
	AddLanguageWord(Words, "Minute",              "Minute",          "Function",   False, , True);
	AddLanguageWord(Words, "Second",             "Second",          "Function",   False, , True);
	AddLanguageWord(Words, "BeginOfPeriod",       "BeginOfPeriod",   "Function",   False, , True);
	AddLanguageWord(Words, "EndOfPeriod",        "EndOfPeriod",     "Function",   False, , True);
	AddLanguageWord(Words, "DateAdd",       "DateAdd",         "Function",   False, , True);
	AddLanguageWord(Words, "DateDiff",         "DateDiff",        "Function",   False, , True);
	AddLanguageWord(Words, "Sum",               "Sum",             "Function",   False, , True);
	AddLanguageWord(Words, "Min",             "Min",             "Function",   False, , True);
	AddLanguageWord(Words, "Max",            "Max",             "Function",   False, , True);
	AddLanguageWord(Words, "Avg",             "Avg",             "Function",   False, , True);
	AddLanguageWord(Words, "Count",          "Count",           "Function",   False, , True);
	AddLanguageWord(Words, "Presentation",       "Presentation",    "Function",   False, , True);
	AddLanguageWord(Words, "RefPresentation", "RefPresentation", "Function",   False, , True);
	
	Return New FixedMap(Words);
	
EndFunction

// For the LanguageSyntax function.
Function LanguageOperations()
	
	LanguageOperations = New Map;
	
	AddLanguageWord(LanguageOperations, "=",  "=",  "Connector", , 4);
	AddLanguageWord(LanguageOperations, "<>", "<>", "Connector", , 4);
	
	// Not supported, reserved operations.
	AddLanguageWord(LanguageOperations, "<",  "<",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "<=", "<=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">",  ">",  "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, ">=", ">=", "Connector", , 4, True);
	AddLanguageWord(LanguageOperations, "+",  "+",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "-",  "-",  "Connector", , 1, True);
	AddLanguageWord(LanguageOperations, "*",  "*",  "Connector", , 6, True);
	AddLanguageWord(LanguageOperations, "/",  "/",  "Connector", , 6, True);
	
	Return New FixedMap(LanguageOperations);
	
EndFunction

// For the LanguageWords and LanguageOperations functions.
Procedure AddLanguageWord(Words, LanguageRussian, LanguageEnglish, WordType,
			Uppercase = True, Priority = 0, IsReserve = False)
	
	WordProperties = New Structure;
	WordProperties.Insert("ID",  LanguageRussian);
	WordProperties.Insert("LanguageRussian",    LanguageRussian);
	WordProperties.Insert("LanguageEnglish", LanguageEnglish);
	WordProperties.Insert("Type",            WordType);
	WordProperties.Insert("Uppercase", Uppercase);
	WordProperties.Insert("Priority",      Priority);
	WordProperties.Insert("IsReserve",      IsReserve);
	
	WordProperties = New FixedStructure(WordProperties);
	
	Words.Insert(Upper(LanguageRussian),    WordProperties);
	Words.Insert(Upper(LanguageEnglish), WordProperties);
	
EndProcedure

// For the LanguageSyntax function.
Function TablesTypes()
	
	TablesTypes = New Structure;
	TablesTypes.Insert("ByNames",     New Map);
	TablesTypes.Insert("ByCollections", New Map);
	
	// Setting table type names.
	AddTablesType(TablesTypes, "ExchangePlan",             "ExchangePlan",               "ExchangePlans");
	AddTablesType(TablesTypes, "FilterCriterion",         "FilterCriterion",            "FilterCriteria");
	AddTablesType(TablesTypes, "Constants",              "Constants",                  "");
	AddTablesType(TablesTypes, "Constant",              "Constant",                   "Constants");
	AddTablesType(TablesTypes, "Catalog",             "Catalog",                    "Catalogs");
	AddTablesType(TablesTypes, "Sequence",     "Sequence",                   "Sequences");
	AddTablesType(TablesTypes, "Document",               "Document",                   "Documents");
	AddTablesType(TablesTypes, "DocumentJournal",       "DocumentJournal",            "DocumentJournals");
	AddTablesType(TablesTypes, "Enum",           "Enum",                       "Enums");
	AddTablesType(TablesTypes, "ChartOfCharacteristicTypes", "ChartOfCharacteristicTypes", "ChartsOfCharacteristicTypes");
	AddTablesType(TablesTypes, "ChartOfAccounts",             "ChartOfAccounts",            "ChartsOfAccounts");
	AddTablesType(TablesTypes, "ChartOfCalculationTypes",       "ChartOfCalculationTypes",    "ChartsOfCalculationTypes");
	AddTablesType(TablesTypes, "InformationRegister",        "InformationRegister",        "InformationRegisters");
	AddTablesType(TablesTypes, "AccumulationRegister",      "AccumulationRegister",       "AccumulationRegisters");
	AddTablesType(TablesTypes, "AccountingRegister",     "AccountingRegister",         "AccountingRegisters");
	AddTablesType(TablesTypes, "CalculationRegister",         "CalculationRegister",        "CalculationRegisters");
	AddTablesType(TablesTypes, "BusinessProcess",          "BusinessProcess",            "BusinessProcesses");
	AddTablesType(TablesTypes, "Task",                 "Task",                       "Tasks");
	
	// Setting main properties of the main table types.
	TablesTypesNames = "ExchangePlan,Catalog,Document,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes,BusinessProcess,Task";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "IsReferenceType", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "CommonAttributes",  "Allowed");
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use",   "Allowed");
	
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, "TabularSections", "Allowed");
	
	AddTablesTypeField(TablesTypes, TablesTypesNames, "DataVersion",  "DataVersion",  "Denied");
	AddTablesTypeField(TablesTypes, TablesTypesNames, "Presentation", "Presentation", "Denied");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Changes", "Changes", "Denied");
	
	// Setting main register properties.
	TablesTypesNames = "InformationRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Allowed");
	
	TablesTypesNames = "AccumulationRegister,AccountingRegister";
	SetTablesTypeProperty(TablesTypes,     TablesTypesNames, "CommonAttributes",       "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Resources",              "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Attributes",            "Illegal");
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "StandardAttributes", "Illegal");
	
	TablesTypesNames = "InformationRegister,AccumulationRegister,AccountingRegister,CalculationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, "Dimensions", "Allowed");
	
	AddTablesTypeExtension(TablesTypes, TablesTypesNames, "Changes", "Changes", "Denied");
	
	// Setting some of the earlier mentioned properties for other table types.
	SetTablesTypeProperty(TablesTypes,     "Sequence", "HasLimit", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Sequence", "Dimensions", "Allowed");
	
	SetTablesTypeProperty(TablesTypes,     "DocumentJournal", "CommonAttributes",       "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "StandardAttributes", "Allowed");
	
	SetTablesTypeProperty(TablesTypes,     "Enum", "IsReferenceType", True);
	AddTablesTypeFieldsCollection(TablesTypes, "Enum", "StandardAttributes", "Allowed");
	
	TablesTypesNames = "Constant,InformationRegister";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "Use", "Allowed");
	SetTablesTypeProperty(TablesTypes, "FilterCriterion", "Use", "Illegal");
	
	AddTablesTypeExtension(TablesTypes, "Constant",       "Changes",     "Changes",    "Denied");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "SliceFirst",    "SliceFirst", "Illegal");
	AddTablesTypeExtension(TablesTypes, "InformationRegister", "SliceLast", "SliceLast",  "Illegal");
	AddTablesTypeExtension(TablesTypes, "BusinessProcess",   "Points",         "Points",     "Denied");
	
	// Setting special properties.
	SetTablesTypeProperty(TablesTypes, "ChartOfAccounts", "ExtDimensionAccountingFlags", "Allowed");
	
	AddTablesTypeFieldsCollection(TablesTypes, "DocumentJournal", "Columns",              "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "ChartOfAccounts",       "AccountingFlags",      "Allowed");
	AddTablesTypeFieldsCollection(TablesTypes, "Task",           "AddressingAttributes", "Allowed");
	
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfAccounts",       "StandardTabularSections", "Allowed");
	AddTablesTypeTabularSectionsCollection(TablesTypes, "ChartOfCalculationTypes", "StandardTabularSections", "Allowed");
	
	TablesTypesNames = "Catalog,Enum,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	SetTablesTypeProperty(TablesTypes, TablesTypesNames, "HasPredefined", True);
	
	// Clarifying standard fields of table types.
	TablesTypesNames = "Document,InformationRegister,AccumulationRegister,AccountingRegister";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "PointInTime", "PointInTime", "Illegal");
	
	TablesTypesNames = "Catalog,ChartOfCharacteristicTypes,ChartOfAccounts,ChartOfCalculationTypes";
	AddTablesTypeField(TablesTypes, TablesTypesNames, "PredefinedDataName", "PredefinedDataName", "Denied");
	
	AddTablesTypeField(TablesTypes, "Constant",          "Value",          "Value",               "Allowed");
	AddTablesTypeField(TablesTypes, "Sequence", "Recorder",       "Recorder",            "Allowed");
	AddTablesTypeField(TablesTypes, "Sequence", "Period",            "Period",              "Allowed");
	AddTablesTypeField(TablesTypes, "DocumentJournal",   "Type",               "Type",                "Illegal");
	AddTablesTypeField(TablesTypes, "Enum",       "Order",           "Order",               "Denied");
	
	Return TablesTypes;
	
EndFunction

// For the TablesTypes function.
Procedure AddTablesType(TablesTypes, LanguageRussian, LanguageEnglish, CollectionName)
	
	// The "Use" property for tables.
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to connect as an additional table in the SSL access restriction.
	
	TablesTypeProperties = New Structure;
	TablesTypeProperties.Insert("CollectionName",             CollectionName);
	TablesTypeProperties.Insert("LanguageRussian",              LanguageRussian);
	TablesTypeProperties.Insert("LanguageEnglish",           LanguageEnglish);
	TablesTypeProperties.Insert("IsReferenceType",          False);
	TablesTypeProperties.Insert("HasLimit",          False);
	TablesTypeProperties.Insert("HasPredefined",     False);
	TablesTypeProperties.Insert("FieldCollections",           New Map);
	TablesTypeProperties.Insert("TabularPartCollections", New Map);
	TablesTypeProperties.Insert("CommonAttributes",           "Missing");
	TablesTypeProperties.Insert("ExtDimensionAccountingFlags",    "Missing");
	TablesTypeProperties.Insert("FieldsClarification",           New Map);
	TablesTypeProperties.Insert("TablesClarification",          New Map);
	TablesTypeProperties.Insert("Use",            "Denied");
	
	TablesTypes.ByNames.Insert(Upper(LanguageRussian),    TablesTypeProperties);
	TablesTypes.ByNames.Insert(Upper(LanguageEnglish), TablesTypeProperties);
	
	If ValueIsFilled(CollectionName) Then
		TablesTypes.ByCollections.Insert(CollectionName, TablesTypeProperties);
	EndIf;
	
EndProcedure

// For the TablesTypes function.
Procedure SetTablesTypeProperty(TablesTypes, TablesTypesNames, Property, Value)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties[Property] = Value;
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeFieldsCollection(TablesTypes, TablesTypesNames, CollectionName, Usage)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.FieldCollections.Insert(CollectionName, Usage);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeTabularSectionsCollection(TablesTypes, TablesTypesNames, CollectionName, Usage)
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		TablesTypeProperties.TabularPartCollections.Insert(CollectionName, Usage);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeField(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Usage)
	
	// Use:
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to use in the SSL access restriction.
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		FieldClarification = New Structure;
		FieldClarification.Insert("LanguageRussian",    LanguageRussian);
		FieldClarification.Insert("LanguageEnglish", LanguageEnglish);
		FieldClarification.Insert("Use",  Usage);
		
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageRussian),    FieldClarification);
		TablesTypeProperties.FieldsClarification.Insert(Upper(LanguageEnglish), FieldClarification);
	EndDo;
	
EndProcedure

// For the TablesTypes function.
Procedure AddTablesTypeExtension(TablesTypes, TablesTypesNames, LanguageRussian, LanguageEnglish, Usage)
	
	// Use:
	// "Allowed"   - can be used without restrictions.
	// "NotAllowed" - cannot be used in 1C:Enterprise platform access restriction.
	// "Prohibited"   - it is prohibited to use in the SSL access restriction.
	
	For Each TableTypeName In StrSplit(TablesTypesNames, ",", False) Do
		TablesClarification = New Structure;
		TablesClarification.Insert("LanguageRussian",    LanguageRussian);
		TablesClarification.Insert("LanguageEnglish", LanguageEnglish);
		TablesClarification.Insert("Use",  Usage);
		
		TablesTypeProperties = TablesTypes.ByNames.Get(Upper(TableTypeName));
		
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageRussian),    TablesClarification);
		TablesTypeProperties.TablesClarification.Insert(Upper(LanguageEnglish), TablesClarification);
	EndDo;
	
EndProcedure

#EndRegion

#Region Parsing

// For the ParsedRestriction function.
Function RestrictionParts(InternalData)
	
	RestrictionParts = New Structure;
	RestrictionParts.Insert("AdditionalTables",    New Array);
	RestrictionParts.Insert("MainTableAlias", "");
	RestrictionParts.Insert("ReadRestriction",        New Structure);
	RestrictionParts.Insert("UpdateRestriction",     New Structure);
	
	CharsetsTable = InternalData.CharsetsTable;
	
	If CharsetsTable.Count() = 0 Then
		Return RestrictionParts;
	EndIf;
	
	CharsetsTable.Columns.Add("Rows", New TypeDescription("Array"));
	CharsetsTable.Columns.Add("EndString");
	
	// Separating a restriction into main parts.
	Rows = CharsetsTable.FindRows(New Structure("Chars, Kind", ";", "Separator"));
	
	SeparatorRowsIndexes = New Array;
	For Each Row In Rows Do
		SeparatorRowsIndexes.Add(CharsetsTable.IndexOf(Row));
	EndDo;
	SeparatorRowsIndexes.Add(CharsetsTable.Count() - 1);
	
	PartsProperties = New Array;
	RowIndex = 0;
	For Each SeparatorRowIndex In SeparatorRowsIndexes Do
		PartRows = New Array;
		While RowIndex < SeparatorRowIndex Do
			PartRow = CharsetsTable[RowIndex];
			If PartRow.Kind <> "InvalidChar" Then
				PartRows.Add(PartRow);
			EndIf;
			RowIndex = RowIndex + 1;
		EndDo;
		SeparatorRow = CharsetsTable[SeparatorRowIndex];
		If PartRows.Count() = 0 Then
			PartRows.Add(SeparatorRow);
		EndIf;
		PartProperties = New Structure;
		PartProperties.Insert("Rows", PartRows);
		PartProperties.Insert("SeparatorRow", SeparatorRow);
		PartsProperties.Add(PartProperties);
		If PartRows[0].Kind = "Keyword"
		   AND PartRows[0].Type = "Begin" Then
			
			PartProperties.Insert("Name",           PartRows[0].Clarification);
			PartProperties.Insert("Presentation", PartRows[0].Chars);
			
			ParseRestrictionPart(PartProperties, InternalData);
		Else
			PartProperties.Insert("Name",           "");
			PartProperties.Insert("Presentation", "");
		EndIf;
		RowIndex = SeparatorRowIndex + 1;
	EndDo;
	
	AddDefaultAliases(InternalData);
	
	// Part 1 analysis.
	Part1Properties = PartsProperties[0];
	
	If Part1Properties.Name = "" Then
		SetPartBeginningError(Part1Properties, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'В начале первой части текста ограничения не найдено ни одно из ключевых слов
			           |""%1"", ""%2"", ""%3""'; 
			           |en = 'None of ""%1"", ""%2"", ""%3"" keywords
			           |is found in the first part of the restriction text'; 
			           |pl = 'Na początku pierwszej części tekstu ograniczenia, nie znaleziono ani jednego ze słów kluczowych
			           |""%1"", ""%2"", ""%3""';
			           |de = 'Am Anfang des ersten Teils des Einschränkungstextes wurden keine Schlüsselwörter
			           |""%1"", ""%2"", ""%3"" gefunden';
			           |ro = 'La începutul primei părți a textului restricției nu a fost găsit nici unul din cuvintele-cheie
			           |""%1"", ""%2"", ""%3""';
			           |tr = 'Kısıtlama metnin ilk bölümünde anahtar kelimelerin hiç biri bulunamadı 
			           |""%1"", ""%2"", ""%3""'; 
			           |es_ES = 'Al inicio de la primera parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
			           |""%1"", ""%2"", ""%3""'"),
			"AllowReadUpdate,AllowRead,AttachAdditionalTables"));
		Return RestrictionParts;
		
	ElsIf Part1Properties.Name = "AllowUpdateIfReadingAllowed" Then
		SetPartBeginningError(Part1Properties,
			NStr("ru = 'В начале первой части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the first part of the restriction text'; pl = 'Na początku pierwszej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';de = 'Am Anfang des ersten Teils des Einschränkungstextes wurde ein ungültiges Schlüsselwort gefunden';ro = 'La începutul primei părți a textului restricției a fost găsit cuvântul-cheie inadmisibil';tr = 'Kısıtlama metnin ilk kısmının başında izin verilmeyen anahtar kelime bulundu'; es_ES = 'Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida'"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 1
	        AND (    Part1Properties.Name = "AttachAdditionalTables"
	           Or Part1Properties.Name = "AllowRead" ) Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Текст ограничения не может быть только из одной части
				           |с ключевым словом ""%1""'; 
				           |en = 'Restriction text cannot have just one part
				           |with keyword ""%1""'; 
				           |pl = 'Tekst ograniczenia nie może składać się tylko z jednej części
				           |ze słowem kluczowym ""%1""';
				           |de = 'Der Text der Einschränkung darf nicht nur ein Teil
				           |des Schlüsselwortes ""%1"" sein';
				           |ro = 'Textul restricției nu poate fi compus dintr-o singură parte
				           |cu cuvântul-cheie ""%1""';
				           |tr = 'Kısıtlama metni, "
" anahtar kelime ile tek bölümden %1 oluşmaz'; 
				           |es_ES = 'Texto con restricciones no puede contener solo una parte
				           |con una palabra clave ""%1""'"), Part1Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part1Properties);
	
	If PartsProperties.Count() < 2 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 2 analysis.
	Part2Properties = PartsProperties[1];
	
	If Part1Properties.Name = "AllowReadUpdate" Then
		SetPartBeginningError(Part1Properties.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Второй части текста ограничения не должно быть, когда
				           |в первой части указано ключевое слово ""%1""'; 
				           |en = 'There must not be the second part of the restriction text when
				           |the ""%1"" keyword is specified in the first part'; 
				           |pl = 'Drugiej części tekstu ograniczenia nie powinno być, gdy
				           |w pierwszej części podane słowo kluczowe ""%1""';
				           |de = 'Der zweite Teil des Textes der Einschränkung sollte nicht sein, wenn
				           |der erste Teil das Schlüsselwort ""%1"" enthält';
				           |ro = 'Restricția nu trebuie să conțină partea a doua de text, dacă
				           |în prima parte este indicat cuvântul-cheie ""%1""';
				           |tr = 'Kısıtlama metninin ikinci kısmı, %1ilk bölümde "
" bir anahtar kelime belirtildiğinde olmamalıdır'; 
				           |es_ES = 'No debe haber segunda parte de restricción cuando
				           |en la primera parte está indicada la palabra clave ""%1""'"), Part1Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If Part2Properties.Name = "" Then
		If Part1Properties.Name = "AllowRead" Then
			SetPartBeginningError(Part2Properties, InsertKeywordsIntoString(InternalData,
				NStr("ru = 'В начале второй части текста ограничения не найдено
				           |ключевое слово ""%1""'; 
				           |en = 'The ""%1"" keyword is not found
				           |at the beginning of the second part of the restriction text'; 
				           |pl = 'Na początku drugiej części tekstu ograniczenia nie znaleziono
				           |słowo kluczowe ""%1""';
				           |de = 'Zu Beginn des zweiten Teils des Einschränkungstextes wurde
				           |das Schlüsselwort ""%1"" nicht gefunden';
				           |ro = 'La începutul părții a doua a textului restricției nu a fost găsit
				           |cuvântul-cheie ""%1""';
				           |tr = 'Kısıtlama metninin ikinci bölümünün başında %1 "
" anahtar kelimesi bulunmadı '; 
				           |es_ES = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado
				           | una palabra clave ""%1""'"),
				"AllowUpdateIfReadingAllowed"));
		Else // Part1Properties.Name = "AttachAdditionalTables".
			SetPartBeginningError(Part2Properties, InsertKeywordsIntoString(InternalData,
				NStr("ru = 'В начале второй части текста ограничения не найдено ни одно из ключевых слов
				           |""%1"", ""%2""'; 
				           |en = 'None of ""%1"", ""%2"" keywords
				           |is found at the beginning of the second part of the restriction text'; 
				           |pl = 'Na początku drugiej części tekstu ograniczenia, nie znaleziono ani jednego ze słów kluczowych
				           |""%1"", ""%2""';
				           |de = 'Am Anfang des zweiten Teils des Einschränkungstextes wurden keine Schlüsselwörter
				           |""%1"", ""%2"" gefunden';
				           |ro = 'La începutul părții a doua a textului restricției nu a fost găsit nici unul din cuvintele-cheie
				           |""%1"", ""%2""';
				           |tr = 'Kısıtlama metnin ikinci bölümünde anahtar kelimelerin hiç biri bulunamadı 
				           |""%1"", ""%2""'; 
				           |es_ES = 'Al inicio de la segunda parte de texto de la restricción no se ha encontrado ninguna de las palabras claves
				           |""%1"", ""%2""'"),
				"AllowReadUpdate,AllowRead"));
		EndIf;
		Return RestrictionParts;
		
	ElsIf Part1Properties.Name = "AllowRead"
	        AND Part2Properties.Name <> "AllowUpdateIfReadingAllowed"
	      Or Part1Properties.Name = "AttachAdditionalTables"
	        AND Part2Properties.Name <> "AllowReadUpdate"
	        AND Part2Properties.Name <> "AllowRead" Then
		
		SetPartBeginningError(Part2Properties,
			NStr("ru = 'В начале второй части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the second part of the restriction text'; pl = 'Na początku drugiej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';de = 'Am Anfang des zweiten Teils des Einschränkungstextes wurde ein ungültiges Schlüsselwort gefunden';ro = 'La începutul părții a doua a textului restricției a fost găsit cuvântul-cheie inadmisibil';tr = 'Kısıtlama metnin ikinci kısmının başında izin verilmeyen anahtar kelime bulundu'; es_ES = 'Al inicio de la segunda parte de texto de la restricción se ha encontrado una palabra clave no admitida'"));
		Return RestrictionParts;
		
	ElsIf PartsProperties.Count() = 2
	        AND Part2Properties.Name = "AllowRead" Then
		
		SetPartBeginningError(CharsetsTable,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Текст ограничения не может быть только из двух частей, когда
				           |во второй части указано ключевое слово ""%1""'; 
				           |en = 'Restriction text cannot consist only of two parts when
				           |the ""%1"" keyword is specified in the second part'; 
				           |pl = 'Tekst ograniczenia nie może być tylko z dwóch części, gdy
				           |w drugiej części wskazano słowo kluczowe ""%1""';
				           |de = 'Der Text der Einschränkung darf nicht nur aus zwei Teilen bestehen, wenn
				           |der zweite Teil das Schlüsselwort ""%1"" enthält';
				           |ro = 'Textul restricției nu poate fi compus numai din două părți, dacă
				           |în partea a doua este indicat cuvântul-cheie ""%1""';
				           |tr = 'Ikinci kısmında "
" anahtar kelime belirtildiğinde kısıtlama metni sadece %1iki kısımdan oluşamaz'; 
				           |es_ES = 'Texto de restricción no puede tener solo dos partes cuando
				           |en la segunda parte está indicada una palabra clave ""%1""'"), Part2Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part2Properties);
	
	If PartsProperties.Count() < 3 Then
		Return RestrictionParts;
	EndIf;
	
	// Part 3 analysis.
	Part3Properties = PartsProperties[2];
	
	If Part2Properties.Name = "AllowReadUpdate" Then
		SetPartBeginningError(Part2Properties.SeparatorRow,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Третьей части текста ограничения не должно быть, когда
				           |во второй части указано ключевое слово ""%1""'; 
				           |en = 'There should not be the third part of the restriction text when
				           |the ""%1"" keyword is specified in the second part'; 
				           |pl = 'Trzeciej części tekstu ograniczenia nie powinno być, gdy
				           |w drugiej części wskazano słowo kluczowe ""%1""';
				           |de = 'Der dritte Teil des Textes der Einschränkung sollte nicht sein, wenn
				           |der zweite Teil das Schlüsselwort ""%1"" enthält';
				           |ro = 'Restricția nu trebuie să conțină partea a treia de text, dacă
				           |în partea a doua este indicat cuvântul-cheie ""%1""';
				           |tr = 'Kısıtlama metninin üçüncü kısmı, %1ikinci bölümde "
" bir anahtar kelime belirtildiğinde olmamalıdır'; 
				           |es_ES = 'No debe haber tercera parte de restricción cuando
				           |en la segunda parte está indicada la palabra clave ""%1""'"), Part2Properties.Presentation));
		Return RestrictionParts;
	EndIf;
	
	If Part3Properties.Name = "" Then
		SetPartBeginningError(Part3Properties, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'В начале третьей части текста ограничения не найдено
			           |ключевое слово ""%1""'; 
			           |en = 'The ""%1"" keyword is not found
			           |at the beginning of the third part of the restriction text'; 
			           |pl = 'Na początku trzeciej części tekstu ograniczenia nie znaleziono
			           |słowo kluczowe ""%1""';
			           |de = 'Am Anfang des dritten Teils des Einschränkungstextes wird
			           |das Schlüsselwort ""%1"" nicht gefunden';
			           |ro = 'La începutul părții a treia a textului restricției nu a fost găsit
			           |cuvântul-cheie ""%1""';
			           |tr = 'Kısıtlama metninin üçüncü bölümünün başında %1 "
" anahtar kelimesi bulunmadı '; 
			           |es_ES = 'Al inicio de la tercera parte de texto de la restricción se ha encontrado
			           | una palabra clave ""%1""'"),
			"AllowUpdateIfReadingAllowed"));
		Return RestrictionParts;
		
	ElsIf Part2Properties.Name = "AllowRead"
	        AND Part3Properties.Name <> "AllowUpdateIfReadingAllowed" Then
		
		SetPartBeginningError(Part3Properties,
			NStr("ru = 'В начале третьей части текста ограничения найдено недопустимое ключевое слово'; en = 'Invalid keyword is found at the beginning of the third part of the restriction text'; pl = 'Na początku trzeciej części tekstu ograniczenia znaleziono nieprawidłowe słowo kluczowe';de = 'Am Anfang des dritten Teils des Textes der Einschränkung wurde ein ungültiges Schlüsselwort gefunden';ro = 'La începutul părții a treia a textului restricției a fost găsit cuvântul-cheie inadmisibil';tr = 'Kısıtlama metnin üçüncü kısmının başında izin verilmeyen anahtar kelime bulundu'; es_ES = ' Al inicio de la primera parte de texto de la restricción se ha encontrado una palabra clave no admitida'"));
		Return RestrictionParts;
	EndIf;
	
	SetRestrictionPart(RestrictionParts, Part3Properties);
	
	Return RestrictionParts;
	
EndFunction

// For the RestrictionParts function.
Procedure SetRestrictionPart(RestrictionParts, PartProperties)
	
	If PartProperties.Name = "AllowReadUpdate"
	 Or PartProperties.Name = "AllowRead" Then
		
		PropertyName = "ReadRestriction";
		
	ElsIf PartProperties.Name = "AllowUpdateIfReadingAllowed" Then
		
		PropertyName = "UpdateRestriction";
		
	Else // AttachAdditionalTables.
		
		PropertyName = "AdditionalTables";
		RestrictionParts.MainTableAlias = PartProperties.MainTableAlias;
	EndIf;
	
	RestrictionParts[PropertyName] = PartProperties.Content;
	
EndProcedure

// For the RestrictionParts function and the ParseAdditionalTables and ParseRestrictionCondition procedures.
Procedure SetPartBeginningError(PartProperties, ErrorText)
	
	If TypeOf(PartProperties) = Type("ValueTable") Then
		RowWithError = PartProperties[PartProperties.Count() - 1];
		
	ElsIf TypeOf(PartProperties) = Type("ValueTableRow") Then
		RowWithError = PartProperties;
	Else
		RowWithError = PartProperties.Rows[0];
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
	// Description of the first keyword options of parts is required.
	RowWithError.ErrorPosition = -1;
	
EndProcedure

// For the ParseConnection procedure.
Procedure SetErrorInsidePart(Rows, RowIndex, ErrorText)
	
	If RowIndex < Rows.Count() Then
		RowWithError = Rows[RowIndex];
	Else
		RowWithError = Rows[RowIndex - 1];
		// An error in the end of the word.
		RowWithError.ErrorPosition = StrLen(RowWithError.Chars);
	EndIf;
	
	RowWithError.ErrorText = ErrorText;
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments function.
Procedure SetErrorInRow(Row, ErrorText, InWordEnd = False, WordNumber = 1)
	
	If ValueIsFilled(Row.ErrorText) Then
		Return;
	EndIf;
	
	If InWordEnd Then
		Row.ErrorPosition = StrLen(Row.Chars);
		
	ElsIf WordNumber > 1 Then
		NameContent = StrSplit(Row.Chars, ".");
		If NameContent.Count() > 1 Then
			Row.ErrorPosition = StrLen(NameContent[0]) + 1;
		EndIf;
	EndIf;
	
	Row.ErrorText = ErrorText;
	
EndProcedure

// For the RestrictionParts function.
Procedure ParseRestrictionPart(PartProperties, InternalData)
	
	If PartProperties.Name = "AttachAdditionalTables" Then
		PartProperties.Insert("Content", New Array);
		PartProperties.Insert("MainTableAlias", "");
		ParseAdditionalTables(PartProperties, InternalData);
	Else
		PartProperties.Insert("Content", New Structure);
		ParseRestrictionCondition(PartProperties, InternalData);
	EndIf;
	
EndProcedure

// For the ParseRestrictionPart procedure.
Procedure ParseAdditionalTables(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows;
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Clarification <> "ThisList" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[1]),
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено
				           |ключевое слово ""%2""'; 
				           |en = 'Keyword ""%2"" is not found
				           |after keyword ""%1""'; 
				           |pl = 'Po słowie kluczowym ""%1"" nie znaleziono
				           |słowo kluczowe ""%2""';
				           |de = 'Nach dem Schlüsselwort ""%1"" wurde
				           |das Schlüsselwort ""%2"" nicht gefunden';
				           |ro = 'După cuvântul-cheie ""%1"" nu a fost găsit
				           |cuvântul-cheie ""%2""';
				           |tr = '""%1"" anahtar kelimesinden sonra "
" anahtar kelimesi %2 bulunamadı'; 
				           |es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado
				           |una palabra clave ""%2""'"),
				PartProperties.Presentation,
				KeywordRegardingLanguage("ThisList", InternalData)));
		Return;
	EndIf;
	
	ChangeKeywordTypeListToName(PartRows, PartRows[1]);
	
	If PartRows.Count() < 3
	 Or PartRows[2].Kind <> "Keyword"
	 Or PartRows[2].Clarification <> "As" Then
		SetPartBeginningError(
			?(PartRows.Count() < 3, PartProperties.SeparatorRow, PartRows[2]),
				InsertKeywordsIntoString(InternalData,
					NStr("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'; en = 'Keyword ""%2"" is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono słowo kluczowe ""%2""';de = 'Nach dem Schlüsselwort ""%1"" wurde das Schlüsselwort ""%2"" nicht gefunden';ro = 'După cuvântul-cheie ""%1"" nu a fost găsit cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi bulunamadı'; es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""'"),
					"List,As"));
		Return;
	EndIf;
	
	If PartRows.Count() < 4
	 Or PartRows[3].Kind <> "Name" Then
		SetPartBeginningError(
			?(PartRows.Count() < 4, PartProperties.SeparatorRow, PartRows[3]),
				InsertKeywordsIntoString(InternalData,
					NStr("ru = 'После ключевого слова ""%1"" не найден псевдоним'; en = 'Alias is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono alias';de = 'Kein Alias nach dem Schlüsselwort ""%1"" gefunden';ro = 'După cuvântul-cheie ""%1"" nu a fost găsit pseudonimul';tr = '""%1"" anahtar kelimesinden sonra takma ad bulunamadı'; es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado alias'"),
					"As"));
		Return;
	EndIf;
	
	SetAlias(PartRows[3], PartProperties.MainTableAlias, InternalData);
	
	// Dividing description into groups of left connections.
	Connections = New Array;
	CurrentConnection = New Array;
	
	For Index = 4 To PartRows.Count()-1 Do
		PartRow = PartRows[Index];
		
		If PartRow.Kind = "Keyword"
		   AND PartRow.Clarification = "Left" Then
			
			If CurrentConnection.Count() > 0 Then
				Connections.Add(CurrentConnection);
			EndIf;
			CurrentConnection = New Array;
			CurrentConnection.Add(PartRow);
			
			If Index + 1 < PartRows.Count()
			   AND PartRows[Index + 1].Kind = "Keyword"
			   AND PartRows[Index + 1].Clarification = "Join" Then
				
				Index = Index + 1;
				CurrentConnection.Add(PartRows[Index]);
			EndIf;
			
			Continue;
		EndIf;
		CurrentConnection.Add(PartRow);
	EndDo;
	
	If CurrentConnection.Count() > 0
	 Or Connections.Count() = 0 Then
		
		Connections.Add(CurrentConnection);
	EndIf;
	
	InternalData.Insert("AvailableAliases",
		New Map(New FixedMap(InternalData.Aliases)));
	
	For Each Connection In Connections Do
		// The condition is parsed universally (maximum), after that errors for the prohibited possibilities 
		// are identified.
		ParseConnection(Connection, PartProperties, InternalData);
	EndDo;
	
	// Continue parsing after filling in the aliases of all additional tables.
	For Each ConnectionDetails In PartProperties.Content Do
		InternalData.AvailableAliases.Insert(Upper(ConnectionDetails.Alias), True);
		// Only simple conditions are allowed:
		// Field1 = Field2 [And Field3 = Field4] [And Field5 = Constant].
		ParseConnectionConditionFieldsAndMarkProhibitions(ConnectionDetails, InternalData);
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables procedure.
Procedure ParseConnection(Connection, PartProperties, InternalData)
	
	ConnectionDetails = New Structure;
	ConnectionDetails.Insert("Table", "");
	ConnectionDetails.Insert("Alias", "");
	ConnectionDetails.Insert("ConnectionCondition", Undefined);
	
	If Connection[0].Kind <> "Keyword"
	 Or Connection[0].Clarification <> "Left" Then
		SetErrorInsidePart(Connection, 0, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'Не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found'; pl = 'Nie znaleziono słowo kluczowe ""%1""';de = 'Es wurde kein Schlüsselwort ""%1"" gefunden';ro = 'Nu a fost găsit cuvântul-cheie ""%1""';tr = '""%1"" anahtar kelimesi bulunamadı'; es_ES = 'No se ha encontrado la palabra clave ""%1""'"), "Left"));
		
		If Connection[0].Kind <> "Keyword"
		 Or Connection[0].Clarification <> "Inner"
		   AND Connection[0].Clarification <> "Full" Then
			
			Return;
		EndIf;
	EndIf;
	
	If Connection.Count() < 2
	 Or Connection[1].Kind <> "Keyword"
	 Or Connection[1].Clarification <> "Join" Then
		SetErrorInsidePart(Connection, 1,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено ключевое слово ""%2""'; en = 'Keyword ""%2"" is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono słowo kluczowe ""%2""';de = 'Nach dem Schlüsselwort ""%1"" wurde das Schlüsselwort ""%2"" nicht gefunden';ro = 'După cuvântul-cheie ""%1"" nu a fost găsit cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi bulunamadı'; es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado una palabra clave ""%2""'"),
				Connection[0].Chars,
				KeywordRegardingLanguage("Join", InternalData)));
		Return;
	EndIf;
	
	If Connection.Count() < 3
	 Or Connection[2].Kind <> "Name" Then
		SetErrorInsidePart(Connection, 2,
			StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" не найдено имя таблицы'; en = 'Table name is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono nazwy tabeli';de = 'Kein Tabellenname nach dem Schlüsselwort ""%1"" gefunden';ro = 'După cuvântul-cheie ""%1"" nu a fost găsit numele tabelului';tr = '""%1"" anahtar kelimesinden sonra tablo adı bulunamadı'; es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado nombre de tabla'"),
				Connection[1].Chars));
		Return;
	EndIf;
	
	SetTableName(Connection[2], ConnectionDetails, InternalData);
	
	If Connection.Count() < 4
	 Or Connection[3].Kind <> "Keyword"
	 Or Connection[3].Clarification <> "As" Then
		SetErrorInsidePart(Connection, 3, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После имени таблицы не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found after the table name'; pl = 'Po nazwie tabeli nie znaleziono słowo kluczowe ""%1""';de = 'Es wurde kein Schlüsselwort ""%1"" nach dem Tabellennamen gefunden';ro = 'După numele tabelului nu a fost găsit cuvântul-cheie ""%1""';tr = 'Tablo adından sonra ""%1"" anahtar kelimesi bulunamadı'; es_ES = 'Después del nombre de tabla no se ha encontrado palabra clave ""%1""'"), "As"));
		Return;
	EndIf;
	
	If Connection.Count() < 5
	 Or Connection[4].Kind <> "Name" Then
		SetErrorInsidePart(Connection, 4, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После ключевого слова ""%1"" не найден псевдоним таблицы'; en = 'Table alias is not found after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie znaleziono aliasu tabeli';de = 'Kein Tabellenalias nach dem Schlüsselwort ""%1"" gefunden';ro = 'După cuvântul-cheie ""%1"" nu a fost găsit pseudonimul tabelului';tr = '""%1"" anahtar kelimesinden sonra tablonun takma adı bulunamadı'; es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado alias de la tabla'"), "As"));
		Return;
	EndIf;
	
	SetAlias(Connection[4], ConnectionDetails, InternalData);
	
	If Connection.Count() < 6
	 Or Connection[5].Kind <> "Keyword"
	 Or Connection[5].Clarification <> "On" Then
		SetErrorInsidePart(Connection, 5, InsertKeywordsIntoString(InternalData,
			NStr("ru = 'После псевдонима таблицы не найдено ключевое слово ""%1""'; en = 'Keyword ""%1"" is not found after the table alias'; pl = 'Po aliasie tabeli nie znaleziono słowo kluczowe ""%1""';de = 'Es wurde kein Schlüsselwort ""%1"" nach dem Tabellenalias gefunden';ro = 'După pseudonimul tabelului nu a fost găsit cuvântul-cheie ""%1""';tr = 'Tablonun takma adından sonra ""%1"" anahtar kelimesi bulunamadı'; es_ES = 'Después de alias de tabla no se ha encontrado palabra clave ""%1""'"), "On"));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(Connection));
	For Index = 0 To 5 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, ConnectionDetails.ConnectionCondition, InternalData);
	
	PartProperties.Content.Add(ConnectionDetails);
	
EndProcedure

// For the ParseAdditionalTables procedure.
Procedure ParseConnectionConditionFieldsAndMarkProhibitions(ConnectionDetails, InternalData)
	
	// Marking incorrect operation arguments and prohibited features.
	CommonNodes = New Map(AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,AND,=", False));
	
	CommonNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", False, False, False));
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Common",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      CommonNodes);
	AvailableNodes.Insert("NodesThenElse", CommonNodes);
	
	FixedContext = New FixedStructure(InternalData);
	Context = New Structure(FixedContext);
	Context.Insert("IsConnectionCondition",  True);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          ConnectionDetails.ConnectionCondition);
	Context.Insert("Parents",              New Array);
	
	MarkIncorrectArgumentsAndProhibitedNodes(ConnectionDetails.ConnectionCondition,
		AvailableNodes, Context, New Structure("Node", ""));
	
	DeleteSourceProperty(ConnectionDetails.ConnectionCondition);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Function NodesToCheckAvailability(List, IsExceptionsList) Export
	
	AllNodes = New Map;
	AllNodes.Insert("Field", New Structure("Cast, Attachment, IsNull", True, True, True));
	AllNodes.Insert("Value",    True);
	AllNodes.Insert("Constant",   True);
	AllNodes.Insert("AND",           True);
	AllNodes.Insert("Or",         True);
	AllNodes.Insert("Not",          True);
	AllNodes.Insert("=",           True);
	AllNodes.Insert("<>",          True);
	AllNodes.Insert("IN",           True);
	AllNodes.Insert("IsNull",    True);
	AllNodes.Insert("Type",         True);
	AllNodes.Insert("ValueType", True);
	AllNodes.Insert("Case",       True);
	AllNodes.Insert("ValueAllowed",             True);
	AllNodes.Insert("IsAuthorizedUser", True);
	AllNodes.Insert("ObjectReadingAllowed",        True);
	AllNodes.Insert("ObjectUpdateAllowed",     True);
	AllNodes.Insert("ListReadingAllowed",         True);
	AllNodes.Insert("ListUpdateAllowed",      True);
	AllNodes.Insert("ForAllRows",                  True);
	AllNodes.Insert("ForAtLeastOneRow",               True);
	
	NodesArray = StrSplit(List, ",", False);
	Nodes = New Map;
	
	For Each Node In AllNodes Do
		If IsExceptionsList Then
			If NodesArray.Find(Node.Key) = Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		Else
			If NodesArray.Find(Node.Key) <> Undefined Then
				Nodes.Insert(Node.Key, Node.Value);
			EndIf;
		EndIf;
	EndDo;
	
	Return New FixedMap(Nodes);
	
EndFunction

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure MarkIncorrectArgumentsAndProhibitedNodes(Condition, AvailableNodes, Context, Parent)
	
	If Not ValueIsFilled(Condition) Then
		Return;
	EndIf;
	Context.Parents.Insert(0, Parent);
	
	If Context.IsConditionWhen Then
		CurrentAvailableNodes = AvailableNodes.NodesWhen;
		
	ElsIf Context.IsValueThenElse Then
		CurrentAvailableNodes = AvailableNodes.NodesThenElse;
	Else
		CurrentAvailableNodes = AvailableNodes.Common;
	EndIf;
	
	NodeAvailability = CurrentAvailableNodes.Get(Condition.Node);
	
	If NodeAvailability = Undefined Then
		SetNodeProhibitedError(Condition.Source, Context);
	EndIf;
	
	If Condition.Node = "Field" Then
		
		If Not Context.IsConnectionCondition Then
			If Parent = Undefined Then
				Parent = New Structure("Node", "");
			EndIf;
			AccessKeyField = New Structure;
			AccessKeyField.Insert("Field",     Condition);
			AccessKeyField.Insert("Parents", New FixedArray(Context.Parents));
			AccessKeyField.Insert("Read",   Context.Read);
			Context.AccessKeyFields.Add(AccessKeyField);
		EndIf;
		
		SelectFieldAlias(Condition, Context);
		
		If Not NodeAvailability.Cast
		   AND Condition.Cast <> Undefined Then
			
			SetNodeProhibitedError(Condition.Source, Context);
			
		ElsIf Not NodeAvailability.Attachment
		        AND Condition.Attachment <> Undefined Then
		
			SetNodeProhibitedError(Condition.Attachment.Source, Context);
			
		ElsIf Not NodeAvailability.IsNull
		        AND Condition.IsNull <> Undefined Then
		
			SetNodeProhibitedError(Condition.IsNullSource, Context);
		EndIf;
		
	ElsIf Upper( Condition.Node ) = Upper( "AND" ) // PATCHED:
	      Or Condition.Node = "Or" Then
		
		For Each Argument In Condition.Arguments Do
			MarkIncorrectArgumentsAndProhibitedNodes(Argument, AvailableNodes, Context, Condition);
		EndDo;
		
	ElsIf Condition.Node = "Not"
	      Or Condition.Node = "IsNull"
	      Or Condition.Node = "ForAllRows"
	      Or Condition.Node = "ForAtLeastOneRow" Then
		
		// Checking the parameter correctness.
		If Condition.Node = "IsNull"
		   AND (    Condition.Argument = Undefined
		      Or Condition.Argument.Node <> "Field" ) Then
			
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Операция ""%1"" допустима только после поля'; en = 'Operation ""%1"" is allowed only after the field'; pl = 'Operacja ""%1"" jest dopuszczalna tylko po polu';de = 'Die Operation ""%1"" ist nur nach dem Feld zulässig';ro = 'Operația ""%1"" se admite numai după câmpul';tr = '""%1"" işlemi yalnızca alandan sonra mümkündür'; es_ES = 'Operación ""%1"" no se admite después de este campo'"),
					Condition.Source.Chars));
		EndIf;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context, Condition);
		
	ElsIf Condition.Node = "="
	      Or Condition.Node = "<>" Then
		
		NodesCombinations = New Map;
		NodesCombinations.Insert("Value",  ",Field,");
		NodesCombinations.Insert("Constant", ",Field,Constant,");
		
		If Context.IsConnectionCondition Then
			NodesCombinations.Insert("Field",        ",Field,Value,Constant,");
		Else
			NodesCombinations.Insert("Field",        ",Value,Constant,");
			NodesCombinations.Insert("Type",         ",ValueType,");
			NodesCombinations.Insert("ValueType", ",Type,");
		EndIf;
		
		FirstArgumentCombinations = NodesCombinations.Get(Condition.FirstArgument.Node);
		SecondArgumentCombinations = NodesCombinations.Get(Condition.SecondArgument.Node);
		
		ErrorInFirstArgument  = FirstArgumentCombinations = Undefined;
		ErrorInSecondArgument = SecondArgumentCombinations = Undefined
			Or FirstArgumentCombinations <> Undefined
			  AND StrFind(FirstArgumentCombinations, "," + Condition.SecondArgument.Node + ",") = 0;
		
		If ErrorInFirstArgument Or ErrorInSecondArgument Then
			If Context.IsConnectionCondition Then
				ErrorText =
					NStr("ru = 'Операция ""%1"" допустима только для поля с полем, значением или константой'; en = 'Operation ""%1"" is allowed only after a field with a field, a value, or a constant'; pl = 'Operacja ""%1"" jest dopuszczalna tylko dla pola z polem wartość lub wartość stała';de = 'Die Operation ""%1"" ist nur für ein Feld mit einem Feld, einem Wert oder einer Konstanten zulässig';ro = 'Operația ""%1"" se admite numai pentru câmpul cu câmp, valoare sau constantă';tr = '""%1"" İşlemi yalnızca alan, değer veya sabit alan için geçerlidir'; es_ES = 'Operación ""%1"" se admite solo para el campo con el campo, valor o constante'");
			Else
				ErrorText =
					NStr("ru = 'Операция ""%1"" допустима только для поля со значением или константой,
					           |а также для типа значения с типом'; 
					           |en = 'Operation ""%1"" is allowed only after a field with a value or a constant,
					           |as well as a value type with a type'; 
					           |pl = 'Operacja ""%1"" jest dopuszczalna tylko dla pola z wartością lub wartością stałą,
					           |a także do typu wartości z typem';
					           |de = 'Die Operation ""%1"" ist nur für ein Feld mit einem Wert oder einer Konstanten
					           |sowie für eine Wertart mit einem Typ';
					           |ro = 'Operația ""%1"" se admite numai pentru câmpul cu valoare sau constantă,
					           |precum și pentru tipul de valoare cu tipul';
					           |tr = '""%1"" işlemi yalnızca bir değer veya sabit alan için ve
					           | bir türe sahip bir değer türü için geçerlidir'; 
					           |es_ES = 'Operación ""%1"" se admite solo para el campo con el valor o constante
					           |y también para el tipo de valor con el tipo'");
			EndIf;
			If ErrorInFirstArgument Then
				SetErrorInRow(Condition.FirstArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars),
					True);
			EndIf;
			If ErrorInSecondArgument Then
				SetErrorInRow(Condition.SecondArgument.Source,
					StringFunctionsClientServer.SubstituteParametersToString(
						ErrorText, Condition.Source.Chars));
			EndIf;
		EndIf;
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.FirstArgument, AvailableNodes, Context, Condition);
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SecondArgument, AvailableNodes, Context, Condition);
		
	ElsIf Upper( Condition.Node ) = Upper( "IN" ) Then // PATCHED
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.SearchFor, AvailableNodes, Context, Condition);
		For Each Value In Condition.Values Do
			MarkIncorrectArgumentsAndProhibitedNodes(Value, AvailableNodes, Context, Condition);
		EndDo;
		
	ElsIf Condition.Node = "ValueType"
	      Or Condition.Node = "Type" Then
		
		If Parent = Undefined
		 Or Parent.Node <> "="
		   AND Parent.Node <> "<>" Then
		
			SetErrorInRow(Condition.Source,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Функция ""%1"" допустима только в операциях ""="" и ""<>""'; en = 'Function ""%1"" is available only in operations ""="" and ""<>""'; pl = 'Funkcja ""%1"" jest dopuszczalna tylko w operacjach ""="" i ""<>""';de = 'Die Funktion ""%1"" ist nur in den Operationen ""="" und ""<>"" erlaubt';ro = 'Funcția ""%1"" se admite numai în operațiile ""="" și ""<>""';tr = '""%1"" işlevi yalnızca ""="" ve ""<>"" işlemlerde geçerlidir'; es_ES = 'Función ""%1"" se admite solo en las operaciones ""="" y ""<>""'"),
					Condition.Source.Chars));
		EndIf;
		
		If Condition.Node = "ValueType" Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Argument, AvailableNodes, Context, Condition);
		EndIf;
		
	ElsIf Condition.Node = "Case" Then
		If Condition.Case <> Undefined Then
			MarkIncorrectArgumentsAndProhibitedNodes(Condition.Case, AvailableNodes, Context, Condition);
		EndIf;
		FixedContext = New FixedStructure(Context);
		ContextWhen = New Structure(FixedContext);
		ContextWhen.IsConditionWhen = True;
		ContextThenElse = New Structure(FixedContext);
		ContextThenElse.IsValueThenElse = True;
		
		For Each When In Condition.When Do
			MarkIncorrectArgumentsAndProhibitedNodes(When.Condition,  AvailableNodes, ContextWhen,      Condition);
			MarkIncorrectArgumentsAndProhibitedNodes(When.Value, AvailableNodes, ContextThenElse, Condition);
		EndDo;
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Else, AvailableNodes, ContextThenElse, Condition);
		
	ElsIf Condition.Node = "ValueAllowed"
	      Or Condition.Node = "IsAuthorizedUser"
	      Or Condition.Node = "ObjectReadingAllowed"
	      Or Condition.Node = "ObjectUpdateAllowed"
	      Or Condition.Node = "ListReadingAllowed"
	      Or Condition.Node = "ListUpdateAllowed" Then
		
		MarkIncorrectArgumentsAndProhibitedNodes(Condition.Field, AvailableNodes, Context, Condition);
		MarkTypesRepetitionsAmongThoseToCheckAndClarify(Condition, Context);
		
		// Adding types that need to be checked for fields.
		Field = Condition.Field;
		Clarifications = New Map;
		For Each ComparisonClarification In Condition.ComparisonClarifications Do
			If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
				Clarifications.Insert(ComparisonClarification.Key, ComparisonClarification.Value);
				Continue;
			EndIf;
			Clarifications.Insert(ComparisonClarification.Key.Chars, ComparisonClarification.Value);
			AddRequiredTableField(Context, Field.Table, Field.Name, Field.NameSource,
				ComparisonClarification.Key.Chars, ComparisonClarification.Key);
		EndDo;
		
		// Deleting type sources.
		Condition.ComparisonClarifications = Clarifications;
		
		Types = New Array;
		For Each Type In Condition.Types Do
			Types.Add(Type.Chars);
		EndDo;
		Condition.Types = Types;
	EndIf;
	
	Context.Parents.Delete(0);
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SelectFieldAlias(FieldNode, Context)
	
	If FieldNode.Attachment <> Undefined Then
		Attachment = FieldNode.Attachment;
		SelectFieldAlias(Attachment, Context);
		If ValueIsFilled(Attachment.Cast) Then
			FieldNode.Table = Attachment.Cast;
		EndIf;
		
	ElsIf Not ValueIsFilled(FieldNode.Name) Then
		Return;
	Else
		NameContent = StrSplit(FieldNode.Name, ".");
		If NameContent.Count() > 1 Then
			Properties = Context.Aliases.Get(Upper(NameContent[0]));
			If Properties <> Undefined Then
				FieldNode.Alias = Properties.Alias;
				NameContent.Delete(0);
				FieldNode.Name = StrConcat(NameContent, ".");
				If ValueIsFilled(Properties.Table) Then
					FieldNode.Table = Properties.Table;
				EndIf;
			EndIf;
		EndIf;
		If Context.IsConnectionCondition Then
			If Not ValueIsFilled(FieldNode.Alias) Then
				SetErrorInRow(FieldNode.NameSource,
					NStr("ru = 'В условии соединения перед именем поля требуется псевдоним'; en = 'Alias is required before a field name in the join condition'; pl = 'W założeniu połączenia przed nazwą pola wymagany jest alias';de = 'Im Falle einer Verbindung ist ein Alias vor dem Feldnamen erforderlich';ro = 'În condiția de conexiune în fața numelui câmpului este necesar pseudonimul';tr = 'Bağlantı koşulunda alanın adından önce takma ad gerekir'; es_ES = 'En la condición de conexión antes del nombre del campo se requiere un alias'"));
			ElsIf Context.AvailableAliases.Get(Upper(FieldNode.Alias)) = Undefined Then
				SetErrorInRow(FieldNode.NameSource,
					NStr("ru = 'Нельзя указывать псевдоним из следующего соединения'; en = 'You cannot specify an alias from the next join'; pl = 'Zabronione jest podawanie aliasu z następnego połączenia';de = 'Sie können keinen Alias aus der folgenden Verbindung angeben';ro = 'Nu se permite indicarea pseudonimului din următoarea conexiune';tr = 'Aşağıdaki bağlantıdan bir takma ad belirtemezsiniz.'; es_ES = 'Está prohibido indicar apodo de la siguiente conexión'"));
			EndIf;
		EndIf;
	EndIf;
	
	If ValueIsFilled(FieldNode.Cast) Then
		AddRequiredTableAsReferenceType(Context, FieldNode.Cast, FieldNode.CastSource);
	EndIf;
	
	AddRequiredTableField(Context, FieldNode.Table, FieldNode.Name, FieldNode.NameSource,
		FieldNode.Cast, FieldNode.CastSource, FieldNode);
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure DeleteSourceProperty(Condition)
	
	If TypeOf(Condition) = Type("ValueTableRow") Then
		ErrorText = NStr("ru = 'Не все источники наборов символов удалены'; en = 'Not all sources of character sets are deleted'; pl = 'Nie wszystkie źródła zestawów znaków zostały usunięte';de = 'Nicht alle Zeichen-Set-Quellen wurden gelöscht';ro = 'Nu au fost șterse toate sursele seturilor de caractere';tr = 'Tüm karakter kümesi kaynakları kaldırılmadı'; es_ES = 'No todas las fuentes de conjuntos de símbolos se han eliminado'");
		Raise ErrorText;
		
	ElsIf TypeOf(Condition) <> Type("Structure") Then
		Return;
	EndIf;
	
	If Condition.Property("Source") Then
		Condition.Delete("Source");
	EndIf;
	
	If Condition.Property("NameSource") Then
		Condition.Delete("NameSource");
	EndIf;
	
	If Condition.Property("CastSource") Then
		Condition.Delete("CastSource");
	EndIf;
	
	If Condition.Property("IsNullSource") Then
		Condition.Delete("IsNullSource");
	EndIf;
	
	For Each KeyAndValue In Condition Do
		Value = KeyAndValue.Value;
		
		If TypeOf(Value) = Type("Array") Then
			For Each Item In Value Do
				DeleteSourceProperty(Item);
			EndDo;
			
		ElsIf TypeOf(Value) = Type("Map") Then
			For Each KeyAndValue In Value Do
				DeleteSourceProperty(KeyAndValue.Key);
				DeleteSourceProperty(KeyAndValue.Value);
			EndDo;
		Else
			DeleteSourceProperty(Value);
		EndIf;
	EndDo;
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure SetNodeProhibitedError(Row, Context)
	
	If Row.Type = "Function" Then
		If Context.IsConnectionCondition Then
			ErrorTemplate = NStr("ru = 'Функция ""%1"" запрещена в условии соединения'; en = 'The ""%1"" function is prohibited in the join condition'; pl = 'Funkcja ""%1"" zakazana w założeniu połączenia';de = 'Die Funktion ""%1"" ist im Verbindungszustand nicht erlaubt';ro = 'Funcția ""%1"" este interzisă în condiția de conexiune';tr = '""%1"" işlevi bağlantı koşulunda yasaklanmıştır'; es_ES = 'Función ""%1"" se ha prohibido en condición de conexión'");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Функция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'; en = 'The ""%3"" function is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" sentence'; pl = 'Funkcja ""%3"" jest zabroniona w warunku ograniczenia w operacji  ""%1""  w zdaniu ""%2"" ';de = 'Die Funktion ""%3"" ist unter der Bedingung von Einschränkungen in der Operation ""%1"" im Satz ""%2"" verboten';ro = 'Funcția ""%3"" este interzisă în condiția de restricționare în operația ""%1"" în propoziția ""%2""';tr = '""%3"" teklifte ""%1"" işlevi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı'; es_ES = 'Función ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""'"),
				"Case,When", Row.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Функция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'; en = 'The ""%4"" function is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" and ""%3"" sentences'; pl = 'Funkcja ""%4"" jest zabroniona w warunku ograniczenia w operacji  ""%1""  w ""%2""  zdaniu ""%3"" ';de = 'Die Funktion ""%4"" ist im Falle einer Einschränkung der Operation ""%1"" in den Angeboten ""%2"" und ""%3"" verboten';ro = 'Funcția ""%4"" este interzisă în condiția de restricționare în operația ""%1"" în propozițiile ""%2"" și ""%3""';tr = '""%3"" ve ""%4"" teklifte ""%1"" işlevi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı'; es_ES = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""'"),
				"Case,Then,Else");
		Else
			ErrorTemplate = NStr("ru = 'Функция ""%1"" запрещена в условии ограничения'; en = 'The ""%1"" function is prohibited in the restriction condition'; pl = 'Funkcja ""%1"" zakazana w warunku ograniczenia';de = 'Die Funktion ""%1"" ist in der Einschränkungsbedingung nicht zulässig';ro = 'Funcția ""%1"" este interzisă în condiția de restricționare';tr = '""%1"" işlevi bağlantı koşulunda yasaklanmıştır'; es_ES = 'Función ""%1"" se ha prohibido en condición de restricción'");
		EndIf;
	Else
		If Context.IsConnectionCondition Then
			ErrorTemplate = NStr("ru = 'Операция ""%1"" запрещена в условии соединения'; en = 'The ""%1"" operation is prohibited in the joint condition'; pl = 'Operacja ""%1"" zakazana w warunku ograniczenia';de = 'Die Operation ""%1"" ist in der Verbindungsbedingung nicht zulässig';ro = 'Operația ""%1"" este interzisă în condiția de conexiune';tr = '""%1"" işlemi bağlantı koşulunda yasaklanmıştır'; es_ES = 'Operación ""%1"" se ha prohibido en condición de conexión'");
			
		ElsIf Context.IsConditionWhen Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Операция ""%3"" запрещена в условии ограничения в операции ""%1"" в предложении ""%2""'; en = 'The ""%3"" operation is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" sentence'; pl = 'Operacja ""%3"" zakazana w warunku ograniczenia w operacji ""%1"" w ofercie ""%2""';de = 'Operation ""%3"" ist im Sinne der Einschränkungen in der Operation ""%1"" im Satz ""%2"" verboten';ro = 'Operația ""%3"" este interzisă în condiția de restricționare în operația ""%1"" în propoziția ""%2""';tr = '""%3"" teklifte ""%1"" işlemi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı'; es_ES = 'Operación ""%3"" se ha prohibido en condición de restricción en la operación ""%1"" en la frase ""%2""'"),
				"Case,When", Row.Chars);
			
		ElsIf Context.IsValueThenElse Then
			ErrorTemplate = InsertKeywordsIntoString(Context,
				NStr("ru = 'Операция ""%4"" запрещена в условии ограничения в операции ""%1"" в предложениях ""%2"" и ""%3""'; en = 'The ""%4"" operation is prohibited in the restriction condition in the ""%1"" operation in the ""%2"" and ""%3"" sentences'; pl = 'Operacja ""%4"" zakazana w warunku ograniczenia w operacji ""%1"" w zdaniach ""%2"" i ""%3""';de = 'Operation ""%4"" ist im Sinne der Einschränkungen in der Operation ""%1"" in den Sätzen ""%2"" und ""%3"" verboten';ro = 'Operația ""%4"" este interzisă în condiția de restricționare în operația ""%1"" în propozițiile ""%2"" și ""%3""';tr = '""%3"" ve ""%4"" teklifte ""%1"" işlemi ""%2"" işlemindeki kısıtlama koşulunda yasaklandı'; es_ES = 'Función ""%4"" se ha prohibido en condición de restricción en la operación ""%1"" en las frases ""%2"" y ""%3""'"),
				"Case,Then,Else");
		Else
			ErrorTemplate = NStr("ru = 'Операция ""%1"" запрещена в условии ограничения'; en = 'The ""%1"" operation is prohibited in the restriction condition'; pl = 'Operacja ""%1"" zakazana w warunku ograniczenia';de = 'Die Operation ""%1"" ist unter der Einschränkung verboten';ro = 'Operația ""%1"" este interzisă în condiția de restricționare';tr = '""%1"" işlemi kısıtlama koşulunda yasaklanmıştır'; es_ES = 'Operación ""%1"" se ha prohibido en condición de restricción'");
		EndIf;
	EndIf;
	
	SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
		ErrorTemplate, Row.Chars));
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes procedure.
Procedure MarkTypesRepetitionsAmongThoseToCheckAndClarify(Node, Context)
	
	TypesInList = New Map;
	
	For Each TypeInList In Node.Types Do
		If TypesInList.Get(Upper(TypeInList.Chars)) = Undefined Then
			TypesInList.Insert(Upper(TypeInList.Chars), True);
		Else
			SetErrorInRow(TypeInList, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Тип ""%1"" уже указан'; en = 'The ""%1"" type is already specified'; pl = 'Typ ""%1"" jest już określony';de = 'Typ ""%1"" ist bereits aufgeführt';ro = 'Tipul ""%1"" deja este indicat';tr = 'Tür ""%1"" daha önce belirtilmişti'; es_ES = 'Tipo ""%1"" se ha indicado ya'"), TypeInList.Chars));
		EndIf;
	EndDo;
	
	TypesToClarify = New Map;
	
	For Each ComparisonClarification In Node.ComparisonClarifications Do
		If TypeOf(ComparisonClarification.Key) <> Type("ValueTableRow") Then
			Continue;
		EndIf;
		TypeSource = ComparisonClarification.Key;
		
		If Not Node.CheckTypesExceptListed
		   AND TypesInList.Get(Upper(TypeSource.Chars)) <> Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("ru = 'Тип ""%2"" уже указан среди типов ключевого слова ""%1""'; en = 'The ""%2"" type is already specified among the ""%1"" keyword types'; pl = 'Typ ""%2"" jest już określony wśród typów słów kluczowych ""%1""';de = 'Type ""%2"" ist bereits unter den Schlüsselwort-Typen ""%1"" aufgeführt';ro = 'Tipul ""%2"" deja este indicat în rândul tipurilor cuvântului-cheie ""%1""';tr = 'Tür ""%2"" anahtar kelimesi ""%1"" türleri arasında zaten belirtilmiştir'; es_ES = 'Tipo ""%2"" se ha indicado ya en los tipos de la palabra clave ""%1""'"),
				"Only",
				TypeSource.Chars));
			
		ElsIf Node.CheckTypesExceptListed
		        AND TypesInList.Get(Upper(TypeSource.Chars)) = Undefined Then
			
			SetErrorInRow(TypeSource, InsertKeywordsIntoString(Context,
				NStr("ru = 'Тип ""%2"" не указан среди типов ключевого слова ""%1""'; en = 'The ""%2"" type is not specified among the ""%1"" keyword types'; pl = 'Typ ""%2"" nie jest określony wśród typów słów kluczowych ""%1""';de = 'Typ ""%2"" ist nicht unter den Schlüsselwort-Typen ""%1"" aufgeführt';ro = 'Tipul ""%2"" nu este indicat în rândul tipurilor cuvântului-cheie ""%1""';tr = 'Tür ""%2"" anahtar kelimesi ""%1"" türleri arasında belirtilmemiştir'; es_ES = 'Tipo ""%2"" no se ha indicado en los tipos de la palabra clave ""%1""'"),
				"Except",
				TypeSource.Chars));
			
		ElsIf TypesToClarify.Get(Upper(TypeSource.Chars)) <> Undefined Then
			SetErrorInRow(TypeSource, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Уточнение типа ""%1"" уже указано'; en = 'The ""%1"" type clarification is already specified'; pl = 'Doprecyzowanie typu ""%1"" jest już określone';de = 'Die Typ-Verfeinerung ""%1"" wurde bereits festgelegt';ro = 'Concretizarea tipului ""%1"" deja este indicată';tr = 'Tür ""%1"" netleştirilmesi zaten belirtilmiştir'; es_ES = 'Especificación del tipo ""%1"" se ha indicado ya'"), TypeSource.Chars));
		Else
			TypesToClarify.Insert(Upper(TypeSource.Chars), True);
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseRestrictionPart procedure.
Procedure ParseRestrictionCondition(PartProperties, InternalData)
	
	PartRows = PartProperties.Rows;
	ChangeKeywordTypeListToName(PartRows);
	
	If PartRows.Count() < 2
	 Or PartRows[1].Kind <> "Keyword"
	 Or PartRows[1].Clarification <> "Where" Then
		SetPartBeginningError(
			?(PartRows.Count() < 2, PartProperties.SeparatorRow, PartRows[1]),
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'После ключевого слова ""%1"" не найдено
					           |ключевое слово ""%2""'; 
					           |en = 'Keyword ""%2"" is not found
					           |after keyword ""%1""'; 
					           |pl = 'Po słowie kluczowym ""%1"" nie znaleziono
					           |słowo kluczowe ""%2""';
					           |de = 'Nach dem Schlüsselwort ""%1"" wurde
					           |das Schlüsselwort ""%2"" nicht gefunden';
					           |ro = 'După cuvântul-cheie ""%1"" nu a fost găsit
					           |cuvântul-cheie ""%2""';
					           |tr = '""%1"" anahtar kelimesinden sonra "
" anahtar kelimesi %2 bulunamadı'; 
					           |es_ES = 'Después de la palabra clave ""%1"" no se ha encontrado
					           |una palabra clave ""%2""'"),
					PartProperties.Presentation,
					KeywordRegardingLanguage("Where", InternalData)));
		Return;
	EndIf;
	
	Condition = New Array(New FixedArray(PartRows));
	For Index = 0 To 1 Do
		Condition.Delete(0);
	EndDo;
	
	ParseCondition(Condition, PartProperties.Content, InternalData);
	
	// Marking incorrect parameters of operations and unsupported functionality.
	CommonNodes = AccessManagementInternalCached.NodesToCheckAvailability("", True);
	
	NodesWhen = AccessManagementInternalCached.NodesToCheckAvailability(
		"Field,Value,Constant,AND,Or,Not,=,<>,IN,IsNull,Type,ValueType", False);
	
	NodesThenElse = AccessManagementInternalCached.NodesToCheckAvailability(
		"Case,ForAllRows,ForAtLeastOneRow", True);
	
	AvailableNodes = New Structure;
	AvailableNodes.Insert("Common",          CommonNodes);
	AvailableNodes.Insert("NodesWhen",      NodesWhen);
	AvailableNodes.Insert("NodesThenElse", NodesThenElse);
	
	FixedContext = New FixedStructure(InternalData);
	Context = New Structure(FixedContext);
	Context.Insert("IsConnectionCondition",  False);
	Context.Insert("IsConditionWhen",       False);
	Context.Insert("IsValueThenElse", False);
	Context.Insert("RootNode",          PartProperties.Content);
	Context.Insert("Parents",              New Array);
	Context.Insert("Read",
		    PartProperties.Name = "AllowReadUpdate"
		Or PartProperties.Name = "AllowRead");
	
	AddDefaultAliases(Context);
	
	MarkIncorrectArgumentsAndProhibitedNodes(PartProperties.Content,
		AvailableNodes, Context, New Structure("Node", ""));
	
	DeleteSourceProperty(PartProperties.Content);
	
EndProcedure

// For the RestrictionParts and ParseRestrictionCondition procedures.
Procedure AddDefaultAliases(Context);
	
	If Context.Aliases.Count() > 0 Then
		Return;
	EndIf;
	
	Context.Aliases.Insert(Upper("ThisList"), New Structure("Alias, Table", "ThisList"));
	Context.Aliases.Insert(Upper("ThisList"),   New Structure("Alias, Table", "ThisList"));
	
EndProcedure

// For the ParseConnectionCondition and ParseRestrictionCondition procedures.
Procedure ParseCondition(Condition, Composition, InternalData)
	
	ExpressionsInParenthesesInAttachments = ExpressionsInParenthesesInAttachments(Condition);
	
	FunctionsWithExpressionsInParentheses = FunctionsWithExpressionsInParentheses(
		ExpressionsInParenthesesInAttachments, InternalData);
	
	ExpressionsSelectionWhenThenInAttachments = ExpressionsSelectionWhenThenInAttachments(
		FunctionsWithExpressionsInParentheses, InternalData);
	
	Condition = ExpressionsSelectionWhenThenInAttachments;
	
	ParseExpression(Condition, Composition, InternalData, False);
	
	UnionNestedLogicalOperations(Composition);
	
EndProcedure

// For the ParseCondition procedure.
Procedure UnionNestedLogicalOperations(Composition)
	
	If Composition = Undefined Then
		Return;
	EndIf;
	
	If Upper( Composition.Node ) = Upper( "AND" ) // PATCHED:
	 Or Composition.Node = "Or" Then
		
		Index = Composition.Arguments.Count() - 1;
		While Index >= 0 Do
			
			Argument = Composition.Arguments[Index];
			UnionNestedLogicalOperations(Argument);
			
			If Argument.Node = Composition.Node Then
				Composition.Arguments.Delete(Index);
				NestedIndex = Argument.Arguments.Count() - 1;
				While NestedIndex >= 0 Do
					Composition.Arguments.Insert(Index, Argument.Arguments[NestedIndex]);
					NestedIndex = NestedIndex - 1;
				EndDo;
			EndIf;
			Index = Index - 1;
		EndDo;
	EndIf;
	
EndProcedure


// For the ParseCondition, ParseFunction, and ParseChoice procedures.
Procedure ParseExpression(Condition, Composition, CurrentContext, NestedExpression = True)
	
	FixedContext = New FixedStructure(CurrentContext);
	Context = New Structure(FixedContext);
	Context.Insert("Attachments", New Array);
	Context.Insert("Details");
	Context.Insert("String");
	
	For Each Row In Condition Do
		Context.String = Row;
		
		If Row.Kind = "Name"
		 Or Row.Kind = "Number"
		 Or Row.Kind = "ArbitraryLine"
		 Or Row.Kind = "Keyword" 
		   AND (    Row.Clarification = "True"
		      Or Row.Clarification = "False"
		      Or Row.Clarification = "Undefined" ) Then
			
			NewDetails = FieldNodeOrConstantNodeDetails(Row);
			AddArgumentFunctionChoiceOperator(Context, NewDetails);
			
		ElsIf Row.Kind = "Keyword" Then
			
			If Row.Type = "Function"
			 Or Upper( Row.Clarification ) = Upper( "IN" ) Then // PATCHED:
				
				If Row.Type = "Function" Then
					ParseFunction(Context);
				Else
					ParseConnectorIn(Context);
				EndIf;
				
			ElsIf Row.Type = "Connector" Then
				ParseConnector(Context);
			
			ElsIf Row.Type = "Operator" Then
				ParseOperator(Context);
				
			ElsIf Row.Type = "SelectionWord" Then
				ParseChoice(Context);
			Else
				ParseErrorKeyword(Context);
			EndIf;
			
		ElsIf Row.Kind = "Operation" Then
			ParseConnector(Context, True);
			
		ElsIf Row.Kind = "Separator" Then
			If Row.Chars = "(" Then
				NewDetails = Undefined;
				ParseExpression(Row.Rows, NewDetails, Context);
				AddArgumentFunctionChoiceOperator(Context, NewDetails);
				If NewDetails <> Undefined Then
					NewDetails.Source.Priority = 99;
				EndIf;
			Else
				Context.Details = Undefined;
				SetErrorInRow(Row,
					NStr("ru = 'Запятая может использоваться только для разделения параметров функций'; en = 'Comma can be used only to separate function parameters'; pl = 'Przecinek może być używany tylko do oddzielania parametrów funkcji';de = 'Das Komma kann nur zur Trennung von Funktionsparametern verwendet werden';ro = 'Virgula poate fi utilizată numai pentru separarea parametrilor funcției';tr = 'Virgül sadece işlev parametreleri ayırmak için kullanılabilir'; es_ES = 'La coma puede ser usada solo para separar los parámetros de la función'"));
			EndIf;
		Else
			Context.Details = Undefined;
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert';ro = 'Procesarea cuvântului cheie ""%1"" nu este determinată';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi'; es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado'"), Row.Chars));
		EndIf;
		
		If Context.Details = Undefined Then
			// An error that stops further parsing (preventing from false starts) occurred.
			Break;
		EndIf;
	EndDo;
	
	If Context.Details = Undefined Then
		If NestedExpression Then
			Composition = New Structure("Source, Node, Value", Row, "Constant", False);
		Else
			Composition = Undefined;
		EndIf;
		
	ElsIf Context.Attachments.Count() = 0 Then
		Composition = Context.Details;
	Else
		Composition = Context.Attachments[Context.Attachments.Count() - 1];
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters, ParseChoice procedures and the 
// FieldNodeDetailsFromIsNullFunction function.
//
Function FieldNodeOrConstantNodeDetails(Row)
	
	// <Field name>, <Number>, <Arbitrary string>, True, False, Undefined.
	
	If Row.Kind = "Name" Then
		NewDetails = FieldNodeDetails(Row);
		NewDetails.Name         = Row.Chars;
		NewDetails.NameSource = Row;
	Else
		NodeProperties = "Source, Node, Value";
		NewDetails = New Structure(NodeProperties, Row, "Constant");
		
		If Row.Kind = "Keyword" Then
			If Row.Clarification = "True" Then
				NewDetails.Value = True;
				
			ElsIf Row.Clarification = "False" Then
				NewDetails.Value = False;
				
			Else // String.Kind = "Undefined".
				NewDetails.Value = Undefined;
			EndIf;
		Else // "Number" or "ArbitraryString".
			NewDetails.Value = Row.Clarification;
		EndIf;
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the FieldNodeOrConstantNodeDetails, FieldNodeDetailsFromExpressFunction, and FieldNodeDetailsFromIsNullFunction functions.
Function FieldNodeDetails(Row)
	
	NodeProperties = "Source, Node, Name, Table, Alias, Cast, Attachment, IsNull";
	NewDetails = New Structure(NodeProperties, Row, "Field");
	
	NewDetails.Insert("NameSource",      Undefined);
	NewDetails.Insert("CastSource", Undefined);
	NewDetails.Insert("IsNullSource", Undefined);
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression procedure.
Procedure ParseConnector(Context, IsOperation = False)
	
	// And, Or, As, Except, Only, Is, and any operation =, <>, ...
	// The In keyword is parsed separately in the ParseOperationIn procedure.
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row,
		?(Row.Kind = "Operation", Row.Chars, Row.Clarification));
	
	If Upper( Row.Clarification ) = Upper( "AND" ) // PATCHED:
	 Or Row.Clarification = "Or" Then
		
		NewDetails.Insert("Arguments", New Array);
		NewDetails.Arguments.Add(Undefined);
		AddConnector(Context, NewDetails, NewDetails.Arguments[0]);
	
	ElsIf Row.Clarification = "Is" Then
		NewDetails.Node = "IsNull";
		NewDetails.Insert("Argument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.Argument);
		// Checking the parameter accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
		// 
		
	ElsIf Row.Kind = "Operation" Then
		NewDetails.Insert("FirstArgument", Undefined);
		NewDetails.Insert("SecondArgument", Undefined);
		AddConnector(Context, NewDetails, NewDetails.FirstArgument);
		// Checking the argument accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
		// 
		
	ElsIf Row.Clarification = "As"
	      Or Row.Clarification = "Except"
	      Or Row.Clarification = "Only" Then
		
		Context.Details = Undefined;
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Ключевое слово ""%1"" может использоваться только в параметрах функций'; en = 'The ""%1"" keyword can be used only in function parameters'; pl = 'Słowo kluczowe ""%1"" może być używane tylko w parametrach funkcji';de = 'Das Schlüsselwort ""%1"" kann nur in Funktionsparametern verwendet werden';ro = 'Cuvântul-cheie ""%1"" poate fi utilizat numai în parametrii funcției';tr = '""%1"" anahtar kelimesi sadece işlevlerin parametrelerinde kullanılabilir'; es_ES = 'La palabra clave ""%1"" puede ser usada solo en los parámetros de las funciones'"), Row.Chars));
	Else
		Context.Details = Undefined;
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert';ro = 'Procesarea cuvântului cheie ""%1"" nu este determinată';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi'; es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseConnectorIn(Context)
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row, Row.Clarification);
	NewDetails.Insert("SearchFor",  Undefined);
	NewDetails.Insert("Values", New Array);
	
	ParametersContent = CommaSeparatedParameters(Row);
	// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	
	For Each ParameterDetails In ParametersContent Do
		For Each Substring In ParameterDetails.Rows Do
			
			ParseConnectorValueIn(Context, Substring, NewDetails);
			
			If ParameterDetails.Rows[0] <> Substring Then
				SetErrorInRow(Substring, NStr("ru = 'Перед параметром не указана запятая'; en = 'Comma is not specified before the parameter'; pl = 'Brak przecinka określonego przed parametrem';de = 'Es wird kein Komma vor dem Parameter angegeben';ro = 'În fața parametrului nu este indicată virgula';tr = 'Parametreden önce virgül belirtilmedi'; es_ES = 'Antes del parámetro no se ha indicado una coma'"));
			EndIf;
			
		EndDo;
	EndDo;
	
	AddConnector(Context, NewDetails, NewDetails.SearchFor);
	
	If NewDetails.SearchFor.Node <> "Field" Then
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Операцию ""%1"" можно указывать только после имени поля'; en = 'The ""%1"" operation can be specified only after a field name'; pl = 'Operacja ""%1"" może być określona tylko po nazwie pola';de = 'Operation ""%1"" kann nur nach dem Feldnamen angegeben werden';ro = 'Operația ""%1"" poate fi indicată numai după numele câmpului';tr = '""%1"" İşlemi yalnızca alan adından sonra belirtilebilir'; es_ES = 'Operación ""%1"" se puede indicarla solo después del campo del nombre'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorIn procedure.
Procedure ParseConnectorValueIn(Context, Substring, NewDetails)
	
	Row = Context.String;
	
	If Substring.Kind = "Number"
	 Or Substring.Kind = "ArbitraryLine" Then
		
		ConstantDetails = New Structure("Source, Node", Substring, "Constant");
		ConstantDetails.Insert("Value", Substring.Clarification);
		NewDetails.Values.Add(ConstantDetails);
		
	ElsIf Substring.Kind = "Keyword" Then
		
		If Substring.Clarification = "Value" Then
			NewContext = NewContext(Context, Substring, Undefined);
			ParseFunction(NewContext);
			If NewContext.Details <> Undefined Then
				NewDetails.Values.Add(NewContext.Details);
			EndIf;
		Else
			SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'В списке значений операции ""%1"" ключевое слово ""%2"" недопустимо'; en = 'The ""%2"" keyword is invalid in the ""%1"" operation value list'; pl = 'Na liście wartości operacji ""%1"" słowo kluczowe ""%2"" jest nieprawidłowe';de = 'In der Werteliste der Operation ""%1"" ist das Schlüsselwort ""%2"" nicht erlaubt';ro = 'În lista valorilor operației ""%1"" este inadmisibil cuvântul-cheie ""%2""';tr = '""%1"" işlem değerleri listesinde ""%2"" anahtar kelimesine izin verilmez'; es_ES = 'En la lista de valores de la operación ""%1"" la palabra clave ""%2"" no se admite'"),
				Row.Chars, Substring.Chars));
		EndIf;
		
	ElsIf Substring.Kind = "Name" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" имя поля недопустимо'; en = 'Field name is invalid in the ""%1"" operation value list'; pl = 'Nazwa pola jest nieprawidłowa na liście wartości operacji ""%1""';de = 'In der Werteliste der Operation ""%1"" ist der Feldname ungültig';ro = 'În lista valorilor operației ""%1"" este inadmisibil numele câmpului';tr = '""%1"" işlem değerleri listesinde alan adı kullanılmaz'; es_ES = 'En la lista de valores de la operación ""%1"" el nombre del campo no se admite'"), Row.Chars));
		
	ElsIf Substring.Chars = "(" Then
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" скобки допустимы только для параметров функции'; en = 'Parentheses are valid only for function parameters in the ""%1"" operation value list'; pl = 'Na liście wartości operacji ""%1"" nawiasy są prawidłowe tylko dla parametrów funkcji';de = 'In der Werteliste der Operation ""%1"" sind Klammern nur für Funktionsparameter gültig';ro = 'În lista valorilor operației ""%1"" parantezele se admit numai pentru parametrii funcției';tr = 'Parantez ""%1"" işlem değerleri listesinde yalnızca işlev parametreleri için geçerlidir'; es_ES = 'En la lista de valores de la operación ""%1"" las paréntesis se admiten solo para los parámetros de la función'"), Row.Chars));
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В списке значений операции ""%1"" можно указывать только значения'; en = 'Only values can be specified in the ""%1"" operation value list'; pl = 'Można określić tylko wartości na liście wartości operacji ""%1""';de = 'In der Werteliste der Operation ""%1"" können Sie nur Werte angeben';ro = 'În lista valorilor operației ""%1"" puteți indica doar valorile';tr = '""%1"" İşlem değerleri listesinde yalnızca değerleri belirtebilirsiniz'; es_ES = 'En la lista de valores de la operación ""%1"" se puede indicar solo valores'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseConnectorValueIn procedure.
Function NewContext(Context, Row = null, Details = null)
	
	FixedContext = New FixedStructure(Context);
	NewContext = New Structure(FixedContext);
	
	If Row <> null Then
		NewContext.String = Row;
	EndIf;
	
	If Details <> null Then
		NewContext.Details = Details;
	EndIf;
	
	Return NewContext;
	
EndFunction

// For the ParseConnector, ParseConnectorIn, and InsertConnectorConsideringPriority procedures.
Procedure AddConnector(Context, NewDetails, FirstArgument);
	
	// A connector to add: And, Or, In, Is, and any operation (=, <>, ...).
	
	Details = Context.Details;
	
	If Details = Undefined Then
		Context.Details = NewDetails;
		
	ElsIf Upper( Details.Node ) = Upper( "AND" ) // PATCHED:
	      Or Details.Node = "Or" Then
		
		If Details.Arguments.Count() = 1 Then
			Details.Arguments.Add(Undefined);
			ProcessMissingArgumentAfterConnector(Context, Details.Arguments[1]);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.Arguments[1], NewDetails, FirstArgument);
		
	ElsIf Details.Node = "Not" Then
		If Not ValueIsFilled(Details.Argument) Then
			ProcessMissingArgumentAfterConnector(Context, Details.Argument);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.Argument, NewDetails, FirstArgument);
		
	ElsIf Details.Source.Kind = "Operation" Then
		If Not ValueIsFilled(Details.SecondArgument) Then
			ProcessMissingArgumentAfterConnector(Context, Details.SecondArgument, False);
		EndIf;
		InsertConnectorConsideringPriority(Context,
			Details.SecondArgument, NewDetails, FirstArgument);
		
	ElsIf StrFind(",Field,Value,Constant,IN,IsNull,Case,", "," + Details.Node + ",") > 0
	      Or Details.Source.Type = "Function" Then
		// The second argument of the In operation is already parsed in the ParseOperationIn procedure.
		// The second Null argument of the Has operation is already parsed in the FunctionsWithExpressionsInParentheses function.
		// The remaining nodes do not have the second argument.
		InsertConnectorConsideringPriority(Context, Undefined, NewDetails, FirstArgument);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert';ro = 'Nu a fost determinată procesarea nodului ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir'; es_ES = 'El procesamiento del nodo no se ha realizado ""%1""'"), Details.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddConnector procedure.
Procedure ProcessMissingArgumentAfterConnector(Context, SecondArgument, LogicalOperation = True)
	
	SetErrorInRow(Context.Details.Source,
		?(LogicalOperation,
			NStr("ru = 'Не указан аргумент после логической операции'; en = 'Argument after logical operation is not specified'; pl = 'Argument nie jest określony po operacji logicznej';de = 'Nach der logischen Operation ist kein Argument angegeben';ro = 'Argumentul nu este indicat după operația logică';tr = 'Mantıksal işlemden sonra bağımsız değişken belirtilmedi'; es_ES = 'No se ha indicado el argumento después de la operación lógica'"),
			NStr("ru = 'Не указан аргумент после операции'; en = 'Argument after operation is not specified'; pl = 'Argument nie określono po operacji';de = 'Kein Argument angegeben nach der Operation';ro = 'Argumentul nu este indicat după operație';tr = 'İşlemden sonra bağımsız değişken belirtilmedi'; es_ES = 'No se ha indicado argumento después de la operación'")),
		True);
	
	SecondArgument = New Structure("Source, Node, Value", Context.String, "Constant", True);
	
EndProcedure

// For the AddConnector and ProcessMissingLogicalOperation procedures.
Procedure InsertConnectorConsideringPriority(Context,
			DetailsLastArgument, NewDetails, NewDetailsFirstArgument)
	
	Attachments = Context.Attachments;
	
	If DetailsLastArgument <> Undefined
	   AND Context.String.Priority >= Context.Details.Source.Priority Then
		
		// Replacing the current node argument with the connector (case "A Or B And ...").
		NewDetailsFirstArgument = DetailsLastArgument;
		DetailsLastArgument = NewDetails;
		
		Attachments.Insert(0, Context.Details);
		Context.Details = NewDetails;
		Return;
	EndIf;
	
	If Attachments.Count() = 0 Then
		// Nesting the current node as the first connector argument (case "A And B Or ...").
		NewDetailsFirstArgument = Context.Details;
		Context.Details = NewDetails;
		Return;
	EndIf;
	
	// Nesting the previous node as the first connector argument (case "A And Not B Or ...").
	Context.Details = Attachments[0];
	Attachments.Delete(0);
	
	AddConnector(Context, NewDetails, NewDetailsFirstArgument);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseOperator(Context)
	
	// The Not operator.
	
	NewDetails = New Structure("Source, Node, Argument",
		Context.String, Context.String.Clarification);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
	Context.Attachments.Insert(0, Context.Details);
	Context.Details = NewDetails;
	
EndProcedure

// For the ParseExpression and ParseConnectorValueIn procedures.
Procedure ParseFunction(Context)
	
	Row = Context.String;
	
	NewDetails = New Structure("Source, Node", Row, Row.Clarification);
	
	If Row.Clarification = "ValueAllowed"
	 Or Row.Clarification = "ObjectReadingAllowed"
	 Or Row.Clarification = "ObjectUpdateAllowed"
	 Or Row.Clarification = "ListReadingAllowed"
	 Or Row.Clarification = "ListUpdateAllowed"
	 Or Row.Clarification = "IsAuthorizedUser" Then
		
		ParseCheckingFunctionParameters(Context, NewDetails);
		
	ElsIf Row.Clarification = "ForAllRows"
	      Or Row.Clarification = "ForAtLeastOneRow" Then
		
		ExpressionDetails = Undefined;
		ParseExpression(Row.Rows, ExpressionDetails, Context);
		NewDetails.Insert("Argument", ExpressionDetails);
	
	ElsIf Row.Clarification = "Value" Then
		ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, True, Context);
		
	ElsIf Row.Clarification = "Type" Then
		ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, False, Context);
		
	ElsIf Row.Clarification = "ValueType" Then
		ParseValueTypeFunctionParameters(Context, NewDetails);
		
	ElsIf Row.Clarification = "IsNull" Then
		NewDetails = FieldNodeDetailsFromIsNullFunction(Context.String, Context);
		
	ElsIf Row.Clarification = "Cast" Then
		NewDetails =  FieldNodeDetailsFromExpressFunction(Context.String, Context);
		
	ElsIf Not Row.IsReserve Then
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка функции ""%1""'; en = '""%1"" function data processor is not determined'; pl = 'Brak specyficznych funkcji przetwarzania ""%1""';de = 'Die Bearbeitung der Funktion ""%1"" ist nicht definiert';ro = 'Nu a fost determinată procesarea funcției ""%1""';tr = '""%1"" işlevin işlemesi belirlenmemiştir'; es_ES = 'No se ha determinado el procesamiento de la función ""%1""'"), Row.Clarification);
		Raise ErrorText;
	EndIf;
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseCheckingFunctionParameters(Context, NewDetails)
	
	Row = Context.String;
	
	NewDetails.Insert("Field",                        Undefined);
	NewDetails.Insert("Types",                        New Array);
	NewDetails.Insert("CheckTypesExceptListed", False);
	NewDetails.Insert("ComparisonClarifications",          New Map);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	ParseFirstCheckingFunctionParameter(Context, ParametersContent[0], NewDetails);
	
	For Index = 1 To ParametersContent.Count() - 1 Do
		ParseAdditionalCheckingFunctionParameter(Context,
			ParametersContent[Index], NewDetails);
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
Procedure ParseFirstCheckingFunctionParameter(Context, FirstParameter, NewDetails)
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Field = FieldNodeOrConstantNodeDetails(FirstParameter.Rows[0]);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Field = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails.Field = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'First parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Pierwszym parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';de = 'Der erste Parameter kann Feldname, Funktion ""%1"" oder Funktion ""%2"" sein';ro = 'Primul parametru poate fi numele câmpului, funcția ""%1"" sau funcția ""%2""';tr = 'İlk parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir '; es_ES = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""'"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If FirstParameter.Rows[0].Kind = "Keyword"
	   AND FirstParameter.Rows[0].Clarification = "Cast"
	   AND NewDetails.Field.Attachment = Undefined Then
		
		SetErrorInRow(FirstParameter.Rows[0].EndString,
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После вложенной функции ""%3"" должно быть указано имя поля через точку,
				           |если в параметре функции ""%4"" используется ключевое слово ""%1"" или ""%2""'; 
				           |en = 'Period-separated field name must be specified after the ""%3"" nested function
				           |if keyword ""%1"" or ""%2"" is used in the ""%4"" function parameter'; 
				           |pl = 'Po włożonej funkcji ""%3"" powinny być wskazane nazwa pola przez punkt,
				           |jeśli w parametrze funkcji ""%4"" używane jest słowo kluczowe ""%1"" lub ""%2""';
				           |de = 'Nach der verschachtelten Funktion ""%3"" muss der Feldname über einen Punkt angegeben werden,
				           |wenn das Schlüsselwort ""%1"" oder ""%2"" im Funktionsparameter ""%4"" verwendet wird';
				           |ro = 'După funcția incorporată ""%3"" trebuie să fie indicat numele câmpului prin punct,
				           |dacă în parametrul funcției ""%4"" se utilizează cuvântul-cheie ""%1"" sau ""%2""';
				           |tr = 'İç içe geçmiş ""%3""işlevinden sonra, 
				           |""%4"" işlev parametresinde ""%1"" veya ""%2"" anahtar kelime kullanıyorsa, alan adı nokta ile belirtilmelidir'; 
				           |es_ES = 'Después de la función adjunta ""%3"" debe estar indicado un nombre de campo con puntos,
				           |si en el parámetro de la función ""%4"" se usa la palabra clave ""%1"" o ""%2""'"),
				"Only,Except",
				FirstParameter.Rows[0].Chars,
				Context.String.Chars),
			True);
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or (  FirstParameter.Rows[1].Clarification <> "Only"
	      AND FirstParameter.Rows[1].Clarification <> "Except" ) Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля может быть указано, либо ключевое слово ""%1"", либо ""%2""'; en = 'Keyword ""%1"" or ""%2"" can be specified after field description'; pl = 'Po opisie pola może być wskazane, albo słowo kluczowe ""%1"", albo ""%2""';de = 'Nachdem die Beschreibung des Feldes kann entweder das Schlüsselwort ""%1"" oder ""%2"" angegeben werden';ro = 'După descrierea câmpului poate fi indicat sau cuvântul-cheie ""%1"", sau ""%2""';tr = 'Alan açıklamasından sonra ya ""%1"", ya da ""%2"" anahtar kelimesi belirtilebilir'; es_ES = 'Después de la descripción del campo puede estar indicada una palabra clave ""%1"" o ""%2""'"),
				"Only,Except"));
		Return;
	EndIf;
	
	If FirstParameter.Rows[1].Clarification = "Except" Then
		NewDetails.CheckTypesExceptListed = True;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'; en = 'Type (table name) is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie jest określony typ (nazwa tabeli)';de = 'Nach dem Schlüsselwort ""%1"" wird kein Typ (Tabellenname) angegeben';ro = 'După cuvântul-cheie ""%1"" nu este indicat tipul (numele tabelului)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)'"), FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name"
	   AND FirstParameter.Rows[2].Chars <> "(" Then
	
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" должен быть указан, либо тип (имя таблицы), либо список типов в скобках'; en = 'Either a type (a table name) or a type list in parentheses must be specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" musi być podany rodzaj (nazwa tabeli), albo lista typów w nawiasach';de = 'Nach dem Schlüsselwort ""%1"" sollte entweder der Typ (Tabellenname) oder die Liste der Typen in Klammern angegeben werden';ro = 'După cuvântul-cheie ""%1"" trebuie să fie indicat sau tipul (numele tabelului), sau lista tipurilor în paranteze';tr = '""%1"" anahtar kelimeden sonra tür (tablo adı) veya parantez içinde türler listesi belirtilmelidir'; es_ES = 'Después de la palabra clave ""%1"" debe estar indicado tipo (nombre de tabla) o lista de tipos en paréntesis'"),
			FirstParameter.Rows[1].Chars));
		Return;
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Перед параметром функции ""%1"" не указана запятая'; en = 'Comma is not specified before the ""%1"" function parameter'; pl = 'Przed parametrem funkcji ""%1"" nie podano przecinek';de = 'Vor dem Funktionsparameter ""%1"" wird kein Komma angegeben';ro = 'În fața parametrului funcției ""%1"" nu este indicată virgula';tr = '""%1"" işlevin parametresinden önce virgül belirtilmemiştir'; es_ES = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma'"), Context.String.Chars));
	EndIf;
	
	If FirstParameter.Rows[2].Kind = "Name" Then
		NewDetails.Types.Add(FirstParameter.Rows[2]);
		AddRequiredTableAsReferenceType(Context, FirstParameter.Rows[2].Chars, FirstParameter.Rows[2]);
		Return;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(FirstParameter.Rows[2]);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	For Each Parameter In ParametersContent Do
		
		If Parameter.Rows[0].Kind = "Name"
		   AND Parameter.Rows.Count() < 2 Then
			
			NewDetails.Types.Add(Parameter.Rows[0]);
		Else
			SetErrorInRow(Parameter.Rows[?(Parameter.Rows.Count() < 2, 0, 1)],
				NStr("ru = 'В списке типов могут быть указаны только имена таблицы через запятую'; en = 'Only table names separated by commas can be specified in the type list'; pl = 'W liście typów mogą być podane tylko nazwy tabeli oddzielone przecinkami';de = 'In der Liste der Typen können nur die durch Komma getrennten Tabellennamen angegeben werden';ro = 'În lista tipurilor pot fi indicate numai numele tabelelor prin virgulă';tr = 'Türler listesinde yalnızca virgül ile tablo adları belirtilebilir'; es_ES = 'En la lista de tipos pueden estar indicados solo nombres de tabla con comas'"));
		EndIf;
	EndDo;
	
EndProcedure

// For the ParseCheckingFunctionParameters procedure.
Procedure ParseAdditionalCheckingFunctionParameter(Context, Parameter, NewDetails)
	
	If Parameter.Rows[0].Kind = "Name"
	 Or Parameter.Rows[0].Kind = "Keyword"
	   AND (    Parameter.Rows[0].Type = "ComparisonValue"
	      Or Parameter.Rows[0].Type = "TypeName" ) Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			ComparisonValue = Parameter.Rows[0];
			AddRequiredTableAsReferenceType(Context, Parameter.Rows[0].Chars, Parameter.Rows[0]);
		Else
			ComparisonValue = Parameter.Rows[0].Clarification;
		EndIf;
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Дополнительным параметром может быть тип (имя таблицы),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" и ""%7""'; 
				           |en = 'Additional parameter can be a type (a table name),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"", and ""%7""'; 
				           |pl = 'Opcją dodatkową może być rodzaj (nazwa tabeli),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" i ""%7""';
				           |de = 'Ein zusätzlicher Parameter kann vom Typ (Tabellenname),
				           |""%1"",""%2"", ""%3"", ""%4"", ""%5"", ""%6"" und ""%7"" sein';
				           |ro = 'Parametru suplimentar poate fi tipul (numele tabelului),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" și ""%7""';
				           |tr = 'Tür (tablo adı) ek parametre olabilir, 
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" ve ""%7""'; 
				           |es_ES = 'Como el parámetro adicional puede ser tipo (nombre de tabla),
				           |""%1"", ""%2"", ""%3"", ""%4"", ""%5"", ""%6"" y ""%7""'"),
				"EmptyRef,Undefined,Null,Number,String,Date,Boolean"));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		If Parameter.Rows[0].Kind = "Name" Then 
			Template = NStr("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after type (table name) ""%2""'; pl = 'Po rodzaju (nazwy tabeli) ""%2"" powinno być słowo kluczowe ""%1""';de = 'Nach dem Typ (Tabellenname) ""%2"" muss das Schlüsselwort ""%1"" angegeben werden';ro = 'După tip (numele tabelului) ""%2"" trebuie să fie indicat cuvântul-cheie ""%1""';tr = 'Türden (tablo adından) sonra ""%2"" ""%1"" anahtar kelime belirtilmelidir'; es_ES = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""'");
		Else
			Template = NStr("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" powinno być słowo kluczowe ""%1""';de = 'Dem Schlüsselwort ""%2"" sollte das Schlüsselwort ""%1"" folgen';ro = 'După cuvântul-cheie ""%2"" nu este indicat cuvântul-cheie ""%1""';tr = '""%2"" anahtar kelimeden sonra ""%1"" anahtar kelimesi belirtilmelidir'; es_ES = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""'");
		EndIf;
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
				Template, "As", Parameter.Rows[0].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[1].Kind <> "Keyword"
	 Or Parameter.Rows[1].Clarification <> "As" Then
		
		If Parameter.Rows[0].Kind = "Name" Then
			Template = NStr("ru = 'После типа (имени таблицы) ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after type (table name) ""%2""'; pl = 'Po rodzaju (nazwy tabeli) ""%2"" powinno być słowo kluczowe ""%1""';de = 'Nach dem Typ (Tabellenname) ""%2"" muss das Schlüsselwort ""%1"" angegeben werden';ro = 'După tip (numele tabelului) ""%2"" trebuie să fie indicat cuvântul-cheie ""%1""';tr = 'Türden (tablo adından) sonra ""%2"" ""%1"" anahtar kelime belirtilmelidir'; es_ES = 'Después del tipo (nombre de tabla) ""%2"" debe estar indicada la palabra clave ""%1""'");
		Else
			Template = NStr("ru = 'После ключевого слова ""%2"" должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" powinno być słowo kluczowe ""%1""';de = 'Dem Schlüsselwort ""%2"" sollte das Schlüsselwort ""%1"" folgen';ro = 'După cuvântul-cheie ""%2"" nu este indicat cuvântul-cheie ""%1""';tr = '""%2"" anahtar kelimeden sonra ""%1"" anahtar kelimesi belirtilmelidir'; es_ES = 'Después de la palabra clave ""%2"" debe estar indicada la palabra clave ""%1""'");
		EndIf;
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
			Template, "As", Parameter.Rows[0].Chars));
		Return;
	EndIf;
	
	If Parameter.Rows.Count() < 3 Then
		SetErrorInRow(Parameter.Rows[1], InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%4"" не указано значение уточнения ""%1"", ""%2"" или ""%3""'; en = 'Clarification value ""%1"", ""%2"", or ""%3"" is not specified after the ""%4"" keyword'; pl = 'Po słowie kluczowym ""%4"" nie określono wartości objaśnienia ""%1"", ""%2"" lub ""%3""';de = 'Nach dem Schlüsselwort ""%4"" gibt nicht den Wert der Klarstellung ""%1"", ""%2"" oder ""%3"" an';ro = 'După cuvântul-cheie ""%4"" nu este indicată valoarea concretizării ""%1"", ""%2"" sau ""%3""';tr = '""%4"" anahtar kelimeden sonra ""%1"", ""%2"" veya ""%3"" netleştirme değeri belirtilmemiştir'; es_ES = 'Después de la palabra clave ""%4"" no está indicado el valor de la especificación ""%1"", ""%2"" o ""%3""'"),
				"False,True,Empty",
				Parameter.Rows[1].Chars),
			True);
		Return;
	EndIf;
	
	If Parameter.Rows[2].Kind <> "Keyword"
	 Or Parameter.Rows[2].Type <> "ClarificationValue" Then
		
		SetErrorInRow(Parameter.Rows[2], InsertKeywordsIntoString(Context,
			NStr("ru = 'После ключевого слова ""%4"" должно быть указано значение уточнения ""%1"", ""%2"" или ""%3""'; en = 'Clarification value ""%1"", ""%2"", or ""%3"" must be specified after the ""%4"" keyword'; pl = 'Po słowie kluczowym ""%4"" musi być określona wartość objaśnienia ""%1"", ""%2"" lub ""%3""';de = 'Auf das Schlüsselwort ""%4"" sollte der Wert der Klarstellung ""%1"", ""%2"" oder ""%3"" folgen';ro = 'După cuvântul-cheie ""%4"" trebuie să fie indicată valoarea concretizării ""%1"", ""%2"" sau ""%3""';tr = '""%4"" anahtar kelimeden sonra ""%1"", ""%2"" veya ""%3"" netleştirme değeri belirtilmelidir'; es_ES = 'Después de la palabra clave ""%4"" debe estar indicado el valor de especificación ""%1"", ""%2"" o ""%3""'"),
			"False,True,Empty",
			Parameter.Rows[1].Chars));
	Else
		NewDetails.ComparisonClarifications.Insert(ComparisonValue, Parameter.Rows[2].Clarification);
	EndIf;
	
	If Parameter.Rows.Count() > 3 Then
		SetErrorInRow(Parameter.Rows[3],
			NStr("ru = 'Перед параметром не указана запятая или лишний параметр'; en = 'Comma or extra parameter is not specified before the parameter'; pl = 'Przed opcją nie podano przecinek lub dodatkowy parametr';de = 'Es wird kein Komma oder zusätzlicher Parameter vor dem Parameter angegeben';ro = 'În fața parametrului nu este indicată virgula sau parametrul în plus';tr = 'Parametreden önce virgül veya fazla parametre belirtilmemiştir'; es_ES = 'Antes del parámetro no está indicada coma o parámetro de sobra'"));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueFunctionOrTypeFunctionParameters(Row, NewDetails, IsValueFunction, Context)
	
	NewDetails.Insert("Name", Undefined);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Name = Parameter.Rows[0].Chars;
		
		If IsValueFunction Then
			AddRequiredPredefinedItem(Context, NewDetails.Name, Parameter.Rows[0]);
		Else
			AddRequiredTableAsReferenceType(Context, NewDetails.Name, Parameter.Rows[0]);
		EndIf;
		
	ElsIf IsValueFunction Then
		SetErrorInRow(Parameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В функции ""%1"" можно указать только имя предопределенного значения'; en = 'In the ""%1"" function, only a predefined value name can be specified'; pl = 'W funkcji ""%1"" można wpisać tylko nazwę zadanej wartości';de = 'In der Funktion ""%1"" kann nur der Name des vordefinierten Wertes angegeben werden';ro = 'În funcția ""%1"" puteți indica numai numele valorii predefinite';tr = '""%1"" işlevinde yalnızca önceden tanımlanmış değerin adı belirtilebilir'; es_ES = 'En la función ""%1"" se puede indicar solo un nombre del valor predeterminado'"), Row.Chars));
	
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Type = "TypeName" Then
		
		NewDetails.Name = Parameter.Rows[0].Clarification;
	Else
		SetErrorInRow(Parameter.Rows[0], InsertKeywordsIntoString(Context,
			NStr("ru = 'В функции ""%5"" можно указать имя таблицы или ""%1"", ""%2"", ""%3"" и ""%4""'; en = 'In the ""%5"" function, a table name or ""%1"", ""%2"", ""%3"" and ""%4"" can be specified'; pl = 'W funkcji ""%5"" można określić nazwę tabeli lub ""%1"", ""%2"", ""%3"" i ""%4""';de = 'In der Funktion ""%5"" können Sie einen Tabellennamen angeben oder ""%1"", ""%2"", ""%3"" und ""%4""';ro = 'În funcția ""%5"" puteți indica numele tabelului sau ""%1"", ""%2"", ""%3"" și ""%4""';tr = '""%5"" işlevinde tablo adı veya ""%1"", ""%2"", ""%3"" ve ""%4"" belirtilebilir'; es_ES = 'En la función ""%5"" se puede indicar el nombre de tabla o ""%1"", ""%2"", ""%3"", y ""%4""'"),
			"Number,String,Date,Boolean",
			Row.Chars));
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction procedure.
Procedure ParseValueTypeFunctionParameters(Context, NewDetails)
	
	Row = Context.String;
	NewDetails.Insert("Argument", Undefined);
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		Return; // The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
	EndIf;
	
	Parameter = ParametersContent[0];
	
	If Parameter.Rows[0].Kind = "Name" Then
		NewDetails.Argument = FieldNodeOrConstantNodeDetails(Parameter.Rows[0]);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Argument = FieldNodeDetailsFromExpressFunction(Parameter.Rows[0], Context);
		
	ElsIf Parameter.Rows[0].Kind = "Keyword"
	        AND Parameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails.Argument = FieldNodeDetailsFromIsNullFunction(Parameter.Rows[0], Context);
	Else
		SetErrorInRow(Parameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'Parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';de = 'Parameter können Feldname, Funktion ""%1"" oder Funktion ""%2"" sein';ro = 'Parametru poate fi numele câmpului, funcția ""%1"" sau funcția ""%2""';tr = 'Parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir '; es_ES = 'Como el parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""'"),
				"Cast,IsNull"));
		Return;
	EndIf;
	
	If Parameter.Rows[0].Kind = "Keyword"
	   AND Parameter.Rows[0].Clarification = "Cast"
	   AND NewDetails.Argument.Attachment = Undefined Then
		
		SetErrorInRow(Parameter.Rows[0].EndString,
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'; en = 'Period-separated field name must be specified after the ""%1"" nested function'; pl = 'Po włożonej funkcji ""%1"" powinna być wskazana nazwa pola przez kropkę';de = 'Nach der verschachtelten Funktion ""%1"" muss der Feldname über einen Punkt angegeben werden';ro = 'După funcția incorporată ""%1"" trebuie să fie indicat numele câmpului prin punct';tr = 'İç içe geçmiş ""%1"" işlevinden sonra, alan adı nokta ile belirtilmelidir'; es_ES = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos'"),
				Parameter.Rows[0].Chars),
			True);
	EndIf;
	
	If Parameter.Rows.Count() < 2 Then
		Return;
	EndIf;
	
	If Parameter.Rows.Count() > 1 Then
		SetErrorInRow(Parameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(ParametersContent[1].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseFunction, ParseFirstCheckingFunctionParameter, and ParseValueTypeFunctionParameters procedures.
Function FieldNodeDetailsFromExpressFunction(Row, Context)
	
	NewDetails = FieldNodeDetails(Row);
	
	If Row.Rows.Count() > 0 Then
		LastRow = Row.Rows[Row.Rows.Count() - 1];
		If LastRow.Type = "AdditionToExpress" Then
			Row.Rows.Delete(Row.Rows.Count() - 1);
			NewDetails.Name         = Mid(LastRow.Chars, 2);
			NewDetails.NameSource = LastRow;
			NewDetails.Attachment    = FieldNodeDetailsFromExpressFunction(Row, Context);
			Return NewDetails;
		EndIf;
	EndIf;
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "Cast" Then
		
		NewDetails.Attachment = FieldNodeDetailsFromExpressFunction(FirstParameter.Rows[0], Context);
		If NewDetails.Attachment.Attachment = Undefined Then
			SetErrorInRow(FirstParameter.Rows[0].EndString,
				StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'После вложенной функции ""%1"" должно быть указано имя поля через точку'; en = 'Period-separated field name must be specified after the ""%1"" nested function'; pl = 'Po włożonej funkcji ""%1"" powinna być wskazana nazwa pola przez kropkę';de = 'Nach der verschachtelten Funktion ""%1"" muss der Feldname über einen Punkt angegeben werden';ro = 'După funcția incorporată ""%1"" trebuie să fie indicat numele câmpului prin punct';tr = 'İç içe geçmiş ""%1"" işlevinden sonra, alan adı nokta ile belirtilmelidir'; es_ES = 'Después de la función adjunta ""%1"" debe estar indicado un nombre de campo con puntos'"),
					FirstParameter.Rows[0].Chars),
				True);
		Else
			NewDetails = NewDetails.Attachment;
		EndIf;
		
	ElsIf FirstParameter.Rows[0].Kind = "Keyword"
	        AND FirstParameter.Rows[0].Clarification = "IsNull" Then
		
		NewDetails = FieldNodeDetailsFromIsNullFunction(FirstParameter.Rows[0], Context);
	Else
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'Первым параметром может быть имя поля, функция ""%1"" или функция ""%2""'; en = 'First parameter can be a field name, function ""%1"", or function ""%2""'; pl = 'Pierwszym parametrem może być nazwa pola, funkcja ""%1"" lub funkcja ""%2""';de = 'Der erste Parameter kann Feldname, Funktion ""%1"" oder Funktion ""%2"" sein';ro = 'Primul parametru poate fi numele câmpului, funcția ""%1"" sau funcția ""%2""';tr = 'İlk parametre alan adı, ""%1"" işlevi veya ""%2"" işlevi olabilir '; es_ES = 'Como el primer parámetro puede ser nombre de campo, la función ""%1"" o la función ""%2""'"),
				"Cast,IsNull"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 2 Then
		SetErrorInRow(FirstParameter.Rows[0],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after field description'; pl = 'Po opisie pola powinno być podane słowo kluczowe ""%1""';de = 'Nach der Beschreibung des Feldes muss das Schlüsselwort ""%1"" angegeben werden';ro = 'După descrierea câmpului trebuie să fie indicat cuvântul-cheie ""%1""';tr = 'Alan açıklamasından sonra ""%1"" anahtar kelimesi belirtilmelidir'; es_ES = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""'"), "As"), True);
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[1].Kind <> "Keyword"
	 Or FirstParameter.Rows[1].Clarification <> "As" Then
		
		SetErrorInRow(FirstParameter.Rows[1],
			InsertKeywordsIntoString(Context,
				NStr("ru = 'После описания поля должно быть указано ключевое слово ""%1""'; en = 'The ""%1"" keyword must be specified after field description'; pl = 'Po opisie pola powinno być podane słowo kluczowe ""%1""';de = 'Nach der Beschreibung des Feldes muss das Schlüsselwort ""%1"" angegeben werden';ro = 'După descrierea câmpului trebuie să fie indicat cuvântul-cheie ""%1""';tr = 'Alan açıklamasından sonra ""%1"" anahtar kelimesi belirtilmelidir'; es_ES = 'Después de la descripción del campo debe estar indicada una palabra clave ""%1""'"), "As"));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows.Count() < 3 Then
		SetErrorInRow(FirstParameter.Rows[1],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" не указан тип (имя таблицы)'; en = 'Type (table name) is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie jest określony typ (nazwa tabeli)';de = 'Nach dem Schlüsselwort ""%1"" wird kein Typ (Tabellenname) angegeben';ro = 'După cuvântul-cheie ""%1"" nu este indicat tipul (numele tabelului)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado tipo (nombre de tabla)'"), FirstParameter.Rows[1].Chars));
		Return NewDetails;
	EndIf;
	
	If FirstParameter.Rows[2].Kind <> "Name" Then
		SetErrorInRow(FirstParameter.Rows[2],  StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'После ключевого слова ""%1"" должен быть указан тип (имя таблицы)'; en = 'Type (table name) must be specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" musi być określony rodzaj (nazwa tabeli)';de = 'Nach dem Schlüsselwort ""%1"" muss der Typ (Tabellenname) angegeben werden';ro = 'După cuvântul-cheie ""%1"" trebuie să fie indicat tipul (numele tabelului)';tr = '""%1"" anahtar kelimesinden sonra tür (tablo adı) belirtilmelidir'; es_ES = 'Después de la palabra clave ""%1"" debe estar indicado el tipo (nombre de tabla)'"),
			FirstParameter.Rows[1].Chars));
	Else
		NewDetails.Cast = FirstParameter.Rows[2].Chars;
		NewDetails.CastSource = FirstParameter.Rows[2];
	EndIf;
	
	If FirstParameter.Rows.Count() > 3 Then
		SetErrorInRow(FirstParameter.Rows[3], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 1 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только один параметр'; en = 'The ""%1"" function can have only one parameter'; pl = 'Funkcja ""%1"" może być tylko jeden parametr';de = 'Die Funktion ""%1"" kann nur einen Parameter haben';ro = 'Funcția ""%1"" poate avea un singur parametru';tr = '""%1"" işlevi yalnızca bir parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo un parámetro'"), Row.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseExpression, ParseFirstCheckingFunctionParameter,
// ParseValueTypeFunctionParameters procedures and the FieldNodeDetailsFromExpressFunction function.
// 
//
Function FieldNodeDetailsFromIsNullFunction(Row, Context)
	
	NewDetails = FieldNodeDetails(Row);
	NewDetails.IsNullSource = Row;
	
	ParametersContent = CommaSeparatedParameters(Row);
	
	If ParametersContent.Count() = 0 Then
		// The parameter missing error is already set in the FunctionsWithExpressionsInParentheses function.
		Return NewDetails;
	EndIf;
	
	FirstParameter = ParametersContent[0];
	
	If FirstParameter.Rows[0].Kind = "Name" Then
		NewDetails.Name         = FirstParameter.Rows[0].Chars;
		NewDetails.NameSource = FirstParameter.Rows[0];
	Else
		SetErrorInRow(FirstParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Первым параметром функции ""%1"" может быть только имя поля'; en = 'First parameter of the ""%1"" function can be only a field name'; pl = 'Pierwszym parametrem funkcji ""%1"" może być tylko nazwa pola';de = 'Der erste Parameter der Funktion ""%1"" kann nur der Feldname sein';ro = 'Primul parametru al funcției ""%1"" poate fi numai numele câmpului';tr = '""%1"" işlevin ilk parametresi yalnızca alan adı olabilir'; es_ES = 'Como el primer parámetro de la función ""%1"" puede ser solo nombre de campo'"), Row.Chars));
	EndIf;
	
	If FirstParameter.Rows.Count() > 1 Then
		SetErrorInRow(FirstParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Перед параметром функции ""%1"" не указана запятая'; en = 'Comma is not specified before the ""%1"" function parameter'; pl = 'Przed parametrem funkcji ""%1"" nie podano przecinek';de = 'Vor dem Funktionsparameter ""%1"" wird kein Komma angegeben';ro = 'În fața parametrului funcției ""%1"" nu este indicată virgula';tr = '""%1"" işlevin parametresinden önce virgül belirtilmemiştir'; es_ES = 'Antes del parámetro de la función ""%1"" no se ha indicado una coma'"), Row.Chars));
		Return NewDetails;
	EndIf;
	
	If ParametersContent.Count() < 2 Then
		SetErrorInRow(FirstParameter.EndString, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" должно быть два параметра'; en = 'The ""%1"" function must have two parameters'; pl = 'Funkcja ""%1"" powinna mieć dwa parametry';de = 'Die Funktion ""%1"" muss zwei Parameter haben';ro = 'Funcția ""%1"" trebuie să aibă doi parametri';tr = '""%1"" işlevin iki parametresi olmalıdır'; es_ES = 'La función ""%1"" debe tener dos parámetros'"), Row.Chars));
		Return NewDetails;
	EndIf;
	
	SecondParameter = ParametersContent[1];
	
	If SecondParameter.Rows[0].Kind = "Number"
	 Or SecondParameter.Rows[0].Kind = "ArbitraryLine"
	 Or SecondParameter.Rows[0].Kind = "Keyword"
	   AND (    SecondParameter.Rows[0].Clarification = "True"
	      Or SecondParameter.Rows[0].Clarification = "False"
	      Or SecondParameter.Rows[0].Clarification = "Undefined"
	      Or SecondParameter.Rows[0].Clarification = "Value" ) Then
		
		If SecondParameter.Rows[0].Clarification = "Value" Then
			NewDetails.IsNull = New Structure("Source, Node",
				SecondParameter.Rows[0], SecondParameter.Rows[0].Clarification);
			
			ParseValueFunctionOrTypeFunctionParameters(SecondParameter.Rows[0], NewDetails.IsNull, True, Context);
		Else
			NewDetails.IsNull = FieldNodeOrConstantNodeDetails(SecondParameter.Rows[0]);
		EndIf;
	Else
		SetErrorInRow(SecondParameter.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" второй параметр может быть, либо предопределенным значением, либо константой'; en = 'The second parameter of the ""%1"" function can be either a predefined value or a constant'; pl = 'Funkcja ""%1"" drugi parametr może być, albo z predefiniowanych wartości, albo wartością stałą';de = 'Der zweite Parameter der Funktion ""%1"" kann entweder ein vordefinierter Wert oder eine Konstante sein';ro = 'Parametrul doi al funcției ""%1"" poate fi sau valoare predefinită, sau constantă';tr = '""%1"" işlevinde, ikinci parametre önceden tanımlanmış bir değer veya sabit olabilir'; es_ES = 'El segundo parámetro de la función ""%1"" puede ser valor predeterminado o constante'"),
			Row.Chars));
	EndIf;
	
	If SecondParameter.Rows.Count() > 1 Then
		SetErrorInRow(SecondParameter.Rows[1], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" может быть только два параметра'; en = 'The ""%1"" function can have only two parameters'; pl = 'Funkcja ""%1"" może mieć tylko dwa parametry';de = 'Die Funktion ""%1"" kann nur zwei Parameter haben';ro = 'Funcția ""%1"" poate avea doar doi parametri';tr = '""%1"" işlevi yalnızca iki parametreye sahip olabilir'; es_ES = 'La función ""%1"" puede tener solo dos parámetros'"), Row.Chars));
	EndIf;
	
	If ParametersContent.Count() > 2 Then
		SetErrorInRow(ParametersContent[2].Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'У функции ""%1"" должно быть только два параметра'; en = 'The ""%1"" function must have only two parameters'; pl = 'Funkcja ""%1"" powinna mieć tylko dwa parametry';de = 'Die Funktion ""%1"" sollte nur zwei Parameter haben';ro = 'Funcția ""%1"" poate avea doar doi parametri';tr = '""%1"" işlevin iki parametresi olmalıdır'; es_ES = 'La función ""%1"" debe tener solo dos parámetros'"), Row.Chars));
	EndIf;
	
	Return NewDetails;
	
EndFunction

// For the ParseConnectorIn, ParseCheckingFunctionParameters,
// ParseValueFunctionOrTypeFunctionParameters, and ParseValueTypeFunctionParameters procedures and 
// the FieldNodeDetailsFromExpressFunction and FieldNodeDetailsFromIsNullFunction functions.
//
Function CommaSeparatedParameters(Row)
	
	ParametersContent = New Array;
	
	If Row.Rows.Count() = 0 Then
		Return ParametersContent;
	EndIf;
	
	ParameterDetails = New Structure("Rows, EndString", New Array);
	PreviousSubstringIsArgumentPart = False;
	
	For Each Substring In Row.Rows Do
		
		If Substring.Chars = "," Then
			If Not PreviousSubstringIsArgumentPart Then
				If Row.Rows[0] = Substring Then
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Перед запятой не указан параметр'; en = 'Parameter is not specified before comma'; pl = 'Przed przecinkiem nie podano parametru';de = 'Es wird kein Parameter vor dem Punkt angegeben';ro = 'Înainte de virgulă nu este indicat parametrul';tr = 'Virgülden önce parametre belirtilmedi'; es_ES = 'Antes de la coma no está indicado parámetro'"), Substring.Chars));
					ParameterDetails.Rows.Add(AdditionalString(Substring, ""));
				Else
					SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Пропущен параметр или лишняя запятая'; en = 'Parameter or extra comma was skipped'; pl = 'Pominięty parametr lub zbędny przecinek';de = 'Parameter oder zusätzliches Komma fehlt';ro = 'Este omis parametrul sau există virgula în plus';tr = 'Eksik parametre veya fazla virgül'; es_ES = 'Parámetro saltado o coma de sobra'"), Substring.Chars));
				EndIf;
			EndIf;
			If ParameterDetails.Rows.Count() > 0 Then
				ParametersContent.Add(ParameterDetails);
				ParameterDetails.EndString = Substring;
			EndIf;
			ParameterDetails = New Structure("Rows, EndString", New Array);
			PreviousSubstringIsArgumentPart = False;
			Continue;
		EndIf;
		
		PreviousSubstringIsArgumentPart = True;
		
		ParameterDetails.Rows.Add(Substring);
	EndDo;
	
	If ParameterDetails.Rows.Count() > 0 Then
		ParametersContent.Add(ParameterDetails);
		ParameterDetails.EndString = Row.EndString;
	Else
		SetErrorInRow(Substring, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Лишняя запятая или после запятой не указан параметр'; en = 'Extra comma or parameter is not specified after comma'; pl = 'Zbędny przecinek lub po przecinku nie podano parametru';de = 'Überschüssiges Komma oder nach dem Punkt wird der Parameter nicht angegeben';ro = 'Virgula în plus sau după virgulă nu este indicat parametrul';tr = 'Fazla virgül veya virgülden sonra belirtilmemiş parametre'; es_ES = 'Coma de sobra o después de la coma no está indicado el parámetro'"), Substring.Chars), True);
	EndIf;
	
	Return ParametersContent;
	
EndFunction

// For the ParseExpression procedure.
Procedure ParseChoice(Context)
	
	Row = Context.String;
	
	NodeProperties = "Source, Node, Case, When, Else";
	NewDetails = New Structure(NodeProperties, Row, "Case");
	NewDetails.When = New Array;
	
	SkipWhenAnalysis = False;
	
	Choice = Row.Rows[0];
	If Choice.Rows.Count() > 0 Then
		If Choice.Rows[0].Kind = "Name" Then
			NewDetails.Case = FieldNodeOrConstantNodeDetails(Choice.Rows[0]);
		Else
			SkipWhenAnalysis = True;
			SetErrorInRow(Choice.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Когда аргумент ключевого слова ""%1"" указан, то это может быть только имя поля'; en = 'When the ""%1"" keyword argument is specified, it can only be a field name'; pl = 'Gdy argument słowa kluczowego ""%1"" jest określony, to może to być tylko nazwa pola';de = 'Wenn das Argument des Schlüsselwortes ""%1"" angegeben wird, kann es nur der Feldname sein';ro = 'Dacă este indicat argumentul cuvântului-cheie ""%1"", atunci acesta poate fi doar numele câmpului';tr = 'Anahtar kelime argümanı ""%1"" belirtildiğinde, yalnızca alan adı olabilir'; es_ES = 'Cuando el argumento de la palabra clave ""%1"" está indicado, esto puede ser solo el nombre de campo'"),
				Row.Chars));
		EndIf;
	EndIf;
	
	Index = 1;
	While Row.Rows[Index].Clarification = "When" Do
		WhenThenDetails = New Structure("Condition, Value");
		NewDetails.When.Add(WhenThenDetails);
		
		When = Row.Rows[Index];
		
		If Not SkipWhenAnalysis Then
			If NewDetails.Case = Undefined Then
				ParseExpression(When.Rows, WhenThenDetails.Condition, Context);
				
			ElsIf When.Rows.Count() = 0 Then
				If ValueIsFilled(When.Chars) Then
					SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
						           |должно быть указано, либо предопределенное значение, либо константа'; 
						           |en = 'As the field is specified after the ""%1"" keyword, 
						           |either a predefined value or a constant must be specified after the ""%2"" keyword'; 
						           |pl = 'Ponieważ po słowie kluczowym ""%1"" zaznaczono pole, to po słowie kluczowym ""%2""
						           |powinny być wskazane, albo zdefiniowanego wartość lub wartość stała';
						           |de = 'Da das Feld nach dem Schlüsselwort ""%1"" angegeben wird, sollte entweder ein vordefinierter Wert oder eine Konstante nach dem Schlüsselwort ""%2""
						           |angegeben werden';
						           |ro = 'Deoarece după cuvântul-cheie ""%1"" este indicat câmpul, atunci după cuvântul-cheie ""%2""
						           |trebuie să fie indicată sau valoarea predefinită, sau constanta';
						           |tr = '""%1""Anahtar kelimesinden sonra alan belirtildiğinden, ""%2""anahtar kelimesinden sonra önceden
						           | tanımlanmış bir değer veya sabit belirtilmelidir'; 
						           |es_ES = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
						           |debe estar indicado un valor predeterminado o constante'"),
						Row.Chars,
						When.Chars));
				EndIf;
				
			ElsIf When.Rows[0].Kind = "Number"
			      Or When.Rows[0].Kind = "ArbitraryLine"
			      Or When.Rows[0].Kind = "Keyword"
			        AND (    When.Rows[0].Clarification = "True"
			           Or When.Rows[0].Clarification = "False"
			           Or When.Rows[0].Clarification = "Undefined"
			           Or When.Rows[0].Clarification = "Value" ) Then
				
				If When.Rows[0].Clarification = "Value" Then
					WhenThenDetails.Condition = New Structure("Source, Node",
						When.Rows[0], When.Rows[0].Clarification);
					
					ParseValueFunctionOrTypeFunctionParameters(When.Rows[0], WhenThenDetails.Condition, True, Context);
				Else
					WhenThenDetails.Condition = FieldNodeOrConstantNodeDetails(When.Rows[0]);
				EndIf;
			ElsIf ValueIsFilled(When.Chars) Then
				SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Так как после ключевого слова ""%1"" указано поле, то после ключевого слова ""%2""
					           |должно быть указано, либо предопределенное значение, либо константа'; 
					           |en = 'As the field is specified after the ""%1"" keyword, 
					           |either a predefined value or a constant must be specified after the ""%2"" keyword'; 
					           |pl = 'Ponieważ po słowie kluczowym ""%1"" zaznaczono pole, to po słowie kluczowym ""%2""
					           |powinny być wskazane, albo zdefiniowanego wartość lub wartość stała';
					           |de = 'Da das Feld nach dem Schlüsselwort ""%1"" angegeben wird, sollte entweder ein vordefinierter Wert oder eine Konstante nach dem Schlüsselwort ""%2""
					           |angegeben werden';
					           |ro = 'Deoarece după cuvântul-cheie ""%1"" este indicat câmpul, atunci după cuvântul-cheie ""%2""
					           |trebuie să fie indicată sau valoarea predefinită, sau constanta';
					           |tr = '""%1""Anahtar kelimesinden sonra alan belirtildiğinden, ""%2""anahtar kelimesinden sonra önceden
					           | tanımlanmış bir değer veya sabit belirtilmelidir'; 
					           |es_ES = 'Como después de la palabra clave ""%1"" está indicado un campo, después de la palabra clave ""%2""
					           |debe estar indicado un valor predeterminado o constante'"),
					Row.Chars,
					When.Chars));
			EndIf;
		EndIf;
		
		ThenContent = Row.Rows[Index + 1];
		If ThenContent.Rows.Count() > 0 Then
			ParseExpression(ThenContent.Rows, WhenThenDetails.Value, Context);
			
		ElsIf ValueIsFilled(ThenContent.Chars) Then
			SetErrorInRow(When.Rows[0], StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'После ключевого слова ""%1"" должно быть указано логическое выражение'; en = 'Logical expression must be specified after the ""%1"" keyword'; pl = 'Po słowie kluczowym ""%1"" powinno być wskazane wyrażenie logiczne';de = 'Auf das Schlüsselwort ""%1"" sollte ein logischer Ausdruck folgen';ro = 'După cuvântul-cheie ""%1"" trebuie să fie indicată expresia logică';tr = '""%1"" Anahtar kelimesinden sonra mantıksal ifade belirtilmelidir'; es_ES = 'Después de la palabra clave ""%1"" debe estar indicada una expresión lógica'"), ThenContent.Chars));
		EndIf;
		
		Index = Index + 2;
	EndDo;
	
	ParseExpression(Row.Rows[Index].Rows, NewDetails.Else, Context);
	
	AddArgumentFunctionChoiceOperator(Context, NewDetails);
	
EndProcedure

// For the ParseExpression procedure.
Procedure ParseErrorKeyword(Context)
	
	Row = Context.String;
	Context.Details = Undefined;
	
	If Row.Type = "Undefined" Then
		// The error is already set for the reserved words.
		Return;
	EndIf;
	
	If Row.Type = "ComparisonValue" Then
		If Row.Clarification = "Disabled" Then
			// "Disabled".
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функции ""%2""'; 
				           |en = 'The ""%1"" value can be used only as a specifying value
				           |in the ""%2"" function parameters'; 
				           |pl = 'Wartość ""%1"" może być stosowana tylko jako doprecyzowana wartość
				           |w parametrach funkcji ""%2""';
				           |de = 'Der Wert ""%1"" kann nur als spezifizierter Wert
				           |in den Parametern der Funktion ""%2"" verwendet werden';
				           |ro = 'Valoarea ""%1"" poate fi utilizată numai ca valoare concretizată
				           |în parametrii funcției ""%2""';
				           |tr = '""%1"" Değeri yalnızca işlev parametrelerinde "
" belirtilen değer olarak%2 kullanılabilir '; 
				           |es_ES = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de la función ""%2""'"),
				Row.Chars,
				KeywordRegardingLanguage("ValueAllowed", Context)));
		Else
			// "BlankRef" or "Null".
			SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
				NStr("ru = 'Значение ""%1"" может использоваться только как уточняемое значение
				           |в параметрах функций проверки разрешений'; 
				           |en = 'The ""%1"" value can be used only as a specifying value
				           |in the permission check function parameters'; 
				           |pl = 'Wartość ""%1"" może być stosowana tylko jako doprecyzowana wartość
				           |w parametrach funkcji sprawdzania uprawnień';
				           |de = 'Der Wert ""%1"" kann nur als spezifizierter Wert
				           |in den Parametern der Berechtigungsprüfungsfunktionen verwendet werden';
				           |ro = 'Valoarea ""%1"" poate fi utilizată numai ca valoare concretizată
				           |în parametrii funcțiilor de verificare a permisiunilor';
				           |tr = '""%1"" Değeri yalnızca işlev parametrelerinde "
" netleştirilen değer olarak kullanılabilir '; 
				           |es_ES = 'El valor ""%1"" puede ser usado solo como un valor detallado
				           |en los parámetros de las funciones de prueba de permisos'"),
				Row.Chars));
		EndIf;
		
	ElsIf Row.Type = "TypeName" Then
		// "Number", "String", "Date", "Boolean".
		SetErrorInRow(Row, InsertKeywordsIntoString(Context,
			NStr("ru = 'Имя типа ""%1"" может использоваться только, как параметр функции ""%2"" или
			           |как уточняемое значение в параметрах функций проверки разрешений'; 
			           |en = 'Name of the ""%1"" type can be used only as a parameter of the ""%2"" function or
			           |as a specifying value in parameters of permission check functions'; 
			           |pl = 'Nazwa typu ""%1"" może być używana tylko, jako ustawienie funkcji ""%2"" lub 
			           |jako doprecyzowana wartość w parametrach funkcji sprawdzania uprawnień';
			           |de = 'Der Name des Typs ""%1"" kann nur als Funktionsparameter ""%2"" oder
			           |als spezifizierter Wert in den Parametern der Berechtigungsprüfungsfunktionen verwendet werden';
			           |ro = 'Numele tipului ""%1"" poate fi utilizat numai ca parametrul funcției ""%2"" sau
			           |ca valoarea concretizată în parametrii funcțiilor de verificare a permisiunilor';
			           |tr = '""%1""Türü adı yalnızca ""%2"" işlev parametresi olarak veya 
			           |izin doğrulama işlev parametrelerinde netleştirilen değer olarak kullanılabilir'; 
			           |es_ES = 'El nombre del tipo ""%1"" puede ser usado solo como el parámetro de la función ""%2"" o
			           |como un valor detallado en los parámetros de las funciones de prueba de permisos'"),
			Row.Chars,
			"Type"));
	Else
		SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Обработка ключевого слова ""%1"" не определена'; en = 'The ""%1"" keyword data processor is not determined'; pl = 'Przetwarzanie słów kluczowych ""%1"" niezdefiniowane';de = 'Die Bearbeitung des Schlüsselwortes ""%1"" ist nicht definiert';ro = 'Procesarea cuvântului cheie ""%1"" nu este determinată';tr = '""%1"" anahtar kelimesinin işlemesi belirlenmedi'; es_ES = 'El procesamiento de la palabra clave ""%1"" no se ha determinado'"), Row.Chars));
	EndIf;
	
EndProcedure

// For the ParseExpression, ParseOperator, ParseFunction, and ParseChoice procedures.
Procedure AddArgumentFunctionChoiceOperator(Context, DetailsToAdd)
	
	// Current node: Any.
	// Details to add: Field, Value, Constant, Not, Choice, any function.
	
	Details = Context.Details;
	
	If Details = Undefined Then
		Context.Details = DetailsToAdd;
		
	ElsIf Upper( Details.Node ) = Upper( "AND" ) // PATCHED
	      Or Details.Node = "Or" Then
		
		If Details.Arguments.Count() = 1 Then
			Details.Arguments.Add(DetailsToAdd);
		Else
			ProcessMissingLogicalOperation(Context, Details.Arguments[1], DetailsToAdd);
		EndIf;
		
	ElsIf Details.Node = "Not" Then
		
		If Not ValueIsFilled(Details.Argument) Then
			Details.Argument = DetailsToAdd;
		Else
			ProcessMissingLogicalOperation(Context, Details.Argument, DetailsToAdd);
		EndIf;
		
	ElsIf Details.Source.Kind = "Operation" Then
		
		If Not ValueIsFilled(Details.SecondArgument) Then
			Details.SecondArgument = DetailsToAdd;
			// Checking the argument accuracy in the MarkIncorrectArgumentsAndProhibitedNodes procedure.
			// 
		Else
			ProcessMissingLogicalOperation(Context, Details.SecondArgument, DetailsToAdd);
		EndIf;
		
	ElsIf StrFind(",Field,Value,Constant,IN,IsNull,Case,", "," + Details.Node + ",") > 0
	      Or Details.Source.Type = "Function" Then
		// The second argument of the In operation is already parsed in the ParseOperationIn procedure.
		// The second Null argument of the Has operation is already parsed in the FunctionsWithExpressionsInParentheses function.
		// The remaining nodes do not have the second argument.
		ProcessMissingLogicalOperation(Context, Undefined, DetailsToAdd);
	Else
		ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Не определена обработка узла ""%1""'; en = '""%1"" node data processor is not determined'; pl = 'Nie zdefiniowane przetwarzanie węzła ""%1""';de = 'Die Bearbeitung des Knotens ""%1"" ist nicht definiert';ro = 'Nu a fost determinată procesarea nodului ""%1""';tr = '""%1"" ünitenin işlemesi belirlenmemiştir'; es_ES = 'El procesamiento del nodo no se ha realizado ""%1""'"), Details.Node);
		Raise ErrorText;
	EndIf;
	
EndProcedure

// For the AddArgumentFunctionChoiceOperator procedure
Procedure ProcessMissingLogicalOperation(Context, DetailsLastArgument, DetailsToAdd)
	
	SetErrorInRow(Context.String, NStr("ru = 'Не указана логическая операция'; en = 'Logical operation is not specified'; pl = 'Nie podana logiczna operacja';de = 'Keine logische Verknüpfung angegeben';ro = 'Operația logică nu este specificată';tr = 'Mantıksal işlem belirtilmedi'; es_ES = 'Operación lógica no indicada'"));
	
	// Recovery.
	AdditionalString = AdditionalString(Context.String, Upper( "AND" ), Context);
	
	NewDetails = New Structure("Source, Node, Arguments", AdditionalString, Upper( "AND" ), New Array);
	NewDetails.Arguments.Add();
	
	CurrentRow = Context.String;
	Context.String = AdditionalString;
	
	InsertConnectorConsideringPriority(Context,
		DetailsLastArgument, NewDetails, NewDetails.Arguments[0]);
	
	Context.String = CurrentRow;
	
	NewDetails.Arguments.Add(DetailsToAdd);
	
EndProcedure

// For the ParseCondition procedure.
Function ExpressionsInParenthesesInAttachments(Rows)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows", Result);
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each Row In Rows Do
		If Row.Chars = "(" Then
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Chars = ")" Then
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row,
					NStr("ru = 'Указана закрывающаяся скобка до открывающейся скобки'; en = 'Closing parenthesis is specified before opening parenthesis'; pl = 'Podano otwierający nawias do otwierającego nawiasu';de = 'Die schließende Klammer wird bis zur öffnenden Klammer angezeigt';ro = 'Este indicată paranteza de închidere în fața parantezei de deschidere';tr = 'Açılış parantezinden önce kapanış parantezi belirtildi'; es_ES = 'Se ha indicado una paréntesis de cierre antes de una paréntesis de apertura'"));
			Else
				DeleteLastAttachment(Attachments, CurrentAttachment, Row);
			EndIf;
		Else
			CurrentAttachment.Rows.Add(Row);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		LastAttachmentIndex = Attachments.Count() - 1;
		Attachment = Attachments[LastAttachmentIndex];
		Attachment.EndString = Row;
		Attachments.Delete(LastAttachmentIndex);
		SetErrorInRow(Attachment,
			NStr("ru = 'Указана открывающаяся скобка без закрывающейся скобки'; en = 'Opening parenthesis is specified without closing parenthesis'; pl = 'Podano otwierający nawias bez zamykającego nawiasu';de = 'Die öffnende Klammer wird angezeigt, ohne die schließende Klammer';ro = 'Este indicată paranteza de deschidere fără paranteza de închidere';tr = 'Kapanış parantezi olmadan açılış parantez belirtildi'; es_ES = 'Se ha indicado una paréntesis de cierre sin una paréntesis de apertura'"), True);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
Function ExpressionsSelectionWhenThenInAttachments(Rows, Context)
	
	Result = New Array;
	
	CurrentAttachment = New Structure("Rows, Clarification", Result, "");
	Attachments = New Array;
	Attachments.Add(CurrentAttachment);
	
	For Each Row In Rows Do
		
		If Row.Kind <> "Keyword"
		 Or Row.Type <> "SelectionWord" Then
			
			If CurrentAttachment.Clarification = "Case" Then
				CurrentAttachment.Rows[0].Rows.Add(Row);
			Else
				CurrentAttachment.Rows.Add(Row);
				If Row.Chars = "(" Then
					Row.Rows = ExpressionsSelectionWhenThenInAttachments(Row.Rows, Context);
				EndIf;
			EndIf;
		ElsIf Row.Clarification = "Case" Then
			If Attachments.Count() = 1 Then
				// Standard processing after the condition.
			Else
				If CurrentAttachment.Clarification = "Case" Then
					SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
						NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu este indicat cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""'"), "Case,When"), True);
					RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				EndIf;
			EndIf;
			AddAttachment(Row, Attachments, CurrentAttachment);
			CurrentAttachment.Rows.Add(AdditionalString(CurrentAttachment, "Case", Context));
			
		ElsIf Row.Clarification = "When" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""'"), "When,Case"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case", Context);
				
			ElsIf CurrentAttachment.Clarification = "Case" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu este indicat cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""'"), "When,Then"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				DeleteLastAttachment(Attachments, CurrentAttachment);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'; en = 'Keyword ""%1"" must be specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" musi być do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" sollte vor dem Schlüsselwort ""%2"" stehen';ro = 'Cuvântul-cheie ""%1"" trebuie să fie în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce olmalıdır'; es_ES = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""'"), "When,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
			EndIf;
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Clarification = "Then" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"" și ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""'"), "Then,Case,When"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When", Context);
			
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""'"), "Then,When"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				// Standard processing after the condition.
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				SetErrorInRow(CurrentAttachment, InsertKeywordsIntoString(Context,
					NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слова ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu este indicat cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""'"), "Then,When"), True);
				RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When", Context);
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" должно быть до ключевого слова ""%2""'; en = 'Keyword ""%1"" must be specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" musi być do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" sollte vor dem Schlüsselwort ""%2"" stehen';ro = 'Cuvântul-cheie ""%1"" trebuie să fie în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce olmalıdır'; es_ES = 'La palabra clave ""%1"" debe estar indicada antes de la palabra clave ""%2""'"), "Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When", Context);
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		ElsIf Row.Clarification = "Else" Then
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", and ""%4""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"", ""%3"" i ""%4""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"" und ""%4"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"", ""%3"" și ""%4""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"", ""%3"" ve ""%4"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""'"), "Else,Case,When,Then"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When,Then", Context);
			
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"" și ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""'"), "Else,When,Then"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When,Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""'"), "Else,Then"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Then", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				// Standard processing after the condition.
				
			Else // CurrentAttachment.Clarification = "Else"
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано повторно'; en = 'Keyword ""%1"" is specified again'; pl = 'Słowo kluczowe ""%1"" podano ponownie';de = 'Das Schlüsselwort ""%1"" wird wiederholt';ro = 'Cuvântul-cheie ""%1"" este indicat repetat';tr = 'Anahtar kelime ""%1"" tekrar belirtildi'; es_ES = 'La palabra clave ""%1"" se ha indicado otra vez'"), "Else"));
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			AddAttachment(Row, Attachments, CurrentAttachment);
			
		Else // String.Clarification = "End"
			
			If Attachments.Count() = 1 Then
				SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"", ""%4"" и ""%5""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", ""%4"", and ""%5""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych,""%2"", ""%3"", ""%4"" i ""%5""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"", ""%4"" und ""%5"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"", ""%3"", ""%4"" și ""%5""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"", ""%3"" , ""%4"" ve ""%5"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""'"), "End,Case,When,Then,Else"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Case,When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "Case" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"", ""%3"" и ""%4""'; en = 'Keyword ""%1"" is specified before keywords ""%2"", ""%3"", and ""%4""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"", ""%3"" i ""%4""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"", ""%3"" und ""%4"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"", ""%3"" și ""%4""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"", ""%3"" ve ""%4"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"", ""%3"" y ""%4""'"), "End,When,Then,Else"));
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "When,Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "When" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевых слов ""%2"" и ""%3""'; en = 'Keyword ""%1"" is specified before keywords ""%2"" and ""%3""'; pl = 'Słowo kluczowe ""%1"" podano do słów kluczowych ""%2"" i ""%3""';de = 'Das Schlüsselwort ""%1"" wird vor den Schlüsselwörtern ""%2"" und ""%3"" angezeigt';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvintelor-cheie ""%2"" și ""%3""';tr = 'Anahtar kelime ""%1"" anahtar kelimelerden ""%2"" ve ""%3"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de las palabras clave ""%2"" y ""%3""'"), "End,Then,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Then,Else", Context);
				
			ElsIf CurrentAttachment.Clarification = "Then" Then
				SetErrorInRow(Row, InsertKeywordsIntoString(Context,
					NStr("ru = 'Ключевое слово ""%1"" указано до ключевого слова ""%2""'; en = 'Keyword ""%1"" is specified before keyword ""%2""'; pl = 'Słowo kluczowe ""%1"" podano do słowa kluczowego ""%2""';de = 'Das Schlüsselwort ""%1"" wird vor dem Schlüsselwort ""%2"" angegeben';ro = 'Cuvântul-cheie ""%1"" este indicat în fața cuvântului-cheie ""%2""';tr = 'Anahtar kelime ""%1"" anahtar kelimeden ""%2"" önce belirtildi '; es_ES = 'La palabra clave ""%1"" se ha indicado antes de la palabra clave ""%2""'"), "End,Else"));
				DeleteLastAttachment(Attachments, CurrentAttachment);
				RestoreChoiceStructure(Row, Attachments, CurrentAttachment, "Else", Context);
				
			Else // CurrentAttachment.Clarification = "Else".
				// Standard processing after the condition.
			EndIf;
			DeleteLastAttachment(Attachments, CurrentAttachment);
			DeleteLastAttachment(Attachments, CurrentAttachment);
		EndIf;
	EndDo;
	
	While Attachments.Count() > 1 Do
		CurrentAttachment = Attachments[Attachments.Count() - 1];
		
		If CurrentAttachment.Clarification = "Case" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4"" и ""%5""'; en = 'Keywords ""%2"", ""%3"", ""%4"", and ""%5"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie podano słowa kluczowe ""%2"", ""%3"", ""%4"" i ""%5""';de = 'Die Schlüsselwörter ""%2"", ""%3"", ""%4"" und ""%5"" sind nicht nach dem Schlüsselwort ""%1"" aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu sunt indicate cuvintele-cheie ""%2"", ""%3"", ""%4"" și ""%5""';tr = 'Anahtar kelimeden ""%1"" sonra anahtar kelimeler ""%2"", ""%3"" , ""%4"" ve ""%5"" belirtilmedi '; es_ES = 'Antes de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4"" y ""%5""'"), "Case,When,Then,Else,End");
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "When,Then,Else", Context);
			
		ElsIf CurrentAttachment.Clarification = "When" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"", ""%3"", ""%4""'; en = 'Keywords ""%2"", ""%3"", and ""%4"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie są określone słowa kluczowe ""%2"", ""%3"", ""%4""';de = 'Die Schlüsselwörter ""%2"", ""%3"", ""%4"" werden nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu sunt indicate cuvintele-cheie ""%2"", ""%3"", ""%4""';tr = 'Anahtar kelimeden ""%1"" sonra anahtar kelimeler ""%2"", ""%3"" ve ""%4"" belirtilmedi '; es_ES = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"", ""%3"", ""%4""'"), "When,Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Then,Else", Context);
			
		ElsIf CurrentAttachment.Clarification = "Then" Then
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указаны ключевые слова ""%2"" и ""%3""'; en = 'Keywords ""%2"" and ""%3"" are not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie podano słowa kluczowe ""%2"" i ""%3""';de = 'Die Schlüsselwörter ""%2"" und ""%3"" werden nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu sunt indicate cuvintele-cheie ""%2"" și ""%3""';tr = 'Anahtar kelimeden ""%1"" sonra anahtar kelimeler ""%2"" ve ""%3"" belirtilmedi '; es_ES = 'Después de la palabra clave ""%1"" no se han indicado las palabras clave ""%2"" y ""%3""'"), "Then,Else,End");
			DeleteLastAttachment(Attachments, CurrentAttachment);
			RestoreChoiceStructure(CurrentAttachment, Attachments, CurrentAttachment, "Else", Context);
			
		Else // CurrentAttachment.Clarification = "Else"
			ErrorText = InsertKeywordsIntoString(Context,
				NStr("ru = 'После ключевого слова ""%1"" не указано ключевое слово ""%2""'; en = 'Keyword ""%2"" is not specified after keyword ""%1""'; pl = 'Po słowie kluczowym ""%1"" nie określono słowo kluczowe ""%2""';de = 'Das Schlüsselwort ""%2"" wird nach dem Schlüsselwort ""%1"" nicht aufgeführt';ro = 'După cuvântul-cheie ""%1"" nu este indicat cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelimesi belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se ha indicado una palabra clave ""%2""'"), "Else,End");
		EndIf;
		SetErrorInRow(CurrentAttachment, ErrorText, True);
		DeleteLastAttachment(Attachments, CurrentAttachment);
		DeleteLastAttachment(Attachments, CurrentAttachment);
	EndDo;
	
	Return Result;
	
EndFunction

// For the ParseCondition procedure.
Function FunctionsWithExpressionsInParentheses(Rows, InternalData)
	
	Result = New Array;
	RowsCount = Rows.Count();
	
	Row = Undefined;
	Index = 0;
	While Index < RowsCount Do
		PreviousString = Row;
		Row = Rows[Index];
		
		If Row.Chars = "(" Then
			Row.Rows = FunctionsWithExpressionsInParentheses(Row.Rows, InternalData);
			
		ElsIf Row.Kind = "Keyword"
		        AND (    Row.Type = "Function"
		           Or Upper( Row.Clarification ) = Upper( "IN" ) ) Then // PATCHED:
			
			If Index + 1 < Rows.Count()
			   AND Rows[Index + 1].Chars = "(" Then
				
				Index = Index + 1;
				Row.Rows = FunctionsWithExpressionsInParentheses(Rows[Index].Rows, InternalData);
				Row.EndString = Rows[Index].EndString;
				
				If Row.Rows.Count() = 0 Then
					If Row.Type = "Function" Then
						SetErrorInRow(Rows[Index], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'У функции ""%1"" не указано ни одного параметра'; en = 'No parameter is specified for the ""%1"" function'; pl = 'Funkcja ""%1"" nie podano żadnego parametru';de = 'Für die Funktion ""%1"" ist kein Parameter angegeben';ro = 'Pentru funcția ""%1"" nu este indicat nici un parametru';tr = '""%1"" işlevin hiç bir parametresi belirtilmedi'; es_ES = 'Para la función ""%1"" no se ha indicado ningún parámetro'"), Row.Chars), True);
					Else
						SetErrorInRow(Rows[Index], StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'В списке значений операции ""%1"" не указано ни одного значения'; en = 'No value is specified in the value list of the ""%1"" operation'; pl = 'W liście wartości operacji ""%1"" nie określono żadnej wartości';de = 'In der Werteliste der Operation ""%1"" ist kein Wert angegeben';ro = 'În lista de valori ale operației ""%1"" nu este indicată nici o valoare';tr = '""%1"" İşlem değerleri listesinde herhangi bir değer belirtilmedi'; es_ES = 'En la lista de valores de la operación ""%1"" no se ha indicado ningún valor'"), Row.Chars), True);
					EndIf;
				EndIf;
			Else
				Row.Rows = New Array;
				If Row.Type = "Function" Then
					SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'После функции ""%1"" не указаны параметры в скобках'; en = 'Parameters in parentheses are not specified after the ""%1"" function'; pl = 'Po funkcji ""%1"" nie podano parametry w nawiasach';de = 'Parameter in Klammern werden nach der Funktion ""%1"" nicht angegeben';ro = 'După funcția ""%1"" nu sunt indicați parametrii în paranteze';tr = '""%1"" İşlevinden sonra parantez içindeki parametreler belirtilmedi'; es_ES = 'Después de la función ""%1"" no se han indicado parámetros en paréntesis'"), Row.Chars), True);
				Else
					SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'После ключевого слова ""%1"" не указаны значения в скобках'; en = 'Values in parentheses are not specified after the ""%1"" keyword'; pl = 'Po słowie kluczowym ""%1"" nie podano wartości w nawiasach';de = 'Nach dem Schlüsselwort ""%1"" werden die Werte in Klammern nicht angegeben';ro = 'După cuvântul-cheie ""%1"" nu sunt indicate valorile în paranteze';tr = '""%1"" anahtar kelimesinden sonra parantez içindeki değerler belirtilmedi'; es_ES = 'Después de la palabra clave ""%1"" no se han indicado valores en paréntesis'"), Row.Chars), True);
				EndIf;
			EndIf;
			
		ElsIf Row.Kind = "Keyword"
		        AND Row.Clarification = "Is"  Then
			
			If Index + 1 < Rows.Count()
			   AND Rows[Index + 1].Kind = "Keyword"
			   AND Rows[Index + 1].Clarification = "Null" Then
				
				Index = Index + 1;
				Row.Rows.Add(Rows[Index]);
			Else
				Row.Rows = New Array;
				SetErrorInRow(Row, InsertKeywordsIntoString(InternalData,
						NStr("ru = 'После ключевого слова ""%2"" не указано ключевое слово ""%1""'; en = 'Keyword ""%1"" is not specified after keyword ""%2""'; pl = 'Po słowie kluczowym ""%2"" nie określono słowo kluczowe ""%1""';de = 'Nach dem Schlüsselwort ""%2"" wird das Schlüsselwort ""%1"" nicht angegeben';ro = 'După cuvântul-cheie ""%1"" nu este indicat cuvântul-cheie ""%2""';tr = '""%1"" anahtar kelimesinden sonra ""%2"" anahtar kelime belirtilmedi'; es_ES = 'Después de la palabra clave ""%2"" no se ha indicado una palabra clave ""%1""'"),
						"Null",
						Row.Chars),
					True);
			EndIf;
			
		ElsIf Row.Kind = "Name"
		        AND StrStartsWith(Row.Chars, ".")
		        AND PreviousString <> Undefined Then
			
			If PreviousString <> Undefined
			   AND PreviousString.Kind = "Keyword"
			   AND PreviousString.Clarification = "Cast" Then
				
				Row.Type = "AdditionToExpress";
				PreviousString.Rows.Add(Row);
				Index = Index + 1;
				Continue;
			Else
				SetErrorInRow(Row, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Имя поля не может начинаться с символа "".""'; en = 'Field name cannot start with a period (""."")'; pl = 'Nazwa pola nie może zaczynać się od znaku "".""';de = 'Der Feldname darf nicht mit dem Symbol ""."" beginnen';ro = 'Numele câmpului nu poate începe cu simbolul "".""';tr = 'Alan adı ""."" karakterinden başlayamaz'; es_ES = 'El nombre del campo no puede empezarse con el símbolo "".""'"), Row.Chars));
			EndIf;
		EndIf;
		
		Result.Add(Row);
		Index = Index + 1;
	EndDo;
	
	Return Result;
	
EndFunction

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure AddAttachment(Row, Attachments, CurrentAttachment)
	
	CurrentAttachment.Rows.Add(Row);
	CurrentAttachment = Row;
	Attachments.Add(CurrentAttachment);
	
EndProcedure

// For the ExpressionsInParenthesesInAttachments and ExpressionsWhenThenSelectionInAttachments functions.
Procedure DeleteLastAttachment(Attachments, CurrentAttachment, EndString = Undefined)
	
	If EndString = Undefined Then
		If CurrentAttachment.Rows.Count() = 0 Then
			EndString = CurrentAttachment;
		Else
			EndString = CurrentAttachment.Rows[CurrentAttachment.Rows.Count() - 1];
			If EndString.EndString <> Undefined Then
				EndString = EndString.EndString;
			EndIf;
		EndIf;
	EndIf;
	
	CurrentAttachment.EndString = EndString;
	
	LastAttachmentIndex = Attachments.Count() - 1;
	Attachments.Delete(LastAttachmentIndex);
	CurrentAttachment = Attachments[LastAttachmentIndex - 1];
	
EndProcedure

// For the ExpressionsWhenThenSelectionInAttachments function.
Procedure RestoreChoiceStructure(Row, Attachments, CurrentAttachment, MissingWordsList, Context)
	
	MissingWords = StrSplit(MissingWordsList, ",", False);
	
	For Each MissingWord In MissingWords Do
		NewRow = AdditionalString(Row, MissingWord, Context);
		CurrentAttachment.Rows.Add(NewRow);
		
		If MissingWord = "Case" Then
			CurrentAttachment = NewRow;
			Attachments.Add(CurrentAttachment);
		EndIf;
	EndDo;
	
	If MissingWord <> "Case" Then
		CurrentAttachment = NewRow;
		Attachments.Add(CurrentAttachment);
	EndIf;
	
EndProcedure

// For the ProcessMissingLogicalOperation, ExpressionsWhenThenSelectionInAttachments,
// RestoreChoiceStructure procedures, and the CommaSeparatedParameters function.
//
Function AdditionalString(Row, Clarification = "", Context = Undefined)
	
	Fields = "Chars, Kind, Type, Priority, Clarification, SourceString, Rows, EndString, ErrorPosition, ErrorText";
	
	NewRow = New Structure(Fields);
	NewRow.Clarification      = Clarification;
	NewRow.Rows         = New Array;
	NewRow.SourceString = Row;
	
	WordProperties = ?(Context = Undefined,
		Undefined, Context.LanguageSyntax.LanguageWords.Get(Upper(Clarification)));
	
	If WordProperties <> Undefined Then
		NewRow.Kind       = "Keyword";
		NewRow.Type       = WordProperties.Type;
		NewRow.Priority = WordProperties.Priority;
	EndIf;
	
	Return NewRow;
	
EndFunction

// For the ParseAdditionalTables and ParseRestrictionCondition procedures.
Procedure ChangeKeywordTypeListToName(PartRows, RowToExclude = Undefined)
	
	For Each Row In PartRows Do
		If Row = RowToExclude
		 Or Row.Kind <> "Keyword"
		 Or Row.Clarification <> "ThisList" Then
			Continue;
		EndIf;
		Row.Kind = "Name";
		Row.Clarification = "";
	EndDo;
	
EndProcedure

// For the ParseAdditionalTables and ParseCondition procedures.
Procedure SetAlias(PartRow, ConnectionDetails, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	PointPosition = StrFind(PartRow.Chars, ".");
	If PointPosition > 0 Then
		PartRow.ErrorPosition = PointPosition - 1;
		PartRow.ErrorText =
			NStr("ru = 'Псевдоним не может содержать символа "".""'; en = 'Alias cannot contain a period (""."")'; pl = 'Alias nie może zawierać znaku "".""';de = 'Der Alias darf nicht das Symbol ""."" enthalten';ro = 'Pseudonimul nu poate conține simbolul "".""';tr = 'Takma ad ""."" karakterini içeremez'; es_ES = 'El alias no puede contener el símbolo "".""'");
			
	ElsIf TypeOf(ConnectionDetails) = Type("String") Then
		ConnectionDetails = PartRow.Chars;
		InternalData.Aliases.Insert(Upper(PartRow.Chars),
			New Structure("Alias, Table", PartRow.Chars));
	Else
		ConnectionDetails.Alias = PartRow.Chars + "Alias";
		If InternalData.Aliases.Get(Upper(PartRow.Chars)) = Undefined Then
			If ValueIsFilled(ConnectionDetails.Table) Then
				InternalData.Aliases.Insert(Upper(PartRow.Chars),
					New Structure("Alias, Table",
						ConnectionDetails.Alias, ConnectionDetails.Table));
			EndIf;
		Else
			PartRow.ErrorText = NStr("ru = 'Псевдоним повторяется'; en = 'Alias is repeated'; pl = 'Alias powtarza się';de = 'Das Pseudonym wiederholt sich';ro = 'Pseudonimul se repetă';tr = 'Takma ad tekrarlandı'; es_ES = 'Alias se repite'");
		EndIf;
	EndIf;
	
EndProcedure

// For the ParseConnection procedure.
Procedure SetTableName(PartRow, ConnectionDetails, InternalData)
	
	If ValueIsFilled(PartRow.ErrorText) Then
		Return;
	EndIf;
	
	If StrStartsWith(PartRow.Chars, ".") Then
		PartRow.ErrorText =
			NStr("ru = 'Имя таблицы не может начинаться с символа "".""'; en = 'Table name cannot start with a period "".""'; pl = 'Nazwa tabeli nie może zaczynać się od znaku "".""';de = 'Der Tabellenname darf nicht mit dem Symbol ""."" beginnen';ro = 'Numele tabelului nu poate începe cu simbolul "".""';tr = 'Tablo adı ""."" karakterinden başlayamaz'; es_ES = 'El nombre de la tabla no puede empezarse con el símbolo "".""'");
		Return;
	EndIf;
	
	If StrOccurrenceCount(PartRow.Chars, ".") > 2 Then
		
		PointPosition = StrFind(PartRow.Chars, ".");
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		
		PointPosition = PointPosition + StrFind(Mid(PartRow.Chars, PointPosition + 1), ".");
		PartRow.ErrorText =
			NStr("ru = 'Полное имя таблицы не может содержать более двух символов "".""'; en = 'Full table name cannot contain more than two periods (""."")'; pl = 'Pełna nazwa tabeli nie może zawierać więcej niż dwóch znaków "".""';de = 'Der vollständige Name der Tabelle darf nicht mehr als zwei Symbole ""."" enthalten';ro = 'Numele complet al tabelului nu poate conține mai mult de două simboluri "".""';tr = 'Tablonun tam adı ikiden fazla ""."" karakter içeremez'; es_ES = 'El nombre completo de la tabla no puede contener más de dos símbolos "".""'");
		
		PartRow.ErrorPosition = PointPosition - 1;
		Return;
	EndIf;
	
	ConnectionDetails.Table = PartRow.Chars;
	
	AddRequiredTableAsDataSource(InternalData, ConnectionDetails.Table, PartRow);
	
EndProcedure

// For the SetTableName procedure.
Procedure AddRequiredTableAsDataSource(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount < 2
	 Or NameProperties.NamePartsCount > 3 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени присоединяемой таблицы должна быть одна или две точки'; en = 'Attached table name must contain one or two periods'; pl = 'W imieniu dodawanej tabeli musi być jedna lub dwie kropki';de = 'Der Name der zu verbindenden Tabelle muss einen oder zwei Punkte enthalten';ro = 'Numele tabelului atașat trebuie să conțină unul sau două puncte';tr = 'Ekli tablo adında bir veya iki nokta olmalıdır'; es_ES = 'En el nombre de la tabla adjunta debe haber uno o dos puntos'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""';ro = 'Început incorect ""%1"" al numelui tabelului ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış'; es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If NameProperties.NamePartsCount = 3 Then
		ClarificationProperties = NameProperties.TablesTypeProperties.TablesClarification.Get(
			Upper(NameProperties.Extension));
		
		If ClarificationProperties <> Undefined
		   AND ClarificationProperties.Use <> "Allowed" Then
			
			If ClarificationProperties.Use = "Illegal" Then
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Недопустимо использовать таблицы ""%1"" группы таблиц ""%2""'; en = 'Cannot use tables ""%1"" of the ""%2"" table group'; pl = 'Niedopuszczalne jest stosowanie tabeli ""%1"" grupy tabel ""%2""';de = 'Verwenden Sie keine Tabellen ""%1"" der Tabellengruppen ""%2""';ro = 'Nu se permite utilizarea tabelelor ""%1"" din grupul tabelelor ""%2""';tr = '""%1"" tablo grubunun ""%2"" tabloları kullanılamaz'; es_ES = 'No se admite usar las tablas ""%1"" del grupo de tablas ""%2""'"),
					NameProperties.Extension, NameProperties.TypeName));
			Else
				SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
					NStr("ru = 'Запрещено присоединять таблицы ""%1"" группы таблиц ""%2""'; en = 'Cannot attach tables ""%1"" of the ""%2"" table group'; pl = 'Zabronione jest dołączanie tabeli ""%1"" grupy tabel ""%2""';de = 'Es ist verboten, Tabellen ""%1"" der Tischgruppe ""%2"" anzuhängen';ro = 'Nu se permite atașarea tabelelor ""%1"" din grupul tabelelor ""%2""';tr = '""%1"" tablo grubunun ""%2"" tabloları eklenemez'; es_ES = 'No se admite adjuntar las tablas ""%1"" del grupo de tablas ""%2""'"),
					NameProperties.Extension, NameProperties.TypeName));
			EndIf;
			Return;
		EndIf;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the SelectFieldAlias, ParseFirstCheckingFunctionParameter,
// ParseAdditionalCheckingFunctionParameter, and ParseValueFunctionOrTypeFunctionParameters procedures.
//
Procedure AddRequiredTableAsReferenceType(Context, Table, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	
	If NameProperties.NamePartsCount <> 2 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени таблицы, указанной в качестве типа, должна быть одна точка'; en = 'Table name specified as a type must contain a period'; pl = 'W nazwie tabeli, podanej jako typ, musi być jedna kropka';de = 'Der als Typ angegebene Tabellenname muss einen Punkt haben';ro = 'Numele tabelului indicat în calitate de tip trebuie să conțină un punct';tr = 'Bir tür olarak belirtilen tablo adında tek bir nokta olmalıdır'; es_ES = 'En el nombre de la tabla indicada como el tipo debe haber un punto'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""';ro = 'Început incorect ""%1"" al numelui tabelului ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış'; es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'; en = '""%1"" table group is not included in reference types'; pl = 'Grupa tabel ""%1"" nie wchodzi w skład typów odwołań';de = 'Die Tabellengruppe ""%1"" ist nicht Bestandteil von Referenztypen';ro = 'Grupul de tabele ""%1"" nu face parte din componența tipurilor de referință';tr = '""%1"" tablo grubu referans türlerin kapsamına girmez'; es_ES = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace'"), NameProperties.TypeName, Table));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	Properties.Sources.Add(Source);
	
EndProcedure

// For the ParseValueFunctionOrTypeFunctionParameters procedure.
Procedure AddRequiredPredefinedItem(Context, FullPredefinedItemName, Source)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, FullPredefinedItemName);
	
	If NameProperties.NamePartsCount <> 3 Then
		SetErrorInRow(Source,
			NStr("ru = 'В имени предопределенного значения должно быть две точки'; en = 'Predefined value name must contain two periods'; pl = 'W imieniu zadanej wartości powinny być dwie kropki';de = 'Der Name eines vordefinierten Werts muss zwei Punkte enthalten';ro = 'Numele tabelului predefinit trebuie să conțină două puncte';tr = 'Önceden belirlenmiş değerin adından iki nokta olmalıdır'; es_ES = 'En el nombre del valor predeterminado debe haber dos puntos'"));
		Return;
	EndIf;
	
	If NameProperties.TablesTypeProperties = Undefined Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Некорректное начало ""%1"" имени таблицы ""%2""'; en = 'Incorrect beginning ""%1"" of the ""%2"" table name'; pl = 'Nieprawidłowy początek ""%1"" nazwy tabeli ""%2""';de = 'Falscher Anfang von ""%1"" Tabellenname ""%2""';ro = 'Început incorect ""%1"" al numelui tabelului ""%2""';tr = '""%1"" tablo adının ""%2"" başlangıcı yanlış'; es_ES = 'Inicio incorrecto ""%1"" del nombre de la tabla ""%2""'"),
			NameProperties.TypeName,
			NameProperties.TypeName + "." + NameProperties.NameWithoutType));
		Return;
	EndIf;
	
	If Not NameProperties.TablesTypeProperties.IsReferenceType Then
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'Группа таблиц ""%1"" не входит в состав ссылочных типов'; en = '""%1"" table group is not included in reference types'; pl = 'Grupa tabel ""%1"" nie wchodzi w skład typów odwołań';de = 'Die Tabellengruppe ""%1"" ist nicht Bestandteil von Referenztypen';ro = 'Grupul de tabele ""%1"" nu face parte din componența tipurilor de referință';tr = '""%1"" tablo grubu referans türlerin kapsamına girmez'; es_ES = 'Grupo de tablas ""%1"" no forma parte de los tipos de enlace'"), NameProperties.TypeName));
		Return;
	EndIf;
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(NameProperties.Extension));
	
	If Not NameProperties.TablesTypeProperties.HasPredefined
	   AND Not NameProperties.TypeName = "Enum"
	   AND (    WordProperties = Undefined
	      Or WordProperties.ID <> "EmptyRef") Then
		
		SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
			NStr("ru = 'В группе таблиц ""%1"" нет предопределенных элементов'; en = 'There are no predefined items in the ""%1"" table group'; pl = 'W grupie tabel ""%1"" nie ma gotowych elementów';de = 'Die Tabellengruppe ""%1"" enthält keine vordefinierten Elemente';ro = 'În grupul de tabele ""%1"" lipsesc elementele predefinite';tr = '""%1"" tablo grubunda önceden tanımlanmış unsurlar yok'; es_ES = 'En el grupo de tablas ""%1"" no hay elementos predeterminados'"), NameProperties.TypeName));
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties, True);
	
	PredefinedOptionProperties = Properties.Predefined.Get(Upper(NameProperties.Extension));
	If PredefinedOptionProperties = Undefined Then
		PredefinedOptionProperties = New Structure;
		PredefinedOptionProperties.Insert("NameExists", False);
		PredefinedOptionProperties.Insert("Sources", New Array);
		Properties.Predefined.Insert(Upper(NameProperties.Extension), PredefinedOptionProperties);
	EndIf;
	PredefinedOptionProperties.Sources.Add(Source);
	
EndProcedure

// For the MarkIncorrectArgumentsAndProhibitedNodes, SelectFieldAlias,
// and AddUsersAndExternalUsersAccessKindsTypesToCheckAbsence procedures.
//
Procedure AddRequiredTableField(Context, Table, FieldName, Source,
			FieldType = "", FieldTypeSource = Undefined, FieldNode = Undefined)
	
	If ValueIsFilled(Source.ErrorText) Then
		Return;
	EndIf;
	
	NameProperties = TableNameProperties(Context, Table);
	If NameProperties.TablesTypeProperties = Undefined Then
		
		If NameProperties.IsMainTable
		   AND Not Context.Property("ErrorSetToFirstFieldInMainTable") Then
			
			Context.Insert("ErrorSetToFirstFieldInMainTable");
			SetErrorInFieldNameString(Context, Source,
				NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde';ro = 'Câmpul nu a fost găsit, deoarece nu a fost găsit tabelul ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı'; es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""'"), 0, ,
				Context.MainTable);
		EndIf;
		
		Return;
	EndIf;
	
	Properties = RequiredTableProperties(Context, NameProperties);
	
	FieldProperties = Properties.Fields.Get(Upper(FieldName));
	If FieldProperties = Undefined Then
		FieldProperties = New Structure;
		FieldProperties.Insert("FieldWithError", 0);
		FieldProperties.Insert("ErrorKind",    "");
		FieldProperties.Insert("Collection",    "");
		FieldProperties.Insert("ContainsTypes", New Map);
		FieldProperties.Insert("Sources",    New Map);
		FieldProperties.Insert("FieldNodes",     New Array);
		Properties.Fields.Insert(Upper(FieldName), FieldProperties);
		
		If Properties.Property("FirstField")
		   AND Properties.FirstField = Undefined
		   AND Source <> Undefined Then
			
			FieldProperties.Insert("FirstSource", New Structure("Key,Value", Source, Table));
			Properties.FirstField = FieldProperties;
		EndIf;
	EndIf;
	FieldProperties.Sources.Insert(Source, Table);
	If FieldNode <> Undefined Then
		FieldProperties.FieldNodes.Add(FieldNode);
	EndIf;
	
	If Not ValueIsFilled(FieldType) Then
		Return;
	EndIf;
	
	If TypeOf(FieldTypeSource) = Type("ValueTableRow")
	   AND ValueIsFilled(FieldTypeSource.ErrorText) Then
		Return;
	EndIf;
	
	TypeProperties = FieldProperties.ContainsTypes.Get(Upper(FieldType));
	If TypeProperties = Undefined Then
		NameContent = StrSplit(FieldType, ".");
		TablesTypeProperties = Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0]));
		If TablesTypeProperties = Undefined Then
			TypeName = FieldType;
			TypeCollectionName = "";
			TypeCollectionObjectName = "";
		Else
			TypeName = TablesTypeProperties.LanguageRussian + "Ref." + NameContent[1];
			TypeCollectionName = TablesTypeProperties.CollectionName;
			TypeCollectionObjectName = NameContent[1];
		EndIf;
		TypeProperties = New Structure;
		TypeProperties.Insert("ContainsType", False);
		TypeProperties.Insert("TypeName", TypeName);
		TypeProperties.Insert("TypeCollectionName", TypeCollectionName);
		TypeProperties.Insert("TypeCollectionObjectName", TypeCollectionObjectName);
		TypeProperties.Insert("Sources", New Map);
		FieldProperties.ContainsTypes.Insert(Upper(FieldType), TypeProperties);
	EndIf;
	TypeProperties.Sources.Insert(FieldTypeSource, Source);
	
EndProcedure

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function TableNameProperties(Context, FullName)
	
	If ValueIsFilled(FullName) Then
		Table = FullName;
	Else
		Table = Context.MainTable;
	EndIf;
	
	NameContent = StrSplit(Table, ".", False);
	
	Properties = New Structure;
	Properties.Insert("NamePartsCount", NameContent.Count());
	Properties.Insert("TypeName",    NameContent[0]);
	Properties.Insert("NameWithoutType", ?(NameContent.Count() > 1, NameContent[1], Undefined));
	Properties.Insert("Extension", ?(NameContent.Count() = 3, NameContent[2], Undefined));
	Properties.Insert("IsMainTable", Upper(Table) = Upper(Context.MainTable));
	Properties.Insert("TablesTypeProperties",
		Context.LanguageSyntax.TablesTypes.ByNames.Get(Upper(NameContent[0])));
	
	Return Properties;
	
EndFunction

// For the AddRequiredTableAsDataSource, AddRequiredTableAsReferenceType,
// AddRequiredPredefinedItem, and AddRequiredTableField procedures.
//
Function RequiredTableProperties(Context, NameProperties, WithoutExtension = False)
	
	CollectionName = NameProperties.TablesTypeProperties.CollectionName;
	
	CollectionProperties = Context.TablesFields.Get(CollectionName);
	If CollectionProperties = Undefined Then
		CollectionProperties = New Map;
		Context.TablesFields.Insert(CollectionName, CollectionProperties);
	EndIf;
	
	Properties = CollectionProperties.Get(Upper(NameProperties.NameWithoutType));
	If Properties = Undefined Then
		Properties = New Structure;
		Properties.Insert("TableExists",  False);
		Properties.Insert("IsMainTable", NameProperties.IsMainTable);
		Properties.Insert("Sources",          New Array);
		Properties.Insert("Fields",               New Map);
		Properties.Insert("Predefined",   New Map);
		Properties.Insert("Extensions",         New Map);
		If NameProperties.IsMainTable AND NameProperties.Extension = Undefined Then
			Properties.Insert("FirstField");
		EndIf;
		CollectionProperties.Insert(Upper(NameProperties.NameWithoutType), Properties);
	EndIf;
	
	If NameProperties.Extension = Undefined Or WithoutExtension Then
		Return Properties;
	EndIf;
	
	ExtensionProperties = Properties.Extensions.Get(Upper(NameProperties.Extension));
	If ExtensionProperties = Undefined Then
		ExtensionProperties = New Structure;
		ExtensionProperties.Insert("TableExists", False);
		ExtensionProperties.Insert("Sources",         New Array);
		ExtensionProperties.Insert("Fields",              New Map);
		If NameProperties.IsMainTable Then
			ExtensionProperties.Insert("FirstField");
		EndIf;
		Properties.Extensions.Insert(Upper(NameProperties.Extension), ExtensionProperties);
	EndIf;
	
	Return ExtensionProperties;
	
EndFunction

// For the RestrictionParts, ParseAdditionalTables, ParseConnection,
// ParseRestrictionCondition, and ExpressionsWhenThenSelectionInAttachments procedures and functions.
Function InsertKeywordsIntoString(Context, Row, WordsList, ParameterOne = "", ParameterTwo = "", ParameterThree = "")
	
	Words = StrSplit(WordsList, ",", False);
	WordsToInsert = New Map;
	
	For Each Word In Words Do
		WordsToInsert.Insert(Words.Find(Word),
			KeywordRegardingLanguage(TrimAll(Word), Context));
	EndDo;
	
	Index = WordsToInsert.Count();
	WordsToInsert.Insert(Index,     ParameterOne);
	WordsToInsert.Insert(Index + 1, ParameterTwo);
	WordsToInsert.Insert(Index + 2, ParameterThree);
	
	Return StringFunctionsClientServer.SubstituteParametersToString(Row,
		WordsToInsert[0], WordsToInsert[1], WordsToInsert[2],
		WordsToInsert[3], WordsToInsert[4], WordsToInsert[5],
		WordsToInsert[6], WordsToInsert[7], WordsToInsert[8]);
	
EndFunction

// For the ParseAdditionalTables, ParseConnection, and ParseRestrictionCondition procedures.
Function KeywordRegardingLanguage(WordID, Context)
	
	WordProperties = Context.LanguageSyntax.LanguageWords.Get(Upper(WordID));
	
	If ScriptVariantRussian() Then
		Word = WordProperties.LanguageRussian;
	Else
		Word = WordProperties.LanguageEnglish;
	EndIf;
	
	If WordProperties.Uppercase Then
		Word = Upper(Word);
	EndIf;
	
	Return Word;
	
EndFunction

// For the AllowedTemplatesDetails and KeywordRegardingLanguage functions.
Function ScriptVariantRussian()
	
	Return Metadata.ScriptVariant = Metadata.ObjectProperties.ScriptVariant.Russian;
	
EndFunction

#EndRegion

#Region TablesNamesAndTablesFieldsAnalysis

// Checking tables, table fields, and field types found when parsing the restriction text.
// The same procedure is implemented in ASDS.
//
// Parameters:
//  ParsedRestriction - Structure - returned by the ParsedRestriction function.
//
Procedure CheckFieldTablesAndFieldsTypes(ParsedRestriction)
	
	Context = New Structure;
	Context.Insert("TablesTypes", AccessManagementInternalCached.LanguageSyntax().TablesTypes);
	
	For Each TablesType In ParsedRestriction.TablesFields Do
		TablesCollection = Metadata[TablesType.Key];
		
		For Each TableFields In TablesType.Value Do
			
			TableMetadata = TablesCollection.Find(TableFields.Key);
			If TableMetadata = Undefined Then
				Continue;
			EndIf;
			TableFields.Value.TableExists = True;
			
			Context.Insert("TableMetadata",  TableMetadata);
			Context.Insert("TablesTypeProperties", Context.TablesTypes.ByCollections.Get(TablesType.Key));
			Context.Insert("IsMainTable", TableFields.Value.IsMainTable);
			
			For Each TableField In TableFields.Value.Fields Do
				FieldDetails = New Structure;
				FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
				FieldDetails.Insert("Properties",    TableField.Value);
				FieldDetails.Insert("FieldType",     New TypeDescription);
				CheckTableField(FieldDetails, Context);
				If FieldDetails.Properties.FieldWithError = 0 Then
					CheckFieldTypes(FieldDetails, Context);
				EndIf;
			EndDo;
			
			CheckTableExtensions(TableFields, Context);
			CheckPredefinedTableValues(TableFields, Context);
		EndDo;
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckNextPointSeparatedField procedures.
Procedure CheckTableField(FieldDetails, Context, Index = 0, InitialCall = True)
	
	NameContent  = FieldDetails.NameContent;
	FieldProperties = FieldDetails.Properties;
	
	FieldClarification = Context.TablesTypeProperties.FieldsClarification.Get(Upper(NameContent[Index]));
	
	If FieldClarification <> Undefined
	   AND FieldClarification.Use <> "Allowed" Then
		
		FieldProperties.FieldWithError = Index + 1;
		FieldProperties.ErrorKind = FieldClarification;
		Return;
	EndIf;
	
	Properties = FieldOrTabularSectionProperties(NameContent[Index], Context, Index = 0);
	If Properties = Undefined Then
		FieldProperties.FieldWithError = Index + 1;
		FieldProperties.ErrorKind = "NotFound";
		Return;
	EndIf;
	If Index = 0 Then
		FieldProperties.Collection = Properties.Collection;
	EndIf;
	
	If Properties.IsTabularSection Then
		If Index > 0 Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "TabularSectionAfterDot";
			Return;
		EndIf;
		If Not Context.IsMainTable Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "AdditionalTableTabularSection";
			Return;
		EndIf;
		If Index + 1 = NameContent.Count() Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "TabularSectionNoField";
			Return;
		EndIf;
		Index = Index + 1;
		Properties = TabularSectionFieldProperties(NameContent[Index],
			Properties.Metadata, Properties.Collection, Context.TableMetadata);
		If Properties = Undefined Then
			FieldProperties.FieldWithError = Index + 1;
			FieldProperties.ErrorKind = "NotFound";
			Return;
		EndIf;
	EndIf;
	
	CheckNextPointSeparatedField(FieldDetails, Index, Properties, Context);
	
	If InitialCall Then
		FillFieldTypesAsStringAdditional(FieldDetails);
	EndIf;
	
EndProcedure

// For the CheckTableField and CheckTableExtensions procedures.
Procedure CheckNextPointSeparatedField(FieldDetails, Index, CurrentFieldProperties, Context)
	
	AddFieldTypesAdditional(FieldDetails, Index, CurrentFieldProperties, Context);
	
	Index = Index + 1;
	If Index = FieldDetails.NameContent.Count() Then
		FieldDetails.FieldType = New TypeDescription(FieldDetails.FieldType, CurrentFieldProperties.Type.Types());
		Return;
	EndIf;
	
	FieldProperties = FieldDetails.Properties;
	FieldFound = False;
	
	If FieldDetails.Property("NextFieldTables") Then
		// See the AddFieldTypesAdditional procedure.
		If FieldDetails.NextFieldTables.Count() < Index + 1 Then
			NextFieldTables = New Array;
			FieldDetails.NextFieldTables.Add(NextFieldTables);
		Else
			NextFieldTables = FieldDetails.NextFieldTables[Index];
		EndIf;
	EndIf;
	
	For Each Type In CurrentFieldProperties.Type.Types() Do
		If Not Common.IsReference(Type) Then
			Continue;
		EndIf;
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
		
		// Saving the current context.
		CurrentTableMetadata  = Context.TableMetadata;
		CurrentTablesTypeProperties = Context.TablesTypeProperties;
		
		Context.TableMetadata = Metadata.FindByType(Type);
		FullName = Context.TableMetadata.FullName();
		FullNameContent = StrSplit(FullName, ".", False);
		Context.TablesTypeProperties = Context.TablesTypes.ByNames.Get(Upper(FullNameContent[0]));
		
		CurrentIndex = Index;
		CheckTableField(FieldDetails, Context, CurrentIndex, False);
		
		// Restoring the current context.
		Context.TableMetadata  = CurrentTableMetadata;
		Context.TablesTypeProperties = CurrentTablesTypeProperties;
		
		If FieldProperties.FieldWithError = 0 Then
			FieldFound = True;
			If NextFieldTables <> Undefined Then
				// See the AddFieldTypesAdditional procedure.
				NextFieldTables.Add(FullName);
			EndIf;
		ElsIf FieldProperties.ErrorKind <> "NotFound" Then
			Return;
		EndIf;
	EndDo;
	
	If FieldFound Then
		FieldProperties.FieldWithError = 0;
		FieldProperties.ErrorKind = "";
	EndIf;
	
EndProcedure

// For the CheckTableField procedure.
Function FieldOrTabularSectionProperties(FieldOrTabularSectionName, Context, IsFirstField)
	
	Result = New Structure;
	Result.Insert("IsTabularSection", False);
	Result.Insert("Collection");
	Result.Insert("Metadata");
	Result.Insert("Type");
	
	TableMetadata  = Context.TableMetadata;
	TablesTypeProperties = Context.TablesTypeProperties;
	
	For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
		If TabularSectionsCollection.Key = "StandardTabularSections" Then
			For Each StandardTabularSection In TableMetadata.StandardTabularSections Do
				If Upper(FieldOrTabularSectionName) = Upper(StandardTabularSection.Name) Then
					Result.Metadata = StandardTabularSection;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = TableMetadata[TabularSectionsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.IsTabularSection = True;
			Result.Collection = TabularSectionsCollection.Key;
			Return Result;
		EndIf;
	EndDo;
	
	For Each FieldsCollection In TablesTypeProperties.FieldCollections Do
		If FieldsCollection.Key = "StandardAttributes" Then
			Number = 0;
			For Each StandardAttribute In TableMetadata.StandardAttributes Do
				Number = Number + 1;
				If Upper(FieldOrTabularSectionName) = Upper(StandardAttribute.Name) Then
					Result.Metadata = StandardAttribute;
					Break;
				EndIf;
			EndDo;
		Else
			Result.Metadata = TableMetadata[FieldsCollection.Key].Find(FieldOrTabularSectionName);
		EndIf;
		If Result.Metadata <> Undefined Then
			Result.Collection = FieldsCollection.Key;
			If Result.Collection = "Columns" Then
				Result.Type = New TypeDescription;
				For Each RefMetadata In Result.Metadata.References Do
					Result.Type = New TypeDescription(Result.Type, RefMetadata.Type.Types());
				EndDo;
			Else
				Result.Type = Result.Metadata.Type;
			EndIf;
			Return Result;
		EndIf;
	EndDo;
	
	If TablesTypeProperties.CommonAttributes <> "Missing" Then
		Result.Metadata = Metadata.CommonAttributes.Find(FieldOrTabularSectionName);
		If Result.Metadata <> Undefined Then
			Result.Collection = "CommonAttributes";
			Result.Type = Result.Metadata.Type;
			Return Result;
		EndIf;
	EndIf;
	
	If TablesTypeProperties.CollectionName = "Constants" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Value")
		 Or Upper(FieldOrTabularSectionName) = Upper("Value") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = TableMetadata.Type;
			Result.Insert("DefaultOrder", "001"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
		
	ElsIf TablesTypeProperties.CollectionName = "Sequences" Then
		
		If Upper(FieldOrTabularSectionName) = Upper("Period")
		 Or Upper(FieldOrTabularSectionName) = Upper("Period") Then
		
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription("Date");
			Result.Insert("DefaultOrder", "001"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
		
		If Upper(FieldOrTabularSectionName) = Upper("Recorder")
		 Or Upper(FieldOrTabularSectionName) = Upper("Recorder") Then
			
			Result.Collection = "SpecialFields";
			Result.Type = New TypeDescription;
			For Each DocumentMetadata In TableMetadata.Documents Do
				Result.Type = New TypeDescription(Result.Type, "DocumentRef." + DocumentMetadata.Name);
			EndDo;
			Result.Insert("DefaultOrder", "002"); // See the AddMainFieldOrder procedure.
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function TabularSectionFieldProperties(TabularSectionFieldName, TabularSectionMetadata, CollectionName, TableMetadata)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("TabularSectionName", TabularSectionMetadata.Name);
	
	If Upper(TabularSectionFieldName) = Upper("Ref")
	 Or Upper(TabularSectionFieldName) = Upper("Ref") Then
		
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
	EndIf;
	
	For Each StandardAttribute In TabularSectionMetadata.StandardAttributes Do
		If Upper(TabularSectionFieldName) = Upper(StandardAttribute.Name) Then
			Result.Type = StandardAttribute.Type;
			Return Result;
		EndIf;
	EndDo;
	
	If CollectionName = "TabularSections" Then
		FieldMetadata = TabularSectionMetadata.Attributes.Find(TabularSectionFieldName);
		If FieldMetadata <> Undefined Then
			Result.Type = FieldMetadata.Type;
			Result.Insert("TabularSectionMetadata", TabularSectionMetadata);
			Return Result;
		EndIf;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableExtensions and CheckTableField procedures.
Function RecalculationFieldProperties(RecalculationFieldName, RecalculationMetadata, TableMetadata)
	
	Result = New Structure;
	Result.Insert("Type");
	Result.Insert("Collection");
	Result.Insert("Metadata");
	
	If Upper(RecalculationFieldName) = Upper("RecalculationObject")
	 Or Upper(RecalculationFieldName) = Upper("RecalculationObject") Then
		
		FieldName = "Recorder";
		
	ElsIf Upper(RecalculationFieldName) = Upper("CalculationType")
	      Or Upper(RecalculationFieldName) = Upper("CalculationType") Then
	
		FieldName = "CalculationType";
	EndIf;
	
	If ValueIsFilled(FieldName) Then
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If Upper(FieldName) = Upper(StandardAttribute.Name) Then
				Result.Collection = "StandardAttributes";
				Result.Metadata = StandardAttribute;
				Result.Type = StandardAttribute.Type;
				Return Result;
			EndIf;
		EndDo;
		Return Undefined;
	EndIf;
	
	FieldMetadata = RecalculationMetadata.Dimensions.Find(RecalculationFieldName);
	If FieldMetadata <> Undefined Then
		Result.Type = FieldMetadata.RegisterDimension.Type;
		Result.Collection = "SpecialFields";
		Number = 200 + TableMetadata.Dimensions.IndexOf(FieldMetadata) + 1;
		Result.Insert("DefaultOrder", Number); // See the AddMainFieldOrder procedure.
		Return Result;
	EndIf;
	
	Return Undefined;
	
EndFunction

// For the CheckTableField procedure.
Procedure AddFieldTypesAdditional(FieldDetails, Index, CurrentFieldProperties, Context)
	
	// Additionally collecting types to use in service procedures.
	
	// Expanding properties of the Field node to use in service procedures.
	If Index = 0 Or Index = 1 AND CurrentFieldProperties.Property("TabularSectionName") Then
		If FieldDetails.NameContent.Count() > 1 Then
			FieldDetails.Insert("NextFieldTables", New Array);
			If Index = 1 Then
				FieldDetails.NextFieldTables.Add(Undefined);
			EndIf;
		EndIf;
		If Index = 0 AND Not Context.TablesTypeProperties.IsReferenceType Then
			AddMainFieldOrder(CurrentFieldProperties, Context);
		EndIf;
	EndIf;
	
	For Each FieldNode In FieldDetails.Properties.FieldNodes Do
		If CurrentFieldProperties.Property("DefaultOrder")
		   AND Not FieldNode.Property("DefaultOrder") Then
			FieldNode.Insert("DefaultOrder", CurrentFieldProperties.DefaultOrder);
		EndIf;
		If FieldDetails.Property("NextFieldTables")
		   AND Not FieldNode.Property("NextFieldTables") Then
			FieldNode.Insert("NextFieldTables", FieldDetails.NextFieldTables);
		EndIf;
		If Not FieldNode.Property("FieldTypes") Then
			FieldNode.Insert("FieldTypes", New Array);
			SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context);
		EndIf;
		If CurrentFieldProperties.Property("TabularSectionName")
		   AND Upper(CurrentFieldProperties.TabularSectionName) = Upper(FieldDetails.NameContent[0]) Then
			
			FieldNode.FieldTypes.Add(CurrentFieldProperties.TabularSectionName);
		EndIf;
		If Index > FieldNode.FieldTypes.Count() - 1 Then
			FieldNode.FieldTypes.Add(CurrentFieldProperties.Type);
		EndIf;
		FieldNode.FieldTypes[Index] = New TypeDescription(FieldNode.FieldTypes[Index],
			CurrentFieldProperties.Type.Types());
	EndDo;
	
	// Adding field types as a string to check changes in service procedures.
	FullFieldName = Context.TablesTypeProperties.LanguageRussian + "." + Upper(Context.TableMetadata.Name);
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		FullFieldName = FullFieldName + "." + Upper(CurrentFieldProperties.TabularSectionName);
	EndIf;
	
	FullFieldName = FullFieldName + "." + FieldDetails.NameContent[Index];
	
	If Not FieldDetails.Property("AllFields") Then
		FieldDetails.Insert("AllFields",       New Map);
		FieldDetails.Insert("AllFieldsTypes", New ValueList);
	EndIf;
	If FieldDetails.AllFields.Get(FullFieldName) <> Undefined Then
		Return;
	EndIf;
	FieldDetails.AllFields.Insert(FullFieldName, True);
	
	TypesString = DataStringForHashing(CurrentFieldProperties.Type);
	FieldDetails.AllFieldsTypes.Add(TypesString, FullFieldName);
	
EndProcedure

// For the CheckTableField procedure.
Procedure FillFieldTypesAsStringAdditional(FieldDetails)
	
	If FieldDetails.AllFieldsTypes.Count() > 1 Then
		FieldDetails.AllFieldsTypes.SortByPresentation();
	EndIf;
	TypesString = StrConcat(FieldDetails.AllFieldsTypes.UnloadValues(), Chars.LF);
	FieldNodes = FieldDetails.Properties.FieldNodes;
	
	For Each FieldNode In FieldNodes Do
		FieldNode.Insert("TypesString", TypesString);
	EndDo;
	
	FieldDetails.Delete("AllFields");
	FieldDetails.Delete("AllFieldsTypes");
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure AddMainFieldOrder(CurrentFieldProperties, Context)
	
	If CurrentFieldProperties.Collection = "SpecialFields" Then
		Return; // It is set in the FieldOrTabularSectionProperties function.
	EndIf;
	
	TableMetadata = Context.TableMetadata;
	FieldMetadata    = CurrentFieldProperties.Metadata;
	
	If CurrentFieldProperties.Collection = "StandardAttributes" Then
		Index = 0;
		For Each StandardAttribute In TableMetadata.StandardAttributes Do
			If StandardAttribute = FieldMetadata Then
				Break;
			EndIf;
			Index = Index + 1;
		EndDo;
		Number = 100 + Index + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Dimensions" Then
		Number = 200 + TableMetadata.Dimensions.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Resources" Then
		Number = 300 + TableMetadata.Resources.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "Attributes" Then
		Number = 400 + TableMetadata.Attributes.IndexOf(FieldMetadata) + 1;
		
	ElsIf CurrentFieldProperties.Collection = "CommonAttributes" Then
		Number = 500 + Context.TablesTypeProperties.CommonAttributes.IndexOf(FieldMetadata) + 1;
	EndIf;
	
	CurrentFieldProperties.Insert("DefaultOrder", String(Number));
	
EndProcedure

// For the AddFieldTypesAdditional procedure.
Procedure SetFieldContainsNull(FieldNode, CurrentFieldProperties, Context)
	
	If Context.TablesTypeProperties.CollectionName <> "Catalogs"
	   AND Context.TablesTypeProperties.CollectionName <> "ChartsOfCharacteristicTypes"
	 Or Not Context.TableMetadata.Hierarchical Then
		
		Return;
	EndIf;
	
	If Context.TablesTypeProperties.CollectionName = "Catalogs"
	   AND Context.TableMetadata.HierarchyType
	       <> Metadata.ObjectProperties.HierarchyType.HierarchyFoldersAndItems Then
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Property("TabularSectionName") Then
		If CurrentFieldProperties.Property("TabularSectionMetadata")
		   AND CurrentFieldProperties.TabularSectionMetadata.Use
		      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
			
			FieldNode.Insert("FieldContainsNull");
		EndIf;
		
		Return;
	EndIf;
	
	If CurrentFieldProperties.Collection = "Attributes"
	   AND CurrentFieldProperties.Metadata.Use
	      <> Metadata.ObjectProperties.AttributeUse.ForFolderAndItem Then
		
		FieldNode.Insert("FieldContainsNull");
	EndIf;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
Procedure CheckTableExtensions(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	If TablesTypeProperties.TabularPartCollections.Count() = 0
	   AND TablesTypeProperties.CollectionName <> "CalculationRegisters" Then
		Return;
	EndIf;
	
	TableMetadata = Context.TableMetadata;
	
	For Each TableExtension In TableFields.Value.Extensions Do
		
		If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
			ExtensionMetadata = TableMetadata.Recalculations.Find(TableExtension.Key);
		Else
			For Each TabularSectionsCollection In TablesTypeProperties.TabularPartCollections Do
				If TabularSectionsCollection.Key = "StandardTabularSections" Then
					For Each StandardTabularSection In TableMetadata.StandardTabularSections Do
						If Upper(TableExtension.Key) = Upper(StandardTabularSection.Name) Then
							ExtensionMetadata = StandardTabularSection;
							Break;
						EndIf;
					EndDo;
				Else
					ExtensionMetadata = TableMetadata[TabularSectionsCollection.Key].Find(TableExtension.Key);
				EndIf;
				If ExtensionMetadata <> Undefined Then
					Break;
				EndIf;
			EndDo;
		EndIf;
		If ExtensionMetadata = Undefined Then
			Continue;
		EndIf;
		TableExtension.Value.TableExists = True;
		
		For Each TableField In TableExtension.Value.Fields Do
			FieldDetails = New Structure;
			FieldDetails.Insert("NameContent", StrSplit(TableField.Key, "."));
			FieldDetails.Insert("Properties",    TableField.Value);
			FieldDetails.Insert("FieldType",     New TypeDescription);
			
			Index = 0;
			If TablesTypeProperties.CollectionName = "CalculationRegisters" Then
				FieldProperties = RecalculationFieldProperties(FieldDetails.NameContent[Index],
					ExtensionMetadata, TableMetadata);
			Else
				FieldProperties = TabularSectionFieldProperties(FieldDetails.NameContent[Index],
					ExtensionMetadata, TabularSectionsCollection.Key, TableMetadata);
			EndIf;
			
			If FieldProperties = Undefined Then
				FieldDetails.Properties.FieldWithError = Index + 1;
				FieldDetails.Properties.ErrorKind = "NotFound";
				Continue;
			EndIf;
			CheckNextPointSeparatedField(FieldDetails, Index, FieldProperties, Context);
			FillFieldTypesAsStringAdditional(FieldDetails);
			If FieldDetails.Properties.FieldWithError = 0 Then
				CheckFieldTypes(FieldDetails, Context);
			EndIf;
		EndDo;
		
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes and CheckTableExtensions procedures.
Procedure CheckFieldTypes(FieldDetails, Context)
	
	FieldTypesDetails = FieldDetails.FieldType;
	
	For Each TypeDetails In FieldDetails.Properties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		If ValueIsFilled(TypeProperties.TypeCollectionName)
		   AND Metadata[TypeProperties.TypeCollectionName].Find(TypeProperties.TypeCollectionObjectName) = Undefined Then
			Continue;
		EndIf;
		Type = Type(TypeDetails.Value.TypeName);
		TypeProperties.ContainsType = FieldTypesDetails.ContainsType(Type);
	EndDo;
	
EndProcedure

// For the CheckFieldTablesAndFieldsTypes procedure.
Procedure CheckPredefinedTableValues(TableFields, Context)
	
	TablesTypeProperties = Context.TablesTypeProperties;
	
	If TableFields.Value.Predefined.Count() = 0 Then
		Return;
	EndIf;
	
	If TablesTypeProperties.HasPredefined Then
		TableMetadata = Context.TableMetadata;
		
		If TablesTypeProperties.CollectionName = "Enums" Then
			PredefinedItemsNames = New Array;
			For Each EnumValue In TableMetadata.EnumValues Do
				PredefinedItemsNames.Add(EnumValue.Name);
			EndDo;
		Else
			PredefinedItemsNames = New Array(TableMetadata.GetPredefinedNames());
		EndIf;
	Else
		PredefinedItemsNames = New Array;
	EndIf;
	
	PredefinedItemsNames.Add("EmptyRef");
	PredefinedItemsNames.Add("EmptyRef");
	
	For Each Predefined In TableFields.Value.Predefined Do
		For Each PredefinedItemName In PredefinedItemsNames Do
			If Upper(PredefinedItemName) = Predefined.Key Then
				Predefined.Value.NameExists = True;
				Break;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure


// For the RestrictionStructure function.
Procedure MarkIncorrectFieldsTablesAndFieldsTypesNames(TablesFields, Context)
	
	For Each TablesType In TablesFields Do
		For Each TableDetails In TablesType.Value Do
			TableProperties = TableDetails.Value;
			
			If Not TableProperties.TableExists Then
				For Each Source In TableProperties.Sources Do
					SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'Не найдена таблица ""%1""'; en = 'Table ""%1"" not found'; pl = 'Nie znaleziono tabeli ""%1""';de = 'Tabelle ""%1"" nicht gefunden';ro = 'Tabelul ""%1"" nu a fost găsit';tr = '""%1"" tablo bulunamadı'; es_ES = 'Tabla ""%1"" no se ha encontrado'"), Source.Chars), , 2);
				EndDo;
				If TableProperties.Property("FirstField")
				   AND TableProperties.FirstField.FirstSource <> Undefined Then
					
					SetErrorInFieldNameString(Context, TableProperties.FirstField.FirstSource.Key,
						NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde';ro = 'Câmpul nu a fost găsit, deoarece nu a fost găsit tabelul ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı'; es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""'"), 0, ,
						TableProperties.FirstField.FirstSource.Value);
				EndIf;
				For Each PredefinedItemDetails In TableProperties.Predefined Do
					For Each Source In PredefinedItemDetails.Value.Sources Do
						NameContent = StrSplit(Source.Chars, ".");
						
						SetErrorInRow(Source, StringFunctionsClientServer.SubstituteParametersToString(
								NStr("ru = 'Предопределенное значение не найдено, так как не найдена таблица ""%1""'; en = 'Predefined value is not found as the ""%1"" table is not found'; pl = 'Predefiniowanej wartości nie znaleziono, ponieważ nie znaleziono tabeli ""%1""';de = 'Der vordefinierte Wert wurde nicht gefunden, da die Tabelle ""%1"" nicht gefunden wurde';ro = 'Valoarea predefinită nu a fost găsită, deoarece nu a fost găsit tabelul ""%1""';tr = '""%1"" tablo bulunmadığından dolayı önceden tanımlanmış değer bulunamadı'; es_ES = 'Valor predeterminado no encontrado, porque la tabla no se ha encontrado ""%1""'"),
								NameContent[0] + "." + NameContent[1]), , 2);
					EndDo;
				EndDo;
				Continue;
			EndIf;
			
			For Each PredefinedItemDetails In TableProperties.Predefined Do
				PredefinedOptionProperties = PredefinedItemDetails.Value;
				If PredefinedOptionProperties.NameExists Then
					Continue;
				EndIf;
				For Each Source In PredefinedOptionProperties.Sources Do
					NameContent = StrSplit(Source.Chars, ".");
					Source.ErrorPosition = StrLen(NameContent[0] + "." + NameContent[1]) + 1;
					Source.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(
						NStr("ru = 'Не найдено предопределенное значение ""%1""'; en = 'Predefined value ""%1"" is not found'; pl = 'Nie znaleziono zdefiniowanej wartość ""%1""';de = 'Kein vordefinierter Wert ""%1"" gefunden';ro = 'Nu a fost găsită valoarea predefinită ""%1""';tr = '""%1"" Önceden tanımlanmış değer bulunamadı'; es_ES = 'No se ha encontrado un valor predeterminado ""%1""'"), NameContent[2]);
				EndDo;
			EndDo;
			
			For Each FieldDetails In TableProperties.Fields Do
				MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
			EndDo;
			
			For Each ExtensionDetails In TableProperties.Extensions Do
				ExtensionProperties = ExtensionDetails.Value;
				If Not ExtensionProperties.TableExists Then
					For Each Source In ExtensionProperties.Sources Do
						SetErrorInRow(Source,
							StringFunctionsClientServer.SubstituteParametersToString(
								NStr("ru = 'Не найдена таблица ""%1""'; en = 'Table ""%1"" not found'; pl = 'Nie znaleziono tabeli ""%1""';de = 'Tabelle ""%1"" nicht gefunden';ro = 'Tabelul ""%1"" nu a fost găsit';tr = '""%1"" tablo bulunamadı'; es_ES = 'Tabla ""%1"" no se ha encontrado'"), Source.Chars), , 2);
					EndDo;
					If ExtensionProperties.Property("FirstField")
					   AND ExtensionProperties.FirstField.FirstSource <> Undefined Then
						
						SetErrorInFieldNameString(Context, ExtensionProperties.FirstField.FirstSource.Key,
							NStr("ru = 'Поле не найдено, так как не найдена таблица ""%1""'; en = 'Field is not found as the ""%1"" table is not found'; pl = 'Nie znaleziono pola, ponieważ nie znaleziono tabeli ""%1""';de = 'Das Feld wurde nicht gefunden, weil die Tabelle ""%1"" nicht gefunden wurde';ro = 'Câmpul nu a fost găsit, deoarece nu a fost găsit tabelul ""%1""';tr = '""%1"" tablo bulunmadığından dolayı alan bulunamadı'; es_ES = 'Campo no encontrado, porque la tabla no se ha encontrado ""%1""'"), 0, ,
							ExtensionProperties.FirstField.FirstSource.Value);
					EndIf;
					Continue;
				EndIf;
				For Each FieldDetails In ExtensionProperties.Fields Do
					MarkIncorrectFieldAndFieldTypes(FieldDetails, Context);
				EndDo;
			EndDo;
			
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure MarkIncorrectFieldAndFieldTypes(FieldDetails, Context)
	
	FieldProperties = FieldDetails.Value;
	If FieldProperties.FieldWithError = 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			EOF = False;
			If FieldProperties.ErrorKind = "TabularSectionNoField" Then
				EOF = True;
				ErrorTemplate = NStr("ru = 'Не указано поле после табличной части ""%1"" таблицы ""%2""'; en = 'Field is not specified after the ""%1"" tabular section of the ""%2"" table'; pl = 'Nie zaznaczono pola po części tabelarycznej ""%1"" tabeli ""%2""';de = 'Nach dem Tabellenteil ""%1"" der Tabelle ""%2"" ist kein Feld angegeben';ro = 'După secțiunea tabelară ""%1"" a tabelului ""%2"" nu este indicat câmpul';tr = '""%1"" tablonun sekmeli bölümünden sonraki ""%2"" alan belirtilmedi'; es_ES = 'No se ha indicado un campo después de la sección tabular ""%1"" de la tabla ""%2""'");
				
			ElsIf FieldProperties.ErrorKind = "AdditionalTableTabularSection" Then
				ErrorTemplate = NStr("ru = 'Табличная часть ""%1"" не поддерживается для дополнительной таблицы ""%2""'; en = 'Tabular section ""%1"" is not supported for the additional table ""%2""'; pl = 'Część tabelaryczna ""%1"" nie jest obsługiwana dla tabeli dodatkowej ""%2""';de = 'Das Tabellenteil ""%1"" wird für die Zusatztabelle ""%2"" nicht unterstützt';ro = 'Secțiunea tabelară ""%1"" nu este susținută pentru tabelul suplimentar ""%2""';tr = '""%1"" Numaralı tablo ""%2"" ek tablo için desteklenmiyor'; es_ES = 'La sección tabular ""%1"" no se admite para la tabla adicional ""%2""'");
				
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("ru = 'Недопустимо использовать поле ""%1"" таблицы ""%2""'; en = 'Cannot use the ""%1"" field of the ""%2"" table'; pl = 'Niedopuszczalne jest stosowanie pola ""%1"" tabeli ""%2""';de = 'Das Feld ""%1"" der Tabelle ""%2"" darf nicht verwendet werden';ro = 'Câmpul ""%1"" al tabelului ""%2"" nu poate fi utilizat';tr = '""%1"" tablonun ""%2"" alanı kullanılamaz'; es_ES = 'No se admite usar el campo ""%1"" de la tabla ""%2""'");
				
			ElsIf FieldProperties.ErrorKind = "Denied" Then
				ErrorTemplate = NStr("ru = 'Запрещено использовать поле ""%1"" таблицы ""%2""'; en = 'It is prohibited to use the ""%1"" field of the ""%2"" table'; pl = 'Nie wolno używać pola ""%1"" tabeli ""%2""';de = 'Es ist verboten das Feld ""%1"" der Tabelle ""%2"" zu benutzen';ro = 'Câmpul ""%1"" al tabelului ""%2"" nu poate fi utilizat';tr = '""%1"" tablonun ""%2"" alanı kullanılamaz'; es_ES = 'Está prohibido usar el campo ""%1"" de la tabla ""%2""'");
			Else
				ErrorTemplate = NStr("ru = 'Не найдено поле ""%1"" таблицы ""%2""'; en = '""%1"" field of the ""%2"" table is not found'; pl = 'Nie znaleziono pola ""%1"" tabeli ""%2""';de = 'Kein Feld ""%1"" der Tabelle ""%2"" gefunden';ro = 'Câmpul ""%1"" al tabelului ""%2"" nu a fost găsit';tr = '""%1"" tablonun ""%2"" alanı bulunamadı'; es_ES = 'No se ha encontrado el campo ""%1"" de la tabla ""%2""'");
			EndIf;
			SetErrorInFieldNameString(Context,
				 SourceDetails.Key, ErrorTemplate, 1, True, SourceDetails.Value, EOF);
		EndDo;
		Return;
	EndIf;
	
	If FieldProperties.FieldWithError > 1 Then
		For Each SourceDetails In FieldDetails.Value.Sources Do
			If FieldProperties.ErrorKind = "TabularSectionAfterDot" Then
				ErrorTemplate = NStr("ru = 'Табличная часть ""%1"" не поддерживается ""через точку"" от поля'; en = 'Tabular section ""%1"" is not supported being period-separated from the field'; pl = 'Część tabelaryczna ""%1"" nie jest obsługiwana ""przez punkt"" od pola';de = 'Der Tabellenteil ""%1"" wird nicht ""durch einen Punkt"" aus dem Feld unterstützt';ro = 'Secțiunea tabelară ""%1"" nu este susținută cu separare ""prin punct"" de la câmp';tr = '""%1"" tablo kısmı ""nokta ile"" alandan desteklenmez'; es_ES = 'La sección tabular ""%1"" no se admite ""con puntos"" del campo'");
				
			ElsIf FieldProperties.ErrorKind = "Illegal" Then
				ErrorTemplate = NStr("ru = 'Недопустимо использовать поле ""%1""'; en = 'Cannot use the ""%1"" field'; pl = 'Niedopuszczalne jest stosowanie pola ""%1""';de = 'Es ist nicht erlaubt das Feld ""%1"" zu benutzen';ro = 'Nu puteți utiliza câmpul ""%1""';tr = '""%1"" alan kullanılamaz'; es_ES = 'No se admite usar el campo ""%1""'");
				
			ElsIf FieldProperties.ErrorKind = "Denied" Then
				ErrorTemplate = NStr("ru = 'Запрещено использовать поле ""%1""'; en = 'It is prohibited to use the ""%1"" field'; pl = 'Nie wolno używać pola ""%1""';de = 'Es ist verboten das Feld ""%1"" zu benutzen';ro = 'Nu puteți utiliza câmpul ""%1""';tr = '""%1"" alan kullanılamaz'; es_ES = 'Está prohibido usar el campo ""%1""'");
			Else
				ErrorTemplate = NStr("ru = 'Не найдено поле ""%1""'; en = 'Field ""%1"" not found'; pl = 'Nie znaleziono pola ""%1""';de = 'Feld ""%1"" nicht gefunden';ro = 'Câmpul ""%1"" nu a fost găsit';tr = '""%1"" alan bulunamadı'; es_ES = 'No se ha encontrado el campo ""%1""'");
			EndIf;
			SetErrorInFieldNameString(Context,
				SourceDetails.Key, ErrorTemplate, FieldProperties.FieldWithError, True);
		EndDo;
		Return;
	EndIf;
	
	NameContent = StrSplit(FieldDetails.Key, ".");
	If NameContent.Count() > 1
	   AND (    NameContent[1] = Upper("Ref")
	      Or NameContent[1] = Upper("Ref") )
	   AND FieldProperties.Collection <> "TabularSections"
	   AND FieldProperties.Collection <> "StandardTabularSections" Then
		
			For Each SourceDetails In FieldDetails.Value.Sources Do
				ErrorTemplate = NStr("ru = 'Поле ""%1"" избыточно указывать ""через точку"" от любого поля'; en = 'It is redundant to indicate a %1 field separated by period from another field'; pl = 'Pole ""%1"" ponadto wskazywać ""przez kropkę"" od każdego pola';de = 'Das Feld ""%1"" sollte übermäßig ""durch einen Punkt"" von jedem Feld aus angegeben werden';ro = 'Indicarea câmpului ""%1"" cu separare ""prin punct"" de la orice câmp este excesivă';tr = '""%1"" alan herhangi alandan ""nokta ile"" belirt'; es_ES = 'Es excedente indicar campo ""%1"" ""con puntos"" de cualquier campo'");
				SetErrorInFieldNameString(Context,
					SourceDetails.Key, ErrorTemplate, 2, True);
		EndDo;
		Return;
	EndIf;
	
	For Each TypeDetails In FieldProperties.ContainsTypes Do
		TypeProperties = TypeDetails.Value;
		For Each SourceDetails In TypeDetails.Value.Sources Do
			If TypeOf(SourceDetails.Key) = Type("ValueTableRow") Then
				If Not TypeProperties.ContainsType Then
					SetErrorInRow(SourceDetails.Key,
						StringFunctionsClientServer.SubstituteParametersToString(
							NStr("ru = 'У поля ""%1"" не найден тип ""%2""'; en = '""%2"" type is not found in the ""%1"" field'; pl = 'Pole ""%1"" nie znaleziono typu ""%2""';de = 'Im Feld ""%1"" den Typ ""%2"" nicht gefunden';ro = 'Pentru câmpul ""%1"" nu a fost găsit tipul ""%2""';tr = '""%1"" alanın ""%2"" türü bulunamadı'; es_ES = 'Para el campo ""%1"" no se ha encontrado el tipo ""%2""'"),
							SourceDetails.Value.Chars,
							SourceDetails.Key.Chars),
						, 2);
				EndIf;
			EndIf;
		EndDo;
	EndDo;
	
EndProcedure

// For the MarkIncorrectFieldsTablesAndFieldsTypesNames procedure.
Procedure SetErrorInFieldNameString(Context, Row, ErrorTemplate, FieldWithError,
			InsertName = False, Table = Null, EOF = False)
	
	If ValueIsFilled(Row.ErrorText) Then
		Return;
	EndIf;
	
	If TypeOf(InsertName) = Type("String") Then
		NameContent = StrSplit(InsertName, ".");
		InsertName = True;
	Else
		NameContent = StrSplit(Row.Chars, ".");
	EndIf;
	
	If NameContent.Count() > 1
	   AND Context.Aliases.Get(Upper(NameContent[0])) <> Undefined Then
		
		Row.ErrorPosition = StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndIf;
	
	For Number = 1 To FieldWithError - 1 Do
		Row.ErrorPosition = Row.ErrorPosition + StrLen(NameContent[0]) + 1;
		NameContent.Delete(0);
	EndDo;
	If EOF Then
		Row.ErrorPosition = Row.ErrorPosition + StrLen(NameContent[0]);
	EndIf;
	FieldName = NameContent[0];
	
	If InsertName AND Table <> Null Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			FieldName, ?(ValueIsFilled(Table), Table, Context.MainTable));
			
	ElsIf InsertName Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate, FieldName);
		
	ElsIf Table <> Null Then
		Row.ErrorText = StringFunctionsClientServer.SubstituteParametersToString(ErrorTemplate,
			?(ValueIsFilled(Table), Table, Context.MainTable));
	Else
		Row.ErrorText = ErrorTemplate;
	EndIf;
	
EndProcedure

#EndRegion

#EndRegion

#Region AccessUpdateProgressUpdate

Procedure UpdateProgressInBackground(Context, ResultAddress) Export
	
	ProgressUpdateStartDate = CurrentSessionDate();
	TimeConsumingOperations.ReportProgress(0); // Updating progress.
	
	ListsRows   = Context.StoredData.ListsRows;
	ListsProperties = Context.StoredData.ListsProperties;
	If Not Context.IsRepeatedProgressUpdate Then
		Context.StoredData.LatestUpdateDate = '00010101';
	EndIf;
	
	ActiveParameters = Undefined;
	TablesIDs = ListsWithRestrictionIDs(ActiveParameters);
	
	For Each KeyAndValue In TablesIDs Do
		If Not Context.ShowProcessedLists Then
			Continue;
		EndIf;
		If ListsRows.Get(KeyAndValue.Value) <> Undefined Then
			Continue;
		EndIf;
		AddNewListRow(Context, KeyAndValue.Value, KeyAndValue.Key);
	EndDo;
	
	Query = New Query;
	Query.SetParameter("MaxDate", MaxDateOnContinue());
	Query.SetParameter("LatestUpdateDate", Context.StoredData.LatestUpdateDate);
	Query.SetParameter("BlankUUID",
		CommonClientServer.BlankUUID());
	
	Context.StoredData.LatestUpdateDate = ProgressUpdateStartDate;
	
	QueriesTexts = New Array;
	QueriesTexts.Add(
	"SELECT
	|	AllUpdateLists.List AS List,
	|	MAX(AllUpdateLists.ItemsUpdate) AS ItemsUpdate,
	|	MAX(AllUpdateLists.AccessKeysUpdate) AS AccessKeysUpdate
	|FROM
	|	(SELECT DISTINCT
	|		DataAccessKeysUpdate.List AS List,
	|		TRUE AS ItemsUpdate,
	|		FALSE AS AccessKeysUpdate
	|	FROM
	|		InformationRegister.DataAccessKeysUpdate AS DataAccessKeysUpdate
	|	
	|	UNION ALL
	|	
	|	SELECT DISTINCT
	|		UsersAccessKeysUpdate.List,
	|		FALSE,
	|		TRUE
	|	FROM
	|		InformationRegister.UsersAccessKeysUpdate AS UsersAccessKeysUpdate) AS AllUpdateLists
	|
	|GROUP BY
	|	AllUpdateLists.List");
	
	QueriesTexts.Add(
	"SELECT
	|	UpdateKeys.List AS List,
	|	UpdateKeys.ForExternalUsers AS ForExternalUsers,
	|	UpdateKeys.UniqueKey = &BlankUUID AS IsMainRecord,
	|	MAX(UpdateKeys.JobSize) AS JobSize,
	|	MAX(UpdateKeys.RegisterRecordChangeDate) AS MaxChangeDate,
	|	MIN(UpdateKeys.RegisterRecordChangeDate) AS MinChangeDate
	|FROM
	|	InformationRegister.DataAccessKeysUpdate AS UpdateKeys
	|WHERE
	|	UpdateKeys.RegisterRecordChangeDate >= &LatestUpdateDate
	|
	|GROUP BY
	|	UpdateKeys.List,
	|	UpdateKeys.ForExternalUsers,
	|	UpdateKeys.UniqueKey = &BlankUUID
	|TOTALS BY
	|	List,
	|	ForExternalUsers");
	
	QueriesTexts.Add(StrReplace(QueriesTexts[1],
		"InformationRegister.DataAccessKeysUpdate",
		"InformationRegister.UsersAccessKeysUpdate"));
	
	If Context.CalculateByDataAmount Then
		QueriesTexts.Add(
		"SELECT
		|	UpdateKeys.List AS List,
		|	UpdateKeys.ForExternalUsers AS ForExternalUsers,
		|	UpdateKeys.JobParameters AS JobParameters
		|FROM
		|	InformationRegister.DataAccessKeysUpdate AS UpdateKeys
		|WHERE
		|	UpdateKeys.RegisterRecordChangeDate >= &LatestUpdateDate
		|	AND UpdateKeys.UniqueKey = &BlankUUID
		|	AND UpdateKeys.List <> UNDEFINED
		|TOTALS BY
		|	List");
		
		QueriesTexts.Add(StrReplace(QueriesTexts[3],
			"InformationRegister.DataAccessKeysUpdate",
			"InformationRegister.UsersAccessKeysUpdate"));
		
		QueriesTexts.Add(
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	Catalog.AccessKeys AS AccessKeys");
	EndIf;
	
	Query.Text = StrConcat(QueriesTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	
	AllUpdateLists = QueryResults[0].Unload();
	ItemsCountUpdateRows = New Array;
	AccessKeysCountUpdateRows = New Array;
	
	For Each UpdateList In AllUpdateLists Do
		If Not ValueIsFilled(UpdateList.List) Then
			Continue;
		EndIf;
		Row = ListsRows.Get(UpdateList.List);
		If Row = Undefined Then
			AddNewListRow(Context, UpdateList.List, "");
		EndIf;
	EndDo;
	
	RowsToDelete = New Array;
	For Each KeyAndValue In ListsRows Do
		Row = KeyAndValue.Value;
		UpdateList = AllUpdateLists.Find(Row.List, "List");
		If UpdateList = Undefined AND Not Context.ShowProcessedLists Then
			RowsToDelete.Add(Row);
			Continue;
		EndIf;
		ListProperties = ListsProperties.Get(Row.List);
		If UpdateList = Undefined Or Not UpdateList.ItemsUpdate Then
			ListProperties.ItemsUpdateJobSize = 0;
			ListProperties.LastUpdatedItem = Null;
			ListProperties.ExternalUsersItemsUpdateJobSize = 0;
			ListProperties.LastUpdatedItemForExtrenalUsers = Null;
			Row.ProcessedUsersItemsShare = 1;
			Row.ProcessedExternalUsersItemsShare = 1;
			If Context.CalculateByDataAmount Then
				If Row.ItemsProcessed <> 100 Then
					ItemsCountUpdateRows.Add(Row);
				EndIf;
			Else
				ResetItemsCount(Row, Context);
			EndIf;
			UpdateValueInRow(Row.ItemsProcessed, 100, Row, Context);
		EndIf;
		If UpdateList = Undefined Or Not UpdateList.AccessKeysUpdate Then
			ListProperties.AccessKeysUpdateJobSize = 0;
			ListProperties.LastUpdatedAccessKey = Null;
			ListProperties.ExternalUsersAccessKeysUpdateJobSize = 0;
			ListProperties.LastUpdatedAccessKeyForExtrenalUsers = Null;
			Row.ProcessedUsersAccessKeysShare = 1;
			Row.ProcessedExternalUsersAccessKeysShare = 1;
			If Context.CalculateByDataAmount Then
				If Row.AccessKeysProcessed <> 100 Then
					AccessKeysCountUpdateRows.Add(Row);
				EndIf;
			Else
				ResetAccessKeysCount(Row, Context);
			EndIf;
			UpdateValueInRow(Row.AccessKeysProcessed, 100, Row, Context);
		EndIf;
		If UpdateList = Undefined Then
			UpdateValueInRow(Row.LatestUpdate, '00010101', Row, Context);
			UpdateValueInRow(Row.FirstUpdateSchedule, MaxDate(), Row, Context);
		EndIf;
	EndDo;
	
	If Context.CalculateByDataAmount Then
		SelectionByLists = QueryResults[3].Select(QueryResultIteration.ByGroups);
		While SelectionByLists.Next() Do
			ListProperties = ListsProperties.Get(SelectionByLists.List);
			If ListProperties = Undefined Then
				Continue;
			EndIf;
			SelectionByUsersKinds = SelectionByLists.Select();
			While SelectionByUsersKinds.Next() Do
				If SelectionByUsersKinds.ForExternalUsers Then
					ListProperties.LastUpdatedItemForExtrenalUsers
						= SelectionByUsersKinds.JobParameters;
				Else
					ListProperties.LastUpdatedItem
						= SelectionByUsersKinds.JobParameters;
				EndIf;
			EndDo;
		EndDo;
		SelectionByLists = QueryResults[4].Select(QueryResultIteration.ByGroups);
		While SelectionByLists.Next() Do
			ListProperties = ListsProperties.Get(SelectionByLists.List);
			If ListProperties = Undefined Then
				Continue;
			EndIf;
			SelectionByUsersKinds = SelectionByLists.Select();
			While SelectionByUsersKinds.Next() Do
				If SelectionByUsersKinds.ForExternalUsers Then
					ListProperties.LastUpdatedAccessKeyForExtrenalUsers
						= SelectionByUsersKinds.JobParameters;
				Else
					ListProperties.LastUpdatedAccessKey
						= SelectionByUsersKinds.JobParameters;
				EndIf;
			EndDo;
		EndDo;
	EndIf;
	
	ItemsUpdateLists = QueryResults[1].Unload(QueryResultIteration.ByGroups);
	MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
		ItemsUpdateLists.Rows.UnloadColumn("List"), False);
	
	For Each UpdateDetails In ItemsUpdateLists.Rows Do
		Row = ListsRows.Get(UpdateDetails.List);
		If Row = Undefined Then
			Continue;
		EndIf;
		MetadataObject = MetadataObjectsByIDs.Get(UpdateDetails.List);
		If MetadataObject = Undefined Or Not ValueIsFilled(Row.List) Then
			If RowsToDelete.Find(Row) = Undefined Then
				RowsToDelete.Add(Row);
			EndIf;
			Continue;
		ElsIf TypeOf(MetadataObject) = Type("MetadataObject")
		        AND Not ValueIsFilled(Row.TableName) Then
			Row.TableName = MetadataObject.FullName();
		EndIf;
		ListProperties = ListsProperties.Get(Row.List);
		FillProcessedShares(Row, UpdateDetails, ListProperties, True, Context);
		If Not Context.CalculateByDataAmount Then
			Processed = ProcessedByShares(Row.ProcessedUsersItemsShare,
				Row.ProcessedExternalUsersItemsShare, Row.TableName, ActiveParameters);
			UpdateValueInRow(Row.ItemsProcessed, Processed, Row, Context);
			ResetItemsCount(Row, Context);
		Else
			If Context.IsRepeatedProgressUpdate Then
				ItemsCountUpdateRows.Add(Row);
			EndIf;
		EndIf;
	EndDo;
	
	AccessKeysUpdateLists = QueryResults[2].Unload(QueryResultIteration.ByGroups);
	MetadataObjectsByIDs = Common.MetadataObjectsByIDs(
		AccessKeysUpdateLists.Rows.UnloadColumn("List"), False);
	
	For Each UpdateDetails In AccessKeysUpdateLists.Rows Do
		MetadataObject = MetadataObjectsByIDs.Get(UpdateDetails.List);
		Row = ListsRows.Get(UpdateDetails.List);
		If Row = Undefined Then
			Continue;
		EndIf;
		If MetadataObject = Undefined Or Not ValueIsFilled(Row.List) Then
			If RowsToDelete.Find(Row) = Undefined Then
				RowsToDelete.Add(Row);
			EndIf;
			Continue;
		ElsIf TypeOf(MetadataObject) = Type("MetadataObject")
		        AND Not ValueIsFilled(Row.TableName) Then
			Row.TableName = MetadataObject.FullName();
		EndIf;
		ListProperties = ListsProperties.Get(Row.List);
		FillProcessedShares(Row, UpdateDetails, ListProperties, False, Context);
		If Not Context.CalculateByDataAmount Then
			Processed = ProcessedByShares(Row.ProcessedUsersAccessKeysShare,
				Row.ProcessedExternalUsersAccessKeysShare, Row.TableName, ActiveParameters);
			UpdateValueInRow(Row.AccessKeysProcessed, Processed, Row, Context);
			ResetAccessKeysCount(Row, Context);
		Else
			If Context.IsRepeatedProgressUpdate Then
				AccessKeysCountUpdateRows.Add(Row);
			EndIf;
		EndIf;
	EndDo;
	
	For Each RowToDelete In RowsToDelete Do
		ListsRows.Delete(RowToDelete.List);
		ListsProperties.Delete(RowToDelete.List);
		Index = Context.AddedRows.Find(RowToDelete);
		If Index <> Undefined Then
			Context.AddedRows.Delete(Index);
			Continue;
		EndIf;
		Context.DeletedRows.Insert(RowToDelete.List, True);
	EndDo;
	
	Index = Context.AddedRows.Count() - 1;
	While Index >= 0 Do
		If Not ValueIsFilled(Context.AddedRows[Index].TableName) Then
			Context.AddedRows.Delete(Index);
		EndIf;
		Index = Index - 1;
	EndDo;
	
	If Not Context.IsRepeatedProgressUpdate Then
		For Each RowDetails In ListsRows Do
			ItemsCountUpdateRows.Add(RowDetails.Value);
			AccessKeysCountUpdateRows.Add(RowDetails.Value);
		EndDo;
	EndIf;
	
	If Context.CalculateByDataAmount Then
		KeysCount = QueryResults[5].Unload()[0].Count;
		If Context.IsRepeatedProgressUpdate
		   AND Context.StoredData.KeysCount <> KeysCount Then
			
			For Each RowDetails In ListsRows Do
				If AccessKeysCountUpdateRows.Find(RowDetails.Value) = Undefined Then
					AccessKeysCountUpdateRows.Add(RowDetails.Value);
				EndIf;
			EndDo;
		EndIf;
		Context.StoredData.KeysCount = KeysCount;
	Else
		Context.StoredData.KeysCount = 0;
	EndIf;
	
	If Context.CalculateByDataAmount Then
		CurrentContext = New Structure;
		CurrentContext.Insert("AddedRows",                       Context.AddedRows);
		CurrentContext.Insert("ModifiedRows",                        Context.ModifiedRows);
		CurrentContext.Insert("ListsProperties",                         ListsProperties);
		CurrentContext.Insert("ListsRows",                           ListsRows);
		CurrentContext.Insert("ActiveParameters",                    ActiveParameters);
		CurrentContext.Insert("ItemsCountUpdateRows",     ItemsCountUpdateRows);
		CurrentContext.Insert("AccessKeysCountUpdateRows", AccessKeysCountUpdateRows);
		CurrentContext.Insert("TablesIDs",                    TablesIDs);
		CurrentContext.Insert("StoredData",                          Context.StoredData);
		UpdatedTotal = 100;
		CalculateUpdatedByDataCountTotal(CurrentContext, UpdatedTotal);
	Else
		If Context.StoredData.Property("ItemsByListsCount") Then
			Context.StoredData.Delete("ItemsByListsCount");
			Context.StoredData.Delete("AccessKeysByListsCount");
		EndIf;
		CountTotal = TablesIDs.Count();
		If ListsRows.Count() > CountTotal Then
			CountTotal = ListsRows.Count();
		EndIf;
		UpdatedTotal = (100 + 100) * (CountTotal - ListsRows.Count());
		For Each KeyAndValue In ListsRows Do
			Row = KeyAndValue.Value;
			UpdatedTotal = UpdatedTotal + Row.ItemsProcessed + Row.AccessKeysProcessed;
		EndDo;
		UpdatedTotal = UpdatedTotal / 2 / CountTotal;
	EndIf;
	If UpdatedTotal > 100 Then
		UpdatedTotal = 100;
	EndIf;
	Context.UpdatedTotal = Int(UpdatedTotal);
	
	UpdateTime = CurrentSessionDate() - ProgressUpdateStartDate;
	
	If Context.IsRepeatedProgressUpdate
	   AND UpdateTime > Context.ProgressUpdatePeriod Then
		
		Context.ProgressUpdatePeriod = UpdateTime;
	Else
		Context.Delete("ProgressUpdatePeriod");
	EndIf;
	
	If Not Context.IsRepeatedProgressUpdate AND UpdateTime > 60 Then
		Context.ProgressAutoUpdate = False;
	Else
		Context.Delete("ProgressAutoUpdate");
	EndIf;
	
	Filter = New Structure("Metadata", Metadata.ScheduledJobs.AccessUpdateAtRecordLevel);
	Jobs = ScheduledJobsServer.FindJobs(Filter);
	Enabled = False;
	For Each Job In Jobs Do
		If Job.Use Then
			Enabled = True;
			Break;
		EndIf;
	EndDo;
	
	If Not Enabled AND Context.UpdatedTotal < 100 Then
		Context.Insert("ScheduledJobDisabled");
	EndIf;
	
	PutToTempStorage(Context, ResultAddress);
	
EndProcedure

Procedure FillProcessedShares(String, UpdateDetails, ListProperties, IsItemsProcessing, Context)
	
	For Each UpdateProperties In UpdateDetails.Rows Do
		If IsItemsProcessing Then
			If UpdateProperties.ForExternalUsers Then
				JobSizeFieldName    = "ExternalUsersItemsUpdateJobSize";
				JobParametersFieldName = "LastUpdatedItemForExtrenalUsers";
				ShareFieldName              = "ProcessedExternalUsersItemsShare";
			Else
				JobSizeFieldName    = "ItemsUpdateJobSize";
				JobParametersFieldName = "LastUpdatedItem";
				ShareFieldName              = "ProcessedUsersItemsShare";
			EndIf;
		Else
			If UpdateProperties.ForExternalUsers Then
				JobSizeFieldName    = "ExternalUsersAccessKeysUpdateJobSize";
				JobParametersFieldName = "LastUpdatedAccessKeyForExtrenalUsers";
				ShareFieldName              = "ProcessedExternalUsersAccessKeysShare";
			Else
				JobSizeFieldName    = "AccessKeysUpdateJobSize";
				JobParametersFieldName = "LastUpdatedAccessKey";
				ShareFieldName              = "ProcessedUsersAccessKeysShare";
			EndIf;
		EndIf;
		MainRecordJobSize = ListProperties[JobSizeFieldName];
		NewRecordsJobSize = 0;
		For Each JobProperties In UpdateProperties.Rows Do
			If JobProperties.IsMainRecord Then
				If JobProperties.MaxChangeDate > String.LatestUpdate Then
					UpdateValueInRow(String.LatestUpdate,
						JobProperties.MaxChangeDate, String, Context);
				EndIf;
				MainRecordJobSize = JobProperties.JobSize;
			Else
				If JobProperties.MinChangeDate < String.FirstUpdateSchedule Then
					UpdateValueInRow(String.FirstUpdateSchedule,
						JobProperties.MinChangeDate, String, Context);
				EndIf;
				NewRecordsJobSize = JobProperties.JobSize;
			EndIf;
		EndDo;
		ListProperties[JobSizeFieldName] = MainRecordJobSize;
		If NewRecordsJobSize >= MainRecordJobSize Then
			ListProperties[JobParametersFieldName] = True;
			CurrentJobSize = NewRecordsJobSize;
		Else
			CurrentJobSize = MainRecordJobSize;
		EndIf;
		If CurrentJobSize = 1 Then
			String[ShareFieldName] = 0.99;
		ElsIf CurrentJobSize = 2 Then
			String[ShareFieldName] = 0.90;
		Else
			String[ShareFieldName] = 0.00;
		EndIf;
	EndDo;
	
EndProcedure

Function ProcessedByShares(ProcessedShareForUsers, ProcessedShareForExternalUsers, TableName, ActiveParameters)
	
	HasKeysForUsers = False;
	HasKeysForExternalUsers = False;
	Versions = ActiveParameters.ListsRestrictionsVersions.Get(TableName);
	If ValueIsFilled(Versions) Then
		HasKeysForUsers        = ValueIsFilled(StrGetLine(Versions, 1));
		HasKeysForExternalUsers = ValueIsFilled(StrGetLine(Versions, 2));
	EndIf;
	
	If ProcessedShareForUsers < 1 Then
		HasKeysForUsers = True;
	EndIf;
	If ProcessedShareForExternalUsers < 1 Then
		HasKeysForExternalUsers = True;
	EndIf;
	
	If HasKeysForUsers AND HasKeysForExternalUsers Then
		Processed = Int((ProcessedShareForUsers
					+ ProcessedShareForExternalUsers) / 2 * 100);
		
	ElsIf HasKeysForUsers Then
		Processed = Int(ProcessedShareForUsers * 100);
	Else
		Processed = Int(ProcessedShareForExternalUsers * 100);
	EndIf;
	
	Return Processed;
	
EndFunction

Procedure ResetItemsCount(Row, Context);
	
	UpdateValueInRow(Row.ItemCount, 0, Row, Context);
	UpdateValueInRow(Row.ProcessedItemsCount, 0, Row, Context);
	UpdateValueInRow(Row.ItemsForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.ItemsForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingItemsForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.LeftlUsersItemsShare, 0, Row, Context);
	UpdateValueInRow(Row.RemainingItemsForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.LeftExternalUsersItemsShare, 0, Row, Context);
	
EndProcedure

Procedure ResetAccessKeysCount(Row, Context);
	
	UpdateValueInRow(Row.AccessKeysCount, 0, Row, Context);
	UpdateValueInRow(Row.ProcessedAccessKeysCount, 0, Row, Context);
	UpdateValueInRow(Row.AccessKeysForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.AccessKeysForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.RemainingAccessKeysForUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.LeftUsersAccessKeysShare, 0, Row, Context);
	UpdateValueInRow(Row.RemainingAccessKeysForExternalUsersCount, 0, Row, Context);
	UpdateValueInRow(Row.LeftExternalUsersAccessKeysShare, 0, Row, Context);
	
EndProcedure

Procedure AddNewListRow(Context, List, TableName)
	
	Row = New Structure;
	Row.Insert("List", List);
	Row.Insert("ListPresentation", String(List));
	Row.Insert("TableName", TableName);
	Row.Insert("ItemsProcessed", 0);
	Row.Insert("AccessKeysProcessed", 0);
	Row.Insert("ItemCount", 0);
	Row.Insert("AccessKeysCount", 0);
	Row.Insert("ProcessedItemsCount", 0);
	Row.Insert("ProcessedAccessKeysCount", 0);
	Row.Insert("LatestUpdate", '00010101');
	Row.Insert("FirstUpdateSchedule", MaxDate());
	
	Row.Insert("ItemsForUsersCount", 0);
	Row.Insert("ProcessedUsersItemsShare", 1);
	Row.Insert("ItemsForExternalUsersCount", 0);
	Row.Insert("ProcessedExternalUsersItemsShare", 1);
	Row.Insert("AccessKeysForUsersCount", 0);
	Row.Insert("ProcessedUsersAccessKeysShare", 1);
	Row.Insert("AccessKeysForExternalUsersCount", 0);
	Row.Insert("ProcessedExternalUsersAccessKeysShare", 1);
	
	Row.Insert("RemainingItemsForUsersCount", 0);
	Row.Insert("LeftlUsersItemsShare", 0);
	Row.Insert("RemainingItemsForExternalUsersCount", 0);
	Row.Insert("LeftExternalUsersItemsShare", 0);
	Row.Insert("RemainingAccessKeysForUsersCount", 0);
	Row.Insert("LeftUsersAccessKeysShare", 0);
	Row.Insert("RemainingAccessKeysForExternalUsersCount", 0);
	Row.Insert("LeftExternalUsersAccessKeysShare", 0);
	
	Context.StoredData.ListsRows.Insert(List, Row);
	Context.AddedRows.Add(Row);
	
	Properties = New Structure;
	Properties.Insert("ItemsUpdateJobSize", 0);
	Properties.Insert("LastUpdatedItem", Null);
	Properties.Insert("AccessKeysUpdateJobSize", 0);
	Properties.Insert("LastUpdatedAccessKey", Null);
	
	Properties.Insert("ExternalUsersItemsUpdateJobSize", 0);
	Properties.Insert("LastUpdatedItemForExtrenalUsers", Null);
	Properties.Insert("ExternalUsersAccessKeysUpdateJobSize", 0);
	Properties.Insert("LastUpdatedAccessKeyForExtrenalUsers", Null);
	
	Context.StoredData.ListsProperties.Insert(List, Properties);
	
EndProcedure

Procedure CalculateUpdatedByDataCountTotal(Context, UpdatedTotal)
	
	TablesTypesByNames = AccessManagementInternalCached.LanguageSyntax().TablesTypes.ByNames;
	Context.Insert("TablesTypesByNames", TablesTypesByNames);
	
	If Not Context.StoredData.Property("ItemsByListsCount") Then
		FilItemsAndAccessKeysCountByLists(Context);
	EndIf;
	
	UpdateItemsAndAccessKeysCount(Context);
	
	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	
	TotalItemsCount = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		TotalItemsCount = TotalItemsCount + KeyAndValue.Value;
	EndDo;
	TotalItemsCount = ?(TotalItemsCount = 0, 100, TotalItemsCount);
	
	TotalAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		TotalAccessKeysCount = TotalAccessKeysCount + KeyAndValue.Value;
	EndDo;
	TotalAccessKeysCount = ?(TotalAccessKeysCount = 0, 100, TotalAccessKeysCount);
	
	UpdatedItemsTotal = 0;
	UpdatedAccessKeysTotal = 0;
	
	AddTotalItemsCount = 0;
	AddTotalAccessKeysCount = 0;
	
	TablesNamesWithItemsUpdate     = New Map;
	TablesNamesWithAccessKeysUpdate = New Map;
	
	For Each KeyAndValue In Context.ListsRows Do
		Row = KeyAndValue.Value;
		
		ItemsCount = ItemsByListsCount.Get(KeyAndValue.Value.TableName);
		If ItemsCount = Undefined Then
			If ItemsByListsCount.Count() = 0 Then
				Addition = 1;
			Else
				Addition = Int(TotalItemsCount / ItemsByListsCount.Count() / 10);
				Addition = ?(Addition = 0, 1, Addition);
			EndIf;
			AddTotalItemsCount = AddTotalItemsCount + Addition;
			UpdatedItemsTotal = UpdatedItemsTotal + 100 * Addition;
		Else
			UpdatedItemsTotal = UpdatedItemsTotal + Row.ItemsProcessed * ItemsCount;
			TablesNamesWithItemsUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
		
		AccessKeysCount = AccessKeysByListsCount.Get(KeyAndValue.Value.TableName);
		If AccessKeysCount = Undefined Then
			If AccessKeysByListsCount.Count() = 0 Then
				Addition = 1;
			Else
				Addition = Int(TotalAccessKeysCount / AccessKeysByListsCount.Count() / 10);
				Addition = ?(Addition = 0, 1, Addition);
			EndIf;
			AddTotalAccessKeysCount = AddTotalAccessKeysCount + Addition;
			UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + 100 * Addition;
		Else
			UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + Row.AccessKeysProcessed * AccessKeysCount;
			TablesNamesWithAccessKeysUpdate.Insert(KeyAndValue.Value.TableName, True);
		EndIf;
	EndDo;
	
	UpdatedItemsCount = 0;
	For Each KeyAndValue In ItemsByListsCount Do
		If TablesNamesWithItemsUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedItemsCount = UpdatedItemsCount + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedItemsTotal = UpdatedItemsTotal + UpdatedItemsCount  * 100;
		
	UpdatedAccessKeysCount = 0;
	For Each KeyAndValue In AccessKeysByListsCount Do
		If TablesNamesWithAccessKeysUpdate.Get(KeyAndValue.Key) = Undefined Then
			UpdatedAccessKeysCount = UpdatedAccessKeysCount + KeyAndValue.Value;
		EndIf;
	EndDo;
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal + UpdatedAccessKeysCount * 100;
	
	UpdatedItemsTotal = UpdatedItemsTotal
		/ (TotalItemsCount + AddTotalItemsCount);
	
	UpdatedAccessKeysTotal = UpdatedAccessKeysTotal
		/ (TotalAccessKeysCount + AddTotalAccessKeysCount);
	
	UpdatedTotal = (UpdatedItemsTotal + UpdatedAccessKeysTotal) / 2;
	
EndProcedure

Procedure FilItemsAndAccessKeysCountByLists(Context)
	
	ItemsByListsCount     = New Map;
	AccessKeysByListsCount = New Map;
	Context.StoredData.Insert("ItemsByListsCount",     ItemsByListsCount);
	Context.StoredData.Insert("AccessKeysByListsCount", AccessKeysByListsCount);
	
	RequestDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	
	TablesToUpdate = New Map;
	TablesIDs = Context.TablesIDs;
	For Each Row In Context.ItemsCountUpdateRows Do
		If TablesIDs.Get(Row.TableName) = Row.List Then
			TablesToUpdate.Insert(Row.TableName, Row.List);
		EndIf;
	EndDo;
	For Each Row In Context.AccessKeysCountUpdateRows Do
		If TablesIDs.Get(Row.TableName) = Row.List Then
			TablesToUpdate.Insert(Row.TableName, Row.List);
		EndIf;
	EndDo;
	
	Index = 0;
	TablesNames = New Array;
	For Each KeyAndValue In Context.TablesIDs Do
		If TablesToUpdate.Get(KeyAndValue.Key) = KeyAndValue.Value Then
			Continue;
		EndIf;
		TablesNames.Add(KeyAndValue.Key);
		Row = New Structure("List, TableName", KeyAndValue.Value, KeyAndValue.Key);
		AddItemsCountQueryText(RequestDetails, Row, Index, Context, False);
		AddItemsCountQueryText(RequestDetails, Row, Index, Context, True);
		AddQueryTextOfAccessKeysCount(RequestDetails, Row, Index, False);
		AddQueryTextOfAccessKeysCount(RequestDetails, Row, Index, True);
	EndDo;
	
	If RequestDetails.QueryPackageTexts.Count() = 0 Then
		Return;
	EndIf;
	
	QueryResults = ExecuteQueriesPackageByParts(RequestDetails);
	
	Index = 0;
	For Each TableName In TablesNames Do
		Selection = QueryResults[Index].Select();
		ItemsForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		ItemsForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		ItemsByListsCount[TableName] = ItemsForUsersCount
			+ ItemsForExternalUsersCount;
		
		Selection = QueryResults[Index].Select();
		AccessKeysForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		AccessKeysForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		AccessKeysByListsCount[TableName] = AccessKeysForUsersCount
			+ AccessKeysForExternalUsersCount;
	EndDo;
	
EndProcedure

Procedure UpdateItemsAndAccessKeysCount(Context)
	
	RequestDetails = New Structure("Query, QueryPackageTexts", New Query, New Array);
	Index = 0;
	For Each Row In Context.ItemsCountUpdateRows Do
		AddItemsCountQueryText(RequestDetails, Row, Index, Context, False);
		AddItemsCountQueryText(RequestDetails, Row, Index, Context, True);
		AddQueryTextOfRemainingItemsCount(RequestDetails, Row, Index, Context, False);
		AddQueryTextOfRemainingItemsCount(RequestDetails, Row, Index, Context, True);
	EndDo;
	For Each Row In Context.AccessKeysCountUpdateRows Do
		AddQueryTextOfAccessKeysCount(RequestDetails, Row, Index, False);
		AddQueryTextOfAccessKeysCount(RequestDetails, Row, Index, True);
		AddQueryTextOfRemainingAccessKeysCount(RequestDetails, Row, Index, Context, False);
		AddQueryTextOfRemainingAccessKeysCount(RequestDetails, Row, Index, Context, True);
	EndDo;
	
	If RequestDetails.QueryPackageTexts.Count() = 0 Then
		Return;
	EndIf;
	
	QueryResults = ExecuteQueriesPackageByParts(RequestDetails);

	ItemsByListsCount     = Context.StoredData.ItemsByListsCount;
	AccessKeysByListsCount = Context.StoredData.AccessKeysByListsCount;
	ListsRestrictionsVersions         = Context.ActiveParameters.ListsRestrictionsVersions;
	TablesTypesByNames               = Context.TablesTypesByNames;
	
	Index = 0;
	For Each Row In Context.ItemsCountUpdateRows Do
		Selection = QueryResults[Index].Select();
		Row.ItemsForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		Row.ItemsForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		ItemsCount = Row.ItemsForUsersCount + Row.ItemsForExternalUsersCount;
		If ValueIsFilled(Row.TableName) Then
			ItemsByListsCount.Insert(Row.TableName, ItemsCount);
		EndIf;
		
		If ItemsCount = 0 Then
			ResetItemsCount(Row, Context);
			UpdateValueInRow(Row.ItemsProcessed, 100, Row, Context);
			Index = Index + 2;
		Else
			ProcessedItemsCount = 0;
			ListProperties = Context.ListsProperties.Get(Row.List);
			HasKeysForUsers = False;
			HasKeysForExternalUsers = False;
			Versions = ListsRestrictionsVersions.Get(Row.TableName);
			If ValueIsFilled(Versions) Then
				HasKeysForUsers        = ValueIsFilled(StrGetLine(Versions, 1));
				HasKeysForExternalUsers = ValueIsFilled(StrGetLine(Versions, 2));
			EndIf;
			NameContent = StrSplit(Row.TableName, ".", False);
			TypeProperties = TablesTypesByNames.Get(Upper(NameContent[0]));
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedItem = ListProperties.LastUpdatedItem;
				Else
					LastUpdatedItem = ListProperties.LastUpdatedItemForExtrenalUsers;
				EndIf;
				If LastUpdatedItem = Null Or LastUpdatedItem = True Then
					RemainingItemsCount = -1;
				EndIf;
				If LastUpdatedItem <> Null Then
					If UsersKind = 0 Then
						HasKeysForUsers = True;
					Else
						HasKeysForExternalUsers = True;
					EndIf;
					If LastUpdatedItem <> True Then
						Selection = QueryResults[Index].Select();
						RemainingItemsCount = ?(Selection.Next(), Selection.Count, 0);
					EndIf;
				EndIf;
				If RemainingItemsCount = -1 Then
					If UsersKind = 0 Then
						Row.LeftlUsersItemsShare = 0;
					Else
						Row.LeftExternalUsersItemsShare = 0;
					EndIf;
					RemainingItemsCount = 0;
				EndIf;
				If UsersKind = 0 Then
					If Not HasKeysForUsers Then
						Row.RemainingItemsForUsersCount = 0;
						Row.ItemsForUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						Row.RemainingItemsForUsersCount
							= Int(Row.ItemsForUsersCount * (1 - Row.ProcessedUsersItemsShare
								- Row.LeftlUsersItemsShare) + 0.99)
							+ Int(RemainingItemsCount * Row.LeftlUsersItemsShare);
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (Row.ItemsForUsersCount
							- Row.RemainingItemsForUsersCount);
				Else
					If Not HasKeysForExternalUsers Then
						Row.RemainingItemsForExternalUsersCount = 0;
						Row.ItemsForExternalUsersCount = 0;
					ElsIf TypeOf(RemainingItemsCount) = Type("Number") Then
						Row.RemainingItemsForExternalUsersCount
							= Int(Row.ItemsForExternalUsersCount * (1 - Row.ProcessedExternalUsersItemsShare
								- Row.LeftExternalUsersItemsShare) + 0.99)
							+ Int(RemainingItemsCount * Row.LeftExternalUsersItemsShare);
					EndIf;
					ProcessedItemsCount = ProcessedItemsCount
						+ (Row.ItemsForExternalUsersCount
							- Row.RemainingItemsForExternalUsersCount);
				EndIf;
				Index = Index + 1;
			EndDo;
			ItemsCount = Row.ItemsForUsersCount + Row.ItemsForExternalUsersCount;
			If HasKeysForUsers AND HasKeysForExternalUsers AND TypeProperties.IsReferenceType Then
				ItemsCount             = ItemsCount / 2;
				ProcessedItemsCount = ProcessedItemsCount / 2;
			EndIf;
			UpdateValueInRow(Row.ItemCount, ItemsCount, Row, Context);
			UpdateValueInRow(Row.ProcessedItemsCount,
				Int(ProcessedItemsCount), Row, Context);
			If Row.ProcessedItemsCount > Row.ItemCount Then
				UpdateValueInRow(Row.ProcessedItemsCount,
					Row.ItemCount, Row, Context);
			EndIf;
			UpdateValueInRow(Row.ItemsProcessed, ?(Row.ItemCount = 0, 100,
				Int(Row.ProcessedItemsCount / Row.ItemCount * 100)), Row, Context);
		EndIf;
	EndDo;
	
	For Each Row In Context.AccessKeysCountUpdateRows Do
		Selection = QueryResults[Index].Select();
		AccessKeysForUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		Selection = QueryResults[Index].Select();
		AccessKeysForExternalUsersCount = ?(Selection.Next(), Selection.Count, 0);
		Index = Index + 1;
		
		AccessKeysCount = AccessKeysForUsersCount + AccessKeysForExternalUsersCount;
		UpdateValueInRow(Row.AccessKeysCount, AccessKeysCount, Row, Context);
		If ValueIsFilled(Row.TableName) Then
			AccessKeysByListsCount.Insert(Row.TableName, AccessKeysCount);
		EndIf;
		
		If Row.AccessKeysCount = 0 Then
			ResetAccessKeysCount(Row, Context);
			UpdateValueInRow(Row.AccessKeysProcessed, 100, Row, Context);
			Index = Index + 2;
		Else
			ProcessedAccessKeysCount = 0;
			ListProperties = Context.ListsProperties.Get(Row.List);
			For UsersKind = 0 To 1 Do
				If UsersKind = 0 Then
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKey;
				Else
					LastUpdatedAccessKey = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
				EndIf;
				If LastUpdatedAccessKey = Null Or LastUpdatedAccessKey = True Then
					RemainingAccessKeysCount = -1;
				Else
					Selection = QueryResults[Index].Select();
					RemainingAccessKeysCount = ?(Selection.Next(), Selection.Count, 0);
				EndIf;
				If RemainingAccessKeysCount = -1 Then
					If UsersKind = 0 Then
						Row.LeftUsersAccessKeysShare = 0;
					Else
						Row.LeftExternalUsersAccessKeysShare = 0;
					EndIf;
					RemainingAccessKeysCount = 0;
				EndIf;
				If UsersKind = 0 Then
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						Row.AccessKeysForUsersCount = AccessKeysForUsersCount;
						Row.RemainingAccessKeysForUsersCount
							= Int(Row.AccessKeysForUsersCount * (1 - Row.ProcessedUsersAccessKeysShare
								- Row.LeftUsersAccessKeysShare) + 0.99)
							+ Int(RemainingAccessKeysCount * Row.LeftUsersAccessKeysShare);
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (Row.AccessKeysForUsersCount
							- Row.RemainingAccessKeysForUsersCount);
				Else
					If TypeOf(RemainingAccessKeysCount) = Type("Number") Then
						Row.AccessKeysForExternalUsersCount = AccessKeysForExternalUsersCount;
						Row.RemainingAccessKeysForExternalUsersCount
							= Int(Row.AccessKeysForExternalUsersCount * (1 - Row.ProcessedExternalUsersAccessKeysShare
								- Row.LeftExternalUsersAccessKeysShare) + 0.99)
							+ Int(RemainingAccessKeysCount * Row.LeftExternalUsersAccessKeysShare);
					EndIf;
					ProcessedAccessKeysCount = ProcessedAccessKeysCount
						+ (Row.AccessKeysForExternalUsersCount
							- Row.RemainingAccessKeysForExternalUsersCount);
				EndIf;
				Index = Index + 1;
			EndDo;
			UpdateValueInRow(Row.ProcessedAccessKeysCount,
				Int(ProcessedAccessKeysCount), Row, Context);
			If Row.ProcessedAccessKeysCount > Row.AccessKeysCount Then
				UpdateValueInRow(Row.ProcessedAccessKeysCount,
					Row.AccessKeysCount, Row, Context);
			EndIf;
			UpdateValueInRow(Row.AccessKeysProcessed,
				Int(Row.ProcessedAccessKeysCount / Row.AccessKeysCount * 100), Row, Context);
		EndIf;
	EndDo;
	
EndProcedure

Function ExecuteQueriesPackageByParts(RequestDetails)
	
	QueriesPackageResults = New Array;
	
	QueriesBatchTexts = New Array;
	For Each QueryText In RequestDetails.QueryPackageTexts Do
		If QueriesBatchTexts.Count() = 200 Then
			AddQueryResults(QueriesPackageResults, QueriesBatchTexts, RequestDetails);
			QueriesBatchTexts = New Array;
		EndIf;
		QueriesBatchTexts.Add(QueryText);
	EndDo;
	AddQueryResults(QueriesPackageResults, QueriesBatchTexts, RequestDetails);
	
	Return QueriesPackageResults;
	
EndFunction

Procedure AddQueryResults(QueriesPackageResults, QueriesBatchTexts, RequestDetails)
	
	Query = RequestDetails.Query;
	
	Query.Text = StrConcat(QueriesBatchTexts, Common.QueryBatchSeparator());
	QueryResults = Query.ExecuteBatch();
	Query.Text = "";
	
	For Each QueryResult In QueryResults Do
		QueriesPackageResults.Add(QueryResult);
	EndDo;
	
EndProcedure

Procedure UpdateValueInRow(PreviousValue, NewValue, Row, Context)
	
	If PreviousValue = NewValue Then
		Return;
	EndIf;
	PreviousValue = NewValue;
	
	If Context.AddedRows.Find(Row) = Undefined
	   AND Context.ModifiedRows.Get(Row) = Undefined Then
		
		Context.ModifiedRows.Insert(Row.List, Row);
	EndIf;
	
EndProcedure

Procedure AddItemsCountQueryText(RequestDetails, Row, Index, Context, ForExternalUsers)
	
	Versions = Context.ActiveParameters.ListsRestrictionsVersions.Get(Row.TableName);
	
	If ValueIsFilled(Versions)
	   AND ValueIsFilled(Row.TableName) Then
		
		NameContent = StrSplit(Row.TableName, ".", False);
		TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
		If TypeProperties.IsReferenceType Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	&CurrentTable AS CurrentTable";
		Else
			QueryText = RegisterItemsCountQueryText(Context, Row, Index, ForExternalUsers);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", Row.TableName);
	Else
		QueryText =
		"SELECT
		|	0 AS Count";
	EndIf;
	
	RequestDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Function RegisterItemsCountQueryText(Context, Row, Index, ForExternalUsers)
	
	Properties = Context.ActiveParameters.AdditionalContext[?(ForExternalUsers,
		"ForExternalUsers", "ForUsers")].ListRestrictionsProperties.Get(Row.TableName);
	
	If Properties = Undefined
	 Or Properties.BasicFields = Undefined
	 Or Properties.BasicFields.Used.Count() = 0 Then
	
		Return
		"SELECT
		|	0 AS Count";
	EndIf;
	
	SelectionFields = "";
	For Each FieldName In Properties.BasicFields.Used Do
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|		") + "CurrentTable." + FieldName;
	EndDo;
	
	If Properties.BasicFields.Used.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields AS SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable) AS Combinations";
		SelectionFields = TextWithIndent(SelectionFields, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "&SelectionFields", SelectionFields);
	
	Return QueryText;
	
EndFunction

Procedure AddQueryTextOfRemainingItemsCount(RequestDetails, Row, Index, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(Row.List);
	ListsWithDate = Context.ActiveParameters.ListsWithDate;
	
	If ValueIsFilled(Row.TableName) Then
		NameContent = StrSplit(Row.TableName, ".", False);
		TypeProperties = Context.TablesTypesByNames.Get(Upper(NameContent[0]));
	Else
		ListProperties = Undefined;
	EndIf;
	
	If ListProperties = Undefined Then
		JobParameters = Undefined;
		
	ElsIf ForExternalUsers Then
		JobParameters = ListProperties.LastUpdatedItemForExtrenalUsers;
	Else
		JobParameters = ListProperties.LastUpdatedItem;
	EndIf;
	
	If TypeOf(JobParameters) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		ItemsCountShares = New Structure("Processed, Left", 0, 1);
		JobParameters = JobParameters.Get();
		IsListWithDate = ListsWithDate.Get(Row.TableName) <> Undefined;
		
		If TypeOf(JobParameters) = Type("Structure")
		   AND JobParameters.Property("LastUpdatedItem")
		   AND TypeOf(JobParameters.LastUpdatedItem) = Type("Structure")
		   AND JobParameters.LastUpdatedItem.Property("DataKeyKind")
		   AND DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind) <> Undefined
		   AND JobParameters.LastUpdatedItem.Property("DataKey")
		   AND JobParameters.LastUpdatedItem.Property("ProcessObsoleteItems")
		   AND TypeOf(JobParameters.LastUpdatedItem.ProcessObsoleteItems) = Type("Boolean") Then
			
			LastUpdatedItem = JobParameters.LastUpdatedItem;
		Else
			LastUpdatedItem = New Structure;
			LastUpdatedItem.Insert("DataKeyKind", "DataItemsWithObsoleteKeys");
			LastUpdatedItem.Insert("DataKey");
		EndIf;
		
		FilterCriterion = "";
		If TypeProperties.IsReferenceType Then
			DataKey = LastUpdatedItem.DataKey;
			If ListsWithDate.Get(Row.TableName) <> Undefined Then
				
				If LastUpdatedItem.Property("Date")
				   AND TypeOf(LastUpdatedItem.Date) = Type("Date") Then
					
					ParameterName = "LastDate" + Format(Index, "NG=");
					FilterCriterion = "CurrentTable.Date <= &" + ParameterName;
					RequestDetails.Query.SetParameter(ParameterName, LastUpdatedItem.Date);
				EndIf;
				
			ElsIf ValueIsFilled(DataKey) Then
				MetadataObject = Metadata.FindByType(TypeOf(DataKey));
				If MetadataObject <> Undefined
				   AND MetadataObject.FullName() = Row.TableName Then
					
					ParameterName = "LastRef" + Format(Index, "NG=");
					FilterCriterion = "CurrentTable.Ref > &" + ParameterName;
					RequestDetails.Query.SetParameter(ParameterName, DataKey);
				EndIf;
			EndIf;
			If ValueIsFilled(FilterCriterion) Then
				QueryText =
				"SELECT
				|	COUNT(*) AS Count
				|FROM
				|	&CurrentTable AS CurrentTable
				|WHERE
				|	&FilterCriterion";
				QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
			Else
				QueryText =
				"SELECT
				|	-1 AS Count";
			EndIf;
			FillSharesRefTypeItemsCount(ItemsCountShares,
				LastUpdatedItem, Row.TableName);
		Else
			RestrictionProperties = Context.ActiveParameters.AdditionalContext[?(ForExternalUsers,
				"ForExternalUsers", "ForUsers")].ListRestrictionsProperties.Get(Row.TableName);
			
			FillRegisterItemsCountShares(ItemsCountShares,
				LastUpdatedItem, RestrictionProperties);
			
			QueryText = QueryTextOfRemainingRegisterItemsCount(RequestDetails, Row, Index,
				ForExternalUsers, LastUpdatedItem, RestrictionProperties, TypeProperties);
		EndIf;
		QueryText = StrReplace(QueryText, "&CurrentTable", Row.TableName);
		
		If ForExternalUsers Then
			Row.ProcessedExternalUsersItemsShare = ItemsCountShares.Processed;
			Row.LeftExternalUsersItemsShare   = ItemsCountShares.Left;
		Else
			Row.ProcessedUsersItemsShare = ItemsCountShares.Processed;
			Row.LeftlUsersItemsShare   = ItemsCountShares.Left;
		EndIf;
	EndIf;
	
	RequestDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Procedure FillSharesRefTypeItemsCount(ItemsCountShares, Item, TableName)
	
	If TableName = "Catalog.SetsOfAccessGroups" Then
		If Item.DataKeyKind = "ItemsWithObsoleteRights"
		 Or Item.DataKeyKind = "ItemsWithObsoleteKeys" Then
			
			ItemsCountShares.Processed = 0.0;
			ItemsCountShares.Left   = 0.2;
			
		ElsIf Item.DataKeyKind = "NewSingleUserSets" Then
			
			ItemsCountShares.Processed = 0.2;
			ItemsCountShares.Left   = 0.1;
			
		ElsIf Item.DataKeyKind = "AccessGroupsSetsAssignedToUsers" Then
			
			ItemsCountShares.Processed = 0.3;
			ItemsCountShares.Left   = 0.2;
			
		ElsIf Item.DataKeyKind = "UserGroupSetsAssignedToUsers" Then
			
			ItemsCountShares.Processed = 0.5;
			ItemsCountShares.Left   = 0.1;
			
		ElsIf Item.DataKeyKind = "NewGroupsSetsWithObsoleteRights" Then
			
			ItemsCountShares.Processed = 0.6;
			ItemsCountShares.Left   = 0.2;
			
		ElsIf Item.DataKeyKind = "GroupSetsAllowedForUsers" Then
			
			If Item.ProcessObsoleteItems Then
				ItemsCountShares.Processed = 0.8;
				ItemsCountShares.Left   = 0.1;
			Else
				ItemsCountShares.Processed = 0.8;
				ItemsCountShares.Left   = 0.2;
			EndIf;
			
		Else // ObsoleteItems.
			ItemsCountShares.Processed = 0.9;
			ItemsCountShares.Left   = 0.1;
		EndIf;
		Return;
	EndIf;
	
	If Item.DataKeyKind = "ItemsWithObsoleteKeys" Then
		If Item.ProcessObsoleteItems Then
			ItemsCountShares.Processed = 0.0;
			ItemsCountShares.Left   = 0.9;
		Else
			ItemsCountShares.Processed = 0.0;
			ItemsCountShares.Left   = 1.0;
		EndIf;
	Else // ObsoleteItems.
		ItemsCountShares.Processed = 0.9;
		ItemsCountShares.Left   = 0.1;
	EndIf;
	
EndProcedure

Function QueryTextOfRemainingRegisterItemsCount(RequestDetails, Row, Index,
			ForExternalUsers, LastUpdatedItem, RestrictionProperties, TypeProperties)
	
	DataKeyKind = LastUpdatedItem.DataKeyKind;
	DataKey     = LastUpdatedItem.DataKey;
	
	If RestrictionProperties = Undefined
	 Or RestrictionProperties.BasicFields = Undefined
	 Or RestrictionProperties.BasicFields.Used.Count() = 0
	 Or TypeOf(DataKey) <> Type("Structure")
	 Or DataKeyKind = "ItemsWithoutKeysByPeriod"
	   AND (Not LastUpdatedItem.Property("Date")
	      Or TypeOf(LastUpdatedItem.Date) <> Type("Date"))
	 Or DataKeyKind = "ItemsWithoutKeysByFieldValues"
	   AND RestrictionProperties.BasicFields.Used.Count() <> DataKey.Count()
	 Or DataKeyKind <> "ItemsWithoutKeysByPeriod"
	   AND DataKeyKind <> "ItemsWithoutKeysByFieldValues"
	   AND RestrictionProperties.BasicFields.Used.Count() > DataKey.Count() Then
	
		Return
		"SELECT
		|	-1 AS Count";
	EndIf;
	
	SelectionFields = "";
	FilterCriterion = "";
	ConnectionCondition = "";
	
	If ValueIsFilled(RestrictionProperties.SeparateKeysRegisterName) Then
		KeysRegisterName = RestrictionProperties.SeparateKeysRegisterName;
		MaxFieldsCount =
			AccessManagementInternalCached.BasicRegisterFieldsCount(KeysRegisterName);
	Else
		KeysRegisterName = "AccessKeysForRegisters";
		MaxFieldsCount = AccessManagementInternalCached.BasicRegisterFieldsCount();
		ParameterName = "RegisterID" + Format(Index, "NG=");
		ConnectionCondition = "(AccessKeysForRegisters.Register = &" + ParameterName + ")";
		RequestDetails.Query.SetParameter(ParameterName, Row.List);
	EndIf;
	
	BasicFields = RestrictionProperties.BasicFields;
	FilterByUsersType = ?(ForExternalUsers, "TRUE", "FALSE");
	ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
	|			AND ") + "(AccessKeysForRegisters.ForExternalUsers = " + FilterByUsersType + ")";
	
	FieldNumber = 1;
	For Each FieldName In BasicFields.Used Do
		FieldNameInDataKey = "Field" + FieldNumber;
		ParameterName = FieldName + Format(Index, "NG=");
		
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + FieldNumber + " = CurrentTable." + FieldName + ")";
		
		Filter = "";
		For CurrentIndex = 0 To FieldNumber - 2 Do
			CurrentFieldName = BasicFields.Used[CurrentIndex];
			CurrentParameterName = CurrentFieldName + Format(Index, "NG=");
			Filter = Filter + ?(Filter = "", "", "
			|	AND ") + "CurrentTable." + CurrentFieldName + " = &" + CurrentParameterName;
		EndDo;
		Filter = Filter + ?(Filter = "", "", "
		|	AND ") + "CurrentTable." + FieldName + " > &" + ParameterName;
		
		FilterCriterion = FilterCriterion + ?(FieldNumber = 1, ?(BasicFields.Used.Count() > 1, "(", "") + Filter, "
		|		OR " + TextWithIndent(Filter, "		"));
	
		If DataKey.Property(FieldNameInDataKey) Then
			RequestDetails.Query.SetParameter(ParameterName, DataKey[FieldNameInDataKey]);
		Else
			RequestDetails.Query.SetParameter(ParameterName, Undefined);
		EndIf;
		SelectionFields = SelectionFields + ?(SelectionFields = "", "", ",
		|	") + "CurrentTable." + FieldName;
		FieldNumber = FieldNumber + 1;
	EndDo;
	
	If BasicFields.Used.Count() > 1 Then
		FilterCriterion  = FilterCriterion  + ")";
	EndIf;
	
	InitialNumber = FieldNumber + 1;
	For FieldNumber = InitialNumber To MaxFieldsCount Do
		ConnectionCondition = ConnectionCondition + ?(ConnectionCondition = "", "", "
		|			AND ") + "(AccessKeysForRegisters.Field" + FieldNumber + " = VALUE(Enum.AdditionalAccessValues.Null))";
	EndDo;
	
	If DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		PeriodFieldName = ?(TypeProperties.CollectionName = "CalculationRegisters", "RegistrationPeriod", "Period");
		ParameterName = PeriodFieldName + Format(Index, "NG=");
		FilterCriterion = "(CurrentTable." + PeriodFieldName + " < &" + ParameterName + "
		|	OR CurrentTable." + PeriodFieldName + " = &" + ParameterName + "
		|		AND " + TextWithIndent(FilterCriterion, "	") + ")";
		RequestDetails.Query.SetParameter(ParameterName, LastUpdatedItem.Date);
	EndIf;
	
	If RestrictionProperties.BasicFields.Used.Count() = 1 Then
		QueryText =
		"SELECT
		|	COUNT(DISTINCT &SelectionFields) AS Count
		|FROM
		|	&CurrentTable AS CurrentTable
		|		LEFT JOIN CurrentList AS AccessKeysForRegisters
		|		ON (&ConnectionCondition)
		|WHERE
		|	&FilterCriterion
		|	AND AccessKeysForRegisters.ForExternalUsers IS NULL";
	Else
		QueryText =
		"SELECT
		|	COUNT(*) AS Count
		|FROM
		|	(SELECT DISTINCT
		|		&SelectionFields AS SelectionFields
		|	FROM
		|		&CurrentTable AS CurrentTable
		|			LEFT JOIN CurrentList AS AccessKeysForRegisters
		|			ON (&ConnectionCondition)
		|	WHERE
		|		&FilterCriterion
		|		AND AccessKeysForRegisters.ForExternalUsers IS NULL) AS Combinations";
		SelectionFields    = TextWithIndent(SelectionFields, "	");
		FilterCriterion = TextWithIndent(FilterCriterion, "	");
	EndIf;
	
	QueryText = StrReplace(QueryText, "(&ConnectionCondition)", ConnectionCondition);
	QueryText = StrReplace(QueryText, "&SelectionFields",    SelectionFields);
	QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
	QueryText = StrReplace(QueryText, "CurrentList", "InformationRegister." + KeysRegisterName);
	
	Return QueryText;
	
EndFunction

Procedure FillRegisterItemsCountShares(ItemsCountShares, Item, RestrictionProperties)
	
	If Item.DataKeyKind = "ItemsWithObsoleteKeys" Then
		
		ItemsCountShares.Processed = 0.0;
		ItemsCountShares.Left   = 0.5;
		
	ElsIf Item.DataKeyKind = "ItemsWithoutKeysByFieldValues"
	      Or Item.DataKeyKind = "ItemsWithoutKeysByPeriod" Then
		
		If Item.ProcessObsoleteItems Then
			ItemsCountShares.Processed = 0.5;
			ItemsCountShares.Left   = 0.4;
		Else
			ItemsCountShares.Processed = 0.5;
			ItemsCountShares.Left   = 0.5;
		EndIf;
		
	ElsIf Item.DataKeyKind = "ObsoleteItems" Then
		
		If ValueIsFilled(RestrictionProperties.SeparateKeysRegisterName) Then
			ItemsCountShares.Processed = 0.90;
			ItemsCountShares.Left   = 0.09;
		Else
			ItemsCountShares.Processed = 0.9;
			ItemsCountShares.Left   = 0.1;
		EndIf;
		
	Else // ObsoleteCommonRegisterItems
		ItemsCountShares.Processed = 0.99;
		ItemsCountShares.Left   = 0.01;
	EndIf;
	
EndProcedure

Procedure AddQueryTextOfAccessKeysCount(RequestDetails, Row, Index, ForExternalUsers)
	
	QueryText =
	"SELECT
	|	COUNT(AccessKeys.Ref) AS Count
	|FROM
	|	Catalog.AccessKeys AS AccessKeys
	|WHERE
	|	AccessKeys.List = &List
	|	AND AccessKeys.ForExternalUsers = FALSE";
	
	ParameterName = "KeysList" + Format(Index, "NG=");
	QueryText = StrReplace(QueryText, "&List", "&" + ParameterName);
	RequestDetails.Query.SetParameter(ParameterName, Row.List);
	
	If ForExternalUsers Then
		QueryText = StrReplace(QueryText, "FALSE", "TRUE");
	EndIf;
	
	RequestDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Procedure AddQueryTextOfRemainingAccessKeysCount(RequestDetails, Row, Index, Context, ForExternalUsers)
	
	ListProperties = Context.ListsProperties.Get(Row.List);
	
	If ListProperties = Undefined Then
		JobParameters = Undefined;
		
	ElsIf ForExternalUsers Then
		JobParameters = ListProperties.LastUpdatedAccessKeyForExtrenalUsers;
	Else
		JobParameters = ListProperties.LastUpdatedAccessKey;
	EndIf;
	
	If TypeOf(JobParameters) <> Type("ValueStorage") Then
		QueryText =
		"SELECT
		|	UNDEFINED AS Count";
	Else
		AccessKeysCountShares = New Structure("Processed, Left", 0, 1);
		JobParameters = JobParameters.Get();
		
		If TypeOf(JobParameters) = Type("Structure")
		   AND JobParameters.Property("LastUpdatedItem")
		   AND TypeOf(JobParameters.LastUpdatedItem) = Type("Structure")
		   AND JobParameters.LastUpdatedItem.Property("DataKeyKind")
		   AND DataKeyKindOrder(JobParameters.LastUpdatedItem.DataKeyKind) <> Undefined
		   AND JobParameters.LastUpdatedItem.Property("DataKey") Then
			
			LastAccessKey = JobParameters.LastUpdatedItem.DataKey;
			FillAccessKeysCountShares(AccessKeysCountShares,
				JobParameters.LastUpdatedItem);
		EndIf;
		FilterCriterion = "";
		If TypeOf(LastAccessKey) = Type("CatalogRef.AccessKeys") Then
			ParameterName = "ProcessedKeysList" + Format(Index, "NG=");
			FilterCriterion = "AccessKeys.List = &" + ParameterName;
			RequestDetails.Query.SetParameter(ParameterName, Row.List);
			
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.ForExternalUsers = " + ?(ForExternalUsers, "TRUE", "FALSE");
			
			ParameterName = "LastAccessKey" + Format(Index, "NG=");
			FilterCriterion = FilterCriterion + "
			|	AND AccessKeys.Ref > &" + ParameterName;
			RequestDetails.Query.SetParameter(ParameterName, LastAccessKey);
		EndIf;
		
		If ValueIsFilled(FilterCriterion) Then
			QueryText =
			"SELECT
			|	COUNT(*) AS Count
			|FROM
			|	Catalog.AccessKeys AS AccessKeys
			|WHERE
			|	&FilterCriterion";
			QueryText = StrReplace(QueryText, "&FilterCriterion", FilterCriterion);
		Else
			QueryText =
			"SELECT
			|	-1 AS Count";
		EndIf;
		
		If ForExternalUsers Then
			Row.ProcessedExternalUsersAccessKeysShare = AccessKeysCountShares.Processed;
			Row.LeftExternalUsersAccessKeysShare   = AccessKeysCountShares.Left;
		Else
			Row.ProcessedUsersAccessKeysShare = AccessKeysCountShares.Processed;
			Row.LeftUsersAccessKeysShare   = AccessKeysCountShares.Left;
		EndIf;
	EndIf;
	
	RequestDetails.QueryPackageTexts.Add(QueryText);
	Index = Index + 1;
	
EndProcedure

Procedure FillAccessKeysCountShares(AccessKeysCountShares, Item)
	
	If Item.DataKeyKind = "ItemsWithObsoleteRights" Then
		If Item.ProcessObsoleteItems Then
			AccessKeysCountShares.Processed = 0.0;
			AccessKeysCountShares.Left   = 0.9;
		Else
			AccessKeysCountShares.Processed = 0.0;
			AccessKeysCountShares.Left   = 1.0;
		EndIf;
	Else // ObsoleteItems.
		AccessKeysCountShares.Processed = 0.9;
		AccessKeysCountShares.Left   = 0.1;
	EndIf;
	
EndProcedure

Function ListsWithRestrictionIDs(ActiveParameters)
	
	ActiveParameters = ActiveAccessRestrictionParameters(Undefined, Undefined, False);
	
	Lists = New Array;
	For Each VersionDetails In ActiveParameters.ListsRestrictionsVersions Do
		Lists.Add(VersionDetails.Key);
	EndDo;
	
	Return Catalogs.MetadataObjectIDs.MetadataObjectIDs(Lists, True);
	
EndFunction

Function CurrentDateAtServer() Export
	
	Return CurrentDate(); // There must be the server CurrentDate, since this particular date is recorded to the event log.
	
EndFunction

#EndRegion

#EndRegion

#EndRegion
