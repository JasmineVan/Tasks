#Region FormEvents
//This Procedure is used for create Signature - ThuongTV
&AtServer
Procedure GenerateSignatureByDocumentNumberAtServer()
	//<<This part is used for creating Signature
	//Data
	Attributes = New ValueList();
	Attributes.Add("tokenKey");
	Attributes.Add("orderCode");
	Attributes.Add("customMerchantId");
	Attributes.Add("amount");
	Attributes.Add("currency");
	Attributes.Add("orderDescription");
	Attributes.Add("totalItem");
	//Attributes.Add("checkoutType");
	//Attributes.Add("installment");
	//Attributes.Add("month");
	//Attributes.Add("bankCode");
	//Attributes.Add("paymentMethod");
	Attributes.Add("returnUrl");
	Attributes.Add("cancelUrl");
	Attributes.Add("buyerName");
	Attributes.Add("buyerEmail");
	Attributes.Add("buyerPhone");
	Attributes.Add("buyerAddress");
	Attributes.Add("buyerCity");
	Attributes.Add("buyerCountry");
	//Attributes.Add("paymentHours");
	//Attributes.Add("promotionCode");
	//Attributes.Add("allowDomestic");
	//Attributes.Add("language");
	Attributes.SortByValue(SortDirection.Asc);
	//AttributesStructure
	AttributesStructure = New Structure;
	For i = 0 To Attributes.Count()-1 Do
		AttributesStructure.Insert(String(Attributes.Get(i).Value));
	EndDo;
	
	//Get data from Document
	Query = New Query;
	Query.Text = "SELECT
	|	DayCare.Ref AS Ref,
	|	DayCare.Number AS Number,
	|	DayCare.Price AS Price,
	|	DayCare.Owner.Code AS OwnerCode,
	|	DayCare.ListActivity.(
	|		Ref AS Ref,
	|		LineNumber AS LineNumber,
	|		Check AS Check,
	|		Activities AS Activities,
	|		Price AS Price,
	|		Status AS Status,
	|		MarkAsDone AS MarkAsDone,
	|		Ref AS Ref1,
	|		LineNumber AS LineNumber1,
	|		Check AS Check1,
	|		Activities AS Activities1,
	|		Price AS Price1,
	|		Status AS Status1,
	|		MarkAsDone AS MarkAsDone1
	|	) AS ListActivity,
	|	DayCare.Date AS Date,
	|	DayCare.Ref AS Ref1,
	|	DayCare.DataVersion AS DataVersion,
	|	DayCare.DeletionMark AS DeletionMark,
	|	DayCare.Number AS Number1,
	|	DayCare.Date AS Date1,
	|	DayCare.Posted AS Posted,
	|	DayCare.Dog AS Dog,
	|	DayCare.Owner AS Owner,
	|	DayCare.Package AS Package,
	|	DayCare.PackageTime AS PackageTime,
	|	DayCare.DogSize AS DogSize,
	|	DayCare.PickUp AS PickUp,
	|	DayCare.City AS City,
	|	DayCare.District AS District,
	|	DayCare.AddressNumber AS AddressNumber,
	|	DayCare.Street AS Street,
	|	DayCare.Ward AS Ward,
	|	DayCare.Driver AS Driver,
	|	DayCare.TimePickup AS TimePickup,
	|	DayCare.IsFillActivity AS IsFillActivity,
	|	DayCare.Weight AS Weight,
	|	DayCare.Employees AS Employees,
	|	DayCare.Picture AS Picture,
	|	DayCare.PictureAddress AS PictureAddress,
	|	DayCare.StartTime AS StartTime,
	|	DayCare.EndTime AS EndTime,
	|	DayCare.Price AS Price1,
	|	DayCare.ListActivityBackup.(
	|		Ref AS Ref,
	|		LineNumber AS LineNumber,
	|		Check AS Check,
	|		Activities AS Activities,
	|		Price AS Price,
	|		Status AS Status,
	|		MarkAsDone AS MarkAsDone
	|	) AS ListActivityBackup,
	|	DayCare.Presentation AS Presentation,
	|	DayCare.PointInTime AS PointInTime
	|FROM
	|	Document.DayCare AS DayCare
	|WHERE
	|	DayCare.Number = &Number";
	
	Query.SetParameter("Number", Object.DocumentID);
	
	Result = Query.Execute();
	Selection = Result.Unload();
	
	If Selection.Count() = 0 Then
		Message("Document ID is not existed", MessageStatus.Important);
	Else
		For Each Row In Selection Do
			AttributesStructure.tokenKey = Object.TokenKey;
			AttributesStructure.orderCode = Row.Number;
			AttributesStructure.customMerchantId = Row.Number;
			AttributesStructure.amount = Row.Price;
			AttributesStructure.currency = "VND";
			AttributesStructure.orderDescription = "This order was generated by 1C ThuongTV";
			Counter = 0;
			For Each Activity In Row.ListActivity Do
				If Activity.Check Then
					Counter = Counter + 1;
				EndIf;
			EndDo;
			AttributesStructure.totalItem = Counter;
			//AttributesStructure.checkoutType = 0;
			//AttributesStructure.installment = "";
			//Installment cycle: 3,6,9,12,24 months
			//AttributesStructure.month = "6";
			//ATM, IB, QRCODE, VIETQR, BANK_TRANSFER_ONLINE
			//AttributesStructure.bankCode = "QRCODE";
			//ATM_ON, IB_ON, QRCODE
			//AttributesStructure.paymentMethod = "QRCODE";
			AttributesStructure.returnUrl = "http://118.68.218.70/PetsPark/en_US/";
			AttributesStructure.cancelUrl = "http://118.68.218.70/PetsPark/en_US/";
			AttributesStructure.buyerName = UnicodeToASCII(Row.Owner.Description);
			AttributesStructure.buyerEmail = "dogsparkuser@example.com";
			AttributesStructure.buyerPhone = Row.Owner.Code;
			AttributesStructure.buyerAddress = UnicodeToASCII(Row.Owner.Address);
			AttributesStructure.buyerCity = "Ho Chi Minh";
			AttributesStructure.buyerCountry = "Viet Nam";
			//AttributesStructure.paymentHours = "";
			//AttributesStructure.promotionCode = "";
			//AttributesStructure.allowDomestic = "";
			//AttributesStructure.language = "";
		EndDo;		
	EndIf;
	
	//Integer Type Attributes
	NonStringAttributes = New Array();
	NonStringAttributes.Add("amount");
	NonStringAttributes.Add("totalItem");
	//NonStringAttributes.Add("checkoutType");
	//NonStringAttributes.Add("month");
	//RawData initiation and Request Body	
	RawData = "";
	RequestBody = "";
	RequestBody = "{" + Chars.LF;
	Try
		For i = 0 To AttributesStructure.Count() - 1 Do
			//Signature Data and Request Body
			If NonStringAttributes.Find(String(Attributes.Get(i).Value)) = Undefined Then
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + "|" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "|" + "," + Chars.LF;
			Else
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "," + Chars.LF;
			EndIf
		EndDo;
	Except
		Message("Error while writing raw data: "  + Chars.LF + ErrorInfo());
	EndTry;
	RawData = Left(RawData, StrLen(RawData)-1);
	
	//Signature's input paramaters
	CheckSumKey = Object.ChecksumKey;
	
	//HexaDecimal_Key
	CheckSumKey_Hex = EncodeString(JSFunctionConverter("rstr2hex", CheckSumKey, ), StringEncodingMethod.URLEncoding);
	Signature = HMAC(CheckSumKey_Hex, RawData, "SHA256");
	
	//Request Body
	RequestBody = RequestBody + Chars.Tab + "|signature|" + ":" + "|" + Signature + "|" + ","; 
	RequestBody = Left(RequestBody, StrLen(RequestBody)-1);
	RequestBody = RequestBody + Chars.LF + "}";
	RequestBody = StrReplace(RequestBody, "|", """");
	
	//>>
	Object.RequestBody = RequestBody;
	Object.Signature = Signature;
EndProcedure

//Create Signature For Request Payment
&AtServer
Function CreateSignature(DocumentNumber)
	//<<This part is used for creating Signature
	//Data
	Attributes = New ValueList();
	Attributes.Add("tokenKey");
	Attributes.Add("orderCode");
	Attributes.Add("customMerchantId");
	Attributes.Add("amount");
	Attributes.Add("currency");
	Attributes.Add("orderDescription");
	Attributes.Add("totalItem");
	//Attributes.Add("checkoutType");
	//Attributes.Add("installment");
	//Attributes.Add("month");
	//Attributes.Add("bankCode");
	//Attributes.Add("paymentMethod");
	Attributes.Add("returnUrl");
	Attributes.Add("cancelUrl");
	Attributes.Add("buyerName");
	Attributes.Add("buyerEmail");
	Attributes.Add("buyerPhone");
	Attributes.Add("buyerAddress");
	Attributes.Add("buyerCity");
	Attributes.Add("buyerCountry");
	//Attributes.Add("paymentHours");
	//Attributes.Add("promotionCode");
	//Attributes.Add("allowDomestic");
	//Attributes.Add("language");
	Attributes.SortByValue(SortDirection.Asc);
	//AttributesStructure
	AttributesStructure = New Structure;
	For i = 0 To Attributes.Count()-1 Do
		AttributesStructure.Insert(String(Attributes.Get(i).Value));
	EndDo;
	
	//Get data from Document
	Query = New Query;
	Query.Text = "SELECT
	|	DayCare.Ref AS Ref,
	|	DayCare.Number AS Number,
	|	DayCare.Price AS Price,
	|	DayCare.Owner.Code AS OwnerCode,
	|	DayCare.ListActivity.(
	|		Ref AS Ref,
	|		LineNumber AS LineNumber,
	|		Check AS Check,
	|		Activities AS Activities,
	|		Price AS Price,
	|		Status AS Status,
	|		MarkAsDone AS MarkAsDone,
	|		Ref AS Ref1,
	|		LineNumber AS LineNumber1,
	|		Check AS Check1,
	|		Activities AS Activities1,
	|		Price AS Price1,
	|		Status AS Status1,
	|		MarkAsDone AS MarkAsDone1
	|	) AS ListActivity,
	|	DayCare.Date AS Date,
	|	DayCare.Ref AS Ref1,
	|	DayCare.DataVersion AS DataVersion,
	|	DayCare.DeletionMark AS DeletionMark,
	|	DayCare.Number AS Number1,
	|	DayCare.Date AS Date1,
	|	DayCare.Posted AS Posted,
	|	DayCare.Dog AS Dog,
	|	DayCare.Owner AS Owner,
	|	DayCare.Package AS Package,
	|	DayCare.PackageTime AS PackageTime,
	|	DayCare.DogSize AS DogSize,
	|	DayCare.PickUp AS PickUp,
	|	DayCare.City AS City,
	|	DayCare.District AS District,
	|	DayCare.AddressNumber AS AddressNumber,
	|	DayCare.Street AS Street,
	|	DayCare.Ward AS Ward,
	|	DayCare.Driver AS Driver,
	|	DayCare.TimePickup AS TimePickup,
	|	DayCare.IsFillActivity AS IsFillActivity,
	|	DayCare.Weight AS Weight,
	|	DayCare.Employees AS Employees,
	|	DayCare.Picture AS Picture,
	|	DayCare.PictureAddress AS PictureAddress,
	|	DayCare.StartTime AS StartTime,
	|	DayCare.EndTime AS EndTime,
	|	DayCare.Price AS Price1,
	|	DayCare.ListActivityBackup.(
	|		Ref AS Ref,
	|		LineNumber AS LineNumber,
	|		Check AS Check,
	|		Activities AS Activities,
	|		Price AS Price,
	|		Status AS Status,
	|		MarkAsDone AS MarkAsDone
	|	) AS ListActivityBackup,
	|	DayCare.Presentation AS Presentation,
	|	DayCare.PointInTime AS PointInTime
	|FROM
	|	Document.DayCare AS DayCare
	|WHERE
	|	DayCare.Number = &Number";
	
	Query.SetParameter("Number", Object.DocumentID);
	
	Result = Query.Execute();
	Selection = Result.Unload();
	
	If Selection.Count() = 0 Then
		Message("Document ID is not existed", MessageStatus.Important);
	Else
		For Each Row In Selection Do
			AttributesStructure.tokenKey = Object.TokenKey;
			AttributesStructure.orderCode = Row.Number;
			AttributesStructure.customMerchantId = Row.Number;
			AttributesStructure.amount = Row.Price;
			AttributesStructure.currency = "VND";
			AttributesStructure.orderDescription = "This order was generated by 1C ThuongTV";
			Counter = 0;
			For Each Activity In Row.ListActivity Do
				If Activity.Check Then
					Counter = Counter + 1;
				EndIf;
			EndDo;
			AttributesStructure.totalItem = Counter;
			//AttributesStructure.checkoutType = 0;
			//AttributesStructure.installment = "";
			//Installment cycle: 3,6,9,12,24 months
			//AttributesStructure.month = "6";
			//ATM, IB, QRCODE, VIETQR, BANK_TRANSFER_ONLINE
			//AttributesStructure.bankCode = "QRCODE";
			//ATM_ON, IB_ON, QRCODE
			//AttributesStructure.paymentMethod = "QRCODE";
			AttributesStructure.returnUrl = "http://118.68.218.70/PetsPark/en_US/";
			AttributesStructure.cancelUrl = "http://118.68.218.70/PetsPark/en_US/";
			AttributesStructure.buyerName = UnicodeToASCII(Row.Owner.Description);
			AttributesStructure.buyerEmail = "dogsparkuser@example.com";
			AttributesStructure.buyerPhone = Row.Owner.Code;
			AttributesStructure.buyerAddress = UnicodeToASCII(Row.Owner.Address);
			AttributesStructure.buyerCity = "Ho Chi Minh";
			AttributesStructure.buyerCountry = "Viet Nam";
			//AttributesStructure.paymentHours = "";
			//AttributesStructure.promotionCode = "";
			//AttributesStructure.allowDomestic = "";
			//AttributesStructure.language = "";
		EndDo;		
	EndIf;
	
	//Integer Type Attributes
	NonStringAttributes = New Array();
	NonStringAttributes.Add("amount");
	NonStringAttributes.Add("totalItem");
	//NonStringAttributes.Add("checkoutType");
	//NonStringAttributes.Add("month");
	//RawData initiation and Request Body	
	RawData = "";
	Try
		For i = 0 To AttributesStructure.Count() - 1 Do
			//Signature Data and Request Body
			If NonStringAttributes.Find(String(Attributes.Get(i).Value)) = Undefined Then
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "&";
			Else
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "&";
			EndIf
		EndDo;
	Except
		Message("Error while writing raw data: "  + Chars.LF + ErrorInfo());
	EndTry;
	RawData = Left(RawData, StrLen(RawData)-1);
	
	//Signature's input paramaters
	CheckSumKey = Object.ChecksumKey;
	
	//HexaDecimal_Key
	CheckSumKey_Hex = EncodeString(JSFunctionConverter("rstr2hex", CheckSumKey, ), StringEncodingMethod.URLEncoding);
	Signature = HMAC(CheckSumKey_Hex, RawData, "SHA256");
	//>>
	AttributesStructure.Insert("signature", Signature);
	Return AttributesStructure
EndFunction

//Create Signature For Transaction Information
&AtServer
Function CreateSignature2(TransactionCode)
	//<<This part is used for creating Signature
	//Data
	Attributes = New ValueList();
	Attributes.Add("tokenKey");
	Attributes.Add("transactionCode");
	Attributes.SortByValue(SortDirection.Asc);
	
	//AttributesStructure
	AttributesStructure = New Structure;
	For i = 0 To Attributes.Count()-1 Do
		AttributesStructure.Insert(String(Attributes.Get(i).Value));
	EndDo;
	AttributesStructure.tokenKey = Object.TokenKey;
	AttributesStructure.transactionCode = TransactionCode;
	
	//Integer Type Attributes
	NonStringAttributes = New Array();
	
	//Data
	RawData = "";
	Try
		For i = 0 To AttributesStructure.Count() - 1 Do
			//Signature Data and Request Body
			If NonStringAttributes.Find(String(Attributes.Get(i).Value)) = Undefined Then
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "&";
			Else
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "&";
			EndIf
		EndDo;
	Except
		Message("Error while writing raw data: "  + Chars.LF + ErrorInfo());
	EndTry;
	RawData = Left(RawData, StrLen(RawData)-1);
	
	//Signature's input paramaters
	CheckSumKey = Object.ChecksumKey;
	//HexaDecimal_Key
	CheckSumKey_Hex = EncodeString(JSFunctionConverter("rstr2hex", CheckSumKey, ), StringEncodingMethod.URLEncoding);
	Signature = HMAC(CheckSumKey_Hex, RawData, "SHA256");	
	//>>
	AttributesStructure.Insert("signature", Signature);
	Return AttributesStructure	
EndFunction

//This Function is used to create API's Body Param Structure
&AtClient
Procedure GenerateSignatureByDocumentNumber(Command)
	GenerateSignatureByDocumentNumberAtServer();
EndProcedure

// Insert DocumentID when the form is created
&AtServer
Procedure OnCreateAtServer(Cancel, StandardProcessing)
	// Insert handler content.
	Object.DocumentID = "000000010";
	Object.ChecksumKey = "uhpwDH8FzM4ibcDnanxDHw1g9frjmJ";
	Object.TokenKey = "c6pLAlhy0dI9QNshfUwiExSniED33L";
	Object.EncryptKey = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCzC8Mp5+Vl2ZYkxar4nrz8UZa8Hd4oyv41VUirswK/36jJyrY/NtlzppVyHSV54Ss1Qoho6E5WmvgDQiMobBGepzncyHO8mYZGwGlLxqdG/t7+f+WFOqtKIzc9eJJ2nQSYeOsx9LRuG5Yz1ibeAh1FH8PmSYuCqvvBvjeqCBMh0QIDAQAB";
	//Hide request body fields
	If Object.HideRequestBody2 Then
		ThisForm.Items.RequestBody2.Visible = True;
	Else
		ThisForm.Items.RequestBody2.Visible = False;
	EndIf;
	If Object.HideRequestBody Then
		ThisForm.Items.RequestBody.Visible = True;
	Else
		ThisForm.Items.RequestBody.Visible = False;
	EndIf;
EndProcedure

// Get Transaction Information
&AtServer
Procedure GetTransactionInfoAtServer()
	//<<This part is used for creating Signature
	//Data
	Attributes = New ValueList();
	Attributes.Add("tokenKey");
	Attributes.Add("transactionCode");
	Attributes.SortByValue(SortDirection.Asc);
	
	//AttributesStructure
	AttributesStructure = New Structure;
	For i = 0 To Attributes.Count()-1 Do
		AttributesStructure.Insert(String(Attributes.Get(i).Value));
	EndDo;
	AttributesStructure.tokenKey = Object.TokenKey;
	AttributesStructure.transactionCode = TransactionCode;
	
	//Integer Type Attributes
	NonStringAttributes = New Array();

	//Data
	RawData = "";
	RequestBody = "";
	RequestBody = "{" + Chars.LF;
	Try
		For i = 0 To AttributesStructure.Count() - 1 Do
			//Signature Data and Request Body
			If NonStringAttributes.Find(String(Attributes.Get(i).Value)) = Undefined Then
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + "|" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "|" + "," + Chars.LF;
			Else
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "," + Chars.LF;
			EndIf
		EndDo;
	Except
		Message("Error while writing raw data: "  + Chars.LF + ErrorInfo());
	EndTry;
	RawData = Left(RawData, StrLen(RawData)-1);
	
	//Signature's input paramaters
	CheckSumKey = Object.ChecksumKey;
	//HexaDecimal_Key
	CheckSumKey_Hex = EncodeString(JSFunctionConverter("rstr2hex", CheckSumKey, ), StringEncodingMethod.URLEncoding);
	Signature = HMAC(CheckSumKey_Hex, RawData, "SHA256");
	//Request Body
	RequestBody = RequestBody + Chars.Tab + "|signature|" + ":" + "|" + Signature + "|" + ","; 
	RequestBody = Left(RequestBody, StrLen(RequestBody)-1);
	RequestBody = RequestBody + Chars.LF + "}";
	RequestBody = StrReplace(RequestBody, "|", """");
	
	//>>
	Object.RequestBody2 = RequestBody;
	Object.Signature2 = Signature;
EndProcedure

&AtClient
Procedure GetTransactionInfo(Command)
	GetTransactionInfoAtServer();
EndProcedure

// Get bank list
&AtServer
Procedure GetBankListAtServer()
//<<This part is used for creating Signature
	//Data
	Attributes = New ValueList();
	Attributes.Add("tokenKey");
	Attributes.SortByValue(SortDirection.Asc);
	
	//AttributesStructure
	AttributesStructure = New Structure;
	For i = 0 To Attributes.Count()-1 Do
		AttributesStructure.Insert(String(Attributes.Get(i).Value));
	EndDo;
	AttributesStructure.tokenKey = Object.TokenKey;
	
	//Integer Type Attributes
	NonStringAttributes = New Array();

	//Data
	RawData = "";
	RequestBody = "";
	RequestBody = "{" + Chars.LF;
	Try
		For i = 0 To AttributesStructure.Count() - 1 Do
			//Signature Data and Request Body
			If NonStringAttributes.Find(String(Attributes.Get(i).Value)) = Undefined Then
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + "|" + String(TrimAll(AttributesStructure[Attributes.Get(i).Value])) + "|" + "," + Chars.LF;
			Else
				RawData = RawData + String(Attributes.Get(i).Value) + "=" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "&";
				RequestBody = RequestBody + Chars.Tab + "|" + String(Attributes.Get(i).Value) + "|" + ":" + StrReplace(String(TrimAll(AttributesStructure[Attributes.Get(i).Value])), ",", "") + "," + Chars.LF;
			EndIf
		EndDo;
	Except
		Message("Error while writing raw data: "  + Chars.LF + ErrorInfo());
	EndTry;
	RawData = Left(RawData, StrLen(RawData)-1);
	
	//Signature's input paramaters
	CheckSumKey = Object.ChecksumKey;
	//HexaDecimal_Key
	CheckSumKey_Hex = EncodeString(JSFunctionConverter("rstr2hex", CheckSumKey, ), StringEncodingMethod.URLEncoding);
	Signature = HMAC(CheckSumKey_Hex, RawData, "SHA256");
	//Request Body
	RequestBody = RequestBody + Chars.Tab + "|signature|" + ":" + "|" + Signature + "|" + ","; 
	RequestBody = Left(RequestBody, StrLen(RequestBody)-1);
	RequestBody = RequestBody + Chars.LF + "}";
	RequestBody = StrReplace(RequestBody, "|", """");
	
	//>>
	Object.RequestBody3 = RequestBody;
	Object.Signature3 = Signature;	
EndProcedure

&AtClient
Procedure GetBankList(Command)
	GetBankListAtServer();
EndProcedure

//Encode and Decode
&AtServer
Procedure EncodeAtServer()
	Encoded = EncodeString(StringToEncode, StringEncodingMethod.URLEncoding, "UTF-8");
EndProcedure

&AtClient
Procedure Encode(Command)
	EncodeAtServer();
EndProcedure

&AtServer
Procedure DecodeAtServer()
	Decoded = DecodeString(StringToDecode, StringEncodingMethod.URLEncoding, "UTF-8");
EndProcedure

&AtClient
Procedure Decode(Command)
	DecodeAtServer();
EndProcedure

//Unicode 2 ASCII
&AtServer
Procedure Unicode2ASCIIAtServer()
	ASCIIString = UnicodeToASCII(UnicodeString);
EndProcedure

&AtClient
Procedure Unicode2ASCII(Command)
	Unicode2ASCIIAtServer();
EndProcedure

&AtServer
Procedure HideRequestBodyOnChangeAtServer()
	// Insert handler content.
	If Object.HideRequestBody Then
		ThisForm.Items.RequestBody.Visible = True;
	Else
		ThisForm.Items.RequestBody.Visible = False;
	EndIf;
EndProcedure

&AtClient
Procedure HideRequestBodyOnChange(Item)
	HideRequestBodyOnChangeAtServer();
EndProcedure

&AtServer
Procedure HideRequestBody2OnChangeAtServer()
	// Insert handler content.
	If Object.HideRequestBody2 Then
		ThisForm.Items.RequestBody2.Visible = True;
	Else
		ThisForm.Items.RequestBody2.Visible = False;
	EndIf;
EndProcedure

&AtClient
Procedure HideRequestBody2OnChange(Item)
	HideRequestBody2OnChangeAtServer();
EndProcedure

#EndRegion

#Region Hashing
// Функция - HMAC
//
// Параметры:                            1
//  K     - ключ    в шестнадцатеричном виде - Строка
//  text - текстовое сообщение - Строка
//  Hash - Hash function (CRC32, MD5, SHA1, SHA256) - Строка
// Возвращаемое значение:
//     строка HMAC - Строка
Функция HMAC(Знач K, Знач text, Знач Hash)
	
	Перем kResult;
	Перем К0;
	
	//Если длина ключа K больше размера блока, то к ключу K применяем хэш-функцию
	Если СтрДлина(K)>128 Тогда 
		K = SHA1(K,Hash);
	КонецЕсли;	
	
	//1 Дополняем ключ K нулевыми байтами до размера блока. Размер блока хэш-функции SHA-1 равен 64 байтам.
	StringSHA1 = Лев(K,128);
	Для к = СтрДлина(K) По 128 Цикл
		StringSHA1 = StringSHA1 + "0";
	КонецЦикла;
	К0 = StringSHA1;
	
	//2 Выполняем операцию «побитовое исключающее ИЛИ» c константой 0x36.
	b = ПреобразоватьЧислоВДвоичнуюСИ(ПреобразоватьHexВДесятичнуюСИ("36"));
	
	к = 1;
	Пока к < 128 Цикл
		a             = ПреобразоватьЧислоВДвоичнуюСИ(ПреобразоватьHexВДесятичнуюСИ(Сред(StringSHA1,к,2)));
		с             = XOR(a,b);        
		StringSHA1     = Лев(StringSHA1,к-1)+с+Прав(StringSHA1, 128-к);
		к             = к + 2;
	КонецЦикла;
	
	StringSHA1 = Лев(StringSHA1,128);
	
	//3 Выполняем склейку исходного сообщения со строкой, полученной на шаге 2.
	Для к = 1 По СтрДлина(text) Цикл
		
		StringSHA1 = StringSHA1 + ПреобразоватьДесятичнуюСИВHex(КодСимвола(Сред(text,к,1)));
		
	КонецЦикла;
	
	//4 Применим хэш-функцию SHA-1 к строке, полученной на прошлом шаге.
	StringSHA1     = SHA1(StringSHA1,Hash);
	kResult     = StringSHA1;
	
	//5 Выполним операцию «побитовое исключающее ИЛИ» c константой 0x5c.
	StringSHA1 = К0;
	
	b = ПреобразоватьЧислоВДвоичнуюСИ(ПреобразоватьHexВДесятичнуюСИ("5c"));
	
	к = 1;
	Пока к < 128 Цикл
		a             = ПреобразоватьЧислоВДвоичнуюСИ(ПреобразоватьHexВДесятичнуюСИ(Сред(StringSHA1,к,2)));
		с             = XOR(a,b);        
		StringSHA1     = Лев(StringSHA1,к-1)+с+Прав(StringSHA1, 128-к);
		к             = к + 2;
	КонецЦикла;
	
	StringSHA1 = Лев(StringSHA1,128);
	
	//6 Склейка строки, полученной на шаге 4, со строкой, полученной на шаге 5.
	StringSHA1 = StringSHA1 + kResult;
	
	//7 Применим хэш-функцию SHA-1 к строке, полученной на прошлом шаге.
	StringSHA1 = SHA1(StringSHA1,Hash);    
	
	Возврат StringSHA1;
	
КонецФункции

Функция SHA1(Знач nString, Hash)    
	Хеширование        = Новый ХешированиеДанных(ХешФункция[Hash]);
	ТипhexBinary    = ФабрикаXDTO.Тип("http://www.w3.org/2001/XMLSchema", "hexBinary");
	ДвоичныеДанные    = ФабрикаXDTO.Создать(ТипhexBinary,nString);
	Хеширование.Добавить(ДвоичныеДанные.Значение);    
	sign             = Хеширование.ХешСумма;
	sign 			 = СтрЗаменить(НРЕГ(sign), " ", "");
	Возврат СтрЗаменить(НРЕГ(sign), " ", "");
КонецФункции

Функция ПреобразоватьДесятичнуюСИВHex(Знач int)	
	Если int < 256 Тогда 
		Возврат Прав("00" + ПреобразоватьДесятичнуюСИВОднобайтовыйHex(int),2);
	Иначе
		Возврат Прав("0000" + ПреобразоватьДесятичнуюСИВДвухбайтовыйHex(int),4);
	КонецЕсли;                                 	
КонецФункции

Функция ПреобразоватьHexВДесятичнуюСИ(Знач hex)
	simbol     = СтрДлина(hex) - 1;
	dec     = 0;
	i         = 1;
	Пока simbol >= 0 Цикл
		simbolHex     = Сред(hex, i, 1);
		Res         = Найти("0123456789abcdef", simbolHex) - 1;
		dec         = dec + Res * Pow(16, simbol);
		simbol         = simbol - 1;
		i             = i + 1;
	КонецЦикла;   
	Возврат dec;
КонецФункции

Функция ПреобразоватьЧислоВДвоичнуюСИ(Знач int, rBit = 8)
	b = "";
	Для k = 1 По rBit Цикл
		m     = pow(2, rBit - k);
		bit = Цел(int / m);
		int = int - m * bit;
		b     = b + bit;
	КонецЦикла;                                
	Возврат b;                                     
КонецФункции

Функция XOR(a, b)    
	res = 0;
	s     = 1;
	к     = Мин(СтрДлина(a), СтрДлина(b));    
	Пока к > 0 Цикл        
		a1     = Сред(a,к,1);
		b1     = Сред(b,к,1);                     
		res = res + s * ?(a1=b1,0,Макс(a1,b1));
		s     = s*2;        
		к     = к-1;        
	КонецЦикла;     
	Возврат ПреобразоватьДесятичнуюСИВHex(res);
КонецФункции

Функция ПреобразоватьДесятичнуюСИВДвухбайтовыйHex(Знач int)	
	BinaryData = ПреобразоватьЧислоВДвоичнуюСИ(int, 11);	
	BinaryData = "110" + Лев(BinaryData,5) + "10" + Прав(BinaryData, 6);	
	DecimalData = ПолучитьДесятичноеЧислоИзДвоичного(BinaryData);	
	HexData = ПреобразоватьДесятичнуюСИВОднобайтовыйHex(DecimalData);	
	Возврат HexData;                                        	
КонецФункции

Функция ПолучитьДесятичноеЧислоИзДвоичного(b)	
	res 	= 0;
	s     	= 1;
	к     	= СтрДлина(b);
	Пока к > 0 Цикл        
		bit   = Сред(b,к,1);
		res = res + s * bit;
		s   = s*2;        
		к   = к-1;        
	КонецЦикла;                              	
	Возврат res;                             	
КонецФункции

Функция ПреобразоватьДесятичнуюСИВОднобайтовыйHex(Знач int)	
	hex = "";
	Пока int <> 0 Цикл
		p   = int % 16;
		hex = Сред("0123456789abcdef", p + 1, 1) + hex;
		int = Цел(int / 16);
	КонецЦикла;
	Возврат hex;                                           	
КонецФункции
#EndRegion

#Region UnicodeToASCII
//This procedure is used to convert Unicode String to ASCII String (Thuong Rat dep trai)
Функция UnicodeToASCII(Строка) Export 
	Unicode = "0 1 2 3 4 5 6 7 8 9 A Á À Ả Ã Ạ Ă Ắ Ằ Ẳ Ẵ Ặ Â Ấ Ầ Ẩ Ẫ Ậ E É È Ẻ Ẽ Ẹ Ê Ế Ề Ể Ễ Ệ U Ú Ù Ủ Ũ Ụ Ư Ứ Ừ Ử Ữ Ự I Í Ì Ỉ Ĩ Ị O Ó Ò Ỏ Õ Ọ Ơ Ớ Ờ Ỡ Ở Ợ Ô Ố Ồ Ổ Ỗ Ộ a á à ả ã ạ ă ắ ằ ẳ ẵ ặ â ấ ầ ẩ ẫ ậ e é è ẻ ẽ ẹ ê ế ề ể ễ ệ u ú ù ủ ũ ụ ư ứ ừ ử ữ ự i í ì ỉ ĩ ị o ó ò ỏ õ ọ ơ ớ ờ ỡ ở ợ ô ố ồ ổ ỗ ộ Đ đ 0 1 2 3 4 5 6 7 8 9";
	ASCII = "0 1 2 3 4 5 6 7 8 9 A A A A A A A A A A A A A A A A A A E E E E E E E E E E E E U U U U U U U U U U U U I I I I I I O O O O O O O O O O O O O O O O O O a a a a a a a a a a a a a a a a a a e e e e e e e e e e e e u u u u u u u u u u u u i i i i i i o o o o o o o o o o o o o o o o o o D d 0 1 2 3 4 5 6 7 8 9";
	Unicode = StrReplace(Unicode, " ", "");
	ASCII = StrReplace(ASCII, " ", "");
	//Юни = "ÀÁẢÃẠÂÃÄÅÆÇÈÉẺẼẸÊẾỀỂỄỆËÌÍỈĨỊÎÏÐÑÒÓỎÕỌÔÕÖ×ØÙÚỦŨỤUÛÜƯỪỨỰỬỮÝÞßàáâãäåæçèéêëìíîịïðñòóôơõö÷øùúưựûüýþÿ";
	//Аск = "AAAAAAAAA?CEEEEEEEEEEEEIIIIIIIDNOOOOOOOO*OUUUUUUUUUUUUUUY??aaaaaa?ceeeeiiiii?noooooo?ouuuuuuy?y";
	Юни = Unicode;
	Аск = ASCII;
	НоваяСтрока = "";
	Для к = 1 по СтрДлина(Строка) Цикл
		Символ = Сред(Строка, к, 1);
		Если КодСимвола(Символ) >= 192 и КодСимвола(Символ) <= 591 Or КодСимвола(Символ) > 7800 Or КодСимвола(Символ) = 63 Тогда
			Позиция = СтрНайти(Юни, Символ);
			Если Позиция > 0 Тогда
				Символ = Сред(Аск, Позиция, 1);
			Иначе
				Символ = "?";
			КонецЕсли;
		КонецЕсли;
		НоваяСтрока = НоваяСтрока + Символ;
	КонецЦикла;
	Возврат НоваяСтрока;
КонецФункции
#EndRegion

#Region APIFunction
//Get BankList From API - On progess
&AtServer
Procedure GetBankListFromAPIAtServer()
EndProcedure

&AtClient
Procedure GetBankListFromAPI(Command)
	GetBankListFromAPIAtServer();
EndProcedure

//Request Payment From API
&AtServer
Procedure RequestPaymentFromAPIAtServer()
	 Результат = БОНД_Коннектор.PostJson(
	 "https://alepay-v3-sandbox.nganluong.vn/api/v3/checkout/request-payment",
	 CreateSignature(Object.DocumentID));
	 If Результат <> Undefined Then
		 For Each Attribute In Результат Do
			 If Attribute.Key = "transactionCode" Then
				 Object.TransactionCode = Attribute.Value;
			 ElsIf Attribute.Key = "checkoutUrl" Then
				 Object.CheckoutURL = Attribute.Value;
			 ElsIf Attribute.Key = "signature" Then
				 Object.ResponseSignature = Attribute.Value;
			 ElsIf Attribute.Key = "code" Then
				 Object.ResponseCode = Attribute.Value;
			 ElsIf Attribute.Key = "message" Then
				 Object.ResponseMessage = UnicodeToASCII(Attribute.Value);
			 EndIf;
		 EndDo;
	 EndIf;
EndProcedure

&AtClient
Procedure RequestPaymentFromAPI(Command)
	RequestPaymentFromAPIAtServer();
EndProcedure

//Get Transaction Information From API
&AtServer
Procedure GetTransactionInfoFromAPIAtServer()
 Результат = БОНД_Коннектор.PostJson(
	 "https://alepay-v3-sandbox.nganluong.vn/api/v3/checkout/get-transaction-info",
	 CreateSignature2(TransactionCode));
	 TransactionInformationFromResponse = "";
	 If Результат <> Undefined Then
		 For Each Attribute In Результат Do
			 If Attribute.Key = "signature" Then
				 Object.ResponseSignature2 = Attribute.Value;
			 ElsIf Attribute.Key = "code" Then
				 Object.ResponseCode2 = Attribute.Value;
			 ElsIf Attribute.Key = "message" Then
				 Object.ResponseMessage2 = UnicodeToASCII(Attribute.Value);
			 Else
				TransactionInformationFromResponse = TransactionInformationFromResponse +
				String(Attribute.Key) + " = " + String(Attribute.Value) + Chars.LF;
			 EndIf;
		 EndDo;
	 EndIf;
	 Object.TransactionInformation = TransactionInformationFromResponse;
EndProcedure

&AtClient
Procedure GetTransactionInfoFromAPI(Command)
	GetTransactionInfoFromAPIAtServer();
EndProcedure

#EndRegion

#Region JSFunction
Function JSFunctionConverter(JSFunction, Key, Data = Undefined) Export 
   Var Result;
   ScriptControl = New COMObject("MSScriptControl.ScriptControl");
   ScriptControl.Language = "javascript";
   ScriptControl.AddCode("
   |/*
   | * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   | * in FIPS 180-1
   | * Version 2.2 Copyright Paul Johnston 2000 - 2009.
   | * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   | * Distributed under the BSD License
   | * See http://pajhome.org.uk/crypt/md5 for details.
   | */
   |
   |/*
   | * Configurable variables. You may need to tweak these to be compatible with
   | * the server-side, but the defaults work in most cases.
   | */
   |var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
   |var b64pad  = ""=""; /* base-64 pad character. ""="" for strict RFC compliance   */
   |
   |function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
   |function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
   |function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
   |function hex_hmac_sha1(k, d)
   |  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
   |function b64_hmac_sha1(k, d)
   |  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
   |function any_hmac_sha1(k, d, e)
   |  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }
   |
   |/*
   | * Perform a simple self-test to see if the VM is working
   | */
   |function sha1_vm_test()
   |{
   |  return hex_sha1(""abc"").toLowerCase() == ""a9993e364706816aba3e25717850c26c9cd0d89d"";
   |}
   |
   |/*
   | * Calculate the SHA1 of a raw string
   | */
   |function rstr_sha1(s)
   |{
   |  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
   |}
   |
   |/*
   | * Calculate the HMAC-SHA1 of a key and some data (raw strings)
   | */
   |function rstr_hmac_sha1(key, data)
   |{
   |  var bkey = rstr2binb(key);
   |  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);
   |
   |  var ipad = Array(16), opad = Array(16);
   |  for(var i = 0; i < 16; i++)
   |  {
   |    ipad[i] = bkey[i] ^ 0x36363636;
   |    opad[i] = bkey[i] ^ 0x5C5C5C5C;
   |  }
   |
   |  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
   |  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
   |}
   |
   |/*
   | * Convert a raw string to a hex string
   | */
   |function rstr2hex(input)
   |{
   |  try { hexcase } catch(e) { hexcase=0; }
   |  var hex_tab = hexcase ? ""0123456789ABCDEF"" : ""0123456789abcdef"";
   |  var output = """";
   |  var x;
   |  for(var i = 0; i < input.length; i++)
   |  {
   |    x = input.charCodeAt(i);
   |    output += hex_tab.charAt((x >>> 4) & 0x0F)
   |           +  hex_tab.charAt( x        & 0x0F);
   |  }
   |  return output;
   |}
   |
   |/*
   | * Convert a raw string to a base-64 string
   | */
   |function rstr2b64(input)
   |{
   |  try { b64pad } catch(e) { b64pad=''; }
   |  var tab = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";
   |  var output = """";
   |  var len = input.length;
   |  for(var i = 0; i < len; i += 3)
   |  {
   |    var triplet = (input.charCodeAt(i) << 16)
   |                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
   |                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
   |    for(var j = 0; j < 4; j++)
   |    {
   |      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
   |      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
   |    }
   |  }
   |  return output;
   |}
   |
   |/*
   | * Convert a raw string to an arbitrary string encoding
   | */
   |function rstr2any(input, encoding)
   |{
   |  var divisor = encoding.length;
   |  var remainders = Array();
   |  var i, q, x, quotient;
   |
   |  /* Convert to an array of 16-bit big-endian values, forming the dividend */
   |  var dividend = Array(Math.ceil(input.length / 2));
   |  for(i = 0; i < dividend.length; i++)
   |  {
   |    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
   |  }
   |
   |  /*
   |   * Repeatedly perform a long division. The binary array forms the dividend,
   |   * the length of the encoding is the divisor. Once computed, the quotient
   |   * forms the dividend for the next step. We stop when the dividend is zero.
   |   * All remainders are stored for later use.
   |   */
   |  while(dividend.length > 0)
   |  {
   |    quotient = Array();
   |    x = 0;
   |    for(i = 0; i < dividend.length; i++)
   |    {
   |      x = (x << 16) + dividend[i];
   |      q = Math.floor(x / divisor);
   |      x -= q * divisor;
   |      if(quotient.length > 0 || q > 0)
   |        quotient[quotient.length] = q;
   |    }
   |    remainders[remainders.length] = x;
   |    dividend = quotient;
   |  }
   |
   |  /* Convert the remainders to the output string */
   |  var output = """";
   |  for(i = remainders.length - 1; i >= 0; i--)
   |    output += encoding.charAt(remainders[i]);
   |
   |  /* Append leading zero equivalents */
   |  var full_length = Math.ceil(input.length * 8 /
   |                                    (Math.log(encoding.length) / Math.log(2)))
   |  for(i = output.length; i < full_length; i++)
   |    output = encoding[0] + output;
   |
   |  return output;
   |}
   |
   |/*
   | * Encode a string as utf-8.
   | * For efficiency, this assumes the input is valid utf-16.
   | */
   |function str2rstr_utf8(input)
   |{
   |  var output = """";
   |  var i = -1;
   |  var x, y;
   |
   |  while(++i < input.length)
   |  {
   |    /* Decode utf-16 surrogate pairs */
   |    x = input.charCodeAt(i);
   |    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
   |    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
   |    {
   |      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
   |      i++;
   |    }
   |
   |    /* Encode output as utf-8 */
   |    if(x <= 0x7F)
   |      output += String.fromCharCode(x);
   |    else if(x <= 0x7FF)
   |      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
   |                                    0x80 | ( x         & 0x3F));
   |    else if(x <= 0xFFFF)
   |      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
   |                                    0x80 | ((x >>> 6 ) & 0x3F),
   |                                    0x80 | ( x         & 0x3F));
   |    else if(x <= 0x1FFFFF)
   |      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
   |                                    0x80 | ((x >>> 12) & 0x3F),
   |                                    0x80 | ((x >>> 6 ) & 0x3F),
   |                                    0x80 | ( x         & 0x3F));
   |  }
   |  return output;
   |}
   |
   |/*
   | * Encode a string as utf-16
   | */
   |function str2rstr_utf16le(input)
   |{
   |  var output = """";
   |  for(var i = 0; i < input.length; i++)
   |    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
   |                                  (input.charCodeAt(i) >>> 8) & 0xFF);
   |  return output;
   |}
   |
   |function str2rstr_utf16be(input)
   |{
   |  var output = """";
   |  for(var i = 0; i < input.length; i++)
   |    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
   |                                   input.charCodeAt(i)        & 0xFF);
   |  return output;
   |}
   |
   |/*
   | * Convert a raw string to an array of big-endian words
   | * Characters >255 have their high-byte silently ignored.
   | */
   |function rstr2binb(input)
   |{
   |  var output = Array(input.length >> 2);
   |  for(var i = 0; i < output.length; i++)
   |    output[i] = 0;
   |  for(var i = 0; i < input.length * 8; i += 8)
   |    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
   |  return output;
   |}
   |
   |/*
   | * Convert an array of big-endian words to a string
   | */
   |function binb2rstr(input)
   |{
   |  var output = """";
   |  for(var i = 0; i < input.length * 32; i += 8)
   |    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);
   |  return output;
   |}
   |
   |/*
   | * Calculate the SHA-1 of an array of big-endian words, and a bit length
   | */
   |function binb_sha1(x, len)
   |{
   |  /* append padding */
   |  x[len >> 5] |= 0x80 << (24 - len % 32);
   |  x[((len + 64 >> 9) << 4) + 15] = len;
   |
   |  var w = Array(80);
   |  var a =  1732584193;
   |  var b = -271733879;
   |  var c = -1732584194;
   |  var d =  271733878;
   |  var e = -1009589776;
   |
   |  for(var i = 0; i < x.length; i += 16)
   |  {
   |    var olda = a;
   |    var oldb = b;
   |    var oldc = c;
   |    var oldd = d;
   |    var olde = e;
   |
   |    for(var j = 0; j < 80; j++)
   |    {
   |      if(j < 16) w[j] = x[i + j];
   |      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
   |      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
   |                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
   |      e = d;
   |      d = c;
   |      c = bit_rol(b, 30);
   |      b = a;
   |      a = t;
   |    }
   |
   |    a = safe_add(a, olda);
   |    b = safe_add(b, oldb);
   |    c = safe_add(c, oldc);
   |    d = safe_add(d, oldd);
   |    e = safe_add(e, olde);
   |  }
   |  return Array(a, b, c, d, e);
   |
   |}
   |
   |/*
   | * Perform the appropriate triplet combination function for the current
   | * iteration
   | */
   |function sha1_ft(t, b, c, d)
   |{
   |  if(t < 20) return (b & c) | ((~b) & d);
   |  if(t < 40) return b ^ c ^ d;
   |  if(t < 60) return (b & c) | (b & d) | (c & d);
   |  return b ^ c ^ d;
   |}
   |
   |/*
   | * Determine the appropriate additive constant for the current iteration
   | */
   |function sha1_kt(t)
   |{
   |  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
   |         (t < 60) ? -1894007588 : -899497514;
   |}
   |
   |/*
   | * Add integers, wrapping at 2^32. This uses 16-bit operations internally
   | * to work around bugs in some JS interpreters.
   | */
   |function safe_add(x, y)
   |{
   |  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
   |  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
   |  return (msw << 16) | (lsw & 0xFFFF);
   |}
   |
   |/*
   | * Bitwise rotate a 32-bit number to the left.
   | */
   |function bit_rol(num, cnt)
   |{
   |  return (num << cnt) | (num >>> (32 - cnt));
   |}
   |");
   
   If Data = Undefined Then
      Result = ScriptControl.Run(JSFunction, TrimAll(String(Key)));
   Else
      Result = ScriptControl.Run(JSFunction, TrimAll(String(Key)), TrimAll(String(Data)));
   EndIf;
   Return Result;
EndFunction

&AtServer
Procedure OnCloseAtServer()
	// Insert handler content.
EndProcedure

&AtClient
Procedure OnClose(Exit)
	OnCloseAtServer();
EndProcedure

#EndRegion