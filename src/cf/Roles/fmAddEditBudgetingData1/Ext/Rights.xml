<?xml version="1.0" encoding="UTF-8"?>
<Rights xmlns="http://v8.1c.ru/8.2/roles" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Rights" version="2.12">
	<setForNewObjects>false</setForNewObjects>
	<setForAttributesByDefault>true</setForAttributesByDefault>
	<independentRightsOfChildObjects>false</independentRightsOfChildObjects>
	<object>
		<name>Catalog.fmAgreementRoutes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.PredefinedDataName</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Predefined</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Ref</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.DeletionMark</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.IsFolder</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Owner</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Parent</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Description</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAgreementRoutes.StandardAttribute.Code</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmCounterpartyContracts</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Resource.PointState</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmProjects</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonForm.fmPeriodChoice</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.StandardAttribute.Active</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.StandardAttribute.LineNumber</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.StandardAttribute.Recorder</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.StandardAttribute.Period</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmIncomesAndExpensesItems</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.fmPredictionCopy</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmBindingInfoStructuresToDepartments</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>DataProcessor.fmBudgetingDataAllocation</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonForm.fmCommentForm</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmDepartmentsStructuresVersions</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmProjectAccounting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.fmRouteMap</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmViewFormat</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Document.fmBudgetingOperation</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValues("Document.fmBudgetingOperation", "Read", "",
"fmBalanceUnits", "BalanceUnit",
"","",
"","",
"","",
"","","","","","","","",
"","","","","","","","",
"","","","","","","",""
)
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValues("Document.fmBudgetingOperation", "Insert", "",
"fmBalanceUnits", "BalanceUnit",
"","",
"","",
"","",
"","","","","","","","",
"","","","","","","","",
"","","","","","","",""
)
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValues("Document.fmBudgetingOperation", "Update", "",
"fmBalanceUnits", "BalanceUnit",
"","",
"","",
"","",
"","","","","","","","",
"","","","","","","","",
"","","","","","","",""
)
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Posting</name>
			<value>true</value>
		</right>
		<right>
			<name>UndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePostingRegular</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveUndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveChangeOfPosted</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmBudgetingScenarios</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmExtDimension</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmBalanceUnits</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Subsystem.fmBudgeting.Subsystem.fmAllocation</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmDepartmentStructuresBinding</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmStateBalanceUnit</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmDocumentState</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Dimension.RoutePoint</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmDistributionBases</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.Dimension.ResponsibleReplacing</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmBudgetDistributionSteps</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Subsystem.fmBudgeting.Subsystem.fmCatalogsAndSettings</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Subsystem.fmBudgeting.Subsystem.fmUniversalReporting</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmInfoStructuresSections</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.StandardAttribute.Active</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.StandardAttribute.LineNumber</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.StandardAttribute.Recorder</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.StandardAttribute.Period</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>CommonCommand.fmParametersSetting</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmResponsiblesReplacements.Dimension.Responsible</name>
		<right>
			<name>View</name>
			<value>false</value>
		</right>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmDepartmentsAgreementSetting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmBudgetVersioning</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmInfoStructures</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmBatchLoadSettingsExcel</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmItemsDependencies</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmEditFormat</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmManagementTypes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Document.fmBudget</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValuesAdvanced( "Document.fmBudget", "Read", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf
</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValuesAdvanced( "Document.fmBudget", "Insert", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForObject("")
#Else
#ByValuesAdvanced( "Document.fmBudget", "Update", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Posting</name>
			<value>true</value>
		</right>
		<right>
			<name>UndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePostingRegular</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveUndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveChangeOfPosted</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmModelsSelectionSetting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Document.fmBudgetsDistributionBases</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>Posting</name>
			<value>true</value>
		</right>
		<right>
			<name>UndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePostingRegular</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveUndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveChangeOfPosted</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmRoutesPoints</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmNotification</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>AccumulationRegister.fmCashflowBudget</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccumulationRegisterfmCashflowBudget", "BalanceUnit", "Department", "", "", "")
#Else
#ByValuesAdvanced( "AccumulationRegister.fmCashflowBudget", "Read", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccumulationRegisterfmCashflowBudget", "BalanceUnit", "Department", "", "", "")
#Else
#ByValuesAdvanced( "AccumulationRegister.fmCashflowBudget", "Update", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.fmComparativeBudgetingAnalysis</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmDepartmentTypes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmDepartments</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Subsystem.fmBudgeting</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonForm.fmExportImportForm</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmBudgetsDistributionBases</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmDepartmentsState</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmBudgetingCurrencyRates</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.fmAnalyticsTypes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>Delete</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveDeleteMarked</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmLoadTemplates</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmRoutePointsStates</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonForm.fmAvailableFieldChoiceForm</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.fmRoutePassMap</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Document.fmItemDepedenciesSetting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>Posting</name>
			<value>true</value>
		</right>
		<right>
			<name>UndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractivePostingRegular</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveUndoPosting</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveChangeOfPosted</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Dimension.Department</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Dimension.Version</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Dimension.Document</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmDepartmentHierarchy</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Dimension.AgreementRoute</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmAlloctionByPeriodsProfiles</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>AccumulationRegister.fmIncomesAndExpenses</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccumulationRegisterfmIncomesAndExpenses", "BalanceUnit", "Department", "", "", "")
#Else
#ByValuesAdvanced( "AccumulationRegister.fmIncomesAndExpenses", "Read", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccumulationRegisterfmIncomesAndExpenses", "BalanceUnit", "Department", "", "", "")
#Else
#ByValuesAdvanced( "AccumulationRegister.fmIncomesAndExpenses", "Update", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","OR",
"fmDepartments","T.Department","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>AccountingRegister.fmBudgeting</name>
		<right>
			<name>Read</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccountingRegisterfmBudgeting", "BalanceUnit", "", "", "", "")
#Else
#ByValuesAdvanced( "AccountingRegister.fmBudgeting", "Read", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","",
"","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
			<restrictionByCondition>
				<condition>#If &amp;RecordLevelAccessRestrictionIsUniversal #Then
#ForRegister("MetadataObjectIDs.AccountingRegisterfmBudgeting", "BalanceUnit", "", "", "", "")
#Else
#ByValuesAdvanced( "AccountingRegister.fmBudgeting", "Update", "",
"",
"",
"fmBalanceUnits","T.BalanceUnit","",
"","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","", "","","")
#EndIf</condition>
			</restrictionByCondition>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmDistributionScenariosBinding</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>TotalsControl</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Attribute.Responsible</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmDocumentState</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Report.fmOrganizationalDepartmentsStructure</name>
		<right>
			<name>Use</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>CommonForm.fmParametersSetting</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>InformationRegister.fmRouteStates.Attribute.Comment</name>
		<right>
			<name>Edit</name>
			<value>false</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmCashflowItems</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>ChartOfCharacteristicTypes.fmAgreeDocumentTypes</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Constant.fmCurrencyOfManAccounting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmBudgetDistributionScenarios</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>ChartOfAccounts.fmBudgeting</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>Delete</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveDeleteMarked</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Catalog.fmItemGroups</name>
		<right>
			<name>Read</name>
			<value>true</value>
		</right>
		<right>
			<name>Insert</name>
			<value>true</value>
		</right>
		<right>
			<name>Update</name>
			<value>true</value>
		</right>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveInsert</name>
			<value>true</value>
		</right>
		<right>
			<name>Edit</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveSetDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InteractiveClearDeletionMark</name>
			<value>true</value>
		</right>
		<right>
			<name>InputByString</name>
			<value>true</value>
		</right>
	</object>
	<object>
		<name>Subsystem.fmBudgeting.Subsystem.fmApproval</name>
		<right>
			<name>View</name>
			<value>true</value>
		</right>
	</object>
	<restrictionTemplate>
		<name>ByValues</name>
		<condition>// ByValues(Table, -, Modifier, B1,P1, B2,P2, ..., B(n), P(n)).
// Parameter No.: 1, 2,           3, 4, 5, 6, 7, ..., 2+n*2.3+n*2.
// Read as: access restriction by values.
// Parameters:
//     Table - a name of the current table, for example, Document.GoodsAndServicesReceipt.
//     Modifier - changes the template.
//                 1st modifier - string DontLimitAccessToGroups specifies
//                  unconditionally select hierarchical catalog groups.
//                 No other modifiers are available in this template version.
//     B(n) - Access kind - an access kind name, for example, Companies. For composite fields, to improve
//                  performance, it is better to specify several names, for example, Companies, IndividualGroups,
//                  than to use several parameter blocks with the same field name.
//                  Special access kinds Condition, RightsSettings, ReadRight, EditRight,
//                  RightToReadByID, and RightToEditByID can be used only separately.
//                 If B(n) = "Condition" or "", P(n) contains the condition string in the query language. Example:
//                  "T.Author = &amp;AuthorizedUser",
//                  "VALUETYPE(T.Owner) = TYPE(Catalog.Companies)", where T is an alias of the current table.
//                 When B(n) = "ReadRight" or "EditRight",
//                  rights to the T.P(n) value table are checked.
//                 When B(n) = RightToReadByID" or "RightToEditByID",
//                  rights to the table are checked by ID with value T.P(n).
//     P(n) - a field of the value being checked, except for the case B(n) = "Condition" (or "").
//  Note: you can increase the maximum number of field values checked at the same time by changing the template, but
// you will need to specify all template parameters, i.e. specify blank rows when the number of fields is less than the maximum one.
//  The template has the following structure:
//     &lt;Common condition part&gt; &lt;Condition by parameter group 1&gt; AND &lt;Condition by parameter group 2&gt; AND ... &lt;Condition by parameter group(n)&gt;
//  Example:
//      ByValues("Document.GoodsAndServicesReceipt", "", "",
//      "Companies","Company",
//      "Suppliers","Counterparty", "","", ...)

#If &amp;RecordLevelAccessRestrictionInUse = "" #Then // Infobase is locked for update.
    WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ByValues17,") #Then
    Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 17 of the ByValues access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#Else

// Validating the Right parameter.
#If Not ("#Parameter(2)" = "Read"    Or "#Parameter(2)" = "Insert" Or
          "#Parameter(2)" = "Update" Or "#Parameter(2)" = "Delete"   Or "#Parameter(2)" = "")
      Or #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)"  = "Read"
      Or #CurrentAccessRightName  = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
    // When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
    InvalidRight: #Parameter(2)
#EndIf

// Validating the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter.
#If Not ("#Parameter(3)" = "DoNotLimitAccessToGroups" Or "#Parameter(3)" = "") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	InvalidModifier: #Parameter(3)
#EndIf

// The overall checking if access restriction at record level is used and
// checking if at least one restriction of the specified access kind is used.
#If Not
     (  True
      AND ("#Parameter(4)" = "" AND "#Parameter(5)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(4),"))
      AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(6),"))
      AND ("#Parameter(8)" = "" AND "#Parameter(9)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(8),"))
      AND ("#Parameter(10)" = "" AND "#Parameter(11)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(10),"))
      AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(12),"))
      AND ("#Parameter(14)" = "" AND "#Parameter(15)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(14),"))
      AND ("#Parameter(16)" = "" AND "#Parameter(17)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(16),"))
      AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(18),"))
      AND ("#Parameter(20)" = "" AND "#Parameter(21)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(20),"))
      AND ("#Parameter(22)" = "" AND "#Parameter(23)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(22),"))
      AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(24),"))
      AND ("#Parameter(26)" = "" AND "#Parameter(27)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(26),"))
      AND ("#Parameter(28)" = "" AND "#Parameter(29)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(28),"))
      AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(30),"))
      AND ("#Parameter(32)" = "" AND "#Parameter(33)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(32),"))
      AND ("#Parameter(34)" = "" AND "#Parameter(35)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(34),"))
     ) #Then

T WHERE // T - an alias of the current table (it is short to reduce the number of characters in condition parameter text in the query language).

TRUE IN
(	// Checking user rights to the entire current table.
	// Rights to tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
	#If StrContains(&amp;TableOfExtensionsWithAccessRestriction, "|#Parameter(1);") #Then
		Catalog.ExtensionObjectIDs AS CurrentTableProperties
	#Else
		Catalog.MetadataObjectIDs AS CurrentTableProperties
	#EndIf
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			  CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			  (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						  AccessGroupsTables.Table       = CurrentTableProperties.Ref
						AND AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If #CurrentAccessRightName = "Update" #Then
						AND AccessGroupsTables.Update
					#ElseIf #CurrentAccessRightName = "Insert" #Then
						AND AccessGroupsTables.Insert
					#EndIf
			  )
			AND AccessGroups.Ref IN
			  (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
					ON
						  UserGroupCompositions.User = &amp;AuthorizedUser
						AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
			  )
	WHERE

// Unconditional group selection in hierarchical metadata object (if required).
#If "#Parameter(3)" = "DoNotLimitAccessToGroups" #Then
	T.IsFolder OR
#EndIf

  ( // Searching for values of the specified fields in allowed values of access groups or users.

//// Checking the field value of parameter group 1.
#If &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(4)" = "Condition" Or "#Parameter(4)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	( #Parameter(5) )
#ElseIf "#Parameter(4)" = "ReadRight" Or "#Parameter(4)" = "EditRight" #Then
	  T.#Parameter(5) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(5))
		#If Not "#Parameter(4)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(4)" = "ReadByIDRight" Or "#Parameter(4)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(5)
		#If Not "#Parameter(4)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(4)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(5)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(5)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(4),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(4)", ",") #Then
		IncorrectAccessKind: "#Parameter(4)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(4)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(4),") #Then
	
	 (
			ISNULL(T.#Parameter(5), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(4),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(4),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(5)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(4),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(5)
		#ElseIf "T.#Parameter(5)" = "T.Ref"
		         AND "#Parameter(4)" &lt;&gt; "Users"
		         AND "#Parameter(4)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(4)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(4)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(4),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(5)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(5)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(5))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(T.#Parameter(5), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 2.
#If "#Parameter(6)" = "" AND "#Parameter(7)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(6)" = "Condition" Or "#Parameter(6)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Or "#Parameter(6)" = "EditRight" #Then
	AND T.#Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "ReadByIDRight" Or "#Parameter(6)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(7)
		#If Not "#Parameter(6)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(6)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(6),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	AND
	 (
			ISNULL(T.#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(6),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(7)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(7)
		#ElseIf "T.#Parameter(7)" = "T.Ref"
		         AND "#Parameter(6)" &lt;&gt; "Users"
		         AND "#Parameter(6)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(7))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 3.
#If "#Parameter(8)" = "" AND "#Parameter(9)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(8)" = "Condition" Or "#Parameter(8)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(9) )
#ElseIf "#Parameter(8)" = "ReadRight" Or "#Parameter(8)" = "EditRight" #Then
	AND T.#Parameter(9) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(9))
		#If Not "#Parameter(8)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(8)" = "ReadByIDRight" Or "#Parameter(8)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(9)
		#If Not "#Parameter(8)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(8)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(9)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(9)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(8),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(8)", ",") #Then
		IncorrectAccessKind: "#Parameter(8)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(8)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(8),") #Then
	AND
	 (
			ISNULL(T.#Parameter(9), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(8),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(8),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(9)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(8),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(9)
		#ElseIf "T.#Parameter(9)" = "T.Ref"
		         AND "#Parameter(8)" &lt;&gt; "Users"
		         AND "#Parameter(8)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(8)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(8)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(8),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(9)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(9)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(9))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(9), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 4.
#If "#Parameter(10)" = "" AND "#Parameter(11)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(10)" = "Condition" Or "#Parameter(10)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(11) )
#ElseIf "#Parameter(10)" = "ReadRight" Or "#Parameter(10)" = "EditRight" #Then
	AND T.#Parameter(11) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(11))
		#If Not "#Parameter(10)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(10)" = "ReadByIDRight" Or "#Parameter(10)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(11)
		#If Not "#Parameter(10)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(10)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(11)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(11)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(10),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(10)", ",") #Then
		IncorrectAccessKind: "#Parameter(10)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(10)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(10),") #Then
	AND
	 (
			ISNULL(T.#Parameter(11), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(10),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(10),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(11)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(10),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(11)
		#ElseIf "T.#Parameter(11)" = "T.Ref"
		         AND "#Parameter(10)" &lt;&gt; "Users"
		         AND "#Parameter(10)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(10)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(10)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(10),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(11)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(11)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(11))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(11), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 5.
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(12)" = "Condition" Or "#Parameter(12)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Or "#Parameter(12)" = "EditRight" #Then
	AND T.#Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "ReadByIDRight" Or "#Parameter(12)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(13)
		#If Not "#Parameter(12)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(12)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(12),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	AND
	 (
			ISNULL(T.#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(12),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(13)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(13)
		#ElseIf "T.#Parameter(13)" = "T.Ref"
		         AND "#Parameter(12)" &lt;&gt; "Users"
		         AND "#Parameter(12)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(13))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 6.
#If "#Parameter(14)" = "" AND "#Parameter(15)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(14)" = "Condition" Or "#Parameter(14)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(15) )
#ElseIf "#Parameter(14)" = "ReadRight" Or "#Parameter(14)" = "EditRight" #Then
	AND T.#Parameter(15) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(15))
		#If Not "#Parameter(14)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(14)" = "ReadByIDRight" Or "#Parameter(14)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(15)
		#If Not "#Parameter(14)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(14)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(15)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(15)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(14),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(14)", ",") #Then
		IncorrectAccessKind: "#Parameter(14)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(14)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(14),") #Then
	AND
	 (
			ISNULL(T.#Parameter(15), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(14),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(14),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(15)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(14),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(15)
		#ElseIf "T.#Parameter(15)" = "T.Ref"
		         AND "#Parameter(14)" &lt;&gt; "Users"
		         AND "#Parameter(14)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(14)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(14)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(14),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(15)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(15)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(15))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(15), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 7.
#If "#Parameter(16)" = "" AND "#Parameter(17)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(16)" = "Condition" Or "#Parameter(16)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(17) )
#ElseIf "#Parameter(16)" = "ReadRight" Or "#Parameter(16)" = "EditRight" #Then
	AND T.#Parameter(17) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(17))
		#If Not "#Parameter(16)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(16)" = "ReadByIDRight" Or "#Parameter(16)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(17)
		#If Not "#Parameter(16)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(16)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(17)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(17)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(16),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(16)", ",") #Then
		IncorrectAccessKind: "#Parameter(16)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(16)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(16),") #Then
	AND
	 (
			ISNULL(T.#Parameter(17), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(16),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(16),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(17)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(16),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(17)
		#ElseIf "T.#Parameter(17)" = "T.Ref"
		         AND "#Parameter(16)" &lt;&gt; "Users"
		         AND "#Parameter(16)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(16)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(16)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(16),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(17)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(17)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(17))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(17), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 8.
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(18)" = "Condition" Or "#Parameter(18)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Or "#Parameter(18)" = "EditRight" #Then
	AND T.#Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "ReadByIDRight" Or "#Parameter(18)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(19)
		#If Not "#Parameter(18)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(18)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(18),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	AND
	 (
			ISNULL(T.#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(18),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(19)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(19)
		#ElseIf "T.#Parameter(19)" = "T.Ref"
		         AND "#Parameter(18)" &lt;&gt; "Users"
		         AND "#Parameter(18)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(19))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 9.
#If "#Parameter(20)" = "" AND "#Parameter(21)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(20)" = "Condition" Or "#Parameter(20)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(21) )
#ElseIf "#Parameter(20)" = "ReadRight" Or "#Parameter(20)" = "EditRight" #Then
	AND T.#Parameter(21) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(21))
		#If Not "#Parameter(20)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(20)" = "ReadByIDRight" Or "#Parameter(20)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(21)
		#If Not "#Parameter(20)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(20)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(21)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(21)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(20),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(20)", ",") #Then
		IncorrectAccessKind: "#Parameter(20)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(20)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(20),") #Then
	AND
	 (
			ISNULL(T.#Parameter(21), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(20),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(20),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(21)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(20),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(21)
		#ElseIf "T.#Parameter(21)" = "T.Ref"
		         AND "#Parameter(20)" &lt;&gt; "Users"
		         AND "#Parameter(20)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(20)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(20)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(20),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(21)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(21)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(21))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(21), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 10.
#If "#Parameter(22)" = "" AND "#Parameter(23)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(22)" = "Condition" Or "#Parameter(22)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(23) )
#ElseIf "#Parameter(22)" = "ReadRight" Or "#Parameter(22)" = "EditRight" #Then
	AND T.#Parameter(23) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(23))
		#If Not "#Parameter(22)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(22)" = "ReadByIDRight" Or "#Parameter(22)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(23)
		#If Not "#Parameter(22)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(22)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(23)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(23)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(22),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(22)", ",") #Then
		IncorrectAccessKind: "#Parameter(22)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(22)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(22),") #Then
	AND
	 (
			ISNULL(T.#Parameter(23), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(22),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(22),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(23)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(22),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(23)
		#ElseIf "T.#Parameter(23)" = "T.Ref"
		         AND "#Parameter(22)" &lt;&gt; "Users"
		         AND "#Parameter(22)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(22)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(22)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(22),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(23)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(23)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(23))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(23), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 11.
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(24)" = "Condition" Or "#Parameter(24)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Or "#Parameter(24)" = "EditRight" #Then
	AND T.#Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "ReadByIDRight" Or "#Parameter(24)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(25)
		#If Not "#Parameter(24)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(24)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(24),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	AND
	 (
			ISNULL(T.#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(24),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(25)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(25)
		#ElseIf "T.#Parameter(25)" = "T.Ref"
		         AND "#Parameter(24)" &lt;&gt; "Users"
		         AND "#Parameter(24)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(25))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 12.
#If "#Parameter(26)" = "" AND "#Parameter(27)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(26)" = "Condition" Or "#Parameter(26)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(27) )
#ElseIf "#Parameter(26)" = "ReadRight" Or "#Parameter(26)" = "EditRight" #Then
	AND T.#Parameter(27) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(27))
		#If Not "#Parameter(26)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(26)" = "ReadByIDRight" Or "#Parameter(26)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(27)
		#If Not "#Parameter(26)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(26)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(27)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(27)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(26),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(26)", ",") #Then
		IncorrectAccessKind: "#Parameter(26)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(26)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(26),") #Then
	AND
	 (
			ISNULL(T.#Parameter(27), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(26),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(26),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(27)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(26),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(27)
		#ElseIf "T.#Parameter(27)" = "T.Ref"
		         AND "#Parameter(26)" &lt;&gt; "Users"
		         AND "#Parameter(26)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(26)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(26)" - "Only one access kind can be specified upon checking the access value table."
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(26),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(27)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(27)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(27))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(27), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 13.
#If "#Parameter(28)" = "" AND "#Parameter(29)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(28)" = "Condition" Or "#Parameter(28)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(29) )
#ElseIf "#Parameter(28)" = "ReadRight" Or "#Parameter(28)" = "EditRight" #Then
	AND T.#Parameter(29) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(29))
		#If Not "#Parameter(28)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(28)" = "ReadByIDRight" Or "#Parameter(28)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(29)
		#If Not "#Parameter(28)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(28)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(29)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(29)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(28),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(28)", ",") #Then
		IncorrectAccessKind: "#Parameter(28)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(28)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(28),") #Then
	AND
	 (
			ISNULL(T.#Parameter(29), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(28),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(28),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(29)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(28),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(29)
		#ElseIf "T.#Parameter(29)" = "T.Ref"
		         AND "#Parameter(28)" &lt;&gt; "Users"
		         AND "#Parameter(28)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(28)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(28)" - "Only one access kind can be specified upon checking the access value table."
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(28),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(29)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(29)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(29))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(29), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 14.
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(30)" = "Condition" Or "#Parameter(30)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Or "#Parameter(30)" = "EditRight" #Then
	AND T.#Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "ReadByIDRight" Or "#Parameter(30)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(31)
		#If Not "#Parameter(30)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(30)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(30),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	AND
	 (
			ISNULL(T.#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(30),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(31)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(31)
		#ElseIf "T.#Parameter(31)" = "T.Ref"
		         AND "#Parameter(30)" &lt;&gt; "Users"
		         AND "#Parameter(30)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(31))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 15.
#If "#Parameter(32)" = "" AND "#Parameter(33)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(32)" = "Condition" Or "#Parameter(32)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(33) )
#ElseIf "#Parameter(32)" = "ReadRight" Or "#Parameter(32)" = "EditRight" #Then
	AND T.#Parameter(33) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(33))
		#If Not "#Parameter(32)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(32)" = "ReadByIDRight" Or "#Parameter(32)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(33)
		#If Not "#Parameter(32)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(32)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(33)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(33)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(32),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(32)", ",") #Then
		IncorrectAccessKind: "#Parameter(32)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(32)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(32),") #Then
	AND
	 (
			ISNULL(T.#Parameter(33), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(32),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(32),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(33)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(32),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(33)
		#ElseIf "T.#Parameter(33)" = "T.Ref"
		         AND "#Parameter(32)" &lt;&gt; "Users"
		         AND "#Parameter(32)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(32)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(32)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(32),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(33)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(33)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(33))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(33), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

//// Checking the field value of parameter group 16.
#If "#Parameter(34)" = "" AND "#Parameter(35)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(34)" = "Condition" Or "#Parameter(34)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	AND ( #Parameter(35) )
#ElseIf "#Parameter(34)" = "ReadRight" Or "#Parameter(34)" = "EditRight" #Then
	AND T.#Parameter(35) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(T.#Parameter(35))
		#If Not "#Parameter(34)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(34)" = "ReadByIDRight" Or "#Parameter(34)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = T.#Parameter(35)
		#If Not "#Parameter(34)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	// Parameter group is disabled.
#ElseIf "#Parameter(34)" = "RightsSettings" #Then
	AND
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(35)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = T.#Parameter(35)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(34),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(34)", ",") #Then
		IncorrectAccessKind: "#Parameter(34)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(34)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(34),") #Then
	AND
	 (
			ISNULL(T.#Parameter(35), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(34),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(34),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = T.#Parameter(35)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(34),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.#Parameter(35)
		#ElseIf "T.#Parameter(35)" = "T.Ref"
		         AND "#Parameter(34)" &lt;&gt; "Users"
		         AND "#Parameter(34)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(34)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(34)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(34),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = T.#Parameter(35)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = T.#Parameter(35)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(T.#Parameter(35))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	AND ISNULL(T.#Parameter(35), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

  )
)
#EndIf

#EndIf // Infobase is locked for update.
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesAdvanced</name>
		<condition>// ByValuesExtended(Table, -, Modifier, TablesToJoin, B, A1,F1,B1, A2,F2,B2,..., A(n), F(n), B(n)).
// Parameter No.:                 1, 2,           3,                     4, 5,  6, 7, 8,  9,10,11,...,3+n*3,4+n*3,5+n*3.
// Read as: "access restriction by values advanced".
// Parameters:
//     Table - a name of the current table, for example, Document.GoodsAndServicesReceipt.
//     Modifier - changes the template.
//                 1st modifier - string DontLimitAccessToGroups specifies
//                  unconditionally select hierarchical catalog groups.
//                 No other modifiers are available in this template version.
//     TablesToJoin - a query language text for joining additional tables, for example:
//                 "INNER JOIN Document.ExpenseReport.PaysToSuppliers AS T1
//                  BY T.Ref = T1.Ref.
//                 Joining allows to specify fields of the PaysToVendors table as fields of the main table
//                  for checking whether the values of those fields are the same as the main table field values.
//                 If the joining produces multiple rows, a single row matching the condition is enough
//                  (the conditions are connected with OR).
//     O         - Open parentheses "(".
//     B(n) - Access kind - an access kind name, for example, Companies. For composite fields, to improve
//                  performance, it is better to specify several names, for example, Companies, IndividualGroups,
//                  than to use several parameter blocks with the same field name.
//                  Special access kinds Condition, RightsSettings, ReadRight, EditRight,
//                  RightToReadByID, and RightToEditByID can be used only separately.
//                 If B(n) = "Condition" or "", P(n) contains the condition string in the query language. Example:
//                  "T.Author = &amp;AuthorizedUser",
//                  "VALUETYPE(T.Owner) = TYPE(Catalog.Companies)", where T is an alias of the current table.
//                 When B(n) = "ReadRight" or "EditRight",
//                  rights to the T.P(n) value table are checked.
//                 When B(n) = RightToReadByID" or "RightToEditByID",
//                  rights to the table are checked by ID with value T.P(n).
//     P(n)      - the field that stores the value to be checked (named by alias), for example, "T.Company",
//                 except when A(n) = "Condition" (or"").
//     O(n)      - logical operations AND, OR used with parentheses "(", ")".
//  Note: you can increase the maximum number of field values checked at the same time by changing the template, but
// you will need to specify all template parameters, i.e. specify blank rows when the number of fields is less than the maximum one.
//  The template has the following structure:
//     &lt;Common part of conditions&gt; &lt;Condition for parameter group 1&gt; AND/OR &lt;Condition for parameter group 2&gt; AND/OR ... &lt;Condition for parameter group(n)&gt;
//  Example:
//      ByValuesExtended("Document.GoodsTransfer", "", "",
//      "",
//      "",
//      "Companies","T.Company","AND(",
//      "Warehouses","T.SourceWarehouse","OR",
//      "Warehouses","T.DestinationWarehouse",")", "","","", ...)

#If &amp;RecordLevelAccessRestrictionInUse = "" #Then // Infobase is locked for update.
    WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ByValuesExtended17,") #Then
    Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 17 of the ByValuesExtended access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#Else

// Validating the Right parameter.
#If Not ("#Parameter(2)" = "Read"    Or "#Parameter(2)" = "Insert" Or
          "#Parameter(2)" = "Update" Or "#Parameter(2)" = "Delete"   Or "#Parameter(2)" = "")
      Or #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)"  = "Read"
      Or #CurrentAccessRightName  = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
    // When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
    InvalidRight: #Parameter(2)
#EndIf

// Validating the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter.
#If Not ("#Parameter(3)" = "DoNotLimitAccessToGroups" Or "#Parameter(3)" = "") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	InvalidModifier: #Parameter(3)
#EndIf

// The overall checking if access restriction at record level is used and
// checking if at least one restriction of the specified access kind is used.
#If Not
     (  True
      AND ("#Parameter(6)" = "" AND "#Parameter(7)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(6),"))
      AND ("#Parameter(9)" = "" AND "#Parameter(10)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(9),"))
      AND ("#Parameter(12)" = "" AND "#Parameter(13)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(12),"))
      AND ("#Parameter(15)" = "" AND "#Parameter(16)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(15),"))
      AND ("#Parameter(18)" = "" AND "#Parameter(19)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(18),"))
      AND ("#Parameter(21)" = "" AND "#Parameter(22)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(21),"))
      AND ("#Parameter(24)" = "" AND "#Parameter(25)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(24),"))
      AND ("#Parameter(27)" = "" AND "#Parameter(28)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(27),"))
      AND ("#Parameter(30)" = "" AND "#Parameter(31)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(30),"))
      AND ("#Parameter(33)" = "" AND "#Parameter(34)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(33),"))
      AND ("#Parameter(36)" = "" AND "#Parameter(37)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(36),"))
      AND ("#Parameter(39)" = "" AND "#Parameter(40)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(39),"))
      AND ("#Parameter(42)" = "" AND "#Parameter(43)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(42),"))
      AND ("#Parameter(45)" = "" AND "#Parameter(46)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(45),"))
      AND ("#Parameter(48)" = "" AND "#Parameter(49)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(48),"))
      AND ("#Parameter(51)" = "" AND "#Parameter(52)" = ""
         Or Not &amp;RecordLevelAccessRestrictionInUse
           AND Not StrContains(",Object, ,ReadRight,EditRight,ReadByIDRight,EditByIDRight,", ",#Parameter(51),"))
     ) #Then

T FROM T // T - an alias of the current table (it is short to reduce the number of characters in condition parameter text in the query language).

// Tables joined to the row of the current table "T".
#Parameter(4)

WHERE

TRUE IN
(	// Checking user rights to the entire current table.
	// Rights to tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
	#If StrContains(&amp;TableOfExtensionsWithAccessRestriction, "|#Parameter(1);") #Then
		Catalog.ExtensionObjectIDs AS CurrentTableProperties
	#Else
		Catalog.MetadataObjectIDs AS CurrentTableProperties
	#EndIf
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			  CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			  (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						  AccessGroupsTables.Table       = CurrentTableProperties.Ref
						AND AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If #CurrentAccessRightName = "Update" #Then
						AND AccessGroupsTables.Update
					#ElseIf #CurrentAccessRightName = "Insert" #Then
						AND AccessGroupsTables.Insert
					#EndIf
			  )
			AND AccessGroups.Ref IN
			  (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
					ON
						  UserGroupCompositions.User = &amp;AuthorizedUser
						AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
			  )
	WHERE

// Unconditional group selection in hierarchical metadata object (if required).
#If "#Parameter(3)" = "DoNotLimitAccessToGroups" #Then
	T.IsFolder OR
#EndIf

  ( // Searching for values of the specified fields in allowed values of access groups or users.

	#Parameter(5)  // [([(][(]...] 0-n of open parentheses.

//// Checking the field value of parameter group 1.
#If &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(6)" = "Condition" Or "#Parameter(6)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	( #Parameter(7) )
#ElseIf "#Parameter(6)" = "ReadRight" Or "#Parameter(6)" = "EditRight" #Then
	  #Parameter(7) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(7))
		#If Not "#Parameter(6)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(6)" = "ReadByIDRight" Or "#Parameter(6)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(7)
		#If Not "#Parameter(6)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(6)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(7)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(6),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(6)", ",") #Then
		IncorrectAccessKind: "#Parameter(6)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(6)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(6),") #Then
	
	 (
			ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(6),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(6),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(7)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(7)
		#ElseIf "#Parameter(7)" = "T.Ref"
		         AND "#Parameter(6)" &lt;&gt; "Users"
		         AND "#Parameter(6)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(6)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(6)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(6),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(7)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(7)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(7))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(7), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(8)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 2.
#If "#Parameter(9)" = "" AND "#Parameter(10)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(9)" = "Condition" Or "#Parameter(9)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(10) )
#ElseIf "#Parameter(9)" = "ReadRight" Or "#Parameter(9)" = "EditRight" #Then
	 #Parameter(10) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(10))
		#If Not "#Parameter(9)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(9)" = "ReadByIDRight" Or "#Parameter(9)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(10)
		#If Not "#Parameter(9)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(9)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(10)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(9),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(9)", ",") #Then
		IncorrectAccessKind: "#Parameter(9)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(9)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(9),") #Then
	
	 (
			ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(9),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(9),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(10)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(10)
		#ElseIf "#Parameter(10)" = "T.Ref"
		         AND "#Parameter(9)" &lt;&gt; "Users"
		         AND "#Parameter(9)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(9)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(9)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(9),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(10)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(10)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(10))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(10), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(11)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 3.
#If "#Parameter(12)" = "" AND "#Parameter(13)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(12)" = "Condition" Or "#Parameter(12)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(13) )
#ElseIf "#Parameter(12)" = "ReadRight" Or "#Parameter(12)" = "EditRight" #Then
	 #Parameter(13) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(13))
		#If Not "#Parameter(12)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(12)" = "ReadByIDRight" Or "#Parameter(12)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(13)
		#If Not "#Parameter(12)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(12)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(13)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(12),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(12)", ",") #Then
		IncorrectAccessKind: "#Parameter(12)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(12)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(12),") #Then
	
	 (
			ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(12),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(12),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(13)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(13)
		#ElseIf "#Parameter(13)" = "T.Ref"
		         AND "#Parameter(12)" &lt;&gt; "Users"
		         AND "#Parameter(12)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(12)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(12)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(12),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(13)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(13)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(13))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(13), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(14)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 4.
#If "#Parameter(15)" = "" AND "#Parameter(16)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(15)" = "Condition" Or "#Parameter(15)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(16) )
#ElseIf "#Parameter(15)" = "ReadRight" Or "#Parameter(15)" = "EditRight" #Then
	 #Parameter(16) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(16))
		#If Not "#Parameter(15)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(15)" = "ReadByIDRight" Or "#Parameter(15)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(16)
		#If Not "#Parameter(15)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(15)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(16)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(15),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(15)", ",") #Then
		IncorrectAccessKind: "#Parameter(15)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(15)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(15),") #Then
	
	 (
			ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(15),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(15),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(16)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(16)
		#ElseIf "#Parameter(16)" = "T.Ref"
		         AND "#Parameter(15)" &lt;&gt; "Users"
		         AND "#Parameter(15)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(15)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(15)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(15),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(16)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(16)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(16))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(16), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(17)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 5.
#If "#Parameter(18)" = "" AND "#Parameter(19)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(18)" = "Condition" Or "#Parameter(18)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(19) )
#ElseIf "#Parameter(18)" = "ReadRight" Or "#Parameter(18)" = "EditRight" #Then
	 #Parameter(19) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(19))
		#If Not "#Parameter(18)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(18)" = "ReadByIDRight" Or "#Parameter(18)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(19)
		#If Not "#Parameter(18)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(18)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(19)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(18),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(18)", ",") #Then
		IncorrectAccessKind: "#Parameter(18)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(18)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(18),") #Then
	
	 (
			ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(18),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(18),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(19)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(19)
		#ElseIf "#Parameter(19)" = "T.Ref"
		         AND "#Parameter(18)" &lt;&gt; "Users"
		         AND "#Parameter(18)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(18)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(18)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(18),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(19)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(19)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(19))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(19), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(20)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 6.
#If "#Parameter(21)" = "" AND "#Parameter(22)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(21)" = "Condition" Or "#Parameter(21)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(22) )
#ElseIf "#Parameter(21)" = "ReadRight" Or "#Parameter(21)" = "EditRight" #Then
	 #Parameter(22) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(22))
		#If Not "#Parameter(21)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(21)" = "ReadByIDRight" Or "#Parameter(21)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(22)
		#If Not "#Parameter(21)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(21)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(22)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(21),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(21)", ",") #Then
		IncorrectAccessKind: "#Parameter(21)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(21)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(21),") #Then
	
	 (
			ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(21),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(21),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(22)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(22)
		#ElseIf "#Parameter(22)" = "T.Ref"
		         AND "#Parameter(21)" &lt;&gt; "Users"
		         AND "#Parameter(21)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(21)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(21)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(21),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(22)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(22)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(22))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(22), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(23)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 7.
#If "#Parameter(24)" = "" AND "#Parameter(25)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(24)" = "Condition" Or "#Parameter(24)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(25) )
#ElseIf "#Parameter(24)" = "ReadRight" Or "#Parameter(24)" = "EditRight" #Then
	 #Parameter(25) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(25))
		#If Not "#Parameter(24)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(24)" = "ReadByIDRight" Or "#Parameter(24)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(25)
		#If Not "#Parameter(24)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(24)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(25)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(24),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(24)", ",") #Then
		IncorrectAccessKind: "#Parameter(24)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(24)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(24),") #Then
	
	 (
			ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(24),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(24),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(25)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(25)
		#ElseIf "#Parameter(25)" = "T.Ref"
		         AND "#Parameter(24)" &lt;&gt; "Users"
		         AND "#Parameter(24)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(24)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(24)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(24),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(25)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(25)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(25))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(25), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(26)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 8.
#If "#Parameter(27)" = "" AND "#Parameter(28)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(27)" = "Condition" Or "#Parameter(27)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(28) )
#ElseIf "#Parameter(27)" = "ReadRight" Or "#Parameter(27)" = "EditRight" #Then
	 #Parameter(28) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(28))
		#If Not "#Parameter(27)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(27)" = "ReadByIDRight" Or "#Parameter(27)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(28)
		#If Not "#Parameter(27)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(27)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(28)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(27),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(27)", ",") #Then
		IncorrectAccessKind: "#Parameter(27)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(27)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(27),") #Then
	
	 (
			ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(27),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(27),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(28)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(28)
		#ElseIf "#Parameter(28)" = "T.Ref"
		         AND "#Parameter(27)" &lt;&gt; "Users"
		         AND "#Parameter(27)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(27)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(27)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(27),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(28)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(28)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(28))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(28), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(29)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 9.
#If "#Parameter(30)" = "" AND "#Parameter(31)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(30)" = "Condition" Or "#Parameter(30)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(31) )
#ElseIf "#Parameter(30)" = "ReadRight" Or "#Parameter(30)" = "EditRight" #Then
	 #Parameter(31) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(31))
		#If Not "#Parameter(30)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(30)" = "ReadByIDRight" Or "#Parameter(30)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(31)
		#If Not "#Parameter(30)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(30)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(31)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(30),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(30)", ",") #Then
		IncorrectAccessKind: "#Parameter(30)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(30)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(30),") #Then
	
	 (
			ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(30),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(30),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(31)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(31)
		#ElseIf "#Parameter(31)" = "T.Ref"
		         AND "#Parameter(30)" &lt;&gt; "Users"
		         AND "#Parameter(30)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(30)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(30)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(30),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(31)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(31)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(31))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(31), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(32)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 10.
#If "#Parameter(33)" = "" AND "#Parameter(34)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(33)" = "Condition" Or "#Parameter(33)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(34) )
#ElseIf "#Parameter(33)" = "ReadRight" Or "#Parameter(33)" = "EditRight" #Then
	 #Parameter(34) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(34))
		#If Not "#Parameter(33)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(33)" = "ReadByIDRight" Or "#Parameter(33)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(34)
		#If Not "#Parameter(33)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(33)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(34)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(33),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(33)", ",") #Then
		IncorrectAccessKind: "#Parameter(33)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(33)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(33),") #Then
	
	 (
			ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(33),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(33),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(34)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(34)
		#ElseIf "#Parameter(34)" = "T.Ref"
		         AND "#Parameter(33)" &lt;&gt; "Users"
		         AND "#Parameter(33)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(33)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(33)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(33),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(34)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(34)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(34))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(34), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(35)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 11.
#If "#Parameter(36)" = "" AND "#Parameter(37)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(36)" = "Condition" Or "#Parameter(36)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(37) )
#ElseIf "#Parameter(36)" = "ReadRight" Or "#Parameter(36)" = "EditRight" #Then
	 #Parameter(37) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(37))
		#If Not "#Parameter(36)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(36)" = "ReadByIDRight" Or "#Parameter(36)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(37)
		#If Not "#Parameter(36)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(36)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(37)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(36),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(36)", ",") #Then
		IncorrectAccessKind: "#Parameter(36)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(36)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(36),") #Then
	
	 (
			ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(36),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(36),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(37)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(37)
		#ElseIf "#Parameter(37)" = "T.Ref"
		         AND "#Parameter(36)" &lt;&gt; "Users"
		         AND "#Parameter(36)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(36)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(36)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(36),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(37)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(37)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(37))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(37), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(38)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 12.
#If "#Parameter(39)" = "" AND "#Parameter(40)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(39)" = "Condition" Or "#Parameter(39)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(40) )
#ElseIf "#Parameter(39)" = "ReadRight" Or "#Parameter(39)" = "EditRight" #Then
	 #Parameter(40) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(40))
		#If Not "#Parameter(39)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(39)" = "ReadByIDRight" Or "#Parameter(39)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(40)
		#If Not "#Parameter(39)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(39)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(40)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(39),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(39)", ",") #Then
		IncorrectAccessKind: "#Parameter(39)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(39)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(39),") #Then
	
	 (
			ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(39),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(39),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(40)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(40)
		#ElseIf "#Parameter(40)" = "T.Ref"
		         AND "#Parameter(39)" &lt;&gt; "Users"
		         AND "#Parameter(39)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(39)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(39)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(39),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(40)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(40)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(40))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(40), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(41)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 13.
#If "#Parameter(42)" = "" AND "#Parameter(43)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(42)" = "Condition" Or "#Parameter(42)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(43) )
#ElseIf "#Parameter(42)" = "ReadRight" Or "#Parameter(42)" = "EditRight" #Then
	 #Parameter(43) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(43))
		#If Not "#Parameter(42)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(42)" = "ReadByIDRight" Or "#Parameter(42)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(43)
		#If Not "#Parameter(42)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(42)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(43)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(42),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(42)", ",") #Then
		IncorrectAccessKind: "#Parameter(42)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(42)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(42),") #Then
	
	 (
			ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(42),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(42),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(43)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(43)
		#ElseIf "#Parameter(43)" = "T.Ref"
		         AND "#Parameter(42)" &lt;&gt; "Users"
		         AND "#Parameter(42)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(42)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(42)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(42),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(43)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(43)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(43))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(43), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(44)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 14.
#If "#Parameter(45)" = "" AND "#Parameter(46)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(45)" = "Condition" Or "#Parameter(45)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(46) )
#ElseIf "#Parameter(45)" = "ReadRight" Or "#Parameter(45)" = "EditRight" #Then
	 #Parameter(46) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(46))
		#If Not "#Parameter(45)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(45)" = "ReadByIDRight" Or "#Parameter(45)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(46)
		#If Not "#Parameter(45)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(45)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(46)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(45),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(45)", ",") #Then
		IncorrectAccessKind: "#Parameter(45)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(45)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(45),") #Then
	
	 (
			ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(45),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(45),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(46)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(46)
		#ElseIf "#Parameter(46)" = "T.Ref"
		         AND "#Parameter(45)" &lt;&gt; "Users"
		         AND "#Parameter(45)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(45)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(45)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(45),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(46)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(46)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(46))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(46), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(47)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 15.
#If "#Parameter(48)" = "" AND "#Parameter(49)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(48)" = "Condition" Or "#Parameter(48)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(49) )
#ElseIf "#Parameter(48)" = "ReadRight" Or "#Parameter(48)" = "EditRight" #Then
	 #Parameter(49) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(49))
		#If Not "#Parameter(48)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(48)" = "ReadByIDRight" Or "#Parameter(48)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(49)
		#If Not "#Parameter(48)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(48)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(49)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(48),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(48)", ",") #Then
		IncorrectAccessKind: "#Parameter(48)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(48)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(48),") #Then
	
	 (
			ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(48),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(48),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(49)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(49)
		#ElseIf "#Parameter(49)" = "T.Ref"
		         AND "#Parameter(48)" &lt;&gt; "Users"
		         AND "#Parameter(48)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(48)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(48)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(48),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(49)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(49)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(49))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(49), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(50)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

//// Checking the field value of parameter group 16.
#If "#Parameter(51)" = "" AND "#Parameter(52)" = "" #Then
	// Parameter group is ignored.
#ElseIf &amp;RecordLevelAccessRestrictionInUse AND ("#Parameter(51)" = "Condition" Or "#Parameter(51)" = "") #Then
	// When the access kind name is "Condition" or "", the condition is specified instead of the field name.
	 ( #Parameter(52) )
#ElseIf "#Parameter(51)" = "ReadRight" Or "#Parameter(51)" = "EditRight" #Then
	 #Parameter(52) &lt;&gt; UNDEFINED
	AND TRUE IN
	 (	// Checking user rights to the table of the Value specified in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND VALUETYPE(AccessGroupsTablesRightCheck.TableType) = VALUETYPE(#Parameter(52))
		#If Not "#Parameter(51)" = "ReadRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf "#Parameter(51)" = "ReadByIDRight" Or "#Parameter(51)" = "EditByIDRight" #Then
	  TRUE IN
	 (	// Checking user rights to the table whose ID is specified in the Value set in the field.
		SELECT TOP 1 TRUE
		FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesRightCheck
		WHERE
			  AccessGroupsTablesRightCheck.AccessGroup = AccessGroups.Ref
			AND AccessGroupsTablesRightCheck.Table = #Parameter(52)
		#If Not "#Parameter(51)" = "ReadByIDRight" #Then
			AND AccessGroupsTablesRightCheck.Update
		#EndIf
	 )
#ElseIf Not &amp;RecordLevelAccessRestrictionInUse #Then
	TRUE // Parameter group is disabled.
#ElseIf "#Parameter(51)" = "RightsSettings" #Then
	
	 (
		TRUE IN // Checking if the right is granted to the user or any group that includes the user.
			(
			SELECT TOP 1 TRUE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
		 AND NOT FALSE IN // Checking if the right is restricted to the user or any group that includes the user.
			(
			SELECT TOP 1 FALSE
			FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
				INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
				ON
					  SettingsInheritance.Object = #Parameter(52)
					AND RightsSettings.Object  = SettingsInheritance.Parent
				#If #CurrentAccessRightName = "Read" #Then
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
				#Else
				  #If StrContains(&amp;TablesWithIndividualRightsSettings, "|#Parameter(1);") #Then
					AND RightsSettings.Table = CurrentTableProperties.Ref
				  #Else
					AND RightsSettings.Table = VALUE(Catalog.MetadataObjectIDs.EmptyRef)
				  #EndIf
					AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
				#EndIf
				INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
				ON
					  UserGroupCompositions.User        = &amp;AuthorizedUser
					AND UserGroupCompositions.UsersGroup = RightsSettings.User
			)
	 )
#ElseIf Not StrContains(&amp;AllAccessKindsExceptSpecialOnes, ",#Parameter(51),") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	#If StrContains("#Parameter(51)", ",") #Then
		IncorrectAccessKind: "#Parameter(51)" - "The list of profile names is not found"
	#Else
		IncorrectAccessKind: "#Parameter(51)" - "Access kind name is not found"
	#EndIf
#ElseIf &amp;DisabledAccessKinds &lt;&gt; "All"
         AND Not StrContains(&amp;DisabledAccessKinds, ",#Parameter(51),") #Then
	
	 (
			ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
			AND
		#If (Not StrContains(&amp;DisabledAccessKinds, ",Users,")        AND StrContains(",#Parameter(51),", ",Users,"))
		  Or (Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") AND StrContains(",#Parameter(51),", ",ExternalUsers,")) #Then
			NOT
			(
			NOT TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
				WHERE
					  AccessValuesGroups.AccessValue       = #Parameter(52)
					AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
				)
			AND NOT
		#Else
			(
		#EndIf
			CASE
			WHEN TRUE IN
				(
		#If StrContains(&amp;AccessKindsWithoutGroupsForAccessValues, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = #Parameter(52)
		#ElseIf "#Parameter(52)" = "T.Ref"
		         AND "#Parameter(51)" &lt;&gt; "Users"
		         AND "#Parameter(51)" &lt;&gt; "ExternalUsers" #Then
			#If StrContains("#Parameter(51)", ",") #Then
				// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
				IncorrectAccessKind: "#Parameter(51)" - "Only one access kind can be specified upon checking the access value table"
			#ElseIf StrContains(&amp;AccessKindsWithSingleGroupForAccessValue, ",#Parameter(51),") #Then
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
				WHERE
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = T.AccessGroup
			#Else // Access values for which you can specify multiple access value groups.
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN #Parameter(1).AccessGroups AS ValueGroups
				ON
					  Values.AccessGroup   = AccessGroups.Ref
					AND Values.AccessValue = ValueGroups.AccessGroup
					AND ValueGroups.Ref    = #Parameter(52)
			#EndIf
		#Else
				SELECT TOP 1 TRUE
				FROM InformationRegister.AccessGroupsValues AS Values
					INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
				ON
					  Values.AccessGroup         = AccessGroups.Ref
					AND Values.AccessValue       = ValueGroups.AccessValuesGroup
					AND ValueGroups.AccessValue = #Parameter(52)
		#EndIf
				)
			THEN TRUE
			ELSE FALSE
			END
			=
			CASE
			WHEN TRUE IN
				(
				SELECT TOP 1 TRUE
				FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
				WHERE
				      DefaultValues.AccessGroup = AccessGroups.Ref
				    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(#Parameter(52))
				    AND DefaultValues.AllAllowed = FALSE
				)
			THEN TRUE
			ELSE FALSE
			END
			)
	 )
#Else
	ISNULL(#Parameter(52), UNDEFINED) &lt;&gt; UNDEFINED
#EndIf

	#Parameter(53)  // [)[)][)]...] [OR|AND] [([(][(]...] operator AND/OR with or without parentheses.

  )
)
#EndIf

#EndIf // Infobase is locked for update.
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ByValuesSets</name>
		<condition>// ByValuesSets(Table, -, Modifier, SetsOwner).
// Parameter No.: 1, 2, 3, 4.
// Read as: "access restriction by value sets".
// Parameters:
//     Table - a name of the current table, for example, Document.GoodsAndServicesReceipt.
//     Modifier - changes the template.
//                 1st modifier - string DontLimitAccessToGroups specifies
//                  unconditional selection of hierarchical catalog groups.
//                 2nd modifier - the "AdvancedOR" string 
//                  enables advanced check for restrictions, for example, "ByCompanies or ByAccounts"
//                  where access kind setting option in access groups
//                  "All allowed, none denied" is considered as "Access kind is not used".
//                  If there is no such modifier, then the check result is True, which leads to
//                  the situation where the final result is also True provided that "All allowed, none denied" is set 
//                  for at least one access kind (either ByCompanies or ByAccounts.)
//                  Modifier is intended for use only when checking access value sets.
//                  You can use such modifier combinations as: "DontLimitAccessToGroups",
//                  AdvancedOR, DontLimitAccessToGroups,AdvancedOR.
//                 No other modifiers are available in this template version.
//     SetsOwner -  a name of the field that contains a reference to the owner object.
//                 of the access value sets (stored in the AccessValuesSets information register.
//                 If the field name is not specified, it is the object that is the owner
//                 of the access values sets, which has the &lt;Table&gt;.AccessValuesSets tabular section.
//                 This tabular section is applied when Right = "Update".
//                 Tabular section is exactly the same as InformationRegister.AccessValuesSets
//                 without the Object dimension and attributes.
//                 Specify Ref for document journals.

// Example1: ByValuesSets("Document.CashAdjustment", "", "", "")
// Example2: ByValuesSets("Document.GoodsAndServicesReceipt", "", "", "")
// Example3: ByValuesSets("DocumentJournal.WarehouseDocuments", "", "", "Ref")
// Example4: ByValuesSets("Catalog.EmailAttachments", "", "", "Owner")

#If &amp;RecordLevelAccessRestrictionInUse = "" #Then // Infobase is locked for update.
    WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ByValueSets17,") #Then
    Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 17 of the ByValuesSets access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#Else

// Validating the Right parameter.
#If Not ("#Parameter(2)" = "Read"    Or "#Parameter(2)" = "Insert" Or
          "#Parameter(2)" = "Update" Or "#Parameter(2)" = "Delete"   Or "#Parameter(2)" = "")
      Or #CurrentAccessRightName &lt;&gt; "Read" AND "#Parameter(2)"  = "Read"
      Or #CurrentAccessRightName  = "Read" AND "#Parameter(2)" &lt;&gt; "Read" AND "#Parameter(2)" &lt;&gt; "" #Then
    // When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
    InvalidRight: #Parameter(2)
#EndIf

// Validating the TableName parameter.
#If "#Parameter(1)" &lt;&gt; #CurrentTableName #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	IncorrectCurrentTableName: "#Parameter(1)"
#EndIf

// Validating the Modifier parameter.
#If Not (    "#Parameter(3)" = "DoNotLimitAccessToGroups"
          Or "#Parameter(3)" = "AdvancedOR"
          Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR"
          Or "#Parameter(3)" = "") #Then
	// When the parameter is specified incorrectly, a string is inserted to raise an error while assembling access restriction.
	InvalidModifier: #Parameter(3)
#EndIf

// General checking of access restriction use at the record level.
#If &amp;LimitAccessAtRecordLevel #Then

T WHERE // T - an alias of the current table (it is short to reduce the number of characters in condition parameter text in the query language).

TRUE IN
(	// Checking user rights to the entire current table.
	// Rights to tables are generated according to the set of roles of the access group profile.
	SELECT TOP 1 TRUE
	FROM
	#If StrContains(&amp;TableOfExtensionsWithAccessRestriction, "|#Parameter(1);") #Then
		Catalog.ExtensionObjectIDs AS CurrentTableProperties
	#Else
		Catalog.MetadataObjectIDs AS CurrentTableProperties
	#EndIf
		INNER JOIN Catalog.AccessGroups AS AccessGroups
		ON
			  CurrentTableProperties.FullName = "#Parameter(1)"
			AND TRUE IN
			  (
				SELECT TOP 1 TRUE
				FROM
					InformationRegister.AccessGroupsTables AS AccessGroupsTables
					WHERE
						  AccessGroupsTables.Table       = CurrentTableProperties.Ref
						AND AccessGroupsTables.AccessGroup = AccessGroups.Ref
					#If #CurrentAccessRightName = "Update" #Then
						AND AccessGroupsTables.Update
					#ElseIf #CurrentAccessRightName = "Insert" #Then
						AND AccessGroupsTables.Insert
					#EndIf
			  )
			AND AccessGroups.Ref IN
			  (
				SELECT
					AccessGroupsUsers.Ref AS AccessGroup
				FROM
					Catalog.AccessGroups.Users AS AccessGroupsUsers
					INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
					ON
						  UserGroupCompositions.User = &amp;AuthorizedUser
						AND UserGroupCompositions.UsersGroup = AccessGroupsUsers.User
			  )
	WHERE

// Unconditional group selection in hierarchical metadata object (if required).
#If "#Parameter(3)" = "DoNotLimitAccessToGroups" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
	T.IsFolder Or
#EndIf

#If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
 NOT
 (
  TRUE IN // Not all checks are disabled.
  (
			SELECT TOP 1 TRUE // Selecting the first set where the check is not disabled.
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				  SetsNumbers.Object = T.Ref
			#Else
				  SetsNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				AND SetsNumbers.Read
			#Else
				AND SetsNumbers.Update
			#EndIf
				AND 
	TRUE IN // Not all checks for the current set are disabled.
	(
		SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			  ValueSets.Object = T.Ref
		#Else
			  ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			  ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetsNumbers.SetNumber
			AND NOT TRUE IN
				(
					SELECT TOP 1 TRUE // Searching for access restriction settings.
					FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
					WHERE
						  DefaultValues.AccessGroup = AccessGroups.Ref
						AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						AND DefaultValues.NoSettings = TRUE
				)
	)
  ) AND NOT
#Else
 (
#EndIf
  TRUE IN
  (
			SELECT TOP 1 TRUE // Selecting the first set with access allowed.
		#If #CurrentAccessRightName = "Read" #Then
			FROM InformationRegister.AccessValuesSets AS SetsNumbers
			WHERE
			#If "#Parameter(4)" = "" #Then
				  SetsNumbers.Object = T.Ref
			#Else
				  SetsNumbers.Object = T.#Parameter(4)
			#EndIf
		#Else
			FROM #Parameter(1).AccessValuesSets AS SetsNumbers
			WHERE
				  SetsNumbers.Ref = T.Ref
		#EndIf
			#If #CurrentAccessRightName = "Read" #Then
				AND SetsNumbers.Read
			#Else
				AND SetsNumbers.Update
			#EndIf
				AND
  #If "#Parameter(3)" = "AdvancedOR" Or "#Parameter(3)" = "DoNotLimitAccessToGroups,AdvancedOR" #Then
	TRUE IN // Not all checks for the current set are disabled.
	(
		SELECT TOP 1 TRUE // Selecting the first current set check that is not disabled.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			  ValueSets.Object = T.Ref
		#Else
			  ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			  ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetsNumbers.SetNumber
			AND NOT TRUE IN
				(
					SELECT TOP 1 TRUE // Searching for access restriction settings.
					FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
					WHERE
						  DefaultValues.AccessGroup = AccessGroups.Ref
						AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						AND DefaultValues.NoSettings = TRUE
				)
	) AND
  #EndIf
	NOT FALSE IN // All checks are successful.
	(
		SELECT TOP 1 FALSE // Selecting the first access value that is not allowed.
	#If #CurrentAccessRightName = "Read" #Then
		FROM InformationRegister.AccessValuesSets AS ValueSets
		WHERE
		#If "#Parameter(4)" = "" #Then
			  ValueSets.Object = T.Ref
		#Else
			  ValueSets.Object = T.#Parameter(4)
		#EndIf
	#Else
		FROM #Parameter(1).AccessValuesSets AS ValueSets
		WHERE
			  ValueSets.Ref = T.Ref
	#EndIf
			AND ValueSets.SetNumber = SetsNumbers.SetNumber
			AND NOT
			CASE
		#If #CurrentAccessRightName = "Read" #Then
		  #If Not &amp;DisabledAccessKinds = "All" #Then
			WHEN ValueSets.ValueWithoutGroups
			THEN
				CASE
				WHEN TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.AccessGroupsValues AS Values
					WHERE
						  Values.AccessGroup   = AccessGroups.Ref
						AND Values.AccessValue = ValueSets.AccessValue
					)
				THEN TRUE
				ELSE FALSE
				END
				=
				CASE
				WHEN TRUE IN
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
					WHERE
					      DefaultValues.AccessGroup = AccessGroups.Ref
					    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
					    AND DefaultValues.AllAllowed = FALSE
					)
				THEN TRUE
				ELSE FALSE
				END
		  #EndIf
			WHEN ValueSets.StandardValue
		#Else
			WHEN
				TRUE IN
				(
					SELECT TOP 1 TRUE
					FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
					WHERE
						VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
				)
		#EndIf
		#If &amp;DisabledAccessKinds = "All" #Then
			THEN
				TRUE
		#Else
			THEN
			#If Not #CurrentAccessRightName = "Read"
			  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				CASE
			#EndIf
			#If Not #CurrentAccessRightName = "Read" #Then
				WHEN
					NOT TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM Catalog.MetadataObjectIDs AS RefsTypes
						WHERE
							  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
							AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
						)
					AND NOT TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM Catalog.ExtensionObjectIDs AS RefsTypes
						WHERE
							  VALUETYPE(RefsTypes.EmptyRefValue) = VALUETYPE(ValueSets.AccessValue)
							AND RefsTypes.EmptyRefValue IN (&amp;AccessValuesTypesWithGroups)
						)
				THEN
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
						WHERE
							  Values.AccessGroup   = AccessGroups.Ref
							AND Values.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			#EndIf
			#If Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				WHEN
					TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessValuesGroups AS AccessValuesGroups
						WHERE
							  AccessValuesGroups.AccessValue       = ValueSets.AccessValue
							AND AccessValuesGroups.AccessValuesGroup = &amp;AuthorizedUser
						)
				THEN
					TRUE
			#EndIf
			#If Not #CurrentAccessRightName = "Read"
			  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				ELSE
			#EndIf
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.AccessGroupsValues AS Values
							INNER JOIN InformationRegister.AccessValuesGroups AS ValueGroups
						ON
							  Values.AccessGroup         = AccessGroups.Ref
							AND Values.AccessValue       = ValueGroups.AccessValuesGroup
							AND ValueGroups.AccessValue = ValueSets.AccessValue
						)
					THEN TRUE
					ELSE FALSE
					END
					=
					CASE
					WHEN TRUE IN
						(
						SELECT TOP 1 TRUE
						FROM InformationRegister.DefaultAccessGroupsValues AS DefaultValues
						WHERE
						      DefaultValues.AccessGroup = AccessGroups.Ref
						    AND VALUETYPE(DefaultValues.AccessValuesType) = VALUETYPE(ValueSets.AccessValue)
						    AND DefaultValues.AllAllowed = FALSE
						)
					THEN TRUE
					ELSE FALSE
					END
			#If Not #CurrentAccessRightName = "Read"
			  Or Not StrContains(&amp;DisabledAccessKinds, ",Users,")
			  Or Not StrContains(&amp;DisabledAccessKinds, ",ExternalUsers,") #Then
				END
			#EndIf
		#EndIf
			// Checking a definitely false or true one-line set of values.
			WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessAllowed)
			THEN TRUE
			WHEN ValueSets.AccessValue = VALUE(Enum.AdditionalAccessValues.AccessDenied)
			THEN FALSE
			// Checking user access rights to the AccessValues table.
			WHEN VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.MetadataObjectIDs)
			  OR VALUETYPE(ValueSets.AccessValue) = TYPE(Catalog.ExtensionObjectIDs)
		#If #CurrentAccessRightName = "Read" #Then
			// Read right can depend only on the Read right.
			THEN TRUE IN
				(	SELECT TOP 1 TRUE
					FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
					WHERE
						  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
				)
		#Else
			THEN TRUE IN
				(	SELECT TOP 1 TRUE
					FROM InformationRegister.AccessGroupsTables AS AccessGroupsTablesObjectRightCheck
					WHERE
						  AccessGroupsTablesObjectRightCheck.AccessGroup = AccessGroups.Ref
						AND AccessGroupsTablesObjectRightCheck.Table = ValueSets.AccessValue
						AND NOT(ValueSets.Clarification &lt;&gt; VALUE(Catalog.MetadataObjectIDs.EmptyRef)
								AND AccessGroupsTablesObjectRightCheck.Update = FALSE)
				)
		#EndIf
		#If Not &amp;RightsSettingsOwnersTypes = "" #Then
			ELSE
				(
				TRUE IN // Checking if the right is granted to the user or any group that includes the user.
					(
					SELECT TOP 1 TRUE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = ValueSets.AccessValue
							AND RightsSettings.Object        = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingPermissionLevel
						#Else
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingPermissionLevel
							AND RightsSettings.Table = CASE
								WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
								THEN ValueSets.Clarification
								ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				AND NOT FALSE IN // Checking if the right is restricted to the user or to any group that includes the user.
					(
					SELECT TOP 1 FALSE
					FROM InformationRegister.ObjectsRightsSettings AS RightsSettings
						INNER JOIN InformationRegister.ObjectRightsSettingsInheritance AS SettingsInheritance
						ON
							  SettingsInheritance.Object = ValueSets.AccessValue
							AND RightsSettings.Object        = SettingsInheritance.Parent
						#If #CurrentAccessRightName = "Read" #Then
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ReadingProhibitionLevel
						#Else
							AND SettingsInheritance.UsageLevel &lt; RightsSettings.ChangingProhibitionLevel
							AND RightsSettings.Table = CASE
								WHEN ValueSets.Clarification IN (&amp;IDsOfTablesWithIndividualRightsSettings)
								THEN ValueSets.Clarification
								ELSE VALUE(Catalog.MetadataObjectIDs.EmptyRef) END
						#EndIf
						INNER JOIN InformationRegister.UserGroupCompositions AS UserGroupCompositions
						ON
							  UserGroupCompositions.User        = &amp;AuthorizedUser
							AND UserGroupCompositions.UsersGroup = RightsSettings.User
					)
				)
		#Else
			ELSE
				FALSE
		#EndIf
			END
	) // NOT FALSE IN
  )
 )
)
#EndIf

#EndIf // Infobase is locked for update.
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ForObject(ObjectField)</name>
		<condition>// ForObject(ObjectField = "")
// The template is used to restrict reference items, documents, and
// other object lists by the Reference field. Also, it is used to restrict items of dependent lists
// of objects and register records by the owner object field.

// Parameters:
//  ObjectField - name of the field that stores reference to the object the list item depends on.
//                Value "" (by default) is the same as the name of the Reference field.


#If &amp;ListsWithReadRestrictionDisabled = "Undefined" #Then
  // Infobase is locked for update.
  WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ForRegister5,") #Then
  Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 5 of the ForRegister access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#ElseIf &amp;ListsWithReadRestrictionDisabled = "All" #Then
  // All access kinds are disabled for the user or
  // restriction at the record level is not used.
  WHERE TRUE

#ElseIf StrContains(&amp;ListsWithReadRestrictionDisabled, #CurrentTableName) #Then
  // Restriction for the current table is disabled for the user.
  WHERE TRUE

#ElseIf StrContains(&amp;AccessRestrictionTemplatesVersions, ",SessionRestartRequired,") #Then
  Error. Application version is updated, restart the session. Object: #CurrentTableName, Right: #CurrentAccessRightName.

#ElseIf #CurrentAccessRightName &lt;&gt; "Read" #Then
  // Checking rights Insert, Update, and Delete BeforeWrite / OnWrite.
  WHERE TRUE

#ElseIf Not StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":#ObjectField;")
         AND Not StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then

  Error: Access restriction update required. Reason: Cannot get the access restriction option for ForObject template from the session parameters. Object: #CurrentTableName. Right: #CurrentAccessRightName.
#Else

CurrentTable WHERE TRUE IN
 (
  SELECT TOP 1 TRUE
  FROM InformationRegister.AccessKeysForObjects AS AccessKeysForObjects
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
      ON
      #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
          AccessGroupSetsAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
      #Else
          AccessGroupSetsAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
      #EndIf
        AND AccessGroupSetsAccessKeys.AccessGroupsSet = &amp;AllowedAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;*") #Then
      
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessKeysOfAllowedAccessGroupSet
      ON
      #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
          AccessKeysOfAllowedAccessGroupSet.AccessKey = AccessKeysForObjects.UsersAccessKey
      #Else
          AccessKeysOfAllowedAccessGroupSet.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
      #EndIf
        AND AccessKeysOfAllowedAccessGroupSet.AccessGroupsSet = &amp;AllowedBlankAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForObjects.UsersAccessKey
        AND UsersAccessKeys.User = &amp;AllowedUser
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
        AND UsersAccessKeys.ExternalUser = &amp;AllowedUser
    #EndIf
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;+") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForObjects.UsersAccessKey
        AND AccessKeysOfUserGroupSets.User = &amp;AllowedUserGroupsSet
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForObjects.ExternalUsersAccessKey
        AND AccessKeysOfUserGroupSets.ExternalUser = &amp;AllowedUserGroupsSet
    #EndIf
  #EndIf
  WHERE
  #If "#ObjectField"  = "" #Then
      AccessKeysForObjects.Object = CurrentTable.Ref
  #Else
      AccessKeysForObjects.Object = CurrentTable.#ObjectField
  #EndIf
    AND (
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
          Not AccessGroupSetsAccessKeys.AccessKey Is NULL
  #Else
          False
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":#ObjectField;*") #Then
      Or Not AccessKeysOfAllowedAccessGroupSet.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
      Or Not UsersAccessKeys.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;+") #Then
      Or Not AccessKeysOfUserGroupSets.AccessKey Is NULL
  #EndIf
      )
 )
#EndIf

#If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";ConsiderRightsSettingsOnBuildQueryExecutionPlan;") #Then
  #If Not StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":#ObjectField;") #Then
  AND CASE
	  WHEN
		  #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";31;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";30;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";29;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";28;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";27;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";26;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";25;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";24;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";23;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";22;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";21;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";20;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";19;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";18;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";17;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";16;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";15;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";14;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";13;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";12;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";11;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";10;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";09;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";08;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";07;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";06;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";05;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";04;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";03;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";02;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";01;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";00;") #Then True = True #Else True &lt;&gt; False #EndIf
	  THEN TRUE
	  ELSE FALSE
	END
  #Else
  AND CASE
	  WHEN
		  #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";31^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";30^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";29^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";28^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";27^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";26^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";25^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";24^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";23^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";22^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";21^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";20^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";19^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";18^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";17^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";16^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";15^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";14^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";13^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";12^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";11^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";10^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";09^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";08^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";07^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";06^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";05^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";04^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";03^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";02^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";01^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";00^;") #Then True = True #Else True &lt;&gt; False #EndIf
	  THEN TRUE
	  ELSE FALSE
	END
  #EndIf
#EndIf
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ForRegister(Register, Field1, Field2, Field3, Field4, Field5)</name>
		<condition>// ForRegister(Register, Field1, Field2 = "", Field3 = "", Field4 = "", Field5 = "")
// The template is used to restrict register record groups.

// Parameters:
//  Register - a name of a predefined item of the "Metadata object IDs" catalog
//            or "Extension object IDs" catalog in the following format: a catalog name with a period and a full table name
//            without a period. For example, MetadataObjectIDs.AccumulationRegisterWarehouseBalance.
//          - a name of the separate key register in format KeysOfAccessToRegister&lt;CutName&gt;,
//            For example, KeysOfAccessToRegisterWarehouseBalance.
//  Field1 - a name of the first field (dimension, resource, attribute) that will be connected with the Field1 field
//            of the KeysOfAccessToRegister* information register
//  Field2 - similar to the previous parameter if it is used to restrict access to the register.
//  ...
//  Field5 - similar to the previous parameter if it is used to restrict access to the register.

#If &amp;ListsWithReadRestrictionDisabled = "Undefined" #Then
  // Infobase is locked for update.
  WHERE FALSE

#ElseIf Not StrContains(&amp;AccessRestrictionTemplatesVersions, ",ForRegister5,") #Then
  Error: Template update to version supplied in the EditAccessGroupsMembers role required. Reason: Version 5 of the ForRegister access restriction template is obsolete. Object: #CurrentTableName. Right: #CurrentAccessRightName.

#ElseIf &amp;ListsWithReadRestrictionDisabled = "All" #Then
  // All access kinds are disabled for the user or
  // restriction at the record level is not used.
  WHERE TRUE

#ElseIf StrContains(&amp;ListsWithReadRestrictionDisabled, #CurrentTableName) #Then
  // Restriction for the current table is disabled for the user.
  WHERE TRUE

#ElseIf StrContains(&amp;AccessRestrictionTemplatesVersions, ",SessionRestartRequired,") #Then
  Error. Application version is updated, restart the session. Object: #CurrentTableName, Right: #CurrentAccessRightName.

#ElseIf #CurrentAccessRightName &lt;&gt; "Read" #Then
  // Checking rights Insert, Update, and Delete BeforeWrite / OnWrite.
  WHERE TRUE

#ElseIf Not StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;")
         AND Not StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then

  Error: Access restriction update required. Reason: Cannot get the access restriction option for ForRegister template with parameter values #Register, #Field1, #Field2, #Field3, #Field4, and #Field5 from the session parameters. Object: #CurrentTableName. Right: #CurrentAccessRightName.
#Else

CurrentTable WHERE TRUE IN
 (
  SELECT TOP 1 TRUE
#If Not StrContains("#Register", "AccessKeysToRegister") #Then
  FROM InformationRegister.AccessKeysForRegisters AS AccessKeysForRegisters
#Else
  FROM InformationRegister.#Register AS AccessKeysForRegisters
#EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessGroupSetsAccessKeys
      ON
          AccessGroupSetsAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
        AND AccessGroupSetsAccessKeys.AccessGroupsSet = &amp;AllowedAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction,  #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;*") #Then
      
      LEFT JOIN InformationRegister.AccessGroupSetsAccessKeys AS AccessKeysOfAllowedAccessGroupSet
      ON
          AccessKeysOfAllowedAccessGroupSet.AccessKey = AccessKeysForRegisters.AccessKey
        AND AccessKeysOfAllowedAccessGroupSet.AccessGroupsSet = &amp;AllowedBlankAccessGroupsSet
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
        AND UsersAccessKeys.User = &amp;AllowedUser
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS UsersAccessKeys
      ON
          UsersAccessKeys.AccessKey = AccessKeysForRegisters.AccessKey
        AND UsersAccessKeys.ExternalUser = &amp;AllowedUser
    #EndIf
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;+") #Then
      
    #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
      LEFT JOIN InformationRegister.UsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForRegisters.AccessKey
        AND AccessKeysOfUserGroupSets.User = &amp;AllowedUserGroupsSet
    #Else
      LEFT JOIN InformationRegister.ExternalUsersAccessKeys AS AccessKeysOfUserGroupSets
      ON
          AccessKeysOfUserGroupSets.AccessKey = AccessKeysForRegisters.AccessKey
        AND AccessKeysOfUserGroupSets.ExternalUser = &amp;AllowedUserGroupsSet
    #EndIf
  #EndIf
  WHERE
  #If Not StrContains("#Register", "AccessKeysToRegister") #Then
      AccessKeysForRegisters.Register = Value(Catalog.#Register)
  #Else
      TRUE
  #EndIf
  
  #If &amp;CurrentExternalUser = Value(Catalog.ExternalUsers.EmptyRef) #Then
    AND AccessKeysForRegisters.ForExternalUsers = FALSE
  #Else
    AND AccessKeysForRegisters.ForExternalUsers = TRUE
  #EndIf
  
  #If StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field1=Field1;") #Then
    AND AccessKeysForRegisters.Field1 = CurrentTable.#Field1
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field1=Field2;") #Then
    AND AccessKeysForRegisters.Field1 = CurrentTable.#Field2
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field1=Field3;") #Then
    AND AccessKeysForRegisters.Field1 = CurrentTable.#Field3
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field1=Field4;") #Then
    AND AccessKeysForRegisters.Field1 = CurrentTable.#Field4
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field1=Field5;") #Then
    AND AccessKeysForRegisters.Field1 = CurrentTable.#Field5
  #EndIf
  
  #If StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field2=Field2;") #Then
    AND AccessKeysForRegisters.Field2 = CurrentTable.#Field2
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field2=Field3;") #Then
    AND AccessKeysForRegisters.Field2 = CurrentTable.#Field3
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field2=Field4;") #Then
    AND AccessKeysForRegisters.Field2 = CurrentTable.#Field4
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field2=Field5;") #Then
    AND AccessKeysForRegisters.Field2 = CurrentTable.#Field5
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field2=Null;") #Then
    AND AccessKeysForRegisters.Field2 = Value(Enum.AdditionalAccessValues.Null)
  #EndIf
  
  #If StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field3=Field3;") #Then
    AND AccessKeysForRegisters.Field3 = CurrentTable.#Field3
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field3=Field4;") #Then
    AND AccessKeysForRegisters.Field3 = CurrentTable.#Field4
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field3=Field5;") #Then
    AND AccessKeysForRegisters.Field3 = CurrentTable.#Field5
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field3=Null;") #Then
    AND AccessKeysForRegisters.Field3 = Value(Enum.AdditionalAccessValues.Null)
  #EndIf
  
  #If StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field4=Field4;") #Then
    AND AccessKeysForRegisters.Field4 = CurrentTable.#Field4
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field4=Field5;") #Then
    AND AccessKeysForRegisters.Field4 = CurrentTable.#Field5
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field4=Null;") #Then
    AND AccessKeysForRegisters.Field4 = Value(Enum.AdditionalAccessValues.Null)
  #EndIf
  
  #If StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field5=Field5;") #Then
    AND AccessKeysForRegisters.Field5 = CurrentTable.#Field5
  #ElseIf StrContains(&amp;ListsWithRestrictionByFields, #CurrentTableName + ":Field5=Null;") #Then
    AND AccessKeysForRegisters.Field5 = Value(Enum.AdditionalAccessValues.Null)
  #EndIf
  
    AND (
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
          Not AccessGroupSetsAccessKeys.AccessKey Is NULL
  #Else
          False
  #EndIf
  #If StrContains(&amp;ListsWithAccessGroupsAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;*") #Then
      Or Not AccessKeysOfAllowedAccessGroupSet.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
      Or Not UsersAccessKeys.AccessKey Is NULL
  #EndIf
  #If StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;+") #Then
      Or Not AccessKeysOfUserGroupSets.AccessKey Is NULL
  #EndIf
      )
 )
#EndIf

#If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";ConsiderRightsSettingsOnBuildQueryExecutionPlan;") #Then
  #If Not StrContains(&amp;ListsWithUsersAccessKeysRestriction, #CurrentTableName + ":[#Register]:#Field1:#Field2:#Field3:#Field4:#Field5;") #Then
  AND CASE
	  WHEN
		  #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";31;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";30;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";29;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";28;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";27;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";26;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";25;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";24;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";23;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";22;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";21;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";20;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";19;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";18;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";17;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";16;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";15;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";14;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";13;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";12;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";11;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";10;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";09;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";08;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";07;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";06;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";05;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";04;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";03;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";02;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";01;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";00;") #Then True = True #Else True &lt;&gt; False #EndIf
	  THEN TRUE
	  ELSE FALSE
	END
  #Else
  AND CASE
	  WHEN
		  #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";31^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";30^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";29^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";28^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";27^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";26^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";25^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";24^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";23^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";22^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";21^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";20^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";19^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";18^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";17^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";16^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";15^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";14^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";13^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";12^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";11^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";10^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";09^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";08^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";07^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";06^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";05^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";04^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";03^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";02^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";01^;") #Then True = True #Else True &lt;&gt; False #EndIf
		AND #If StrContains(&amp;CommonAccessRestrictionTemplateParameters, ";00^;") #Then True = True #Else True &lt;&gt; False #EndIf
	  THEN TRUE
	  ELSE FALSE
	END
  #EndIf
#EndIf
</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ПоЗначениям</name>
		<condition>// ПоЗначениям(Таблица, -, Модификатор, В1,П1, В2,П2, ...,  В(n), П(n)).
// № параметра:      1, 2,           3,  4, 5,  6, 7, ..., 2+n*2,3+n*2.
// Читается так: "ограничение доступа по значениям".
// Параметры:
//     Таблица   - Имя текущей таблицы, например "Документ.ПоступлениеТоваровИУслуг".
//     Модификатор - изменяет шаблон.
//                 1-й модификатор - строка "НеОграничиватьДоступКГруппам" указывает
//                  безусловно выбирать группы иерархического справочника. 
//                 Других модификаторов в этой версии шаблона не предусмотрено.
//     В(n)      - Вид доступа - имя вида доступа, например, "Организации". Для полей составного типа, с целью повышения
//                  производительности, лучше указать несколько имен, например, "Организации,ГруппыФизическихЛиц",
//                  чем использовать несколько блоков параметров, с одним и тем же именем поля.
//                  Специальные виды доступа "Условие", "НастройкиПрав", "ПравоЧтения", "ПравоИзменения"
//                  можно использовать только отдельно.
//                 Когда В(n) = "Условие" (или ""), тогда П(n) содержит строку условия на языке запросов, например
//                  "Т.Автор = &amp;АвторизованныйПользователь",
//                  "ТИПЗНАЧЕНИЯ(Т.Владелец) = ТИП(Справочник.Организации)", где Т - псевдоним текущей таблицы.
//                 Когда В(n) = "ПравоЧтения" Или "ПравоИзменения",
//                  выполняется проверка наличия права на таблицу значения Т.П(n).
//     П(n)      - Поле проверяемого значения, кроме случая В(n) = "Условие" (или "").
//  Примечение: максимальное количество одновременно проверяемых значений полей можно увеличить, изменив шаблон, но
// необходимо будет указывать все параметры шаблона, т.е. указывать пустые строки, когда количество полей меньше максимального.
//  Шаблон имеет структуру:
//     &lt;Общая часть условий&gt; &lt;Условие по группе параметров 1&gt; И &lt;Условие по группе параметров 2&gt; И ... &lt;Условие по группе параметров(n)&gt;
//  Пример:
//      ПоЗначениям("Документ.ПоступлениеТоваровИУслуг", "", "",
//      "Организации","Организация",
//      "Поставщики","Контрагент", "","", ...)

// Проверка правильности параметра Право.
#Если Не ("#Параметр(2)" = "Чтение"    Или "#Параметр(2)" = "Добавление" Или
          "#Параметр(2)" = "Изменение" Или "#Параметр(2)" = "Удаление"   Или "#Параметр(2)" = "")
      Или #ИмяТекущегоПраваДоступа &lt;&gt; "Чтение" И "#Параметр(2)"  = "Чтение"
      Или #ИмяТекущегоПраваДоступа  = "Чтение" И "#Параметр(2)" &lt;&gt; "Чтение" И "#Параметр(2)" &lt;&gt; "" #Тогда
    // Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
    НеверноеПраво: #Параметр(2)
#КонецЕсли

// Проверка правильности параметра ИмяТаблицы.
#Если "#Параметр(1)" &lt;&gt; #ИмяТекущейТаблицы #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	НеверноеИмяТекущейТаблицы: "#Параметр(1)"
#КонецЕсли

// Проверка правильности параметра Модификатор.
#Если Не ("#Параметр(3)" = "НеОграничиватьДоступКГруппам" Или "#Параметр(3)" = "") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	НеверныйМодификатор: #Параметр(3)
#КонецЕсли

// Общая проверка использования ограничений доступа на уровне записей и
// проверка использования хотя бы одного ограничения из указанных видов доступа.
#Если &amp;ОграничиватьДоступНаУровнеЗаписей
  И Не (Истина
      И ("#Параметр(4)" = "" И "#Параметр(5)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(4),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(4),"))
      И ("#Параметр(6)" = "" И "#Параметр(7)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(6),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(6),"))
      И ("#Параметр(8)" = "" И "#Параметр(9)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(8),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(8),"))
      И ("#Параметр(10)" = "" И "#Параметр(11)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(10),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(10),"))
      И ("#Параметр(12)" = "" И "#Параметр(13)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(12),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(12),"))
      И ("#Параметр(14)" = "" И "#Параметр(15)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(14),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(14),"))
      И ("#Параметр(16)" = "" И "#Параметр(17)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(16),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(16),"))
      И ("#Параметр(18)" = "" И "#Параметр(19)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(18),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(18),"))
      И ("#Параметр(20)" = "" И "#Параметр(21)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(20),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(20),"))
      И ("#Параметр(22)" = "" И "#Параметр(23)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(22),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(22),"))
      И ("#Параметр(24)" = "" И "#Параметр(25)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(24),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(24),"))
      И ("#Параметр(26)" = "" И "#Параметр(27)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(26),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(26),"))
      И ("#Параметр(28)" = "" И "#Параметр(29)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(28),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(28),"))
      И ("#Параметр(30)" = "" И "#Параметр(31)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(30),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(30),"))
      И ("#Параметр(32)" = "" И "#Параметр(33)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(32),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(32),"))
      И ("#Параметр(34)" = "" И "#Параметр(35)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(34),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(34),"))
       ) #Тогда

Т ГДЕ // Т - псевдоним текущей таблицы (выбран коротким, чтобы сократить количество символов в тексте параметра-условия на языке запросов).

// Безусловная выборка групп в иерархическом объекте метаданных (если нужно).
#Если "#Параметр(3)" = "НеОграничиватьДоступКГруппам" #Тогда
	Т.ЭтоГруппа ИЛИ
#КонецЕсли

ИСТИНА В
(	// Проверка права пользователя на текущую таблицу в целом.
	// Права на таблицы формируются по составу ролей профиля группы доступа.
	ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
	ИЗ
		Справочник.ИдентификаторыОбъектовМетаданных КАК СвойстваТекущейТаблицы
		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
		ПО
			  СвойстваТекущейТаблицы.ПолноеИмя = "#Параметр(1)"
			И ИСТИНА В
			  (
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ
					РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
					ГДЕ
						  ТаблицыГруппДоступа.Таблица       = СвойстваТекущейТаблицы.Ссылка
						И ТаблицыГруппДоступа.ГруппаДоступа = ГруппыДоступа.Ссылка
					#Если Не #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
						И ТаблицыГруппДоступа.Изменение
					#КонецЕсли
			  )
			И ГруппыДоступа.Ссылка В
			  (
				ВЫБРАТЬ
					ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
				ИЗ
					Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
					ПО
						  СоставыГруппПользователей.Пользователь = &amp;АвторизованныйПользователь
						И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
			  )
	ГДЕ
  ( // Поиск значений заданных полей в разрешенных значениях групп доступа (пользователей).

//// Проверка значения поля группы параметров 1.
#Если "#Параметр(4)" = "Условие" Или "#Параметр(4)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	( #Параметр(5) )
#ИначеЕсли "#Параметр(4)" = "ПравоЧтения" Или "#Параметр(4)" = "ПравоИзменения" #Тогда
	  Т.#Параметр(5) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(5))
		#Если Не "#Параметр(4)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(4)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(5)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(5)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(4),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(4)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(4)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(4)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(4),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(4),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(4),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(5)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(4),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(5)
		#ИначеЕсли "Т.#Параметр(5)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(4)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(4)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(4),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(5)
			#КонецЕсли
		#Иначе // "Т.#Параметр(5)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(5)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(5))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

//// Проверка значения поля группы параметров 2.
#Если "#Параметр(6)" = "" И "#Параметр(7)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(6)" = "Условие" Или "#Параметр(6)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(7) )
#ИначеЕсли "#Параметр(6)" = "ПравоЧтения" Или "#Параметр(6)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(7) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(7))
		#Если Не "#Параметр(6)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(6)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(7)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(7)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(6),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(6)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(6)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(6)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(6),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(6),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(6),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(7)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(6),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(7)
		#ИначеЕсли "Т.#Параметр(7)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(6)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(6)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(6),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(7)
			#КонецЕсли
		#Иначе // "Т.#Параметр(7)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(7)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(7))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 3.
#Если "#Параметр(8)" = "" И "#Параметр(9)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(8)" = "Условие" Или "#Параметр(8)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(9) )
#ИначеЕсли "#Параметр(8)" = "ПравоЧтения" Или "#Параметр(8)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(9) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(9))
		#Если Не "#Параметр(8)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(8)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(9)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(9)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(8),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(8)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(8)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(8)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(8),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(8),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(8),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(9)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(8),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(9)
		#ИначеЕсли "Т.#Параметр(9)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(8)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(8)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(8),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(9)
			#КонецЕсли
		#Иначе // "Т.#Параметр(9)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(9)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(9))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 4.
#Если "#Параметр(10)" = "" И "#Параметр(11)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(10)" = "Условие" Или "#Параметр(10)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(11) )
#ИначеЕсли "#Параметр(10)" = "ПравоЧтения" Или "#Параметр(10)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(11) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(11))
		#Если Не "#Параметр(10)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(10)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(11)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(11)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(10),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(10)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(10)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(10)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(10),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(10),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(10),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(11)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(10),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(11)
		#ИначеЕсли "Т.#Параметр(11)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(10)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(10)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(10),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(11)
			#КонецЕсли
		#Иначе // "Т.#Параметр(11)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(11)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(11))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 5.
#Если "#Параметр(12)" = "" И "#Параметр(13)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(12)" = "Условие" Или "#Параметр(12)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(13) )
#ИначеЕсли "#Параметр(12)" = "ПравоЧтения" Или "#Параметр(12)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(13) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(13))
		#Если Не "#Параметр(12)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(12)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(13)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(13)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(12),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(12)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(12)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(12)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(12),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(12),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(12),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(13)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(12),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(13)
		#ИначеЕсли "Т.#Параметр(13)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(12)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(12)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(12),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(13)
			#КонецЕсли
		#Иначе // "Т.#Параметр(13)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(13)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(13))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 6.
#Если "#Параметр(14)" = "" И "#Параметр(15)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(14)" = "Условие" Или "#Параметр(14)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(15) )
#ИначеЕсли "#Параметр(14)" = "ПравоЧтения" Или "#Параметр(14)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(15) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(15))
		#Если Не "#Параметр(14)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(14)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(15)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(15)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(14),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(14)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(14)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(14)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(14),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(14),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(14),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(15)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(14),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(15)
		#ИначеЕсли "Т.#Параметр(15)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(14)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(14)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(14),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(15)
			#КонецЕсли
		#Иначе // "Т.#Параметр(15)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(15)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(15))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 7.
#Если "#Параметр(16)" = "" И "#Параметр(17)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(16)" = "Условие" Или "#Параметр(16)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(17) )
#ИначеЕсли "#Параметр(16)" = "ПравоЧтения" Или "#Параметр(16)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(17) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(17))
		#Если Не "#Параметр(16)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(16)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(17)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(17)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(16),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(16)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(16)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(16)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(16),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(16),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(16),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(17)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(16),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(17)
		#ИначеЕсли "Т.#Параметр(17)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(16)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(16)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(16),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(17)
			#КонецЕсли
		#Иначе // "Т.#Параметр(17)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(17)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(17))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 8.
#Если "#Параметр(18)" = "" И "#Параметр(19)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(18)" = "Условие" Или "#Параметр(18)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(19) )
#ИначеЕсли "#Параметр(18)" = "ПравоЧтения" Или "#Параметр(18)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(19) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(19))
		#Если Не "#Параметр(18)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(18)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(19)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(19)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(18),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(18)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(18)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(18)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(18),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(18),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(18),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(19)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(18),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(19)
		#ИначеЕсли "Т.#Параметр(19)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(18)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(18)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(18),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(19)
			#КонецЕсли
		#Иначе // "Т.#Параметр(19)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(19)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(19))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 9.
#Если "#Параметр(20)" = "" И "#Параметр(21)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(20)" = "Условие" Или "#Параметр(20)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(21) )
#ИначеЕсли "#Параметр(20)" = "ПравоЧтения" Или "#Параметр(20)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(21) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(21))
		#Если Не "#Параметр(20)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(20)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(21)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(21)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(20),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(20)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(20)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(20)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(20),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(20),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(20),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(21)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(20),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(21)
		#ИначеЕсли "Т.#Параметр(21)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(20)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(20)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(20),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(21)
			#КонецЕсли
		#Иначе // "Т.#Параметр(21)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(21)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(21))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 10.
#Если "#Параметр(22)" = "" И "#Параметр(23)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(22)" = "Условие" Или "#Параметр(22)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(23) )
#ИначеЕсли "#Параметр(22)" = "ПравоЧтения" Или "#Параметр(22)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(23) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(23))
		#Если Не "#Параметр(22)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(22)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(23)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(23)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(22),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(22)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(22)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(22)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(22),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(22),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(22),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(23)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(22),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(23)
		#ИначеЕсли "Т.#Параметр(23)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(22)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(22)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(22),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(23)
			#КонецЕсли
		#Иначе // "Т.#Параметр(23)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(23)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(23))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 11.
#Если "#Параметр(24)" = "" И "#Параметр(25)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(24)" = "Условие" Или "#Параметр(24)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(25) )
#ИначеЕсли "#Параметр(24)" = "ПравоЧтения" Или "#Параметр(24)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(25) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(25))
		#Если Не "#Параметр(24)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(24)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(25)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(25)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(24),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(24)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(24)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(24)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(24),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(24),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(24),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(25)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(24),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(25)
		#ИначеЕсли "Т.#Параметр(25)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(24)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(24)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(24),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(25)
			#КонецЕсли
		#Иначе // "Т.#Параметр(25)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(25)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(25))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 12.
#Если "#Параметр(26)" = "" И "#Параметр(27)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(26)" = "Условие" Или "#Параметр(26)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(27) )
#ИначеЕсли "#Параметр(26)" = "ПравоЧтения" Или "#Параметр(26)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(27) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(27))
		#Если Не "#Параметр(26)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(26)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(27)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(27)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(26),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(26)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(26)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(26)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(26),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(26),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(26),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(27)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(26),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(27)
		#ИначеЕсли "Т.#Параметр(27)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(26)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(26)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(26),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(27)
			#КонецЕсли
		#Иначе // "Т.#Параметр(27)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(27)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(27))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 13.
#Если "#Параметр(28)" = "" И "#Параметр(29)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(28)" = "Условие" Или "#Параметр(28)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(29) )
#ИначеЕсли "#Параметр(28)" = "ПравоЧтения" Или "#Параметр(28)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(29) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(29))
		#Если Не "#Параметр(28)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(28)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(29)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(29)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(28),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(28)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(28)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(28)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(28),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(28),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(28),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(29)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(28),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(29)
		#ИначеЕсли "Т.#Параметр(29)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(28)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(28)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(28),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(29)
			#КонецЕсли
		#Иначе // "Т.#Параметр(29)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(29)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(29))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 14.
#Если "#Параметр(30)" = "" И "#Параметр(31)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(30)" = "Условие" Или "#Параметр(30)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(31) )
#ИначеЕсли "#Параметр(30)" = "ПравоЧтения" Или "#Параметр(30)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(31) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(31))
		#Если Не "#Параметр(30)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(30)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(31)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(31)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(30),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(30)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(30)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(30)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(30),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(30),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(30),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(31)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(30),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(31)
		#ИначеЕсли "Т.#Параметр(31)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(30)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(30)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(30),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(31)
			#КонецЕсли
		#Иначе // "Т.#Параметр(31)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(31)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(31))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 15.
#Если "#Параметр(32)" = "" И "#Параметр(33)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(32)" = "Условие" Или "#Параметр(32)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(33) )
#ИначеЕсли "#Параметр(32)" = "ПравоЧтения" Или "#Параметр(32)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(33) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(33))
		#Если Не "#Параметр(32)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(32)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(33)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(33)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(32),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(32)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(32)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(32)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(32),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(32),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(32),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(33)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(32),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(33)
		#ИначеЕсли "Т.#Параметр(33)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(32)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(32)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(32),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(33)
			#КонецЕсли
		#Иначе // "Т.#Параметр(33)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(33)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(33))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

//// Проверка значения поля группы параметров 16.
#Если "#Параметр(34)" = "" И "#Параметр(35)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(34)" = "Условие" Или "#Параметр(34)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	И ( #Параметр(35) )
#ИначеЕсли "#Параметр(34)" = "ПравоЧтения" Или "#Параметр(34)" = "ПравоИзменения" #Тогда
	И Т.#Параметр(35) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(Т.#Параметр(35))
		#Если Не "#Параметр(34)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(34)" = "НастройкиПрав" #Тогда
	И
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(35)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = Т.#Параметр(35)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(34),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(34)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(34)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(34)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(34),") #Тогда
	И
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(34),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(34),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = Т.#Параметр(35)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(34),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.#Параметр(35)
		#ИначеЕсли "Т.#Параметр(35)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(34)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(34)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(34),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = Т.#Параметр(35)
			#КонецЕсли
		#Иначе // "Т.#Параметр(35)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = Т.#Параметр(35)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(Т.#Параметр(35))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#КонецЕсли

  )
)
#КонецЕсли

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ПоЗначениямРасширенный</name>
		<condition>// ПоЗначениямРасширенный(Таблица, -, Модификатор, ПрисоединяемыеТаблицы, О, В1,П1,О1, В2,П2,О2,..., В(n), П(n), О(n)).
// № параметра:                 1, 2,           3,                     4, 5,  6, 7, 8,  9,10,11,...,3+n*3,4+n*3,5+n*3.
// Читается так: "ограничение доступа по значениям расширенный".
// Параметры:
//     Таблица   - Имя текущей таблицы, например "Документ.ПоступлениеТоваровИУслуг".
//     Модификатор - изменяет шаблон.
//                 1-й модификатор - строка "НеОграничиватьДоступКГруппам" указывает
//                  безусловно выбирать группы иерархического справочника. 
//                 Других модификаторов в этой версии шаблона не предусмотрено.
//     ПрисоединяемыеТаблицы - текст присоедиения дополнительных таблиц на языке запросов, например,
//                 "ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.АвансовыйОтчет.ОплатаПоставщикам КАК Т1
//                  ПО Т.Ссылка = Т1.Ссылка".
//                 Присоединение позволяет указать поля таблицы ОплатаПоставщикам, как поля основной таблицы
//                  для проверки их значений, как значений основной таблицы.
//                 Следует помнить, что при размножении строк в результате соединения, достаточно чтобы
//                  всего одна строка прошла условия проверки, т.е. результаты проверки строк объединяются по "ИЛИ".
//     О         - Начальные скобки "(".
//     В(n)      - Вид доступа - имя вида доступа, например, "Организации". Для полей составного типа, с целью повышения
//                  производительности, лучше указать несколько имен, например, "Организации,ГруппыФизическихЛиц",
//                  чем использовать несколько блоков параметров, с одним и тем же именем поля.
//                  Специальные виды доступа "Условие", "НастройкиПрав", "ПравоЧтения", "ПравоИзменения"
//                  можно использовать только отдельно.
//                 Когда В(n) = "Условие" (или ""), тогда П(n) содержит строку условия на языке запросов, например
//                  "Т.Автор = &amp;АвторизованныйПользователь",
//                  "ТИПЗНАЧЕНИЯ(Т.Владелец) = ТИП(Справочник.Организации)", где Т - псевдоним текущей таблицы.
//                 Когда В(n) = "ПравоЧтения" Или "ПравоИзменения",
//                  выполняется проверка наличия права на таблицу значения Т.П(n).
//     П(n)      - Поле проверяемого значения с псевдонимом, например "Т.Организация",
//                 кроме случая В(n) = "Условие" (или "").
//     О(n)      - Логические операции "И", "ИЛИ" в сочетании с скобками "(", ")".
//  Примечение: максимальное количество одновременно проверяемых значений полей можно увеличить, изменив шаблон, но
// необходимо будет указывать все параметры шаблона, т.е. указывать пустые строки, когда количество полей меньше максимального.
//  Шаблон имеет структуру:
//     &lt;Общая часть условий&gt; &lt;Условие по группе параметров 1&gt; И/ИЛИ &lt;Условие по группе параметров 2&gt; И/ИЛИ ... &lt;Условие по группе параметров(n)&gt;
//  Пример:
//      ПоЗначениямРасширенный("Документ.ПеремещениеТоваров", "", "",
//      "",
//      "",
//      "Организации","Т.Организация","И(",
//      "Склады","Т.СкладОтправитель","ИЛИ",
//      "Склады","Т.СкладПолучатель",")", "","","", ...)

// Проверка правильности параметра Право.
#Если Не ("#Параметр(2)" = "Чтение"    Или "#Параметр(2)" = "Добавление" Или
          "#Параметр(2)" = "Изменение" Или "#Параметр(2)" = "Удаление"   Или "#Параметр(2)" = "")
      Или #ИмяТекущегоПраваДоступа &lt;&gt; "Чтение" И "#Параметр(2)"  = "Чтение"
      Или #ИмяТекущегоПраваДоступа  = "Чтение" И "#Параметр(2)" &lt;&gt; "Чтение" И "#Параметр(2)" &lt;&gt; "" #Тогда
    // Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
    НеверноеПраво: #Параметр(2)
#КонецЕсли

// Проверка правильности параметра ИмяТаблицы.
#Если "#Параметр(1)" &lt;&gt; #ИмяТекущейТаблицы #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	НеверноеИмяТекущейТаблицы: "#Параметр(1)"
#КонецЕсли

// Проверка правильности параметра Модификатор.
#Если Не ("#Параметр(3)" = "НеОграничиватьДоступКГруппам" Или "#Параметр(3)" = "") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	НеверныйМодификатор: #Параметр(3)
#КонецЕсли

// Общая проверка использования ограничений доступа на уровне записей и
// проверка использования хотя бы одного ограничения из указанных видов доступа.
#Если &amp;ОграничиватьДоступНаУровнеЗаписей
  И Не (Истина
      И ("#Параметр(6)" = "" И "#Параметр(7)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(6),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(6),"))
      И ("#Параметр(9)" = "" И "#Параметр(10)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(9),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(9),"))
      И ("#Параметр(12)" = "" И "#Параметр(13)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(12),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(12),"))
      И ("#Параметр(15)" = "" И "#Параметр(16)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(15),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(15),"))
      И ("#Параметр(18)" = "" И "#Параметр(19)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(18),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(18),"))
      И ("#Параметр(21)" = "" И "#Параметр(22)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(21),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(21),"))
      И ("#Параметр(24)" = "" И "#Параметр(25)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(24),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(24),"))
      И ("#Параметр(27)" = "" И "#Параметр(28)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(27),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(27),"))
      И ("#Параметр(30)" = "" И "#Параметр(31)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(30),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(30),"))
      И ("#Параметр(33)" = "" И "#Параметр(34)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(33),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(33),"))
      И ("#Параметр(36)" = "" И "#Параметр(37)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(36),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(36),"))
      И ("#Параметр(39)" = "" И "#Параметр(40)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(39),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(39),"))
      И ("#Параметр(42)" = "" И "#Параметр(43)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(42),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(42),"))
      И ("#Параметр(45)" = "" И "#Параметр(46)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(45),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(45),"))
      И ("#Параметр(48)" = "" И "#Параметр(49)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(48),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(48),"))
      И ("#Параметр(51)" = "" И "#Параметр(52)" = ""
         Или &amp;ВидыДоступаСОтключеннымИспользованием = "Все"
           И Не СтрСодержит(",Условие,,НастройкиПрав,Объект, ,ПравоЧтения,ПравоИзменения,", ",#Параметр(51),")
         Или СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(51),"))
       ) #Тогда

Т ИЗ Т // Т - псевдоним текущей таблицы (выбран коротким, чтобы сократить количество символов в тексте параметра-условия на языке запросов).

// Присоединяемые таблицы к проверяемой строке текущей таблицы "Т".
#Параметр(4)

ГДЕ

// Безусловная выборка групп в иерархическом объекте метаданных (если нужно).
#Если "#Параметр(3)" = "НеОграничиватьДоступКГруппам" #Тогда
	Т.ЭтоГруппа ИЛИ
#КонецЕсли

ИСТИНА В
(	// Проверка права пользователя на текущую таблицу в целом.
	// Права на таблицы формируются по составу ролей профиля группы доступа.
	ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
	ИЗ
		Справочник.ИдентификаторыОбъектовМетаданных КАК СвойстваТекущейТаблицы
		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
		ПО
			  СвойстваТекущейТаблицы.ПолноеИмя = "#Параметр(1)"
			И ИСТИНА В
			  (
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ
					РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
					ГДЕ
						  ТаблицыГруппДоступа.Таблица       = СвойстваТекущейТаблицы.Ссылка
						И ТаблицыГруппДоступа.ГруппаДоступа = ГруппыДоступа.Ссылка
					#Если Не #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
						И ТаблицыГруппДоступа.Изменение
					#КонецЕсли
			  )
			И ГруппыДоступа.Ссылка В
			  (
				ВЫБРАТЬ
					ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
				ИЗ
					Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
					ПО
						  СоставыГруппПользователей.Пользователь = &amp;АвторизованныйПользователь
						И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
			  )
	ГДЕ
  ( // Поиск значений заданных полей в разрешенных значениях групп доступа (пользователей).

	#Параметр(5)  // [([(][(]...] 0-n открывающихся скобок.

//// Проверка значения поля группы параметров 1.
#Если "#Параметр(6)" = "Условие" Или "#Параметр(6)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	( #Параметр(7) )
#ИначеЕсли "#Параметр(6)" = "ПравоЧтения" Или "#Параметр(6)" = "ПравоИзменения" #Тогда
	  #Параметр(7) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(7))
		#Если Не "#Параметр(6)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(6)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(7)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(7)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(6),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(6)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(6)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(6)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(6),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(6),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(6),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(7)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(6),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(7)
		#ИначеЕсли "#Параметр(7)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(6)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(6)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(6),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(7)
			#КонецЕсли
		#Иначе // "#Параметр(7)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(7)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(7))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(8)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 2.
#Если "#Параметр(9)" = "" И "#Параметр(10)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(9)" = "Условие" Или "#Параметр(9)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(10) )
#ИначеЕсли "#Параметр(9)" = "ПравоЧтения" Или "#Параметр(9)" = "ПравоИзменения" #Тогда
	 #Параметр(10) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(10))
		#Если Не "#Параметр(9)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(9)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(10)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(10)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(9),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(9)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(9)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(9)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(9),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(9),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(9),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(10)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(9),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(10)
		#ИначеЕсли "#Параметр(10)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(9)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(9)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(9),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(10)
			#КонецЕсли
		#Иначе // "#Параметр(10)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(10)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(10))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(11)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 3.
#Если "#Параметр(12)" = "" И "#Параметр(13)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(12)" = "Условие" Или "#Параметр(12)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(13) )
#ИначеЕсли "#Параметр(12)" = "ПравоЧтения" Или "#Параметр(12)" = "ПравоИзменения" #Тогда
	 #Параметр(13) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(13))
		#Если Не "#Параметр(12)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(12)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(13)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(13)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(12),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(12)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(12)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(12)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(12),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(12),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(12),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(13)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(12),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(13)
		#ИначеЕсли "#Параметр(13)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(12)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(12)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(12),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(13)
			#КонецЕсли
		#Иначе // "#Параметр(13)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(13)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(13))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(14)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 4.
#Если "#Параметр(15)" = "" И "#Параметр(16)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(15)" = "Условие" Или "#Параметр(15)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(16) )
#ИначеЕсли "#Параметр(15)" = "ПравоЧтения" Или "#Параметр(15)" = "ПравоИзменения" #Тогда
	 #Параметр(16) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(16))
		#Если Не "#Параметр(15)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(15)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(16)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(16)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(15),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(15)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(15)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(15)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(15),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(15),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(15),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(16)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(15),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(16)
		#ИначеЕсли "#Параметр(16)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(15)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(15)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(15),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(16)
			#КонецЕсли
		#Иначе // "#Параметр(16)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(16)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(16))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(17)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 5.
#Если "#Параметр(18)" = "" И "#Параметр(19)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(18)" = "Условие" Или "#Параметр(18)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(19) )
#ИначеЕсли "#Параметр(18)" = "ПравоЧтения" Или "#Параметр(18)" = "ПравоИзменения" #Тогда
	 #Параметр(19) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(19))
		#Если Не "#Параметр(18)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(18)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(19)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(19)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(18),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(18)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(18)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(18)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(18),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(18),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(18),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(19)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(18),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(19)
		#ИначеЕсли "#Параметр(19)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(18)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(18)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(18),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(19)
			#КонецЕсли
		#Иначе // "#Параметр(19)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(19)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(19))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(20)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 6.
#Если "#Параметр(21)" = "" И "#Параметр(22)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(21)" = "Условие" Или "#Параметр(21)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(22) )
#ИначеЕсли "#Параметр(21)" = "ПравоЧтения" Или "#Параметр(21)" = "ПравоИзменения" #Тогда
	 #Параметр(22) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(22))
		#Если Не "#Параметр(21)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(21)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(22)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(22)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(21),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(21)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(21)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(21)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(21),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(21),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(21),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(22)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(21),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(22)
		#ИначеЕсли "#Параметр(22)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(21)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(21)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(21),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(22)
			#КонецЕсли
		#Иначе // "#Параметр(22)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(22)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(22))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(23)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 7.
#Если "#Параметр(24)" = "" И "#Параметр(25)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(24)" = "Условие" Или "#Параметр(24)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(25) )
#ИначеЕсли "#Параметр(24)" = "ПравоЧтения" Или "#Параметр(24)" = "ПравоИзменения" #Тогда
	 #Параметр(25) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(25))
		#Если Не "#Параметр(24)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(24)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(25)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(25)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(24),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(24)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(24)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(24)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(24),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(24),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(24),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(25)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(24),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(25)
		#ИначеЕсли "#Параметр(25)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(24)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(24)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(24),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(25)
			#КонецЕсли
		#Иначе // "#Параметр(25)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(25)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(25))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(26)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 8.
#Если "#Параметр(27)" = "" И "#Параметр(28)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(27)" = "Условие" Или "#Параметр(27)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(28) )
#ИначеЕсли "#Параметр(27)" = "ПравоЧтения" Или "#Параметр(27)" = "ПравоИзменения" #Тогда
	 #Параметр(28) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(28))
		#Если Не "#Параметр(27)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(27)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(28)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(28)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(27),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(27)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(27)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(27)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(27),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(27),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(27),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(28)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(27),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(28)
		#ИначеЕсли "#Параметр(28)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(27)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(27)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(27),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(28)
			#КонецЕсли
		#Иначе // "#Параметр(28)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(28)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(28))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(29)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 9.
#Если "#Параметр(30)" = "" И "#Параметр(31)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(30)" = "Условие" Или "#Параметр(30)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(31) )
#ИначеЕсли "#Параметр(30)" = "ПравоЧтения" Или "#Параметр(30)" = "ПравоИзменения" #Тогда
	 #Параметр(31) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(31))
		#Если Не "#Параметр(30)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(30)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(31)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(31)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(30),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(30)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(30)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(30)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(30),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(30),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(30),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(31)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(30),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(31)
		#ИначеЕсли "#Параметр(31)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(30)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(30)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(30),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(31)
			#КонецЕсли
		#Иначе // "#Параметр(31)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(31)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(31))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(32)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 10.
#Если "#Параметр(33)" = "" И "#Параметр(34)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(33)" = "Условие" Или "#Параметр(33)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(34) )
#ИначеЕсли "#Параметр(33)" = "ПравоЧтения" Или "#Параметр(33)" = "ПравоИзменения" #Тогда
	 #Параметр(34) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(34))
		#Если Не "#Параметр(33)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(33)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(34)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(34)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(33),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(33)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(33)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(33)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(33),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(33),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(33),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(34)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(33),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(34)
		#ИначеЕсли "#Параметр(34)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(33)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(33)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(33),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(34)
			#КонецЕсли
		#Иначе // "#Параметр(34)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(34)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(34))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(35)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 11.
#Если "#Параметр(36)" = "" И "#Параметр(37)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(36)" = "Условие" Или "#Параметр(36)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(37) )
#ИначеЕсли "#Параметр(36)" = "ПравоЧтения" Или "#Параметр(36)" = "ПравоИзменения" #Тогда
	 #Параметр(37) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(37))
		#Если Не "#Параметр(36)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(36)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(37)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(37)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(36),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(36)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(36)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(36)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(36),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(36),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(36),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(37)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(36),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(37)
		#ИначеЕсли "#Параметр(37)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(36)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(36)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(36),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(37)
			#КонецЕсли
		#Иначе // "#Параметр(37)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(37)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(37))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(38)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 12.
#Если "#Параметр(39)" = "" И "#Параметр(40)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(39)" = "Условие" Или "#Параметр(39)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(40) )
#ИначеЕсли "#Параметр(39)" = "ПравоЧтения" Или "#Параметр(39)" = "ПравоИзменения" #Тогда
	 #Параметр(40) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(40))
		#Если Не "#Параметр(39)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(39)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(40)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(40)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(39),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(39)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(39)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(39)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(39),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(39),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(39),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(40)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(39),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(40)
		#ИначеЕсли "#Параметр(40)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(39)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(39)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(39),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(40)
			#КонецЕсли
		#Иначе // "#Параметр(40)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(40)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(40))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(41)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 13.
#Если "#Параметр(42)" = "" И "#Параметр(43)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(42)" = "Условие" Или "#Параметр(42)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(43) )
#ИначеЕсли "#Параметр(42)" = "ПравоЧтения" Или "#Параметр(42)" = "ПравоИзменения" #Тогда
	 #Параметр(43) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(43))
		#Если Не "#Параметр(42)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(42)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(43)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(43)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(42),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(42)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(42)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(42)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(42),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(42),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(42),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(43)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(42),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(43)
		#ИначеЕсли "#Параметр(43)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(42)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(42)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(42),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(43)
			#КонецЕсли
		#Иначе // "#Параметр(43)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(43)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(43))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(44)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 14.
#Если "#Параметр(45)" = "" И "#Параметр(46)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(45)" = "Условие" Или "#Параметр(45)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(46) )
#ИначеЕсли "#Параметр(45)" = "ПравоЧтения" Или "#Параметр(45)" = "ПравоИзменения" #Тогда
	 #Параметр(46) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(46))
		#Если Не "#Параметр(45)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(45)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(46)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(46)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(45),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(45)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(45)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(45)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(45),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(45),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(45),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(46)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(45),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(46)
		#ИначеЕсли "#Параметр(46)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(45)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(45)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(45),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(46)
			#КонецЕсли
		#Иначе // "#Параметр(46)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(46)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(46))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(47)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 15.
#Если "#Параметр(48)" = "" И "#Параметр(49)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(48)" = "Условие" Или "#Параметр(48)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(49) )
#ИначеЕсли "#Параметр(48)" = "ПравоЧтения" Или "#Параметр(48)" = "ПравоИзменения" #Тогда
	 #Параметр(49) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(49))
		#Если Не "#Параметр(48)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(48)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(49)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(49)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(48),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(48)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(48)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(48)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(48),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(48),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(48),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(49)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(48),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(49)
		#ИначеЕсли "#Параметр(49)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(48)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(48)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(48),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(49)
			#КонецЕсли
		#Иначе // "#Параметр(49)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(49)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(49))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(50)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

//// Проверка значения поля группы параметров 16.
#Если "#Параметр(51)" = "" И "#Параметр(52)" = "" #Тогда
	// Группа параметров не используется.
#ИначеЕсли "#Параметр(51)" = "Условие" Или "#Параметр(51)" = "" #Тогда
	// Когда имя вида доступа "Условие" (или ""), тогда вместо имени поля задано условие.
	 ( #Параметр(52) )
#ИначеЕсли "#Параметр(51)" = "ПравоЧтения" Или "#Параметр(51)" = "ПравоИзменения" #Тогда
	 #Параметр(52) &lt;&gt; НЕОПРЕДЕЛЕНО
	И ИСТИНА В
	 (	// Проверка права пользователя на таблицу Значения, установленного в поле.
		ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
		ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПрава
		ГДЕ
			  ТаблицыГруппДоступаПроверкаПрава.ГруппаДоступа = ГруппыДоступа.Ссылка
			И ТИПЗНАЧЕНИЯ(ТаблицыГруппДоступаПроверкаПрава.ТипТаблицы) = ТИПЗНАЧЕНИЯ(#Параметр(52))
		#Если Не "#Параметр(51)" = "ПравоЧтения" #Тогда
			И ТаблицыГруппДоступаПроверкаПрава.Изменение
		#КонецЕсли
	 )
#ИначеЕсли "#Параметр(51)" = "НастройкиПрав" #Тогда
	
	 (
		ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(52)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
		 И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено.
			(
			ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
			ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
				ПО
					  НаследованиеНастроек.Объект = #Параметр(52)
					И НастройкиПрав.Объект  = НаследованиеНастроек.Родитель
				#Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
				#Иначе
				  #Если СтрСодержит(&amp;ТаблицыСОтдельнымиНастройкамиПрав, "|#Параметр(1);") #Тогда
					И НастройкиПрав.Таблица = СвойстваТекущейТаблицы.Ссылка
				  #Иначе
					И НастройкиПрав.Таблица = ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
				  #КонецЕсли
					И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
				#КонецЕсли
				ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
				ПО
					  СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
					И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
			)
	 )
#ИначеЕсли Не СтрСодержит(&amp;ВсеВидыДоступаКромеСпециальных, ",#Параметр(51),") #Тогда
	// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
	#Если СтрСодержит("#Параметр(51)", ",") #Тогда
		НеверныйВидДоступа: "#Параметр(51)" - "Список имен видов доступа не найден"
	#Иначе
		НеверныйВидДоступа: "#Параметр(51)" - "Имя вида доступа не найдено"
	#КонецЕсли
#ИначеЕсли &amp;ВидыДоступаСОтключеннымИспользованием &lt;&gt; "Все"
         И Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",#Параметр(51),") #Тогда
	
	 (
		#Если (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")        И СтрСодержит(",#Параметр(51),", ",Пользователи,"))
		  Или (Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") И СтрСодержит(",#Параметр(51),", ",ВнешниеПользователи,")) #Тогда
			НЕ
			(
			НЕ ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
				ГДЕ
					  ГруппыЗначенийДоступа.ЗначениеДоступа       = #Параметр(52)
					И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
				)
			И НЕ
		#Иначе
			(
		#КонецЕсли
			ВЫБОР
			КОГДА ИСТИНА В
				(
		#Если СтрСодержит(&amp;ВидыДоступаБезГруппДляЗначенияДоступа, ",#Параметр(51),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = #Параметр(52)
		#ИначеЕсли "#Параметр(52)" = "Т.Ссылка" #Тогда
			#Если СтрСодержит("#Параметр(51)", ",") #Тогда
				// Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
				НеверныйВидДоступа: "#Параметр(51)" - "При проверке таблицы значения доступа можно указывать только один вид доступа"
			#ИначеЕсли СтрСодержит(&amp;ВидыДоступаСОднойГруппойДляЗначенияДоступа, ",#Параметр(51),") #Тогда
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
				ГДЕ
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = Т.ГруппаДоступа
			#Иначе // Значения доступа, для которых можно указать несколько групп значений доступа.
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ #Параметр(1).ГруппыДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаДоступа
					И ГруппыЗначений.Ссылка    = #Параметр(52)
			#КонецЕсли
		#Иначе // "#Параметр(52)" &lt;&gt; "Т.Ссылка"
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступа КАК Значения
					ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
				ПО
					  Значения.ГруппаДоступа         = ГруппыДоступа.Ссылка
					И Значения.ЗначениеДоступа       = ГруппыЗначений.ГруппаЗначенийДоступа
					И ГруппыЗначений.ЗначениеДоступа = #Параметр(52)
		#КонецЕсли
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			=
			ВЫБОР
			КОГДА ИСТИНА В
				(
				ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
				ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
				ГДЕ
				      ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
				    И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(#Параметр(52))
				    И ЗначенияПоУмолчанию.ВсеРазрешены = ЛОЖЬ
				)
			ТОГДА ИСТИНА
			ИНАЧЕ ЛОЖЬ
			КОНЕЦ
			)
	 )
#Иначе
	ИСТИНА
#КонецЕсли

	#Параметр(53)  // [)[)][)]...] [ИЛИ|И] [([(][(]...] оператор И/ИЛИ с/без скобок.

  )
)
#КонецЕсли

</condition>
	</restrictionTemplate>
	<restrictionTemplate>
		<name>ПоНаборамЗначений</name>
		<condition>// ПоНаборамЗначений(Таблица, -, Модификатор, ВладелецНаборов).
// № параметра:            1, 2,           3,               4.
// Читается так: "ограничение доступа по наборам значений".
// Параметры:
//     Таблица   - Имя текущей таблицы, например "Документ.ПоступлениеТоваровИУслуг".
//     Модификатор - изменяет шаблон.
//                 1-й модификатор - строка "НеОграничиватьДоступКГруппам" указывает
//                  безусловно выбирать группы иерархического справочника.
//                 2-й модификатор - строка "РасширенноеИЛИ" указывает для ограничений,
//                  например, "ПоОрганизациям или ПоУчетнымЗаписям" делать расширенную
//                  проверку, при которой вариант настройки вида доступа в группах доступа
//                  "Все разрешены, без запрещенных" считается, как "Вид доступа не используется".
//                  Если этого модификатора нет, тогда результат проверки Истина, что приводит
//                  к итоговому результату Истина, если "Все разрешены, без запрещенных"
//                  хотя бы по одному из видов доступа (либо ПоОрганизациям, либо ПоУчетнымЗаписям).
//                  Модификатор имеет смысл только при проверке наборов значений доступа.
//                  Можно использовать комбинации модификаторов: "НеОграничиватьДоступКГруппам",
//                  "РасширенноеИЛИ", "НеОграничиватьДоступКГруппам,РасширенноеИЛИ".
//                 Других модификаторов в этой версии шаблона не предусмотрено.
//     ВладелецНаборов - имя поля, содержащего ссылку на объект-владелец
//                 наборов значений доступа в регистре сведений НаборыЗначенийДоступа.
//                 Если имя поля не задано, считается, что проверяется сам объект-владелец
//                 наборов значений доступа, который имеет табличную часть &lt;Таблица&gt;.НаборыЗначенийДоступа.
//                 Эта табличная часть применяется, когда Право = "Изменение".
//                 Табличная часть точно такая, как РегистрСведений.НаборыЗначенийДоступа
//                 без измерения Объект и реквизитов.
//                 Для журналов документов нужно указать "Ссылка".
//
// Пример1: ПоНаборамЗначений("Документ.КорректировкаДенежныхСредств", "", "", "")
// Пример2: ПоНаборамЗначений("Документ.ПоступлениеТоваровИУслуг",     "", "", "")
// Пример3: ПоНаборамЗначений("ЖурналДокументов.СкладскиеДокументы",   "", "", "Ссылка")
// Пример4: ПоНаборамЗначений("Справочник.ВложенияЭлектронныхПисем",   "", "", "Владелец")

// Проверка правильности параметра Право.
#Если Не ("#Параметр(2)" = "Чтение"    Или "#Параметр(2)" = "Добавление" Или
          "#Параметр(2)" = "Изменение" Или "#Параметр(2)" = "Удаление"   Или "#Параметр(2)" = "")
      Или #ИмяТекущегоПраваДоступа &lt;&gt; "Чтение" И "#Параметр(2)"  = "Чтение"
      Или #ИмяТекущегоПраваДоступа  = "Чтение" И "#Параметр(2)" &lt;&gt; "Чтение" И "#Параметр(2)" &lt;&gt; "" #Тогда
    // Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
    НеверноеПраво: #Параметр(2)
#КонецЕсли

// Проверка правильности параметра ИмяТаблицы.
#Если "#Параметр(1)" &lt;&gt; #ИмяТекущейТаблицы #Тогда
    // Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
    НеверноеИмяТекущейТаблицы: "#Параметр(1)"
#КонецЕсли

// Проверка правильности параметра Модификатор.
#Если Не (    "#Параметр(3)" = "НеОграничиватьДоступКГруппам"
          Или "#Параметр(3)" = "РасширенноеИЛИ"
          Или "#Параметр(3)" = "НеОграничиватьДоступКГруппам,РасширенноеИЛИ"
          Или "#Параметр(3)" = "") #Тогда
    // Когда параметр задан неверно, вставляется строка, чтобы вызвать ошибку сборки ограничения доступа.
    НеверныйМодификатор: #Параметр(3)
#КонецЕсли

// Общая проверка использования ограничений доступа на уровне записей.
#Если &amp;ОграничиватьДоступНаУровнеЗаписей #Тогда

Т ГДЕ // Т - псевдоним текущей таблицы (выбран коротким, чтобы сократить количество символов в тексте параметра-условия на языке запросов).

// Безусловная выборка групп в иерархическом объекте метаданных (если нужно).
#Если "#Параметр(3)" = "НеОграничиватьДоступКГруппам" Или "#Параметр(3)" = "НеОграничиватьДоступКГруппам,РасширенноеИЛИ" #Тогда
    Т.ЭтоГруппа Или
#КонецЕсли

ИСТИНА В
(   // Проверка права пользователя на текущую таблицу в целом.
    // Права на таблицы формируются по составу ролей профиля группы доступа.
    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
    ИЗ
        Справочник.ИдентификаторыОбъектовМетаданных КАК СвойстваТекущейТаблицы
        ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ГруппыДоступа КАК ГруппыДоступа
        ПО
              СвойстваТекущейТаблицы.ПолноеИмя = "#Параметр(1)"
            И ИСТИНА В
              (
                ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                ИЗ
                    РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступа
                    ГДЕ
                          ТаблицыГруппДоступа.Таблица       = СвойстваТекущейТаблицы.Ссылка
                        И ТаблицыГруппДоступа.ГруппаДоступа = ГруппыДоступа.Ссылка
                    #Если Не #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                        И ТаблицыГруппДоступа.Изменение
                    #КонецЕсли
              )
            И ГруппыДоступа.Ссылка В
              (
                ВЫБРАТЬ
                    ГруппыДоступаПользователи.Ссылка КАК ГруппаДоступа
                ИЗ
                    Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
                    ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
                    ПО
                          СоставыГруппПользователей.Пользователь = &amp;АвторизованныйПользователь
                        И СоставыГруппПользователей.ГруппаПользователей = ГруппыДоступаПользователи.Пользователь
              )
    ГДЕ
#Если "#Параметр(3)" = "РасширенноеИЛИ" Или "#Параметр(3)" = "НеОграничиватьДоступКГруппам,РасширенноеИЛИ" #Тогда
 НЕ
 (
  ИСТИНА В // Не все проверки отключены.
  (
            ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Выбор первого набора с не отключенной проверкой.
        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
            ИЗ РегистрСведений.НаборыЗначенийДоступа КАК НомераНаборов
            ГДЕ
            #Если "#Параметр(4)" = "" #Тогда
                  НомераНаборов.Объект = Т.Ссылка
            #Иначе
                  НомераНаборов.Объект = Т.#Параметр(4)
            #КонецЕсли
        #Иначе
            ИЗ #Параметр(1).НаборыЗначенийДоступа КАК НомераНаборов
            ГДЕ
                  НомераНаборов.Ссылка = Т.Ссылка
        #КонецЕсли
            #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                И НомераНаборов.Чтение
            #Иначе
                И НомераНаборов.Изменение
            #КонецЕсли
                И 
    ИСТИНА В // Не все проверки текущего набора отключены.
    (
        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Выбор первой не отключенной проверки текущего набора.
    #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
        ИЗ РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
        #Если "#Параметр(4)" = "" #Тогда
              НаборыЗначений.Объект = Т.Ссылка
        #Иначе
              НаборыЗначений.Объект = Т.#Параметр(4)
        #КонецЕсли
    #Иначе
        ИЗ #Параметр(1).НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
              НаборыЗначений.Ссылка = Т.Ссылка
    #КонецЕсли
            И НаборыЗначений.НомерНабора = НомераНаборов.НомерНабора
            И НЕ ИСТИНА В
                (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Поиск настроек ограничений доступа
                    ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                    ГДЕ
                          ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
                        И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                        И ЗначенияПоУмолчанию.БезНастройки = ИСТИНА
                )
    )
  ) И НЕ
#Иначе
 (
#КонецЕсли
  ИСТИНА В
  (
            ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Выбор первого набора по которому доступ разрешен.
        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
            ИЗ РегистрСведений.НаборыЗначенийДоступа КАК НомераНаборов
            ГДЕ
            #Если "#Параметр(4)" = "" #Тогда
                  НомераНаборов.Объект = Т.Ссылка
            #Иначе
                  НомераНаборов.Объект = Т.#Параметр(4)
            #КонецЕсли
        #Иначе
            ИЗ #Параметр(1).НаборыЗначенийДоступа КАК НомераНаборов
            ГДЕ
                  НомераНаборов.Ссылка = Т.Ссылка
        #КонецЕсли
            #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                И НомераНаборов.Чтение
            #Иначе
                И НомераНаборов.Изменение
            #КонецЕсли
                И
  #Если "#Параметр(3)" = "РасширенноеИЛИ" Или "#Параметр(3)" = "НеОграничиватьДоступКГруппам,РасширенноеИЛИ" #Тогда
    ИСТИНА В // Не все проверки текущего набора отключены.
    (
        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Выбор первой не отключенной проверки текущего набора.
    #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
        ИЗ РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
        #Если "#Параметр(4)" = "" #Тогда
              НаборыЗначений.Объект = Т.Ссылка
        #Иначе
              НаборыЗначений.Объект = Т.#Параметр(4)
        #КонецЕсли
    #Иначе
        ИЗ #Параметр(1).НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
              НаборыЗначений.Ссылка = Т.Ссылка
    #КонецЕсли
            И НаборыЗначений.НомерНабора = НомераНаборов.НомерНабора
            И НЕ ИСТИНА В
                (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА // Поиск настроек ограничений доступа
                    ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                    ГДЕ
                          ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
                        И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                        И ЗначенияПоУмолчанию.БезНастройки = ИСТИНА
                )
    ) И
  #КонецЕсли
    НЕ ЛОЖЬ В // Все проверки успешны.
    (
        ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ // Выбор первого не разрешенного значения доступа.
    #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
        ИЗ РегистрСведений.НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
        #Если "#Параметр(4)" = "" #Тогда
              НаборыЗначений.Объект = Т.Ссылка
        #Иначе
              НаборыЗначений.Объект = Т.#Параметр(4)
        #КонецЕсли
    #Иначе
        ИЗ #Параметр(1).НаборыЗначенийДоступа КАК НаборыЗначений
        ГДЕ
              НаборыЗначений.Ссылка = Т.Ссылка
    #КонецЕсли
            И НаборыЗначений.НомерНабора = НомераНаборов.НомерНабора
            И НЕ
            ВЫБОР
        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
          #Если Не &amp;ВидыДоступаСОтключеннымИспользованием = "Все" #Тогда
            КОГДА НаборыЗначений.ЗначениеБезГрупп
            ТОГДА
                ИСТИНА В
                    (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                    ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                        ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияГруппДоступа КАК Значения
                        ПО
                              Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
                            И Значения.ЗначениеДоступа = НаборыЗначений.ЗначениеДоступа
                    ГДЕ
                          ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
                        И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                        И ЕСТЬNULL(Значения.ЗначениеРазрешено, ЗначенияПоУмолчанию.ВсеРазрешены)
                    )
          #КонецЕсли
            КОГДА НаборыЗначений.СтандартноеЗначение
        #Иначе
            КОГДА
                ИСТИНА В
                (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                    ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                    ГДЕ
                        ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                )
        #КонецЕсли
        #Если &amp;ВидыДоступаСОтключеннымИспользованием = "Все" #Тогда
            ТОГДА
                ИСТИНА
        #Иначе
            ТОГДА
            #Если Не #ИмяТекущегоПраваДоступа = "Чтение"
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") #Тогда
                ВЫБОР
            #КонецЕсли
            #Если Не #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                КОГДА
                    НЕ ИСТИНА В
                        (
                        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                        ИЗ Справочник.ИдентификаторыОбъектовМетаданных КАК ТипыСсылок
                        ГДЕ
                              ТИПЗНАЧЕНИЯ(ТипыСсылок.ЗначениеПустойСсылки) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                            И ТипыСсылок.ЗначениеПустойСсылки В (&amp;ТипыЗначенийДоступаСГруппами)
                        )
                ТОГДА
                    ИСТИНА В
                        (
                        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                        ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                            ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияГруппДоступа КАК Значения
                            ПО
                                  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
                                И Значения.ЗначениеДоступа = НаборыЗначений.ЗначениеДоступа
                        ГДЕ
                              ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
                            И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                            И ЕСТЬNULL(Значения.ЗначениеРазрешено, ЗначенияПоУмолчанию.ВсеРазрешены)
                        )
            #КонецЕсли
            #Если Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") #Тогда
                КОГДА
                    ИСТИНА В
                        (
                        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                        ИЗ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначенийДоступа
                        ГДЕ
                              ГруппыЗначенийДоступа.ЗначениеДоступа       = НаборыЗначений.ЗначениеДоступа
                            И ГруппыЗначенийДоступа.ГруппаЗначенийДоступа = &amp;АвторизованныйПользователь
                        )
                ТОГДА
                    ИСТИНА
            #КонецЕсли
            #Если Не #ИмяТекущегоПраваДоступа = "Чтение"
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") #Тогда
                ИНАЧЕ
            #КонецЕсли
                    ИСТИНА В
                        (
                        ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                        ИЗ РегистрСведений.ЗначенияГруппДоступаПоУмолчанию КАК ЗначенияПоУмолчанию
                            ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ГруппыЗначенийДоступа КАК ГруппыЗначений
                            ПО
                                  ГруппыЗначений.ЗначениеДоступа    = НаборыЗначений.ЗначениеДоступа
                                И ЗначенияПоУмолчанию.ГруппаДоступа = ГруппыДоступа.Ссылка
                                И ТИПЗНАЧЕНИЯ(ЗначенияПоУмолчанию.ТипЗначенийДоступа) = ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа)
                            
                            ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияГруппДоступа КАК Значения
                            ПО
                                  Значения.ГруппаДоступа   = ГруппыДоступа.Ссылка
                                И Значения.ЗначениеДоступа = ГруппыЗначений.ГруппаЗначенийДоступа
                        ГДЕ
                            ЕСТЬNULL(Значения.ЗначениеРазрешено, ЗначенияПоУмолчанию.ВсеРазрешены)
                        )
            #Если Не #ИмяТекущегоПраваДоступа = "Чтение"
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",Пользователи,")
              Или Не СтрСодержит(&amp;ВидыДоступаСОтключеннымИспользованием, ",ВнешниеПользователи,") #Тогда
                КОНЕЦ
            #КонецЕсли
        #КонецЕсли
            // Проверка заведомого ложного или истинного однострочного набора значений.
            КОГДА НаборыЗначений.ЗначениеДоступа = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ДоступРазрешен)
            ТОГДА ИСТИНА
            КОГДА НаборыЗначений.ЗначениеДоступа = ЗНАЧЕНИЕ(Перечисление.ДополнительныеЗначенияДоступа.ДоступЗапрещен)
            ТОГДА ЛОЖЬ
            // Проверка права доступа пользователя к таблице ЗначенияДоступа.
            КОГДА ТИПЗНАЧЕНИЯ(НаборыЗначений.ЗначениеДоступа) = ТИП(Справочник.ИдентификаторыОбъектовМетаданных)
        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
            // Право Чтение может зависеть только от права Чтение
            ТОГДА ИСТИНА В
                (   ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                    ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПраваНаОбъект
                    ГДЕ
                          ТаблицыГруппДоступаПроверкаПраваНаОбъект.ГруппаДоступа = ГруппыДоступа.Ссылка
                        И ТаблицыГруппДоступаПроверкаПраваНаОбъект.Таблица = НаборыЗначений.ЗначениеДоступа
                )
        #Иначе
            ТОГДА ИСТИНА В
                (   ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                    ИЗ РегистрСведений.ТаблицыГруппДоступа КАК ТаблицыГруппДоступаПроверкаПраваНаОбъект
                    ГДЕ
                          ТаблицыГруппДоступаПроверкаПраваНаОбъект.ГруппаДоступа = ГруппыДоступа.Ссылка
                        И ТаблицыГруппДоступаПроверкаПраваНаОбъект.Таблица = НаборыЗначений.ЗначениеДоступа
                        И НЕ(НаборыЗначений.Уточнение &lt;&gt; ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
                                И ТаблицыГруппДоступаПроверкаПраваНаОбъект.Изменение = ЛОЖЬ)
                )
        #КонецЕсли
        #Если Не &amp;ТипыВладельцевНастроекПрав = "" #Тогда
            ИНАЧЕ
                (
                ИСТИНА В // Проверка, что пользователю или какой-нибудь группе пользователя право разрешено
                    (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ИСТИНА
                    ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
                        ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
                        ПО
                              НаследованиеНастроек.Объект = НаборыЗначений.ЗначениеДоступа
                            И НастройкиПрав.Объект        = НаследованиеНастроек.Родитель
                        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                            И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияЧтения
                        #Иначе
                            И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньРазрешенияИзменения
                            И НастройкиПрав.Таблица = ВЫБОР
                                КОГДА НаборыЗначений.Уточнение В (&amp;ИдентификаторыТаблицСОтдельнымиНастройкамиПрав)
                                ТОГДА НаборыЗначений.Уточнение
                                ИНАЧЕ ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка) КОНЕЦ
                        #КонецЕсли
                        ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
                        ПО
                              СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
                            И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
                    )
                И НЕ ЛОЖЬ В // Проверка, что пользователю или какой-нибудь группе пользователя право запрещено
                    (
                    ВЫБРАТЬ ПЕРВЫЕ 1 ЛОЖЬ
                    ИЗ РегистрСведений.НастройкиПравОбъектов КАК НастройкиПрав
                        ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.НаследованиеНастроекПравОбъектов КАК НаследованиеНастроек
                        ПО
                              НаследованиеНастроек.Объект = НаборыЗначений.ЗначениеДоступа
                            И НастройкиПрав.Объект        = НаследованиеНастроек.Родитель
                        #Если #ИмяТекущегоПраваДоступа = "Чтение" #Тогда
                            И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияЧтения
                        #Иначе
                            И НаследованиеНастроек.УровеньИспользования &lt; НастройкиПрав.УровеньЗапрещенияИзменения
                            И НастройкиПрав.Таблица = ВЫБОР
                                КОГДА НаборыЗначений.Уточнение В (&amp;ИдентификаторыТаблицСОтдельнымиНастройкамиПрав)
                                ТОГДА НаборыЗначений.Уточнение
                                ИНАЧЕ ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка) КОНЕЦ
                        #КонецЕсли
                        ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.СоставыГруппПользователей КАК СоставыГруппПользователей
                        ПО
                              СоставыГруппПользователей.Пользователь        = &amp;АвторизованныйПользователь
                            И СоставыГруппПользователей.ГруппаПользователей = НастройкиПрав.Пользователь
                    )
                )
        #Иначе
            ИНАЧЕ
                ЛОЖЬ
        #КонецЕсли
            КОНЕЦ
    ) // НЕ ЛОЖЬ В
  )
 )
)
#КонецЕсли</condition>
	</restrictionTemplate>
</Rights>